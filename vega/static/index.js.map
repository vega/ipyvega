{"version":3,"sources":["webpack:///webpack/bootstrap e26d0fc250529948c592","webpack:///./src/index.js","webpack:///./src/embed.css?c5bf","webpack:///./src/embed.css","webpack:///./~/css-loader/lib/css-base.js","webpack:///./~/style-loader/addStyles.js","webpack:///./~/d3/d3.js","webpack:///./~/vega-embed/src/embed.js","webpack:///./~/vega/index.js","webpack:///./~/vega-dataflow/src/index.js","webpack:///./~/vega-dataflow/src/ChangeSet.js","webpack:///./~/vega-dataflow/src/Dependencies.js","webpack:///./~/vega-dataflow/src/Collector.js","webpack:///./~/vega-logging/index.js","webpack:///./~/vega-dataflow/src/Tuple.js","webpack:///./~/vega-dataflow/src/Node.js","webpack:///./~/vega-dataflow/src/DataSource.js","webpack:///./~/datalib/src/index.js","webpack:///./~/datalib/src/util.js","webpack:///./~/node-libs-browser/~/buffer/index.js","webpack:///./~/node-libs-browser/~/base64-js/lib/b64.js","webpack:///./~/ieee754/index.js","webpack:///./~/isarray/index.js","webpack:///./~/datalib/src/import/load.js","webpack:///url (ignored)","webpack:///fs (ignored)","webpack:///sync-request (ignored)","webpack:///request (ignored)","webpack:///./~/datalib/src/import/read.js","webpack:///./~/datalib/src/import/type.js","webpack:///./~/datalib/src/import/formats/index.js","webpack:///./~/datalib/src/import/formats/dsv.js","webpack:///./~/d3-dsv/build/d3-dsv.js","webpack:///./~/datalib/src/import/formats/json.js","webpack:///./~/datalib/src/import/formats/topojson.js","webpack:///./~/topojson/build/topojson.js","webpack:///./~/datalib/src/import/formats/treejson.js","webpack:///./~/datalib/src/format.js","webpack:///./~/d3-time/build/d3-time.js","webpack:///./~/d3-time-format/build/d3-time-format.js","webpack:///./~/d3-format/build/d3-format.js","webpack:///./~/datalib/src/aggregate/aggregator.js","webpack:///./~/datalib/src/aggregate/measures.js","webpack:///./~/datalib/src/stats.js","webpack:///./~/datalib/src/generate.js","webpack:///./~/datalib/src/aggregate/collector.js","webpack:///./~/datalib/src/aggregate/groupby.js","webpack:///./~/datalib/src/bins/bins.js","webpack:///./~/datalib/src/time.js","webpack:///./~/datalib/src/bins/histogram.js","webpack:///./~/datalib/src/template.js","webpack:///./~/datalib/src/accessor.js","webpack:///./~/datalib/src/import/readers.js","webpack:///./~/datalib/src/format-tables.js","webpack:///./~/vega-dataflow/src/Graph.js","webpack:///./~/vega-dataflow/src/Heap.js","webpack:///./~/vega-dataflow/src/Signal.js","webpack:///./~/vega/src/parse/index.js","webpack:///./~/vega/src/parse/axes.js","webpack:///./~/vega/src/scene/axis.js","webpack:///./~/vega/src/parse/mark.js","webpack:///./~/vega/src/parse/properties.js","webpack:///./~/vega/src/util/index.js","webpack:///./~/vega/src/util/format.js","webpack:///./~/vega-scenegraph/src/index.js","webpack:///./~/vega-scenegraph/src/path/index.js","webpack:///./~/vega-scenegraph/src/path/parse.js","webpack:///./~/vega-scenegraph/src/path/render.js","webpack:///./~/vega-scenegraph/src/path/arc.js","webpack:///./~/vega-scenegraph/src/render/index.js","webpack:///./~/vega-scenegraph/src/render/canvas/index.js","webpack:///./~/vega-scenegraph/src/render/canvas/CanvasHandler.js","webpack:///./~/vega-scenegraph/src/util/dom.js","webpack:///./~/vega-scenegraph/src/render/Handler.js","webpack:///./~/vega-scenegraph/src/render/canvas/marks/index.js","webpack:///./~/vega-scenegraph/src/render/canvas/marks/arc.js","webpack:///./~/vega-scenegraph/src/render/canvas/marks/util.js","webpack:///./~/vega-scenegraph/src/render/canvas/marks/area.js","webpack:///./~/vega-scenegraph/src/util/svg.js","webpack:///./~/vega-scenegraph/src/render/canvas/marks/group.js","webpack:///./~/vega-scenegraph/src/render/canvas/marks/image.js","webpack:///./~/vega-scenegraph/src/render/canvas/marks/line.js","webpack:///./~/vega-scenegraph/src/render/canvas/marks/path.js","webpack:///./~/vega-scenegraph/src/render/canvas/marks/rect.js","webpack:///./~/vega-scenegraph/src/render/canvas/marks/rule.js","webpack:///./~/vega-scenegraph/src/render/canvas/marks/symbol.js","webpack:///./~/vega-scenegraph/src/render/canvas/marks/text.js","webpack:///./~/vega-scenegraph/src/util/Bounds.js","webpack:///./~/vega-scenegraph/src/util/bound.js","webpack:///./~/vega-scenegraph/src/util/BoundsContext.js","webpack:///./~/vega-scenegraph/src/util/canvas.js","webpack:///canvas (ignored)","webpack:///./~/vega-scenegraph/src/util/text.js","webpack:///./~/vega-scenegraph/src/render/canvas/CanvasRenderer.js","webpack:///./~/vega-scenegraph/src/util/ImageLoader.js","webpack:///./~/vega-scenegraph/src/render/Renderer.js","webpack:///./~/vega-scenegraph/src/render/svg/index.js","webpack:///./~/vega-scenegraph/src/render/svg/SVGHandler.js","webpack:///./~/vega-scenegraph/src/render/svg/SVGRenderer.js","webpack:///./~/vega-scenegraph/src/render/svg/marks.js","webpack:///./~/vega-scenegraph/src/render/svg/SVGStringRenderer.js","webpack:///./~/vega-scenegraph/src/util/Item.js","webpack:///./~/vega-scenegraph/src/util/Gradient.js","webpack:///./~/vega-scenegraph/src/util/scene.js","webpack:///./~/vega/src/parse/background.js","webpack:///./~/vega/src/parse/data.js","webpack:///./~/vega/src/parse/transforms.js","webpack:///./~/vega/src/transforms/index.js","webpack:///./~/vega/src/transforms/Aggregate.js","webpack:///./~/vega/src/transforms/Transform.js","webpack:///./~/vega/src/transforms/Parameter.js","webpack:///./~/vega/src/transforms/Facetor.js","webpack:///./~/vega/src/transforms/Bin.js","webpack:///./~/vega/src/transforms/BatchTransform.js","webpack:///./~/vega/src/transforms/Cross.js","webpack:///./~/vega/src/transforms/CountPattern.js","webpack:///./~/vega/src/transforms/LinkPath.js","webpack:///./~/vega/src/transforms/Facet.js","webpack:///./~/vega/src/transforms/Filter.js","webpack:///./~/vega/src/transforms/Fold.js","webpack:///./~/vega/src/transforms/Force.js","webpack:///./~/vega/src/transforms/screen.js","webpack:///./~/vega/src/transforms/Formula.js","webpack:///./~/vega/src/transforms/Geo.js","webpack:///./~/vega/src/transforms/GeoPath.js","webpack:///./~/vega/src/transforms/Hierarchy.js","webpack:///./~/vega/src/transforms/Impute.js","webpack:///./~/vega/src/transforms/Lookup.js","webpack:///./~/vega/src/transforms/Pie.js","webpack:///./~/vega/src/transforms/Rank.js","webpack:///./~/vega/src/transforms/Sort.js","webpack:///./~/vega/src/transforms/Stack.js","webpack:///./~/vega/src/transforms/Treeify.js","webpack:///./~/vega/src/transforms/Treemap.js","webpack:///./~/vega/src/transforms/Voronoi.js","webpack:///./~/vega/src/transforms/Wordcloud.js","webpack:///./~/d3-cloud/index.js","webpack:///./~/d3-dispatch/build/d3-dispatch.js","webpack:///./~/vega/src/parse/modify.js","webpack:///./~/vega-event-selector/index.js","webpack:///./~/vega/src/parse/expr.js","webpack:///./~/vega-expression/src/index.js","webpack:///./~/vega-expression/src/parser.js","webpack:///./~/vega-expression/src/codegen.js","webpack:///./~/vega-expression/src/constants.js","webpack:///./~/vega-expression/src/functions.js","webpack:///./~/vega/src/parse/legends.js","webpack:///./~/vega/src/scene/legend.js","webpack:///./~/vega/src/parse/marks.js","webpack:///./~/vega/src/parse/padding.js","webpack:///./~/vega/src/parse/predicates.js","webpack:///./~/vega/src/parse/signals.js","webpack:///./~/vega/src/parse/spec.js","webpack:///./~/vega/src/core/Model.js","webpack:///./~/vega/src/scene/GroupBuilder.js","webpack:///./~/vega/src/scene/Builder.js","webpack:///./~/vega/src/scene/Encoder.js","webpack:///./~/vega/src/scene/Bounder.js","webpack:///./~/vega/src/scene/Scale.js","webpack:///./~/vega/src/scene/visit.js","webpack:///./~/vega/src/core/config.js","webpack:///./~/vega/src/core/View.js","webpack:///./~/vega/src/parse/streams.js","webpack:///./~/vega/src/scene/Transition.js","webpack:///./~/vega/src/core/HeadlessView.js","webpack:///./~/vega/src/core/schema.js","webpack:///./~/vega-lite/src/vl.js","webpack:///./~/vega-lite/src/bin.js","webpack:///./~/vega-lite/src/channel.js","webpack:///./~/vega-lite/src/util.js","webpack:///./~/vega-lite/src/data.js","webpack:///./~/vega-lite/src/type.js","webpack:///./~/vega-lite/src/encoding.js","webpack:///./~/vega-lite/src/fielddef.js","webpack:///./~/vega-lite/src/aggregate.js","webpack:///./~/vega-lite/src/timeunit.js","webpack:///./~/vega-lite/src/compile/compile.js","webpack:///./~/vega-lite/src/compile/Model.js","webpack:///./~/vega-lite/src/config.js","webpack:///./~/vega-lite/src/scale.js","webpack:///./~/vega-lite/src/axis.js","webpack:///./~/vega-lite/src/legend.js","webpack:///./~/vega-lite/src/mark.js","webpack:///./~/vega-lite/src/compile/config.js","webpack:///./~/vega-lite/src/compile/stack.js","webpack:///./~/vega-lite/src/compile/common.js","webpack:///./~/vega-lite/src/sort.js","webpack:///./~/vega-lite/src/compile/time.js","webpack:///./~/vega-lite/src/compile/scale.js","webpack:///./~/vega-lite/src/compile/axis.js","webpack:///./~/vega-lite/src/compile/data.js","webpack:///./~/vega-lite/src/compile/layout.js","webpack:///./~/vega-lite/src/compile/facet.js","webpack:///./~/vega-lite/src/compile/legend.js","webpack:///./~/vega-lite/src/compile/mark/mark.js","webpack:///./~/vega-lite/src/compile/mark/area.js","webpack:///./~/vega-lite/src/compile/mark/bar.js","webpack:///./~/vega-lite/src/compile/mark/line.js","webpack:///./~/vega-lite/src/compile/mark/point.js","webpack:///./~/vega-lite/src/compile/mark/text.js","webpack:///./~/vega-lite/src/compile/mark/tick.js","webpack:///./~/vega-lite/src/shorthand.js","webpack:///./~/vega-lite/src/spec.js","webpack:///./~/vega-lite/src/validate.js","webpack:///./~/vega-embed/src/parameter.js","webpack:///./~/vega-embed/src/post.js","webpack:///external \"jquery\"","webpack:///external \"base/js/events\""],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;ACzCA;;AAEA;AACA;AACA;AACA;AACA,gDAAgF;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,iCAAgC,UAAU,EAAE;AAC5C,E;;;;;;ACpBA;AACA;;;AAGA;AACA,gEAA+D,4BAA4B,GAAG,iCAAiC,sBAAsB,GAAG;;AAExJ;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAgB,iBAAiB;AACjC;AACA;AACA,yCAAwC,gBAAgB;AACxD,KAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA,aAAY,oBAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACjDA;AACA;AACA;AACA;AACA,qBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA,GAAE;AACF;AACA;AACA,GAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,sBAAsB;AACtC;AACA;AACA,mBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA,kBAAiB,2BAA2B;AAC5C;AACA;AACA,SAAQ,uBAAuB;AAC/B;AACA;AACA,IAAG;AACH;AACA,kBAAiB,uBAAuB;AACxC;AACA;AACA,4BAA2B;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA,eAAc;AACd;AACA,iCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;AACA,GAAE;AACF;AACA,GAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA,GAAE;AACF;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,wDAAuD;AACvD;;AAEA,8BAA6B,mBAAmB;;AAEhD;;AAEA;;AAEA;AACA;AACA;;;;;;;ACrPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAsE;AACtE,MAAK;AACL,yFAAwF;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAmD;AACnD;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,gDAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAsF,SAAS;AAC/F,6DAA4D,SAAS;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA,yEAAwE;AACxE,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAiD,OAAO;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAkD,EAAE;AACpD,uBAAsB;AACtB;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC,SAAS;AAC9C;AACA;AACA,yCAAwC,SAAS;AACjD;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC,SAAS;AAC9C,0DAAyD,SAAS;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAgD;AAChD;AACA;AACA;AACA,qEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB,SAAS;AAC7B;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA,qBAAoB,SAAS;AAC7B;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA,qBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA,QAAO;AACP,qBAAoB,UAAU;AAC9B;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,eAAc,MAAM;AACpB;AACA;AACA,eAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAoC,OAAO;AAC3C;AACA;AACA,wCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC,SAAS;AAC9C,6EAA4E,UAAU;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC,SAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,uCAAsC,OAAO;AAC7C,iEAAgE,OAAO;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAoC,OAAO;AAC3C,yDAAwD,OAAO;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC,SAAS;AAC9C;AACA;AACA;AACA,yCAAwC,SAAS;AACjD;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA,mEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA2D,OAAO;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA,YAAW;AACX;AACA,YAAW;AACX,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C,OAAO;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C,OAAO;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAAyD;AACzD;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAsD,wCAAwC;AAC9F;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,iFAAiF;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,+CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C;AAC3C;AACA,UAAS,gBAAgB;AACzB;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA;AACA,mBAAkB,UAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,oCAAmC;AACnC;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA0E;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iDAAgD;AAChD,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,6BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,qDAAoD;AACpD;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB,EAAE;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C;AAC3C,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,uEAAsE,6BAA6B;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAAyD,OAAO;AAChE;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA,iEAAgE,QAAQ;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,8DAA6D,OAAO;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA8C,OAAO;AACrD,YAAW;AACX;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,4CAA2C,QAAQ;AACnD,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,wCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA4B;AAC5B,6BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,OAAO;AAC9B,qEAAoE,OAAO;AAC3E;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,6CAA4C;AAC5C;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,gCAA+B,iCAAiC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,OAAO;AACxB;AACA;AACA;AACA,kBAAiB,OAAO;AACxB;AACA;AACA,iCAAgC,QAAQ;AACxC,0BAAyB,8BAA8B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,YAAW;AACX;AACA;AACA,YAAW;AACX;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAkC;AAClC;AACA;AACA;AACA,QAAO;AACP,mCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,WAAU;AACV;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,+BAA8B,8BAA8B;AAC5D;AACA,gDAA+C;AAC/C,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,wCAAuC;AACvC,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAuC;AACvC,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,gCAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS,iBAAiB,OAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B;AAC3B,4BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA,+CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAiD,OAAO;AACxD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc,QAAQ;AACtB;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA,8BAA6B;AAC7B,QAAO;AACP;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,4BAA2B;AAC3B;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL,yBAAwB,OAAO;AAC/B;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,gBAAe,QAAQ;AACvB,WAAU,OAAO;AACjB,WAAU,OAAO;AACjB;AACA,kBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAqD,8BAA8B;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAqD,8BAA8B;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,oCAAmC;AACnC;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB;AAClB;AACA,yBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,YAAW;AACX,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,kBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,YAAW;AACX;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,OAAO;AACxB;AACA;AACA;AACA,kBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAAyD,OAAO,2DAA2D,iBAAiB,OAAO;AACnJ;AACA,0DAAyD,OAAO,2DAA2D,iBAAiB,OAAO;AACnJ;AACA,oDAAmD,OAAO,mDAAmD,iBAAiB,OAAO;AACrI;AACA;AACA;AACA,sBAAqB,OAAO;AAC5B;AACA;AACA,sBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,kBAAiB,OAAO;AACxB;AACA,oBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,kBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA,IAAG;AACH;AACA;AACA;AACA,kBAAiB,OAAO;AACxB,2BAA0B,OAAO;AACjC;AACA;AACA;AACA,kBAAiB,OAAO;AACxB;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,kBAAiB,OAAO;AACxB,4BAA2B,OAAO;AAClC,wDAAuD,OAAO;AAC9D,2EAA0E,OAAO;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,OAAO;AACxB;AACA,MAAK;AACL;AACA;AACA,kBAAiB,OAAO;AACxB,2BAA0B,OAAO;AACjC,2BAA0B,OAAO,yBAAyB,iBAAiB,OAAO;AAClF;AACA,kBAAiB,OAAO;AACxB;AACA,MAAK;AACL;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU,MAAM;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,OAAO;AAC1B;AACA;AACA,iCAAgC,SAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,mCAAkC,oBAAoB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,kFAAiF;AACjF;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,+EAA8E,OAAO;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,+BAA8B,OAAO;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B,gCAAgC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,MAAM,qBAAqB,OAAO;AAClD;AACA,UAAS;AACT;AACA,iBAAgB,QAAQ,sBAAsB,OAAO;AACrD;AACA,oBAAmB,cAAc;AACjC,+BAA8B,kBAAkB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,6DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC,SAAS;AAC9C;AACA,0DAAyD,SAAS;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC,SAAS;AAC9C;AACA,0DAAyD,SAAS;AAClE;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC,SAAS;AAC9C,0DAAyD,SAAS;AAClE;AACA;AACA;AACA;AACA,gDAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAoC,OAAO;AAC3C;AACA,yDAAwD,OAAO;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,qCAAoC,OAAO;AAC3C;AACA,yDAAwD,OAAO;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,cAAa;AACb,YAAW;AACX,UAAS;AACT;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,YAAW;AACX;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA,uCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAmD,0BAA0B;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,qXAA2E,4EAA4E;AACvJ,EAAC,G;;;;;;ACj1SD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kCAAiC,eAAe,EAAE;AAClD,kCAAiC,gCAAgC;AACjE;;AAEA;AACA,iBAAgB,SAAS;AACzB;AACA;AACA,MAAK;AACL;AACA,2DAA0D,aAAa;AACvE;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,oCAAmC;AACnC;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAgB;;AAEhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG,cAAc,SAAS;;AAE1B;AACA,iBAAgB,WAAW,QAAQ;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAqD,yBAAyB;AAC9E;AACA,cAAa;AACb;AACA;;AAEA;AACA,mCAAkC,yBAAyB,EAAE;;AAE7D;AACA;AACA,iBAAgB,uBAAuB;AACvC,MAAK,cAAc,SAAS;AAC5B,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;AC7JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACVA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC,KAAK;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA,G;;;;;;AC9BA;AACA;AACA;AACA,+BAA8B,2BAA2B,EAAE;;;;;;;ACH3D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,4B;;;;;;ACpDA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;ACjCA;;AAEA;AACA,gDAA+C;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA2B,KAAK;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA,oBAAmB,YAAY,YAAY;AAC3C,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH,sBAAqB,aAAa,EAAE;;AAEpC;AACA;AACA,iCAAgC,OAAO;AACvC;AACA;AACA,qCAAoC,oBAAoB,EAAE;AAC1D;AACA;;;;;;;ACnEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,8BAA6B;AAC7B,sBAAqB;AACrB,mBAAkB;;AAElB;AACA,6BAA4B;;AAE5B;AACA;AACA,+BAA8B,KAAK;AACnC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mC;AACA;AACA;AACA;;AAEA;;AAEA;AACA,WAAU,kBAAkB,EAAE,OAAO,mBAAmB;AACxD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAoC,EAAE;;AAEtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH,wCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2BAA0B,KAAK;AAC/B;AACA;AACA,4BAA2B,KAAK;AAChC;AACA;AACA;;AAEA;AACA;;AAEA,0BAAyB,YAAY;;AAErC;;;;;;;ACpMA;AACA;AACA;AACA;AACA;AACA,oCAA6B;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB;AACtB;AACA;;AAEA;AACA;AACA,0BAAyB;AACzB,0BAAyB;AACzB,yBAAwB;AACxB;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAa,mBAAmB;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA8B,OAAO;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,cAAa,iBAAiB;AAC9B;AACA;AACA;;AAEA,gBAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA,gBAAe,oBAAoB;AACnC;AACA;AACA;AACA,gBAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,+CAA8C;AAC9C;;AAEA;AACA;AACA,QAAO;;AAEP;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA,QAAO;;AAEP;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;ACjTA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC/BA;;AAEA;;AAEA;;AAEA,kCAAiC,6BAA6B;;AAE9D,uBAAsB,kCAAkC;;AAExD,2BAA0B,UAAU;;AAEpC,0CAAyC,aAAa,EAAE;;AAExD,4CAA2C,cAAc,EAAE;;AAE3D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+CAA8C,OAAO;AACrD;AACA,sBAAqB,qBAAqB;AAC1C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAkC,6BAA6B,EAAE,IAAI;AACrE,mCAAkC,0BAA0B,EAAE,IAAI;AAClE;;AAEA;AACA;AACA;AACA;AACA,qCAAoC,KAAK;AACzC;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA,sFAAqF;AACrF;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAmB,cAAc;AACjC;AACA,MAAK;AACL,qBAAoB,UAAU;AAC9B;;;AAGA;AACA;AACA;AACA;AACA,wCAAuC,iBAAiB,EAAE;AAC1D;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,uBAAsB,oBAAoB;AAC1C;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA4B,QAAQ,gBAAgB;AACpD,6BAA4B,QAAQ,gBAAgB;AACpD;AACA;AACA,IAAG;AACH;AACA;AACA,6BAA4B,KAAK;AACjC,mBAAkB,UAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA,4BAA2B,cAAc;;AAEzC;AACA;AACA;AACA,IAAG,IAAI;;AAEP;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,KAAK;AAChB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA2B,iBAAiB,mBAAmB,EAAE;AACjE;AACA,IAAG;AACH,iCAAgC,iBAAiB,mBAAmB,EAAE;AACtE;AACA;AACA;;AAEA;;;;;;;;ACnSA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,YAAY;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,YAAY;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,YAAY;AAC7B;AACA;AACA;AACA;;AAEA,iBAAgB,oCAAoC;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAiB,YAAY;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,iBAAiB;AAChC;AACA;AACA;;AAEA;AACA;AACA,cAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iDAAgD,EAAE;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,6BAA6B;AAChD;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,sBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,oBAAmB,cAAc;AACjC;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wDAAuD,OAAO;AAC9D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,wDAAuD,OAAO;AAC9D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sBAAqB,QAAQ;AAC7B;AACA;AACA,IAAG;AACH;AACA,gBAAe,SAAS;AACxB;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAkB;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oBAAmB,SAAS;AAC5B;AACA;AACA,IAAG;AACH;AACA;AACA,oBAAmB,SAAS;AAC5B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,wCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAiB,YAAY;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,gBAAgB;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;;;;;;;;AC3gDA;;AAEA,EAAC;AACD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,qBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kDAAiD,YAAY;AAC7D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,EAAC,6BAAqD;;;;;;;AC3HtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAQ,WAAW;;AAEnB;AACA;AACA;AACA,SAAQ,WAAW;;AAEnB;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA,SAAQ,WAAW;;AAEnB;AACA;AACA,SAAQ,UAAU;;AAElB;AACA;;;;;;;ACnFA,kBAAiB;;AAEjB;AACA;AACA;;;;;;;ACJA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAAyB,gCAAgC;;AAEzD;AACA;AACA;AACA,uBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wCAAuC,SAAS,EAAE;;AAElD;AACA,iCAAgC;AAChC,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG,mCAAmC;AACtC;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAgC;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA8B;;AAE9B;AACA,iDAAgD,iBAAiB;AACjE;;AAEA,kBAAiB;AACjB;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;AC3LA,gB;;;;;;ACAA,gB;;;;;;ACAA,gB;;;;;;ACAA,gB;;;;;;ACAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,2BAA0B,yBAAyB;AACnD;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH,8BAA6B,OAAO;AACpC;AACA,cAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;AC/CA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAwB,0BAA0B;AAClD;;AAEA;AACA,yBAAwB,uDAAuD,EAAE;AACjF,yBAAwB,0CAA0C,EAAE;AACpE,wBAAuB,sCAAsC,EAAE;AAC/D,sBAAqB,8BAA8B;AACnD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,6BAA4B,yBAAyB;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG,IAAI;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,YAAW,iBAAiB;AAC5B;AACA;AACA;AACA,cAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG,IAAI;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC3FA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACTA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;;;;;;;AClBA;AACA;AACA;AACA,+BAA8B;AAC9B,EAAC,2BAA2B;;AAE5B;AACA;AACA;;AAEA;AACA,uCAAsC;AACtC;AACA,MAAK,gBAAgB;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA,mBAAkB;AAClB,mBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,eAAc;;AAEd;AACA,gCAA+B;AAC/B,0CAAyC;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oCAAmC;AACnC,+BAA8B,YAAY,yCAAyC,EAAE;AACrF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,EAAC,G;;;;;;ACpJD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACTA;;AAEA;AACA;AACA,0BAAyB,6CAA6C;;AAEtE;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;;;;;;AC1BA;AACA;AACA;AACA,iCAAgC;AAChC,EAAC,2BAA2B;;AAE5B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+CAA8C,+BAA+B,EAAE;AAC/E,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,qCAAoC;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iEAAgE,OAAO;AACvE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uCAAsC,OAAO;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,4CAA2C;AAC3C,kCAAiC;AACjC;AACA;;AAEA;AACA,2BAA0B,6BAA6B,EAAE;AACzD,gCAA+B,iCAAiC,EAAE;AAClE,gCAA+B,qBAAqB,EAAE;AACtD,qCAAoC,yBAAyB,EAAE;AAC/D,6BAA4B,wBAAwB,EAAE;AACtD,kCAAiC,4BAA4B;AAC7D;;AAEA;AACA;;AAEA;AACA,0BAAyB;AACzB,6BAA4B;AAC5B,2BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,sEAAqE,gCAAgC,EAAE;AACvG;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B,kCAAkC,EAAE;AACnE;AACA;AACA;;AAEA;AACA;AACA,+BAA8B,wDAAwD,EAAE;;AAExF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qDAAoD,cAAc;AAClE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uCAAsC,uBAAuB;AAC7D;;AAEA;;AAEA;AACA,8BAA6B,uBAAuB;AACpD,8BAA6B,0EAA0E,EAAE;AACzG,MAAK;AACL,gDAA+C,OAAO;AACtD;;AAEA,aAAY;AACZ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA;;AAEA;AACA,qCAAoC,gCAAgC,sBAAsB;AAC1F;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf,cAAa;AACb,YAAW;AACX;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,YAAW;AACX,UAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAO;AACP;AACA;;AAEA;AACA,0BAAyB;AACzB,6CAA4C,WAAW,EAAE;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA,mCAAkC,cAAc,EAAE;AAClD;;AAEA;AACA,8EAA6E,gBAAgB,EAAE;AAC/F;AACA;;AAEA;AACA;AACA;AACA;AACA,wCAAuC,6BAA6B,iBAAiB,EAAE,EAAE;AACzF;;AAEA;;AAEA;AACA,qEAAoE,OAAO;AAC3E,4BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAuC;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kCAAiC,OAAO;AACxC;AACA;AACA;;AAEA,sCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA;;AAEA,wCAAuC,OAAO;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAC,G;;;;;;ACniBD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,8BAA6B,0BAA0B,EAAE;AACzD,iCAAgC,mCAAmC,EAAE;;AAErE;AACA;AACA;AACA,8BAA6B,wBAAwB,EAAE;AACvD,8BAA6B,2BAA2B,EAAE;;AAE1D;AACA,8BAA6B,iBAAiB,eAAe,EAAE;;AAE/D;AACA;AACA;AACA;AACA,2BAA0B,yBAAyB,EAAE;AACrD,2BAA0B,wBAAwB;AAClD,IAAG;;AAEH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,sBAAqB,cAAc,cAAc,eAAe;;AAEhE;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,4BAA2B,OAAO,OAAO;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAkB,SAAS;AAC3B;AACA,wCAAuC;AACvC;AACA;;AAEA;AACA,6CAA4C;AAC5C;AACA;AACA;AACA;AACA,gCAA+B;AAC/B,gCAA+B;AAC/B;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,E;;;;;;AC5NA;AACA;AACA;AACA,+BAA8B;AAC9B,EAAC,2BAA2B;;AAE5B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wDAAuD;AACvD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gCAA+B,8BAA8B;AAC7D,gCAA+B,0CAA0C,EAAE;AAC3E;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA,MAAK;AACL;;AAEA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;;AAEH;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;;AAEH;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;;AAEH;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;;AAEH;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;;AAEH;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;;AAEH;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;;AAEH;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAC,G;;;;;;ACjWD;AACA;AACA;AACA,sCAAqC;AACrC,EAAC,kCAAkC;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kCAAiC,kBAAkB;AACnD;AACA,QAAO;AACP;AACA;AACA;AACA,kCAAiC,kBAAkB;AACnD;AACA;AACA;AACA;;AAEA,eAAc;AACd;AACA;AACA,+CAA8C,EAAE;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAC,G;;;;;;ACnzBD;AACA;AACA;AACA,iCAAgC;AAChC,EAAC,2BAA2B;;AAE5B;AACA;AACA;AACA;AACA,kGAAiG;AACjG;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA0F;AAC1F;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oDAAmD,OAAO;AAC1D;AACA,+BAA8B;AAC9B,wCAAuC,QAAQ;AAC/C;AACA,qCAAoC;AACpC;AACA;;AAEA;AACA;;AAEA;AACA;AACA,0BAAyB,6BAA6B,EAAE;AACxD,uBAAsB,kCAAkC,EAAE;AAC1D,uBAAsB,eAAe,EAAE;AACvC,uBAAsB,mCAAmC,EAAE;AAC3D,0BAAyB,2BAA2B,EAAE;AACtD,0BAAyB,qBAAqB,EAAE;AAChD,0BAAyB,yBAAyB,EAAE;AACpD,uBAAsB,kCAAkC,EAAE;AAC1D,0BAAyB,kCAAkC,EAAE;AAC7D;AACA;AACA,uBAAsB,iDAAiD,EAAE;AACzE,uBAAsB,mCAAmC;AACzD;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,yBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAC,G;;;;;;AC9eD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAI;AACJ;AACA;AACA,6BAA4B;AAC5B,+BAA8B;AAC9B;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA,YAAW,iBAAiB;AAC5B,iCAAgC,gBAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,0BAAyB,YAAY;AACrC;;AAEA;AACA;AACA;AACA;;AAEA;AACA,8BAA6B,eAAe;AAC5C,wBAAuB,WAAW;AAClC;AACA;AACA;AACA,aAAY,qBAAqB;AACjC;AACA;AACA;;AAEA;;AAEA;AACA,2BAA0B;AAC1B;;AAEA;AACA;AACA;AACA;AACA,YAAW,KAAK;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ,2BAA0B,KAAK;AAC/B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,sBAAqB;AACrB;AACA,cAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sBAAqB;AACrB;AACA,cAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA,YAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4BAA2B,uBAAuB;AAClD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,cAAa,eAAe;AAC5B;AACA;;AAEA;AACA;AACA,oCAAmC,kCAAkC;AACrE;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gBAAe,gBAAgB;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACvTA;;AAEA;AACA;AACA;AACA,gCAA+B;AAC/B;AACA,IAAG;AACH;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,yBAAwB;AACxB,0BAAyB;AACzB,0BAAyB;AACzB;AACA,IAAG;AACH;AACA;AACA,0BAAyB;AACzB,kCAAiC,6BAA6B;AAC9D,kCAAiC,sDAAsD;AACvF;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,yBAAwB;AACxB,4CAA2C;AAC3C,4CAA2C;AAC3C;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,8CAA6C;AAC7C,kDAAiD;AACjD;AACA;AACA,IAAG;AACH;AACA;AACA,8CAA6C;AAC7C,kDAAiD;AACjD;AACA;AACA,IAAG;AACH;AACA;AACA,iCAAgC;AAChC,2CAA0C;AAC1C,8CAA6C;AAC7C;AACA;AACA,IAAG;AACH;AACA;AACA,iCAAgC;AAChC,2CAA0C;AAC1C,8CAA6C;AAC7C;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA,0BAAyB,+BAA+B;AACxD;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAwB,0CAA0C;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B,2BAA2B,EAAE,IAAI;AAChE;AACA,8CAA6C,sBAAsB,EAAE;AACrE;;AAEA;AACA;AACA,+BAA8B,gBAAgB,gBAAgB,kBAAkB;AAChF,0CAAyC,8BAA8B,cAAc;AACrF,0CAAyC,8BAA8B,cAAc;AACrF,iCAAgC,sBAAsB;;AAEtD;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,2BAA0B,sBAAsB,EAAE;AAClD;AACA,sDAAqD;AACrD,MAAK;AACL,oBAAmB;;AAEnB;AACA;AACA;AACA,0DAAyD;AACzD,0DAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;ACpLA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAY;AACZ,6BAA4B,KAAK;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6BAA4B,KAAK;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6BAA4B,KAAK;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAY;AACZ,6BAA4B,KAAK;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd,6BAA4B,KAAK;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAwB,OAAO,mBAAmB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2CAA0C,KAAK;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kCAAiC,KAAK;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kCAAiC,KAAK;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kCAAiC,KAAK;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,KAAK;AAChB;AACA,2BAA0B,WAAW,OAAO;AAC5C;AACA,SAAQ,KAAK;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,KAAK;AAChB;AACA,2BAA0B,WAAW,WAAW,OAAO;AACvD;AACA,SAAQ,KAAK;AACb;AACA;AACA,mBAAkB,OAAO,OAAO;AAChC,mBAAkB,OAAO,OAAO;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,iBAAiB;AAC9B;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,cAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,YAAW,KAAK;AAChB,cAAa;AACb,cAAa;AACb;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAc;AACd,MAAK;AACL;;AAEA;AACA;AACA,uBAAsB;;AAEtB,YAAW,KAAK;AAChB;AACA;AACA;AACA,MAAK;AACL;AACA,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAU,OAAO;AACjB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iBAAgB,KAAK;AACrB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,8BAA6B,KAAK;AAClC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,wDAAwD;AACrE;;AAEA,YAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA6B,KAAK;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iCAAgC,+BAA+B;AAC/D;AACA;AACA;AACA,gDAA+C;AAC/C;AACA,IAAG,4BAA4B;AAC/B;AACA,IAAG;AACH,iCAAgC;AAChC,IAAG;AACH,8BAA6B;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAW,KAAK;AAChB;AACA,gBAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAW,KAAK;AAChB;AACA;AACA;AACA;;AAEA,YAAW,KAAK;AAChB,cAAa,KAAK;AAClB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,KAAK;AAChB;AACA;AACA;AACA,YAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAa;AACb,cAAa;AACb;AACA;;AAEA,YAAW,KAAK;AAChB;AACA;AACA;;AAEA,YAAW,KAAK;AAChB;AACA;AACA;AACA;;AAEA;AACA,YAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY;;AAEZ;AACA,YAAW,iBAAiB;AAC5B;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;;;;;;AC/sBA;AACA;;AAEA;AACA;AACA,YAAW,KAAK;AAChB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,yCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,G;;;;;;ACzKA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA8B,KAAK;AACnC;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,+BAA8B,KAAK;AACnC,wCAAuC,eAAe;AACtD;AACA,IAAG;AACH;AACA,0BAAyB,KAAK;AAC9B;AACA;AACA,+BAA8B,KAAK;AACnC,wBAAuB,eAAe;AACtC;AACA,0BAAyB,KAAK;AAC9B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;ACnHA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,iBAAgB,aAAa;AAC7B;;;;;;;ACZA;AACA;AACA;;AAEA;AACA,cAAa,yCAAyC;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAAyC,cAAc;;AAEvD;AACA,cAAa,cAAc;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAY,qBAAqB;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mCAAkC,cAAc;AAChD,WAAU,UAAU;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAa,8CAA8C;;AAE3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AChHA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB,6BAA6B,EAAE;AAChD,kBAAiB,4BAA4B,EAAE;AAC/C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB,sCAAsC,EAAE;AACzD,kBAAiB,6BAA6B,EAAE;AAChD;AACA;AACA;AACA,kBAAiB,mCAAmC,EAAE;AACtD,kBAAiB,6BAA6B,EAAE;AAChD;AACA;AACA;AACA,kBAAiB,gCAAgC,EAAE;AACnD,kBAAiB,2BAA2B,EAAE;AAC9C;AACA;AACA;AACA,kBAAiB,+BAA+B,EAAE;AAClD,kBAAiB,yBAAyB,EAAE;AAC5C;AACA;AACA;AACA,kBAAiB,6BAA6B,EAAE;AAChD,kBAAiB,0BAA0B,EAAE;AAC7C;AACA;AACA;AACA,kBAAiB,kCAAkC,EAAE;AACrD,kBAAiB,2BAA2B,EAAE;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB,gDAAgD,EAAE;AACnE,kBAAiB,gCAAgC,EAAE;AACnD;AACA;AACA;AACA,kBAAiB,6CAA6C,EAAE;AAChE,kBAAiB,gCAAgC,EAAE;AACnD;AACA;AACA;AACA,kBAAiB,0CAA0C,EAAE;AAC7D,kBAAiB,8BAA8B,EAAE;AACjD;AACA;AACA;AACA,kBAAiB,yCAAyC,EAAE;AAC5D,kBAAiB,4BAA4B,EAAE;AAC/C;AACA;AACA;AACA,kBAAiB,uCAAuC,EAAE;AAC1D,kBAAiB,6BAA6B,EAAE;AAChD;AACA;AACA;AACA,kBAAiB,4CAA4C,EAAE;AAC/D,kBAAiB,8BAA8B,EAAE;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,4BAA2B,KAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAc;AACd,4BAA2B,KAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qC;;;;;;ACxKA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAmB,gCAAgC,EAAE;AACrD,oBAAmB,mBAAmB;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA0B;;AAE1B;AACA;AACA;AACA;AACA,0BAAyB,yBAAyB;AAClD;AACA;AACA,WAAU,kBAAkB;AAC5B;AACA;;AAEA;AACA;AACA,uBAAsB,SAAS,6BAA6B,EAAE;;AAE9D,sBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA4B,SAAS,uBAAuB,EAAE;AAC9D;AACA;;AAEA;AACA;AACA;AACA;;;;;;;ACnFA;AACA;;AAEA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB,oBAAoB;;AAErC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,gBAAe,kBAAkB;AACjC;;AAEA;AACA;AACA;AACA;AACA,2BAA0B,iBAAiB,EAAE;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,sBAAqB,EAAE,OAAO,EAAE;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;ACvOA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACpBA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gCAA+B,QAAQ,UAAU;AACjD;AACA;AACA;AACA;;AAEA;AACA,6BAA4B,cAAc;AAC1C;;AAEA;AACA;AACA,qBAAoB,uBAAuB,QAAQ;AACnD;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA,IAAG,IAAI;;;;;;;ACnCP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,sBAAqB,yCAAyC;AAC9D;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAwB,uBAAuB;AAC/C,0CAAyC,oBAAoB,EAAE;AAC/D;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;AACA,QAAO;AACP,IAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAuB,KAAK;AAC5B;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB,oBAAoB,EAAE;AAC/C;AACA,uBAAsB,wCAAwC,EAAE;AAChE;AACA,E;;;;;;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,YAAY;AACzB;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAqB,mBAAmB;AACxC;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6BAA4B,sBAAsB,EAAE;AACpD;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAA+B,KAAK;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uCAAsC,E;AACtC;AACA;;AAEA;AACA;AACA;AACA;;AAEA,6BAA4B,OAAO;AACnC;AACA;;AAEA;AACA,kCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,wCAAuC,OAAO;AAC9C;;AAEA;AACA;AACA,2CAA0C;;AAE1C;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA6B,4BAA4B;AACzD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAe,iBAAiB;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAU;AACV;;AAEA;AACA;;AAEA;AACA,6BAA4B,KAAK;AACjC;AACA;;AAEA;AACA,6BAA4B,KAAK;AACjC;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gCAA+B,KAAK;AACpC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,6BAA4B,KAAK;AACjC;AACA;;AAEA;AACA,6BAA4B,KAAK;AACjC;AACA;;AAEA;AACA,gCAA+B,KAAK;AACpC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,eAAc;AACd;;AAEA,6BAA4B,KAAK;AACjC;AACA;;AAEA,+CAA8C,KAAK;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC7UA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC9FA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAwB;AACxB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;;AAEA,mBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACjBA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,KAAK;AACtB,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAkB;AAClB;AACA,mBAAkB;AAClB,IAAG;AACH,qDAAoD;AACpD,qDAAoD;AACpD;AACA,+CAA8C;AAC9C,0CAAyC;AACzC,4CAA2C;AAC3C,0CAAyC;AACzC;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB,mBAAmB;AACpC,mBAAkB,iBAAiB;AACnC,oBAAmB,2CAA2C;AAC9D,mBAAkB,iBAAiB;AACnC,yBAAwB,iBAAiB;AACzC,oBAAmB,iBAAiB;AACpC,wBAAuB,4CAA4C;AACnE,mBAAkB,iBAAiB;AACnC;AACA;AACA,qBAAoB;AACpB,UAAS;AACT,uBAAsB,iBAAiB;AACvC,yBAAwB,iBAAiB;AACzC,sBAAqB,iBAAiB;AACtC,2BAA0B,iBAAiB;AAC3C,2BAA0B,iBAAiB;AAC3C,yBAAwB,iBAAiB;AACzC;AACA,sBAAqB,iBAAiB;AACtC;AACA;AACA,yBAAwB,iBAAiB;AACzC,yBAAwB;AACxB,cAAa;AACb;AACA;AACA,YAAW;AACX,UAAS;AACT,mBAAkB,8CAA8C;AAChE,kBAAiB,kBAAkB;AACnC;AACA;AACA;AACA,uBAAsB,yBAAyB;AAC/C,4BAA2B,yBAAyB;AACpD,4BAA2B,yBAAyB;AACpD,wBAAuB,yBAAyB;AAChD,uBAAsB,yBAAyB;AAC/C,sBAAqB,yBAAyB;AAC9C,sBAAqB;AACrB,YAAW;AACX;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;;;;;;AC5IA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB;AACxB,0BAAyB;AACzB,0BAAyB;AACzB,0BAAyB;AACzB,sBAAqB;AACrB,uBAAsB;AACtB,YAAW;AACX,uBAAsB;AACtB,uBAAsB;AACtB,uBAAsB;AACtB,uBAAsB;AACtB,mBAAkB;AAClB;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,aAAY;AACZ;;AAEA;AACA;AACA;AACA,oCAAmC,qDAAqD,EAAE;AAC1F;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,yCAAwC,6BAA6B;AACrE,yCAAwC,iBAAiB;AACzD,yCAAwC,iBAAiB;AACzD;AACA,yCAAwC,YAAY;AACpD,yCAAwC,cAAc;AACtD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yBAAwB;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAkB;AAClB;AACA,MAAK;AACL,mBAAkB;AAClB,mBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C;AAC3C,mDAAkD;;AAElD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL,4CAA2C,4BAA4B,EAAE;AACzE;;AAEA;AACA;AACA,uBAAsB,WAAW,SAAS;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAsB,WAAW,SAAS;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA6B,kBAAkB,SAAS;AACxD;AACA;;AAEA;AACA;AACA,6BAA4B,iBAAiB,SAAS;AACtD;AACA;;AAEA;AACA;AACA,uBAAsB,WAAW,SAAS;AAC1C;AACA;;AAEA;AACA;AACA,sBAAqB,UAAU,SAAS;AACxC;AACA;;AAEA;AACA;AACA,+BAA8B,mBAAmB;AACjD;AACA;;AAEA;AACA;AACA,gCAA+B,oBAAoB;AACnD;AACA;;AAEA;AACA;AACA,gCAA+B,oBAAoB;AACnD;AACA;;AAEA;AACA;AACA,gCAA+B,oBAAoB;AACnD;AACA;;AAEA;AACA;AACA,4BAA2B,gBAAgB;AAC3C;AACA;;AAEA;AACA;AACA,6BAA4B,iBAAiB;AAC7C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAmB;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA,qBAAoB,gDAAgD;AACpE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU,YAAY;AACtB,MAAK;AACL;AACA;AACA,WAAU,YAAY;AACtB,eAAc,gBAAgB;AAC9B,kBAAiB;AACjB,MAAK;AACL,IAAG;AACH;AACA,WAAU,YAAY;AACtB;AACA,MAAK;AACL;AACA,WAAU,YAAY;AACtB;AACA,eAAc,yBAAyB;AACvC,kBAAiB;AACjB,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO,QAAQ,0BAA0B,oCAAoC;AAC7E,QAAO,QAAQ,0BAA0B;AACzC,IAAG;AACH,aAAY;AACZ;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB;AACA,MAAK;AACL;AACA;AACA,YAAW,SAAS;AACpB;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA,YAAW,SAAS;AACpB;AACA;AACA,MAAK;AACL;AACA,YAAW,SAAS;AACpB;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAgB;AAChB,qBAAoB;AACpB,kCAAiC;AACjC,IAAG;AACH,iBAAgB;AAChB,qBAAoB;AACpB,kCAAiC;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,oCAAmC;AACnC;;AAEA;AACA,qBAAoB;AACpB;AACA;AACA;AACA,6BAA4B;;AAE5B;AACA;AACA;;AAEA;AACA,uBAAsB,yBAAyB,wBAAwB,OAAO;AAC9E,uBAAsB,gCAAgC,wBAAwB,OAAO;AACrF,uBAAsB,wBAAwB,iCAAiC,OAAO;AACtF,uBAAsB,wBAAwB,yBAAyB,OAAO;AAC9E,uBAAsB,wBAAwB,wBAAwB;AACtE;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA,uBAAsB,4BAA4B,sBAAsB,OAAO;AAC/E,uBAAsB,mCAAmC,sBAAsB,OAAO;AACtF,uBAAsB,sBAAsB,oCAAoC,OAAO;AACvF,uBAAsB,sBAAsB,4BAA4B,OAAO;AAC/E,uBAAsB,sBAAsB,sBAAsB;AAClE;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,wBAAwB;AACzC,uBAAsB,wBAAwB;AAC9C,mBAAkB;AAClB,QAAO;AACP,cAAa,WAAW,YAAY,EAAE;AACtC,gBAAe,WAAW,SAAS;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,6BAA6B;AAC5C,gBAAe,4BAA4B;AAC3C,oBAAmB,gCAAgC;AACnD,mBAAkB,YAAY;AAC9B,gBAAe;AACf,QAAO;AACP,cAAa,WAAW,YAAY,EAAE;AACtC,gBAAe,WAAW,SAAS;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,wBAAwB;AACvC,oBAAmB,4BAA4B;AAC/C,sBAAqB,8BAA8B;AACnD,gBAAe,yBAAyB;AACxC,iBAAgB,gBAAgB;AAChC,oBAAmB,gBAAgB;AACnC,gBAAe;AACf,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY,WAAW;AACvB,aAAY,WAAW;AACvB,kBAAiB,wBAAwB;AACzC,uBAAsB;AACtB,QAAO;AACP;AACA;AACA;AACA;;AAEA;;;;;;;AChkBA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,qDAAoD,kBAAkB;AACtE;;AAEA;AACA;AACA,yCAAwC,4BAA4B,EAAE;AACtE;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAiB,iBAAiB;AAClC,iBAAgB,iBAAiB;AACjC,kBAAiB;AACjB,6DAA4D;;AAE5D;AACA;AACA;AACA,sBAAqB,iBAAiB;AACtC,sBAAqB,iBAAiB;AACtC,2BAA0B;AAC1B,YAAW;AACX;AACA,UAAS;;AAET,mBAAkB,6BAA6B;AAC/C;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA,YAAW;AACX,UAAS;;AAET,yBAAwB,kBAAkB;;AAE1C;AACA;AACA;AACA,wBAAuB,yBAAyB;AAChD,wBAAuB,yBAAyB;AAChD,wBAAuB,yBAAyB;AAChD,wBAAuB;AACvB,YAAW;AACX;AACA,sBAAqB,sBAAsB,GAAG,uBAAuB;AACrE;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;;;;;;;AC9EA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,mCAAkC;AAClC;AACA,oBAAmB;AACnB,oBAAmB;AACnB,oBAAmB;AACnB,oBAAmB;AACnB;AACA,oBAAmB;AACnB;AACA;;AAEA,8BAA6B,kEAAkE,IAAI;AACnG;AACA,qCAAoC;AACpC,gCAA+B;AAC/B,sCAAqC;;AAErC;AACA;AACA;AACA,0BAAyB,KAAK;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,8BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,2DAA0D;AAC1D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6CAA4C,kCAAkC,EAAE;AAChF;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,qCAAoC;AACpC,8BAA6B;AAC7B,6CAA4C;AAC5C,2CAA0C;AAC1C,sBAAqB;AACrB,uDAAsD;AACtD,MAAK;AACL,uDAAsD;AACtD,MAAK;AACL,2CAA0C;AAC1C;AACA;;AAEA;AACA;AACA,yDAAwD;AACxD,MAAK;AACL,2CAA0C;AAC1C;AACA;;AAEA;AACA;AACA,qCAAoC;AACpC,8BAA6B;AAC7B,6CAA4C;AAC5C,2CAA0C;AAC1C,sBAAqB;AACrB,wDAAuD;AACvD,MAAK;AACL,wDAAuD;AACvD,MAAK;AACL,2CAA0C;AAC1C;AACA;;AAEA;AACA;AACA,0DAAyD;AACzD,MAAK;AACL,2CAA0C;AAC1C;AACA;;AAEA,gEAA+D;AAC/D,sDAAqD;AACrD,6BAA4B;;AAE5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAS;AACT,+BAA8B,WAAW,EAAE;AAC3C;;AAEA;AACA;AACA;AACA,+BAA8B,6BAA6B,EAAE;AAC7D;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oEAAmE;AACnE,8DAA6D;AAC7D,kCAAiC,cAAc;;AAE/C;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,+BAA8B,oCAAoC;AAClE,4EAA2E;AAC3E,6DAA4D;AAC5D,oCAAmC,cAAc;AACjD,QAAO;AACP,mBAAkB;AAClB,6DAA4D;AAC5D,iBAAgB;AAChB;AACA;AACA,IAAG;;AAEH,mEAAkE;AAClE;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA0C,iBAAiB;AAC3D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA,KAAI,QAAQ,aAAa,EAAE;AAC3B,KAAI,QAAQ,aAAa,EAAE;AAC3B,KAAI,QAAQ,cAAc,EAAE;AAC5B;AACA;AACA,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA,uBAAsB,wBAAwB;AAC9C,IAAG;AACH;AACA,uBAAsB,yBAAyB;AAC/C,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAI;AACJ,KAAI,QAAQ,WAAW;AACvB,KAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA,0CAAyC,gBAAgB,EAAE;AAC3D;AACA;;AAEA;;AAEA;AACA,8BAA6B,aAAa,IAAI;AAC9C;AACA;AACA;AACA,gBAAe,0CAA0C;AACzD;AACA;AACA;AACA,QAAO;AACP,wBAAuB,cAAc;AACrC;AACA,QAAO;AACP,wBAAuB,UAAU,wBAAwB;AACzD;AACA,QAAO;AACP,wBAAuB,SAAS,mBAAmB;AACnD;AACA,QAAO;AACP,MAAK;AACL;;AAEA;AACA;AACA,sBAAqB,aAAa,kBAAkB;AACpD;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,oBAAmB,sBAAsB;AACzC;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS,iBAAiB;AAC1B;AACA;AACA,cAAa,wBAAwB;AACrC;AACA;AACA,8BAA6B,UAAU,wBAAwB;AAC/D;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,2BAA0B,uBAAuB;AACjD,2BAA0B;AAC1B,gBAAe;AACf;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,4BAA2B,uBAAuB;AAClD,2BAA0B;AAC1B,gBAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,UAAS,uBAAuB;AAChC;AACA;AACA;AACA,sBAAqB,uBAAuB;AAC5C,wBAAuB;AACvB,YAAW;AACX;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,mBAAkB;AAClB;AACA,MAAK;;AAEL;AACA;AACA,kBAAiB,iBAAiB;AAClC,oBAAmB,iBAAiB;AACpC,mBAAkB;AAClB;AACA,MAAK;;AAEL,4BAA2B;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB,6BAA6B;AAC9C;AACA;AACA,iBAAgB,6BAA6B;AAC7C,iBAAgB,6BAA6B;AAC7C,iBAAgB;AAChB,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA,iBAAgB,6BAA6B;AAC7C,iBAAgB,6BAA6B;AAC7C,iBAAgB;AAChB,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA,iBAAgB,6BAA6B;AAC7C,iBAAgB,6BAA6B;AAC7C,iBAAgB;AAChB,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA,iBAAgB,6BAA6B;AAC7C,iBAAgB,6BAA6B;AAC7C,iBAAgB;AAChB,UAAS;AACT;AACA,QAAO;AACP;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,iBAAiB;AAClC;AACA;AACA,kCAAiC,SAAS,oBAAoB;AAC9D;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,0BAAyB,SAAS;AAClC;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,eAAc,6BAA6B;AAC3C,gBAAe,6BAA6B;AAC5C,gBAAe,6BAA6B;AAC5C,mBAAkB,6BAA6B;AAC/C,eAAc,6BAA6B;AAC3C,gBAAe,6BAA6B;AAC5C,gBAAe,6BAA6B;AAC5C,oBAAmB,6BAA6B;AAChD,qBAAoB,6BAA6B;AACjD,kBAAiB,4BAA4B;AAC7C,yBAAwB,6BAA6B;AACrD,oBAAmB,4BAA4B;AAC/C,yBAAwB,6BAA6B;AACrD,2BAA0B,6BAA6B;AACvD,wBAAuB,4BAA4B;AACnD,8BAA6B,6BAA6B;AAC1D,oBAAmB,6BAA6B;;AAEhD;AACA,kBAAiB,8BAA8B;;AAE/C;AACA,kBAAiB,6BAA6B;AAC9C;AACA;;AAEA;AACA,kBAAiB,6BAA6B;;AAE9C;AACA,yBAAwB,6BAA6B;AACrD,yBAAwB,6BAA6B;AACrD,wBAAuB,6BAA6B;AACpD,sBAAqB,6BAA6B;;AAElD;AACA;AACA;AACA,qBAAoB,6BAA6B;AACjD;;AAEA;AACA,iBAAgB,6BAA6B;AAC7C;AACA;;AAEA;AACA,kBAAiB,6BAA6B;AAC9C,gBAAe,6BAA6B;AAC5C,gBAAe,6BAA6B;AAC5C,mBAAkB,6BAA6B;AAC/C,mBAAkB,6BAA6B;AAC/C,mBAAkB,6BAA6B;AAC/C,kBAAiB,6BAA6B;AAC9C,sBAAqB,6BAA6B;AAClD,wBAAuB,6BAA6B;AACpD,uBAAsB;AACtB,QAAO;;AAEP;AACA;AACA;AACA;;;;;;;AC/nBA;AACA;;AAEA;AACA,mC;;;;;;ACJA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,G;;;;;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,G;;;;;;ACVA;AACA;AACA;AACA;;;;;;;ACHA;AACA,eAAc,8CAA8C;AAC5D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA0B,KAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA8B,KAAK;AACnC,4CAA2C;AAC3C;AACA;AACA;;AAEA;AACA;AACA,iCAAgC,KAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;AChDA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,iCAAgC,OAAO;AACvC;;AAEA,0BAAyB;;AAEzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,cAAc;AAC7B;AACA;AACA;AACA;;;;;;;ACrSA,sBAAqB;AACrB,qBAAoB;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA,gBAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AChHA;AACA;AACA;AACA;;;;;;;ACHA;AACA;AACA;AACA,G;;;;;;ACHA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP,MAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAgC;AAChC,MAAK;AACL;AACA,gCAA+B;AAC/B,wBAAuB;AACvB,iCAAgC;AAChC,iCAAgC;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,OAAO;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC1LA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0CAAyC,KAAK;AAC9C;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;;;;;;AC3EA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAgB,uBAAuB;AACvC;AACA;;AAEA;AACA;AACA;AACA;;AAEA,0B;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACXA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,G;;;;;;ACpBA;AACA;;AAEA;AACA;;AAEA,oCAAmC,UAAU;AAC7C,wCAAuC,YAAY;AACnD;;AAEA;AACA;AACA,oCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA2B,aAAa;;AAExC;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,+BAA8B,UAAU;AACxC,0BAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA0B,KAAK;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AClJA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;AChCA;;AAEA,oBAAmB,iBAAiB;AACpC,oBAAmB,iBAAiB;AACpC,oBAAmB,oCAAoC;AACvD,oBAAmB,qCAAqC;AACxD,oBAAmB,sCAAsC;AACzD,oBAAmB,4BAA4B;;AAE/C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACrEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,6BAA4B,KAAK;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA4B,KAAK;AACjC;AACA;AACA;AACA;AACA,8BAA6B,KAAK;AAClC;AACA;AACA,6BAA4B,KAAK;AACjC;AACA;AACA;AACA;AACA,gCAA+B,KAAK;AACpC;AACA;;AAEA;AACA;AACA;AACA,I;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAuB,QAAQ;AAC/B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA0B,QAAQ;AAClC;AACA;AACA;AACA,oBAAmB,aAAa,aAAa;AAC7C;AACA;AACA,wBAAuB,QAAQ;AAC/B;AACA;AACA;AACA,oBAAmB,aAAa,aAAa;AAC7C;AACA;AACA,yBAAwB,QAAQ;AAChC;AACA;AACA;AACA,oBAAmB,aAAa,aAAa;AAC7C;AACA;AACA,wBAAuB,QAAQ;AAC/B;AACA;AACA;AACA,oBAAmB,aAAa,aAAa;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;ACxIA;;AAEA;AACA;;AAEA;AACA;;AAEA,kCAAiC,OAAO;AACxC;AACA;AACA,gBAAe;;AAEf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,G;;;;;;ACpCA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;AChCA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;ACbA;;AAEA;AACA;;AAEA;AACA;;AAEA,kCAAiC,OAAO;AACxC;AACA;AACA,gBAAe;;AAEf;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,G;;;;;;ACjCA;;AAEA;AACA;;AAEA;AACA;;AAEA,kCAAiC,OAAO;AACxC;AACA;AACA,gBAAe;;AAEf;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;ACtDA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,G;;;;;;ACxEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kCAAiC,OAAO;AACxC;AACA;AACA,gBAAe;;AAEf;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA4B;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;ACxEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;AC9HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,aAAa;AACxB;AACA;;AAEA,6BAA4B,KAAK;AACjC;AACA,qBAAoB,WAAW;AAC/B,qBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA4B,KAAK;AACjC;AACA;AACA,8BAA6B,KAAK;AAClC;AACA;AACA;AACA,kCAAiC,KAAK;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAkB;;AAElB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8CAA6C;AAC7C;AACA;AACA;AACA;;AAEA;AACA,c;AACA,8BAA6B,KAAK;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACtSA;AACA,oBAAmB;AACnB,sBAAqB,aAAa;;AAElC;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACvBA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,4BAA2B;;AAE3B,2BAA0B;AAC1B;;AAEA;AACA,oCAAmC,kCAAkC;AACrE,yCAAwC,2BAA2B;AACnE,IAAG;AACH,mCAAkC,sCAAsC;AACxE,yCAAwC,iCAAiC;AACzE,IAAG;AACH,oCAAmC,qBAAqB;AACxD;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;ACxFA,gB;;;;;;ACAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,4BAA2B,KAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAQ,eAAe;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAsB;AACtB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sBAAqB;;AAErB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;;;;;;;ACvIA;;AAEA;AACA;AACA,mD;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,YAAW,SAAS;AACpB,4BAA2B,wBAAwB;AACnD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC1EA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;;AAEA,2B;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA,G;;;;;;ACNA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,4B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAgC,KAAK;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,4BAA2B,KAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA8B;AAC9B;AACA,MAAK,sBAAsB;AAC3B;AACA,MAAK,OAAO;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAQ,2BAA2B;AACnC;AACA;AACA;AACA,MAAK;AACL;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA2B,KAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA0B,KAAK;AAC/B;AACA;AACA;AACA;AACA,4BAA2B,KAAK;AAChC;AACA;AACA,2BAA0B,KAAK;AAC/B;AACA;AACA;AACA;AACA,8BAA6B,KAAK;AAClC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;;AAErB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA,mBAAkB;;AAElB;AACA;AACA;AACA;AACA,4BAA2B;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,0CAAyC,KAAK;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;ACtaA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAuD,OAAO;AAC9D;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;;;;;;;AChJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL,cAAa,gBAAgB;AAC7B;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;;AAEA;AACA;;AAEA,kCAAiC,OAAO;;AAExC;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAAyC;AACzC;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA,YAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA0B,KAAK;AAC/B;AACA;AACA;AACA;AACA,4BAA2B,KAAK;AAChC;AACA;AACA,2BAA0B,KAAK;AAC/B;AACA;AACA;AACA;AACA,8BAA6B,KAAK;AAClC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gCAA+B;AAC/B;;AAEA;AACA,sCAAqC;AACrC;;AAEA,0CAAyC,KAAK;AAC9C;AACA;AACA;;AAEA;AACA;AACA,kDAAiD;AACjD;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,4DAA2D;AAC3D;AACA;;AAEA;AACA;;AAEA;AACA,gCAA+B;AAC/B,+BAA8B;AAC9B,+BAA8B;AAC9B;;AAEA;;;;;;;ACjPA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uB;;;;;;AC/CA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA,2B;;;;;;ACtBA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2BAA0B,KAAK;AAC/B;AACA,gCAA+B,KAAK;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,G;;;;;;ACxDA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAkB,SAAS,eAAe;;;;;;;ACX1C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAAyB,WAAW;AACpC;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK,iBAAiB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,iBAAiB;AACpC,yBAAwB,2BAA2B;AACnD,sBAAqB,wBAAwB;AAC7C;AACA;AACA;AACA;AACA,0BAAyB,iBAAiB;AAC1C;AACA,8BAA6B;AAC7B,gBAAe;AACf;AACA,cAAa;AACb;AACA,0BAAyB,uBAAuB;AAChD;AACA,gBAAe;AACf;AACA,cAAa;AACb;AACA;AACA,4BAA2B,qBAAqB;AAChD,+BAA8B;AAC9B,kBAAiB;AACjB;AACA,gBAAe;AACf;AACA,4BAA2B,qBAAqB;AAChD,4BAA2B;AAC3B,kBAAiB;AACjB;AACA,gBAAe;AACf,cAAa;AACb;AACA,0BAAyB,qBAAqB;AAC9C,8BAA6B,iBAAiB;AAC9C;AACA,gBAAe;AACf;AACA,cAAa;AACb;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA,UAAS;AACT;AACA,4BAA2B,WAAW,kBAAkB;AACxD;AACA,YAAW;AACX,4BAA2B,WAAW,iBAAiB;AACvD;AACA,YAAW;AACX,4BAA2B,QAAQ,kBAAkB;AACrD;AACA,YAAW;AACX,UAAS;AACT,QAAO;AACP;AACA;AACA;;;;;;;ACtJA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;;AAEA;AACA,wBAAuB,6BAA6B,EAAE;;AAEtD;AACA;AACA,EAAC,IAAI;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB;AAClB,UAAS;AACT;AACA;AACA,IAAG;AACH;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,G;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,eAAc,qBAAqB;AACnC;AACA;AACA;AACA,4BAA2B;AAC3B;AACA;;AAEA,+CAA8C;AAC9C;AACA;AACA;AACA,0BAAyB,sBAAsB;AAC/C;AACA;;AAEA,yBAAwB,wCAAwC;;AAEhE,qCAAoC,OAAO;AAC3C;AACA,gCAA+B,gCAAgC;AAC/D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH,sBAAqB;AACrB,sBAAqB;AACrB,sBAAqB;AACrB;AACA;;AAEA;AACA,gBAAe;;AAEf;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA2B,6CAA6C;;AAExE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA,iCAAgC;;AAEhC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oCAAmC,iBAAiB;;AAEpD;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2BAA0B,KAAK;AAC/B;AACA;;AAEA;AACA,2BAA0B,KAAK;AAC/B;AACA,6BAA4B,KAAK;AACjC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAwB,cAAc,oBAAoB;AAC1D,yBAAwB,iBAAiB;AACzC,yBAAwB,oBAAoB;AAC5C,yBAAwB,wBAAwB;AAChD,IAAG;AACH;AACA;AACA;AACA,mBAAkB;AAClB;AACA,yBAAwB,mBAAmB,oBAAoB;AAC/D,yBAAwB,sBAAsB;AAC9C,yBAAwB,8BAA8B;AACtD,yBAAwB,+BAA+B;AACvD;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA,sCAAqC,eAAe;AACpD,mCAAkC,eAAe,OAAO;AACxD;AACA;AACA;;AAEA;AACA,YAAW,cAAc;AACzB;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,sBAAsB;AACnC;AACA;AACA,iBAAgB,WAAW,iBAAiB,GAAG,wBAAwB,EAAE;AACzE;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB,WAAW,kBAAkB,GAAG,wBAAwB;AAC9E;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,iBAAiB,GAAG,wBAAwB;AACvE,gBAAe;AACf;AACA;AACA;AACA,2BAA0B,WAAW,kBAAkB,GAAG,wBAAwB;AAClF,gBAAe;AACf;AACA;AACA;AACA,2BAA0B,WAAW,iBAAiB,GAAG,wBAAwB;AACjF;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;;;;;;AC1QA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC3DA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;AACH,sBAAqB,yBAAyB;AAC9C,gBAAe,4BAA4B;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oDAAmD,sBAAsB,EAAE;AAC3E,2BAA0B;AAC1B;;AAEA,oCAAmC,KAAK;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO,oBAAoB;AAC3B;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,iCAAgC,kCAAkC;AAClE,QAAO;AACP;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,4BAA2B,eAAe;AAC1C,QAAO;AACP;AACA;;AAEA;AACA,IAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,oBAAmB,UAAU,kBAAkB;AAC/C;AACA,IAAG;AACH,oBAAmB,UAAU,kBAAkB;AAC/C;AACA,IAAG;AACH;;;;;;;AC1IA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,eAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAoB;AACpB;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;ACjGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,cAAc;AAC1B,WAAU,cAAc;AACxB,WAAU,cAAc;AACxB,YAAW,2BAA2B;AACtC,eAAc,2BAA2B;AACzC,YAAW,cAAc;AACzB,aAAY,cAAc;AAC1B,eAAc,cAAc;AAC5B,WAAU;AACV,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,gBAAgB;AAC7B;AACA,kBAAiB,iBAAiB,GAAG,wBAAwB;AAC7D;AACA,MAAK;AACL;AACA,kBAAiB,iBAAiB,GAAG,wBAAwB;AAC7D;AACA,MAAK;AACL;AACA,kBAAiB,iBAAiB,GAAG,wBAAwB;AAC7D;AACA,MAAK;AACL;AACA,kBAAiB,iBAAiB,GAAG,wBAAwB;AAC7D;AACA;AACA,MAAK;AACL;AACA,kBAAiB,iBAAiB,GAAG,wBAAwB;AAC7D;AACA;AACA,MAAK;AACL;AACA,kBAAiB,iBAAiB,GAAG,wBAAwB;AAC7D;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,qBAAoB;AACpB,UAAS;AACT,UAAS;AACT;AACA,MAAK;AACL;AACA,kBAAiB,iBAAiB,GAAG,wBAAwB;AAC7D;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,qBAAoB,iBAAiB;AACrC;AACA,UAAS;AACT,UAAS;AACT;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,mBAAkB,yCAAyC;AAC3D,iBAAgB,uCAAuC;AACvD,iBAAgB;AAChB,QAAO;AACP;AACA;AACA,IAAG;AACH;AACA;AACA;;;;;;;AC5JA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,aAAa;AACxB,gBAAe,+BAA+B;AAC9C,cAAa;AACb,IAAG;;AAEH,mBAAkB;AAClB,yBAAwB;AACxB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,wCAAuC,gBAAgB;AACvD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY;;AAEZ,SAAQ,OAAO;AACf;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAAyB,MAAM;AAC/B;AACA,4BAA2B;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,6BAA4B,OAAO;AACnC;AACA,mCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,YAAY;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,kBAAkB;AAC/B;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,kBAAiB,kBAAkB,GAAG,wBAAwB;AAC9D;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,kBAAiB,iCAAiC;AAClD,mBAAkB;AAClB,QAAO;AACP;AACA;AACA,IAAG;AACH;AACA;AACA;;;;;;;AChPA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAgB,+BAA+B;AAC/C,iBAAgB,mCAAmC;AACnD,iBAAgB,gCAAgC;AAChD,iBAAgB;AAChB,IAAG;;AAEH,mBAAkB;;AAElB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,qBAAoB,qCAAqC;AACzD,qBAAoB,2BAA2B;;AAE/C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kDAAiD;AACjD;AACA;;AAEA;AACA;AACA;AACA;AACA,uCAAsC;AACtC;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6CAA4C;AAC5C,6CAA4C;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,YAAW,iBAAiB;AAC5B;AACA,cAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,YAAW,iBAAiB;AAC5B;AACA,cAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,yBAAyB;AACtC;AACA;AACA,kBAAiB,iBAAiB,GAAG,wBAAwB;AAC7D;AACA,MAAK;AACL;AACA;AACA,kBAAiB,iBAAiB,GAAG,wBAAwB;AAC7D;AACA,MAAK;AACL;AACA;AACA,kBAAiB,mCAAmC,GAAG,wBAAwB;AAC/E;AACA,MAAK;AACL;AACA;AACA,kBAAiB,iBAAiB,GAAG,wBAAwB;AAC7D;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,kBAAiB,oCAAoC;AACrD,mBAAkB;AAClB,QAAO;AACP;AACA;AACA,IAAG;AACH;AACA;AACA;;;;;;;ACnKA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,2CAA2C;AAC1D,gBAAe,2CAA2C;AAC1D,gBAAe,2CAA2C;AAC1D,gBAAe,2CAA2C;AAC1D,gBAAe,4BAA4B;AAC3C,gBAAe;AACf,IAAG;;AAEH,mBAAkB;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,qBAAqB;AAClC;AACA;AACA,kBAAiB,iBAAiB,GAAG,wBAAwB;AAC7D;AACA,MAAK;AACL;AACA;AACA,kBAAiB,iBAAiB,GAAG,wBAAwB;AAC7D;AACA,MAAK;AACL;AACA;AACA,kBAAiB,iBAAiB,GAAG,wBAAwB;AAC7D;AACA,MAAK;AACL;AACA;AACA,kBAAiB,iBAAiB,GAAG,wBAAwB;AAC7D;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,UAAS,kGAAkG;AAC3G,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,kBAAiB;AACjB,QAAO;AACP;AACA;AACA,IAAG;AACH;AACA;AACA;;;;;;;ACzLA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA4B;AAC5B,cAAa,kBAAkB;AAC/B,mBAAkB;AAClB,IAAG;AACH;AACA;AACA;;;;;;;AC5DA;AACA;AACA;;AAEA;AACA;AACA,kCAAiC,OAAO,cAAc;;AAEtD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA,MAAK,OAAO;AACZ;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,mBAAmB;AAChC;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;;;;;;ACnEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb,IAAG;;AAEH,mBAAkB;AAClB;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA0B,KAAK;AAC/B;AACA,iCAAgC,KAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,kCAAiC,0BAA0B,EAAE;AAC7D;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA,qBAAoB,WAAW,iBAAiB,GAAG,wBAAwB,EAAE;AAC7E;AACA;AACA,UAAS;AACT,UAAS;AACT;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,iBAAgB,mCAAmC;AACnD,mBAAkB;AAClB,QAAO;AACP;AACA;AACA,IAAG;AACH;AACA;AACA;;;;;;;ACvGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAW,6DAAwD;AACnE,aAAY,6BAA6B;AACzC,aAAY,aAAa;;AAEzB;AACA;AACA,oBAAmB,0BAA0B;AAC7C,oBAAmB,2BAA2B;AAC9C,cAAa,4BAA4B;;AAEzC,sBAAqB,iCAAiC;AACtD,gBAAe,4BAA4B;AAC3C,aAAY,4BAA4B;AACxC,eAAc,4BAA4B;AAC1C,aAAY,4BAA4B;AACxC,kBAAiB,4BAA4B;;AAE7C,mBAAkB,0CAA0C;AAC5D,cAAa,mCAAmC;AAChD,aAAY;AACZ,IAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;;AAEA;AACA;AACA,uCAAsC;AACtC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAsB;;AAEtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6BAA4B,YAAY;AACxC,iBAAgB,YAAY;AAC5B;;AAEA;AACA,4CAA2C,YAAY;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc;;AAEd;AACA;AACA;AACA,8BAA6B,KAAK;AAClC;AACA;AACA;;AAEA,YAAW,gBAAgB;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,kBAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB,WAAW,iBAAiB,GAAG,wBAAwB;AAC3E,UAAS;AACT,UAAS;AACT;;AAEA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,kBAAiB,iBAAiB,GAAG,iBAAiB,GAAG,wBAAwB;AACjF;AACA,MAAK;AACL;AACA,kBAAiB,iBAAiB,GAAG,iBAAiB,GAAG,wBAAwB;AACjF;AACA;AACA,MAAK;AACL;AACA,kBAAiB,iBAAiB,GAAG,iBAAiB,GAAG,wBAAwB;AACjF;AACA;AACA,MAAK;AACL;AACA,kBAAiB,iBAAiB,GAAG,wBAAwB;AAC7D;AACA;AACA,MAAK;AACL;AACA;AACA,kBAAiB,iBAAiB,GAAG,wBAAwB;AAC7D;AACA,MAAK;AACL;AACA;AACA,kBAAiB,iBAAiB,GAAG,wBAAwB;AAC7D;AACA,MAAK;AACL;AACA;AACA,kBAAiB,iBAAiB,GAAG,wBAAwB;AAC7D;AACA,MAAK;AACL;AACA;AACA,kBAAiB,iBAAiB,GAAG,wBAAwB;AAC7D;AACA,MAAK;AACL;AACA;AACA,kBAAiB,iBAAiB,GAAG,wBAAwB;AAC7D;AACA,MAAK;AACL;AACA;AACA,kBAAiB,kBAAkB,GAAG,wBAAwB;AAC9D;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,eAAc,wCAAwC;AACtD,eAAc;AACd,QAAO;AACP;AACA;AACA,IAAG;AACH;AACA;AACA;;;;;;;AC9SA;AACA,aAAY,gBAAgB,GAAG,iBAAiB;AAChD,aAAY,gBAAgB,GAAG,iBAAiB;AAChD;AACA,MAAK,sCAAsC;AAC3C,MAAK;AACL;AACA,G;;;;;;ACPA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,cAAc;AAC1B,aAAY;AACZ,IAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,oBAAoB;AACjC;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;;;;;;ACzDA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAU,cAAc;AACxB,WAAU;AACV,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAe,mCAAmC;AAClD,gBAAe,qBAAqB;AACpC,gBAAe,+DAA0D;AACzE,gBAAe,qBAAqB;AACpC,gBAAe,cAAc;AAC7B,gBAAe,cAAc;AAC7B,gBAAe,cAAc;AAC7B,gBAAe;AACf;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,gBAAe,iBAAiB,GAAG,wBAAwB;AAC3D;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,mBAAkB,WAAW,iBAAiB,GAAG,wBAAwB,EAAE;AAC3E;AACA;AACA,QAAO;AACP,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,mBAAkB,WAAW,iBAAiB,GAAG,wBAAwB,EAAE;AAC3E;AACA;AACA,QAAO;AACP,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA,gBAAe,iBAAiB,GAAG,wBAAwB;AAC3D,IAAG;AACH;AACA;AACA,gBAAe,iBAAiB,GAAG,wBAAwB;AAC3D,IAAG;AACH;AACA;AACA,gBAAe,iBAAiB,GAAG,wBAAwB;AAC3D,IAAG;AACH;AACA;AACA,gBAAe,iBAAiB,GAAG,wBAAwB;AAC3D,IAAG;AACH;AACA;AACA,gBAAe,iBAAiB,GAAG,wBAAwB;AAC3D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,gBAAgB;AAC7B;AACA;AACA,kBAAiB,iBAAiB,GAAG,wBAAwB;AAC7D,MAAK;AACL;AACA;AACA,kBAAiB,iBAAiB,GAAG,wBAAwB;AAC7D,MAAK;AACL;AACA;AACA;AACA;AACA,eAAc,wCAAwC;AACtD,eAAc;AACd,QAAO;AACP;AACA;AACA,IAAG;AACH;AACA;AACA;;;;;;;;ACvKA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAY,6BAA6B;AACzC,IAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,oBAAoB;AACjC;AACA;AACA,kBAAiB,iBAAiB,GAAG,wBAAwB;AAC7D,MAAK;AACL;AACA;AACA;AACA;AACA,kBAAiB;AACjB,QAAO;AACP;AACA;AACA,IAAG;AACH;AACA;AACA,G;;;;;;ACrEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,oCAAoC;AAC/C,gBAAe,mCAAmC;AAClD,cAAa,iCAAiC;AAC9C,aAAY,6BAA6B;AACzC;AACA,YAAW,+BAA+B;AAC1C,YAAW,6DAAwD;AACnE,gBAAe,oCAAoC;AACnD,cAAa;AACb,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,8BAA6B,wCAAwC,EAAE;AACvE,2BAA0B,kDAAkD;AAC5E;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAsC,2BAA2B,EAAE;;AAEnE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,sBAAsB;AACnC;AACA;AACA;AACA;AACA;AACA,qBAAoB,WAAW,iBAAiB,GAAG,wBAAwB;AAC3E,UAAS;AACT,UAAS;AACT;AACA,MAAK;AACL;AACA;AACA,kBAAiB,iBAAiB,GAAG,wBAAwB;AAC7D;AACA,MAAK;AACL;AACA;AACA,kBAAiB,iBAAiB,GAAG,wBAAwB;AAC7D;AACA,MAAK;AACL;AACA;AACA,kBAAiB,iBAAiB,GAAG,wBAAwB;AAC7D,MAAK;AACL;AACA;AACA;AACA,UAAS,yCAAyC;AAClD,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,UAAS,gCAAgC;AACzC,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,qBAAoB,WAAW,iBAAiB,GAAG,wBAAwB,EAAE;AAC7E;AACA;AACA,UAAS;AACT,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,qBAAoB,WAAW,iBAAiB,GAAG,wBAAwB,EAAE;AAC7E;AACA;AACA,UAAS;AACT,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,eAAc,wCAAwC;AACtD,eAAc,wCAAwC;AACtD,mBAAkB,4CAA4C;AAC9D,oBAAmB,6CAA6C;AAChE,mBAAkB;AAClB,QAAO;AACP;AACA;AACA,IAAG;AACH;AACA;AACA;;;;;;;AC3LA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc,qBAAqB;AACnC,eAAc,qBAAqB;AACnC,eAAc,cAAc;AAC5B,eAAc,gCAAgC;AAC9C,eAAc;AACd,IAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,6BAA4B,KAAK;AACjC;;AAEA;AACA;AACA;AACA;;AAEA;AACA,8BAA6B,KAAK;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA0B,KAAK;AAC/B;AACA;AACA,2BAA0B,KAAK;AAC/B;AACA;AACA;;AAEA;AACA;;AAEA;AACA,YAAW,eAAe;AAC1B,YAAW,aAAa;AACxB,YAAW,aAAa;AACxB;AACA;;AAEA;AACA;AACA,0BAAyB,aAAa,EAAE;AACxC,0BAAyB,gCAAgC,EAAE;AAC3D;;AAEA;AACA;AACA;AACA,qBAAoB,iBAAiB;AACrC,IAAG,IAAI;;AAEP;AACA,cAAa,MAAM,eAAe;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,mBAAmB;AAChC;AACA;AACA;AACA,UAAS,kDAAkD;AAC3D,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,UAAS,iBAAiB;AAC1B,UAAS,iBAAiB;AAC1B,UAAS,kBAAkB;AAC3B,UAAS,eAAe;AACxB,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA,kBAAiB,iBAAiB,GAAG,wBAAwB;AAC7D,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,qBAAoB,WAAW,iBAAiB,GAAG,wBAAwB;AAC3E,UAAS;AACT,UAAS;AACT;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,qBAAoB,WAAW,iBAAiB,GAAG,wBAAwB;AAC3E,UAAS;AACT,UAAS;AACT;AACA;AACA,IAAG;AACH;AACA;AACA;;;;;;;AC5JA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc,aAAa;AAC3B,eAAc,6BAA6B;AAC3C,eAAc,qBAAqB;AACnC,eAAc,wCAAwC;AACtD,eAAc;AACd,IAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAc;AACd;AACA,kBAAiB,MAAM,iBAAiB;AACxC;AACA;AACA,MAAK,OAAO;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAiB,cAAc;AAC/B;AACA;AACA;AACA;;AAEA;AACA,0CAAyC,wBAAwB,EAAE;AACnE;AACA;AACA;AACA;;AAEA,2BAA0B,qBAAqB,EAAE;AACjD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,mBAAmB;AAChC;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,kBAAiB,iBAAiB,GAAG,wBAAwB;AAC7D,MAAK;AACL;AACA;AACA;AACA,iBAAgB,WAAW,iBAAiB,GAAG,wBAAwB;AACvE,MAAK;AACL;AACA;AACA;AACA,iBAAgB;AAChB,MAAK;AACL;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;;;;;;ACxGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,6BAA6B;AAC9C,kBAAiB,0BAA0B;AAC3C,kBAAiB,oCAAoC;AACrD,kBAAiB;AACjB,IAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAiB,UAAU;;AAE3B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA,YAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,gBAAgB;AAC7B;AACA,kBAAiB,iBAAiB,GAAG,wBAAwB;AAC7D;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA,kBAAiB,kBAAkB,GAAG,wBAAwB;AAC9D;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,mBAAkB,4CAA4C;AAC9D,iBAAgB,0CAA0C;AAC1D,iBAAgB;AAChB;AACA;AACA,IAAG;AACH;AACA;;;;;;;ACpHA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,6BAA6B;AACzC,iBAAgB;AAChB,IAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,gBAAe;AACf;;AAEA;AACA;AACA,sBAAqB,OAAO;AAC5B;AACA;AACA;AACA;;AAEA;AACA,YAAW,sBAAsB;AACjC;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,iBAAiB;AAC9B;AACA,kBAAiB,iBAAiB,GAAG,wBAAwB;AAC7D;AACA;AACA,MAAK;AACL;AACA;AACA,kBAAiB,kBAAkB,GAAG,wBAAwB;AAC9D;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,kBAAiB;AACjB,QAAO;AACP;AACA;AACA,IAAG;AACH;AACA;AACA;;;;;;;AClFA;AACA;AACA;;AAEA;AACA;AACA,kCAAiC,KAAK,qBAAqB,EAAE;AAC7D;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,iBAAiB;AAC9B;AACA;AACA,UAAS,iBAAiB;AAC1B,UAAS,2BAA2B;AACpC;AACA;AACA;AACA,IAAG;AACH;AACA;;;;;;;ACxCA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc,qBAAqB;AACnC,cAAa,qBAAqB;AAClC,aAAY,cAAc;AAC1B,cAAa;AACb,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gCAA+B,iBAAiB;AAChD;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAa,gBAAgB;AAC7B;AACA,aAAY;AACZ;AACA,2BAA0B;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAAyB,aAAa,EAAE;AACxC;;AAEA;AACA;AACA;AACA,IAAG;AACH,gBAAe,MAAM,eAAe;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAkB,iBAAiB;AACnC;AACA,mBAAkB,YAAY;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,kBAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA,qBAAoB,WAAW,iBAAiB,GAAG,wBAAwB;AAC3E,UAAS;AACT,UAAS;AACT;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,qBAAoB,WAAW,iBAAiB,GAAG,wBAAwB;AAC3E,UAAS;AACT,UAAS;AACT;AACA,MAAK;AACL;AACA;AACA,kBAAiB,iBAAiB,GAAG,wBAAwB;AAC7D,MAAK;AACL;AACA;AACA,kBAAiB,wCAAwC,GAAG,wBAAwB;AACpF;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,mBAAkB,4CAA4C;AAC9D,iBAAgB,0CAA0C;AAC1D,iBAAgB;AAChB,QAAO;AACP;AACA;AACA,IAAG;AACH;AACA;AACA;;;;;;;ACnJA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,mBAAkB,4CAA4C;AAC9D;AACA;AACA,QAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+CAA8C,oBAAoB,EAAE;AACpE,MAAK;AACL;;AAEA,6BAA4B;AAC5B;AACA;AACA;;AAEA;AACA,2BAA0B,KAAK;AAC/B;AACA;AACA,2BAA0B,KAAK;AAC/B;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,oBAAoB;AACjC;AACA;AACA;AACA;AACA;AACA,qBAAoB,WAAW,iBAAiB,GAAG,wBAAwB;AAC3E,UAAS;AACT,UAAS;AACT;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,sBAAqB,wCAAwC;AAC7D,oBAAmB;AACnB,QAAO;AACP;AACA;AACA,IAAG;AACH;AACA;AACA;;;;;;;AC7FA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,YAAW,0CAA0C;AACrD,gBAAe,mCAAmC;AAClD,cAAa,iCAAiC;AAC9C,aAAY,gCAAgC;AAC5C;AACA,YAAW,6DAAwD;AACnE,aAAY,6BAA6B;AACzC,cAAa,8BAA8B;AAC3C,aAAY,qCAAqC;AACjD,eAAc,6BAA6B;AAC3C,YAAW;AACX,IAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uCAAsC,2BAA2B,EAAE;;AAEnE;AACA;AACA,oCAAmC,uBAAuB;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,oBAAoB;AACjC;AACA;AACA;AACA;AACA;AACA,qBAAoB,WAAW,iBAAiB,GAAG,wBAAwB;AAC3E,UAAS;AACT,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA,kBAAiB,iBAAiB,GAAG,wBAAwB;AAC7D;AACA,MAAK;AACL;AACA;AACA,kBAAiB,iBAAiB,GAAG,wBAAwB;AAC7D;AACA,MAAK;AACL;AACA;AACA,kBAAiB,iBAAiB,GAAG,wBAAwB;AAC7D,MAAK;AACL;AACA;AACA;AACA,UAAS,oDAAoD;AAC7D,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,qBAAoB,WAAW,iBAAiB,GAAG,wBAAwB,EAAE;AAC7E;AACA;AACA,UAAS;AACT,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA,kBAAiB,kBAAkB,GAAG,wBAAwB;AAC9D;AACA,MAAK;AACL;AACA;AACA,kBAAiB,kBAAkB,GAAG,wBAAwB;AAC9D;AACA,MAAK;AACL;AACA;AACA,kBAAiB,iBAAiB,GAAG,wBAAwB;AAC7D;AACA,MAAK;AACL;AACA;AACA,UAAS,iBAAiB;AAC1B;AACA;AACA,qBAAoB,WAAW,iBAAiB,GAAG,wBAAwB,EAAE;AAC7E;AACA;AACA,UAAS;AACT,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,eAAc,wCAAwC;AACtD,eAAc,wCAAwC;AACtD,mBAAkB,4CAA4C;AAC9D,oBAAmB,6CAA6C;AAChE,mBAAkB;AAClB,QAAO;AACP;AACA;AACA,IAAG;AACH;AACA;AACA;;;;;;;ACtLA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB,+DAA0D;AAC3E,SAAQ,mCAAmC;AAC3C,SAAQ;AACR,IAAG;;AAEH;AACA,mBAAkB;;AAElB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAe,eAAe;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,oBAAoB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA0B,WAAW,iBAAiB,GAAG,wBAAwB,EAAE;AACnF;AACA;AACA,gBAAe;AACf,gBAAe;AACf;AACA,YAAW;AACX;AACA;AACA,UAAS;AACT,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA,kBAAiB,iBAAiB,GAAG,wBAAwB;AAC7D,MAAK;AACL;AACA;AACA,kBAAiB,iBAAiB,GAAG,wBAAwB;AAC7D,MAAK;AACL;AACA;AACA;AACA;AACA,kBAAiB;AACjB,QAAO;AACP;AACA;AACA,IAAG;AACH;AACA;AACA;;;;;;;AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,6DAAwD;AACnE,YAAW,+BAA+B;AAC1C,cAAa,gCAAgC;AAC7C,YAAW,+BAA+B,qBAAqB;AAC/D,gBAAe,iCAAiC;AAChD,iBAAgB,+BAA+B,iBAAiB;AAChE,kBAAiB,+BAA+B,iBAAiB;AACjE,iBAAgB,wCAAwC;AACxD,eAAc,0BAA0B;AACxC,cAAa;AACb,IAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA4B,uBAAuB;AACnD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAiC,OAAO;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,sBAAsB;AACnC;AACA;AACA;AACA;AACA;AACA,qBAAoB,WAAW,iBAAiB,GAAG,wBAAwB,EAAE;AAC7E;AACA;AACA,UAAS;AACT,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA,kBAAiB,iBAAiB,qBAAqB,wBAAwB;AAC/E;AACA,MAAK;AACL;AACA;AACA,kBAAiB,iBAAiB,qBAAqB,wBAAwB;AAC/E;AACA,MAAK;AACL;AACA;AACA,kBAAiB,iBAAiB,qBAAqB,wBAAwB;AAC/E;AACA,MAAK;AACL;AACA;AACA,kBAAiB,iBAAiB,qBAAqB,iBAAiB,GAAG,wBAAwB;AACnG;AACA,MAAK;AACL;AACA;AACA;AACA,UAAS,iBAAiB;AAC1B;AACA;AACA;AACA;AACA,qBAAoB,WAAW,gBAAgB,GAAG,wBAAwB;AAC1E;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,UAAS,iBAAiB,GAAG,iBAAiB;AAC9C,4BAA2B;AAC3B;AACA;AACA,MAAK;AACL;AACA;AACA,kBAAiB,iBAAiB,qBAAqB,wBAAwB;AAC/E;AACA,MAAK;AACL;AACA;AACA,kBAAiB,uCAAuC,qBAAqB,wBAAwB;AACrG;AACA,MAAK;AACL;AACA;AACA,kBAAiB,iBAAiB,qBAAqB,wBAAwB;AAC/E;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,eAAc,wCAAwC;AACtD,eAAc,wCAAwC;AACtD,kBAAiB,2CAA2C;AAC5D,sBAAqB,+CAA+C;AACpE,uBAAsB,gDAAgD;AACtE,wBAAuB,iDAAiD;AACxE,oBAAmB;AACnB,QAAO;AACP;AACA;AACA,IAAG;AACH;AACA;AACA;;;;;;;AC3MA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS,uBAAuB,wBAAwB,EAAE;;AAE1D;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA0B,6BAA6B,GAAG,6BAA6B;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,aAAY;AACZ;;AAEA;AACA,uBAAsB,WAAW,GAAG,uBAAuB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB,OAAO;AAChC;AACA,4BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,aAAa;AAChC;AACA;AACA;AACA;AACA;AACA,oBAAmB,OAAO;AAC1B,sBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,OAAO;AACxB;AACA,oBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB;AACvB,wBAAuB;AACvB,wBAAuB;AACvB,wBAAuB;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oDAAmD,UAAU;AAC7D;;AAEA;AACA;AACA;AACA;;;;;;;AC9YA;AACA;AACA;AACA,oCAAmC;AACnC,EAAC,2BAA2B;;AAE5B;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA4B;AAC5B,4BAA2B;AAC3B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAsB;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2CAA0C;AAC1C;AACA,eAAc;AACd;;AAEA;AACA;AACA,uEAAsE;AACtE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,EAAC,G;;;;;;ACvGD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,2BAA0B,QAAQ;AAClC,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,8BAA6B;AAC7B;AACA;AACA,4CAA2C;AAC3C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,oCAAmC,iBAAiB,EAAE;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,UAAS;;AAET;AACA,QAAO;;AAEP;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA,iCAAgC,qBAAqB,EAAE;AACvD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA,eAAc;AACd,wBAAuB,iBAAiB;AACxC,uBAAsB;AACtB,YAAW;AACX;AACA,UAAS;AACT;AACA,sBAAqB,sBAAsB;AAC3C,2BAA0B,iBAAiB;AAC3C,YAAW;AACX;AACA,UAAS;AACT;AACA;AACA,sBAAqB,sBAAsB;AAC3C,sBAAqB;AACrB,YAAW;AACX;AACA,UAAS;AACT;AACA;AACA;AACA;;;;;;;ACtLA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAqB,0BAA0B;AAC/C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,2DAA0D;AAC1D;;AAEA,wBAAuB;;AAEvB,mCAAkC,wBAAwB;AAC1D;;AAEA;AACA,mBAAkB,oDAAoD;AACtE,kCAAiC,sBAAsB,EAAE;AACzD,+BAA8B,YAAY,EAAE;AAC5C;AACA,mBAAkB,oDAAoD;AACtE;AACA,mBAAkB,oDAAoD;AACtE;AACA,mBAAkB,oDAAoD;AACtE;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,yCAAwC,kBAAkB,EAAE;AAC5D;AACA,YAAW;AACX,gCAA+B,UAAU,EAAE;AAC3C;AACA,oBAAmB,oDAAoD;AACvE;AACA,oBAAmB,oDAAoD;AACvE;AACA;AACA;AACA,2CAA0C,cAAc,EAAE;AAC1D;AACA,YAAW;AACX;AACA,oBAAmB,oDAAoD;AACvE;AACA,oBAAmB,oDAAoD;AACvE,mCAAkC,SAAS,qCAAqC,EAAE;AAClF,mCAAkC,SAAS,iCAAiC,EAAE;AAC9E,mCAAkC,SAAS,mCAAmC,EAAE;AAChF,gCAA+B,SAAS,kBAAkB,EAAE;AAC5D,gCAA+B,SAAS,mBAAmB,EAAE;AAC7D;AACA,oBAAmB,0DAA0D;AAC7E;AACA,oBAAmB,8DAA8D;AACjF;AACA,oBAAmB,0DAA0D;AAC7E;AACA,oBAAmB,wDAAwD;AAC3E;AACA,oBAAmB,0DAA0D;AAC7E;AACA,oBAAmB,0DAA0D;AAC7E;AACA,oBAAmB,0DAA0D;AAC7E;AACA,oBAAmB,4DAA4D;AAC/E;AACA,oBAAmB,0DAA0D;AAC7E;AACA,oBAAmB,4DAA4D;AAC/E;AACA,oBAAmB,oEAAoE;AACvF;AACA,oBAAmB,gEAAgE;AACnF;AACA,oBAAmB,4DAA4D;AAC/E;AACA,oBAAmB,kEAAkE;AACrF;AACA,oBAAmB,4DAA4D;AAC/E;AACA,oBAAmB,gEAAgE;AACnF;AACA,oBAAmB,kEAAkE;AACrF;AACA,oBAAmB,4DAA4D;AAC/E;AACA,oBAAmB,sEAAsE;AACzF;AACA,oBAAmB,oEAAoE;AACvF;AACA,oBAAmB,kEAAkE;AACrF;AACA,oBAAmB,oEAAoE;AACvF;AACA,oBAAmB,sEAAsE;AACzF;AACA,oBAAmB,sEAAsE;AACzF;AACA,oBAAmB,oEAAoE;AACvF;AACA,oBAAmB,kEAAkE;AACrF;AACA,oBAAmB,oEAAoE;AACvF;AACA,oBAAmB,kEAAkE;AACrF;AACA,oBAAmB,oEAAoE;AACvF,gCAA+B,UAAU,EAAE;AAC3C;AACA,oBAAmB,sEAAsE;AACzF,gCAA+B,mBAAmB,EAAE;AACpD;AACA,oBAAmB,kIAAkI;AACrJ,gCAA+B,mBAAmB,EAAE;AACpD;AACA,oBAAmB,oIAAoI;AACvJ,gCAA+B,mBAAmB,EAAE;AACpD;AACA,oBAAmB,oEAAoE;;AAEvF;AACA;AACA,kCAAiC,oCAAoC;AACrE;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAU,0CAA0C;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mCAAkC,gBAAgB;AAClD;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAAyC,QAAQ;;AAEjD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW;AACX;AACA,YAAW;AACX;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA4B,oDAAoD;;AAEhF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAA+D,yBAAyB,EAAE;AAC1F,gEAA+D,yBAAyB,EAAE;AAC1F,gEAA+D,yBAAyB,EAAE;AAC1F,gEAA+D,yBAAyB,EAAE;AAC1F;;AAEA;AACA;;AAEA,oBAAmB,qBAAqB;AACxC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA,yCAAwC,kBAAkB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,qCAAoC,kBAAkB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA,6CAA4C,kBAAkB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB;AACvB;AACA,qDAAoD,kBAAkB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B;AAC3B;AACA,yDAAwD,kBAAkB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B;AAC/B;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA;AACA,4BAA2B;AAC3B;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA,wBAAuB;AACvB;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA,oBAAmB;AACnB;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,qCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA,yCAAwC,mBAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,uCAAsC,mBAAmB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,2CAA0C,mBAAmB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,2CAA0C,mBAAmB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA,6CAA4C,mBAAmB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA,qCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,uCAAsC,mBAAmB;AACzD;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA,yCAAwC,mBAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,2CAA0C,mBAAmB;AAC7D;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA,6CAA4C,mBAAmB;AAC/D;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA,+CAA8C,mBAAmB;AACjE;AACA;AACA;AACA;AACA;AACA,oBAAmB;AACnB;AACA,iDAAgD,mBAAmB;AACnE;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA,mDAAkD,mBAAmB;AACrE;AACA;AACA;AACA;AACA;AACA,wBAAuB;AACvB;AACA,qDAAoD,mBAAmB;AACvE;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA,uDAAsD,mBAAmB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA,qCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,uCAAsC,mBAAmB;AACzD;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA,yCAAwC,mBAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,2CAA0C,mBAAmB;AAC7D;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA,6CAA4C,mBAAmB;AAC/D;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA,+CAA8C,mBAAmB;AACjE;AACA;AACA;AACA;AACA;AACA,oBAAmB;AACnB;AACA,iDAAgD,mBAAmB;AACnE;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA,mDAAkD,mBAAmB;AACrE;AACA;AACA;AACA;AACA;AACA,wBAAuB;AACvB;AACA,qDAAoD,mBAAmB;AACvE;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA,uDAAsD,mBAAmB;AACzE;AACA;AACA;AACA;AACA;AACA,4BAA2B;AAC3B;AACA,yDAAwD,mBAAmB;AAC3E;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA,2DAA0D,mBAAmB;AAC7E;AACA;AACA;AACA;AACA;AACA,gCAA+B;AAC/B;AACA,6DAA4D,mBAAmB;AAC/E;AACA;AACA;AACA;AACA;AACA,kCAAiC;AACjC;AACA,+DAA8D,mBAAmB;AACjF;AACA;AACA;AACA;AACA;AACA,oCAAmC;AACnC;AACA,iEAAgE,mBAAmB;AACnF;AACA;AACA;AACA;AACA;AACA,sCAAqC;AACrC;AACA,mEAAkE,mBAAmB;AACrF;AACA;AACA;AACA;AACA;AACA,wCAAuC;AACvC;AACA,qEAAoE,mBAAmB;AACvF;AACA;AACA;AACA;AACA;AACA,0CAAyC;AACzC;AACA,uEAAsE,mBAAmB;AACzF;AACA;AACA;AACA;AACA;AACA,4CAA2C;AAC3C;AACA,yEAAwE,mBAAmB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,qCAAoC,kBAAkB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA,yCAAwC,kBAAkB;AAC1D;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,qCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA,yCAAwC,mBAAmB;AAC3D;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,qCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA,yCAAwC,mBAAmB;AAC3D;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,qCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA,yCAAwC,mBAAmB;AAC3D;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,qCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,uCAAsC,mBAAmB;AACzD;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;AACL;AACA,mBAAkB,2CAA2C;AAC7D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAC;;;;;;;AC9pCD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc,SAAS,SAAS;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;AC3HA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,uCAAsC,6BAA6B;AACnE;AACA;AACA,2BAA0B,mCAAmC,EAAE;AAC/D;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,G;;;;;;AC9BA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,yCAAwC;AACxC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kBAAiB,SAAS;AAC1B;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,oBAAmB;AACnB,wBAAuB;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAsC;AACtC,wBAAuB;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,4BAA2B;AAC3B;AACA;AACA;AACA;AACA,4BAA2B;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gCAA+B;AAC/B;AACA;AACA;AACA;AACA,gCAA+B;AAC/B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,uBAAsB;AACtB;AACA,uBAAsB;AACtB,uBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAmB;AACnB;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAuB;AACvB;;AAEA;AACA,wBAAuB;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAuB;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAA+B;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX,4BAA2B;AAC3B;AACA;;AAEA;AACA,wBAAuB;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA,+CAA8C;AAC9C;AACA;AACA,wBAAuB;AACvB;AACA;AACA;AACA;AACA,4BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB;AACvB;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA,YAAW;AACX;AACA;AACA;;AAEA;AACA,wBAAuB;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAgE,GAAG;AACnE;AACA;AACA;AACA,8BAA6B,gBAAgB;AAC7C;AACA;AACA;AACA,gCAA+B;AAC/B,gBAAe;AACf;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP,wBAAuB;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B;AAC/B;AACA;AACA,YAAW;AACX,4BAA2B;AAC3B,YAAW;AACX;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA;;AAEA;AACA,wBAAuB;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAwC,iBAAiB;AACzD;AACA;AACA,oBAAmB;AACnB;AACA;AACA;AACA;AACA,wCAAuC;AACvC,gBAAe;AACf;AACA,wCAAuC;AACvC;AACA,YAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,wDAAuD;AACvD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oDAAmD;AACnD;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,YAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+DAA8D;;AAE9D,gBAAe;;AAEf,uBAAsB;AACtB;;AAEA;AACA;AACA,YAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4CAA2C;AAC3C,oBAAmB;AACnB,4CAA2C;AAC3C;AACA,gBAAe;AACf;AACA,4CAA2C;AAC3C,oBAAmB;AACnB,4CAA2C;AAC3C;AACA;AACA;AACA,YAAW;AACX;AACA;;AAEA;;AAEA,wBAAuB;AACvB;AACA;AACA;;AAEA,gBAAe;;AAEf;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;;AAGA;;AAEA,wBAAuB;;AAEvB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAkB;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,cAAa;AACb;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,YAAW;AACX;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,wCAAuC;AACvC;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,8DAA6D;AAC7D,wCAAuC;AACvC;;AAEA;;AAEA;AACA;AACA,kBAAiB;AACjB,4CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,wCAAuC;AACvC;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,qBAAoB;;AAEpB;AACA;AACA;;AAEA;AACA;;AAEA,kBAAiB,yBAAyB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB;AACtB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA;AACA;AACA,oBAAmB;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,EAAC,I;;;;;;ACtxED;AACA,eAAc;AACd,2BAA0B,KAAK;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA,mBAAkB;AAClB,kBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,+BAA8B,eAAe,EAAE;AAC/C;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA,kBAAiB,4CAA4C;AAC7D,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;AC5IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,G;;;;;;ACVA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC1GA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,4CAA2C;AAC3C,6CAA4C;AAC5C,8CAA6C;AAC7C,+CAA8C;AAC9C,kDAAiD;AACjD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAiB,iBAAiB;AAClC,mBAAkB,iBAAiB;AACnC,kBAAiB,iBAAiB;AAClC,oBAAmB,iBAAiB;AACpC,oBAAmB,8CAA8C;AACjE,oBAAmB,iBAAiB;AACpC,mBAAkB,iBAAiB;AACnC,oBAAmB,gBAAgB;AACnC,oBAAmB,iBAAiB;AACpC,wBAAuB,4CAA4C;AACnE;AACA;AACA;AACA,uBAAsB,yBAAyB;AAC/C,wBAAuB,yBAAyB;AAChD,wBAAuB,yBAAyB;AAChD,yBAAwB,yBAAyB;AACjD,0BAAyB;AACzB,YAAW;AACX;AACA;AACA,QAAO;AACP;AACA;AACA,UAAS,qBAAqB;AAC9B,UAAS,sBAAsB;AAC/B,UAAS,qBAAqB;AAC9B,UAAS;AACT;AACA;AACA;AACA;;;;;;;AC/EA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB;AACtB,uBAAsB;AACtB,yBAAwB;AACxB,sBAAqB;AACrB,sBAAqB;AACrB,YAAW;AACX,oBAAmB;AACnB,oBAAmB;AACnB,oBAAmB;AACnB;AACA;;AAEA,kBAAiB;AACjB;;AAEA,qBAAoB,uBAAuB;AAC3C,0BAAyB,SAAS,mBAAmB;;AAErD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,qCAAoC,gCAAgC,EAAE;AACtE;AACA;AACA;AACA,mCAAkC,EAAE;AACpC,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC,KAAK;;AAEtC;AACA,mCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,qCAAoC,cAAc;AAClD,qCAAoC,aAAa;AACjD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL,kEAAiE,4BAA4B,EAAE;AAC/F;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL,qCAAoC,cAAc;AAClD,qCAAoC,YAAY;AAChD,qCAAoC,aAAa;AACjD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kCAAiC,KAAK;AACtC;AACA;AACA,uCAAsC;;AAEtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL,mEAAkE,4BAA4B,EAAE;AAChG;AACA;;AAEA;AACA;AACA,sBAAqB,UAAU,SAAS;AACxC;AACA;;AAEA;AACA;AACA,uBAAsB,WAAW,SAAS;AAC1C;AACA;;AAEA;AACA;AACA,sBAAqB,UAAU,SAAS;AACxC;AACA;;AAEA;AACA;AACA,wBAAuB,YAAY,SAAS;AAC5C;AACA;;AAEA;AACA;AACA,uBAAsB,WAAW,SAAS;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAAyB,cAAc,SAAS;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,sBAAqB;;AAErB;AACA,qBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAmC,sBAAsB;;AAEzD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,eAAe;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sCAAqC;AACrC,sCAAqC;AACrC,sCAAqC;AACrC,sCAAqC;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY,SAAS;AACrB,aAAY,SAAS;AACrB,gBAAe,yBAAyB;AACxC,gBAAe,wBAAwB;AACvC,oBAAmB,4BAA4B;AAC/C,sBAAqB,8BAA8B;AACnD,oBAAmB,aAAa;AAChC,gBAAe,cAAc;AAC7B,mBAAkB;AAClB,QAAO;AACP,cAAa,WAAW,YAAY,EAAE;AACtC,gBAAe,WAAW,SAAS;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY,2BAA2B;AACvC,aAAY,gCAAgC;AAC5C,iBAAgB,0BAA0B;AAC1C,gBAAe,yBAAyB;AACxC,kBAAiB,0BAA0B;AAC3C,uBAAsB,gCAAgC;AACtD,mBAAkB;AAClB,QAAO;AACP,cAAa,WAAW,YAAY,EAAE;AACtC;AACA,aAAY,2BAA2B;AACvC,aAAY,gCAAgC;AAC5C,mBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY,2BAA2B;AACvC,aAAY,gCAAgC;AAC5C,gBAAe,yBAAyB;AACxC,gBAAe,wBAAwB;AACvC,oBAAmB,4BAA4B;AAC/C,iBAAgB,yBAAyB;AACzC,oBAAmB,4BAA4B;AAC/C,gBAAe,eAAe;AAC9B,mBAAkB;AAClB,QAAO;AACP,cAAa,WAAW,YAAY,EAAE;AACtC;AACA,mBAAkB,SAAS;AAC3B,aAAY,2BAA2B;AACvC,aAAY,gCAAgC;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY,SAAS;AACrB,aAAY,SAAS;AACrB,iBAAgB,4BAA4B;AAC5C,kBAAiB,6BAA6B;AAC9C,kBAAiB,kCAAkC;AACnD,uBAAsB,kCAAkC;AACxD,mBAAkB;AAClB,QAAO;AACP,cAAa,WAAW,YAAY,EAAE;AACtC;AACA,aAAY,SAAS;AACrB,aAAY,SAAS;AACrB,mBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY,+BAA+B;AAC3C,aAAY,UAAU;AACtB,cAAa,SAAS;AACtB,gBAAe,yBAAyB;AACxC,gBAAe,wBAAwB;AACvC,oBAAmB,4BAA4B;AAC/C,iBAAgB,eAAe;AAC/B,oBAAmB,aAAa;AAChC,gBAAe,eAAe;AAC9B,mBAAkB;AAClB,QAAO;AACP,cAAa,WAAW,YAAY,EAAE;AACtC;AACA,aAAY,+BAA+B;AAC3C,aAAY,UAAU;AACtB,mBAAkB;AAClB;AACA;AACA;AACA;;AAEA;;;;;;;ACjiBA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0CAAyC;AACzC;AACA;AACA;AACA,qDAAoD,4BAA4B,EAAE;AAClF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAgB;;AAEhB,mCAAkC,KAAK;AACvC;AACA;AACA,kCAAiC;AACjC,MAAK;AACL,mBAAkB;AAClB,MAAK;AACL;AACA;AACA;;AAEA,eAAc,+CAA+C;AAC7D;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB,iBAAiB,GAAG,wBAAwB;AACrE,cAAa;AACb;AACA,0BAAyB,iBAAiB,GAAG,wBAAwB;AACrE,cAAa;AACb;AACA,0BAAyB,iBAAiB,GAAG,wBAAwB;AACrE,cAAa;AACb;AACA,0BAAyB,iBAAiB,GAAG,wBAAwB;AACrE,cAAa;AACb;AACA,0BAAyB,iBAAiB,GAAG,wBAAwB;AACrE,cAAa;AACb;AACA;AACA,kBAAiB,2BAA2B,kBAAkB;AAC9D,kBAAiB;AACjB;AACA,cAAa;AACb;AACA,0BAAyB,iBAAiB,GAAG,wBAAwB;AACrE,cAAa;AACb;AACA,UAAS;AACT;AACA;AACA,qBAAoB;AACpB,UAAS;AACT;AACA;AACA,qBAAoB;AACpB,UAAS;AACT;AACA;AACA,qBAAoB;AACpB,UAAS;AACT;AACA;AACA,qBAAoB,UAAU,2BAA2B,GAAG,4BAA4B;AACxF;AACA;AACA,MAAK;;;AAGL;AACA;AACA;AACA,0BAAyB,UAAU,kBAAkB,EAAE;AACvD;AACA,UAAS;AACT,UAAS,sBAAsB;AAC/B,UAAS;AACT;AACA,MAAK;;AAEL;AACA;AACA;AACA,mBAAkB,gBAAgB,UAAU,kBAAkB,EAAE,EAAE;AAClE,UAAS;AACT,UAAS;AACT;AACA;AACA;AACA;;;;;;;ACnHA;;AAEA;AACA;AACA;AACA,yBAAwB,yCAAyC;AACjE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,mBAAkB,iBAAiB;AACnC,sBAAqB,iBAAiB;AACtC,oBAAmB,iBAAiB;AACpC,qBAAoB;AACpB,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA;;;;;;;AC7BA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAA4B,UAAU;AACtC;;AAEA;AACA;AACA;;AAEA;AACA;AACA,6BAA4B,+BAA+B,GAAG;AAC9D;AACA;AACA;AACA;;AAEA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAkB;;AAElB,0BAAyB,gBAAgB;AACzC,wBAAuB,WAAW;;AAElC;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA,wCAAuC,kBAAkB,SAAS;AAClE;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4DAA2D;AAC3D,kDAAiD;;AAEjD;AACA,mEAAkE;AAClE;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wDAAuD;AACvD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mDAAkD;;AAElD;AACA;AACA,uCAAsC,wCAAwC;AAC9E,wEAAuE;AACvE,IAAG;AACH;AACA;AACA,wCAAuC;AACvC,mCAAkC;AAClC,WAAU,OAAO;AACjB,2BAA0B,iBAAiB;AAC3C,WAAU;AACV;;AAEA;AACA,gEAA+D;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,eAAc,cAAc;AAC5B;AACA,IAAG,qBAAqB;AACxB;AACA;AACA,IAAG,sBAAsB,0BAA0B;AACnD,wCAAuC,iBAAiB;AACxD;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA,8BAA6B;AAC7B;AACA;;AAEA,iBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB,YAAY;AACrC;AACA,UAAS;AACT;AACA,0BAAyB,QAAQ,kBAAkB;AACnD;AACA,UAAS;AACT,UAAS,wBAAwB;AACjC;AACA;AACA;AACA;AACA,kBAAiB,iBAAiB;AAClC;AACA;AACA,kCAAiC,SAAS,kBAAkB;AAC5D;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,oBAAmB,iBAAiB;AACpC,oBAAmB,2CAA2C;AAC9D;AACA;AACA,uBAAsB,yBAAyB;AAC/C;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA,oBAAmB,iBAAiB;AACpC,oBAAmB,kCAAkC;AACrD;AACA;AACA,uBAAsB,yBAAyB;AAC/C;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA,oBAAmB,iBAAiB;AACpC,oBAAmB,eAAe;AAClC,oBAAmB;AACnB,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA,2BAA0B,yBAAyB;AACnD;AACA,gBAAe;AACf,yBAAwB;AACxB,cAAa;AACb;AACA,YAAW;AACX;AACA;AACA,wBAAuB,iBAAiB;AACxC,yBAAwB;AACxB,cAAa;AACb;AACA;AACA;;AAEA;AACA,QAAO;AACP;AACA;AACA;;;;;;;AC7RA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK,+BAA+B;AACpC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB,WAAW,kBAAkB;AAClD;AACA,MAAK;;AAEL;AACA;AACA,UAAS,iBAAiB;AAC1B;AACA;AACA;AACA;AACA,0BAAyB,wBAAwB,GAAG,iBAAiB;AACrE,cAAa;AACb;AACA;AACA,kBAAiB,wBAAwB;AACzC,kBAAiB;AACjB;AACA,cAAa;AACb,wBAAuB;AACvB,YAAW;;AAEX;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAkB;AAClB,UAAS;AACT,mBAAkB;AAClB,qBAAoB,oCAAoC;AACxD,kBAAiB,iBAAiB;AAClC,mBAAkB,6BAA6B;AAC/C,qBAAoB;AACpB,QAAO;;AAEP;AACA;AACA;AACA;AACA;;;;;;;ACzHA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH,2BAA0B,UAAU;AACpC;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK,cAAc,WAAW;AAC9B;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL,iCAAgC,4BAA4B;;AAE5D;AACA;AACA;AACA;AACA,gEAA+D,4BAA4B;AAC3F,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAiB,2BAA2B;AAC5C;AACA,qBAAoB,iBAAiB;AACrC,sBAAqB,iBAAiB;AACtC;AACA;AACA,uBAAsB,iBAAiB;AACvC;AACA,YAAW;;AAEX,0BAAyB,4BAA4B;AACrD,uBAAsB,yBAAyB;;AAE/C;AACA;AACA,uBAAsB;AACtB,YAAW;;AAEX;AACA;AACA,uBAAsB;AACtB,YAAW;;AAEX;AACA;AACA,uBAAsB;AACtB;AACA;AACA,QAAO;AACP;AACA;AACA;;;;;;;AC9IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAsB;AACtB,uBAAsB;;AAEtB;AACA,wBAAuB;;AAEvB,kBAAiB;;AAEjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAuC;AACvC,MAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA4B,4BAA4B,EAAE;AAC1D;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oCAAmC,yBAAyB;;AAE5D;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,8EAA6E;AAC7E;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wDAAuD,cAAc,EAAE;AACvE,MAAK;AACL;AACA;AACA;AACA;AACA,2DAA0D,WAAW,EAAE;AACvE,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;ACjKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,oCAAmC;AACnC,IAAG;;AAEH;AACA;;AAEA;AACA;AACA,IAAG,IAAI;;AAEP;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA,uCAAsC,yCAAyC,EAAE;AACjF,uCAAsC,8BAA8B,EAAE;AACtE;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,SAAQ,OAAO;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAiC,OAAO;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA4B,MAAM;AAClC;AACA,+CAA8C,MAAM;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iFAAgF;AAChF,uDAAsD;AACtD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kCAAiC,OAAO;AACxC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kCAAiC,OAAO;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,8BAA6B,OAAO;AACpC;AACA;AACA;AACA,uBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qBAAoB;AACpB;AACA;AACA;AACA,wCAAuC,6CAA6C;AACpF,IAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,uBAAsB;AACtB;AACA;AACA;AACA,wCAAuC,+CAA+C;AACtF,IAAG;AACH;;AAEA,+B;;;;;;AC/RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAsB;;AAEtB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAuB;;AAEvB,kBAAiB,iDAAiD;;AAElE;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAuB,iBAAiB;AACxC,8BAA6B,qBAAqB;AAClD,8BAA6B,sBAAsB;AACnD,8BAA6B,eAAe;;AAE5C;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uCAAsC,OAAO;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oCAAmC;AACnC,oCAAmC;AACnC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA,iDAAgD,iBAAiB,EAAE;AACnE;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA2B,OAAO;AAClC;AACA;AACA;AACA;;AAEA,4BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA,4BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,oCAAmC,KAAK;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AClTA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,yCAAwC;AACxC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,8CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sCAAqC,OAAO;AAC5C;AACA;AACA;AACA;;AAEA,kBAAiB;AACjB;;AAEA;AACA;;AAEA;AACA,kCAAiC,OAAO;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAiC,OAAO;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAmC,OAAO;AAC1C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,uCAAsC;AACtC;AACA;AACA,uCAAsC;AACtC;AACA;AACA,uCAAsC;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mCAAkC;AAClC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAQ,OAAO;AACf;;AAEA;AACA;AACA;;AAEA,WAAU,iBAAiB;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;ACzLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,mCAAkC,QAAQ;AAC1C;AACA;;AAEA;AACA,iCAAgC,QAAQ;AACxC;AACA;AACA,+CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;;;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,6BAA4B,yBAAyB;;AAErD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAkC,OAAO;AACzC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,wBAAuB;AACvB;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,+BAA8B,wBAAwB,EAAE;AACxD,0CAAyC,4BAA4B,EAAE;;AAEvE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,MAAK,mCAAmC;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAkB,OAAO,OAAO,OAAO,EAAE;AACzC;AACA;;AAEA;AACA,2BAA0B,kBAAkB,EAAE;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,SAAQ,eAAe;AACvB,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA,mBAAkB,0CAA0C;AAC5D,oBAAmB;AACnB,MAAK;AACL,mBAAkB,8CAA8C;AAChE;AACA;AACA;AACA;AACA,QAAO,KAAK;AACZ,MAAK,OAAO;AACZ;AACA,qBAAoB,uCAAuC;AAC3D;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAoB,WAAW;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gCAA+B,QAAQ;AACvC;AACA;AACA;;AAEA;;AAEA;AACA,oCAAmC,QAAQ;AAC3C;;AAEA;AACA;AACA,UAAS;AACT;AACA,UAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA,6CAA4C,2BAA2B,EAAE;AACzE,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL,mBAAkB;AAClB,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,IAAG,gGAAgG;AACnG;AACA;AACA,eAAc,WAAW,gBAAgB,GAAG,iBAAiB,GAAG,wBAAwB;AACxF,IAAG;AACH,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA,6BAA4B;AAC5B;AACA,gBAAe;AACf;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,cAAa,iBAAiB;AAC9B;AACA;AACA,yBAAwB;AACxB,cAAa;AACb;AACA;AACA;AACA,4BAA2B;AAC3B,gBAAe;AACf;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B,kBAAiB;AACjB;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,sBAAqB,kBAAkB;AACvC;AACA;AACA,yBAAwB,iBAAiB;AACzC,sBAAqB;AACrB;AACA,YAAW;AACX;AACA,QAAO;AACP;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,iBAAiB;;AAEpC;AACA;AACA;AACA;AACA,YAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB,gBAAgB;AACrC,sBAAqB,iBAAiB;AACtC,sBAAqB;AACrB;AACA;AACA,gBAAe;AACf,gBAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA;AACA,+BAA8B;AAC9B;AACA,kBAAiB;AACjB;AACA;AACA;AACA,YAAW;;AAEX;AACA;AACA,gBAAe,iBAAiB;AAChC,gBAAe,sBAAsB;AACrC,gBAAe;AACf;AACA,YAAW;;AAEX;AACA;AACA,gBAAe,iBAAiB;AAChC,gBAAe,sBAAsB;AACrC,gBAAe;AACf;AACA,YAAW;;AAEX;AACA;AACA,gBAAe,gBAAgB;AAC/B,gBAAe,iBAAiB;AAChC,gBAAe;AACf;AACA,YAAW;;AAEX;AACA;AACA,gBAAe,gBAAgB;AAC/B,gBAAe,iBAAiB;AAChC,gBAAe;AACf;AACA,YAAW;;AAEX;AACA;AACA,gBAAe,kBAAkB;AACjC,gBAAe;AACf;AACA,YAAW;AACX,qBAAoB;AACpB,UAAS;;AAET;AACA,QAAO;AACP;AACA;AACA,sBAAqB,wBAAwB;;AAE7C;AACA,yCAAwC,sBAAsB;AAC9D,cAAa;;AAEb,wBAAuB,WAAW,kBAAkB,GAAG,wBAAwB,EAAE;AACjF,yBAAwB,WAAW,iBAAiB,GAAG,wBAAwB,EAAE;AACjF,8BAA6B,WAAW,iBAAiB,GAAG,wBAAwB,EAAE;AACtF,0BAAyB,WAAW,iBAAiB,GAAG,wBAAwB;AAChF,YAAW;AACX;AACA,UAAS;AACT;AACA,sBAAqB,qCAAqC;AAC1D,uBAAsB,kBAAkB;AACxC,uBAAsB,WAAW,kBAAkB,GAAG,wBAAwB,EAAE;AAChF,sBAAqB,WAAW;AAChC,+CAA8C,GAAG,wBAAwB;AACzE,YAAW;AACX;AACA,UAAS;AACT;AACA;AACA,wBAAuB;AACvB,2FAA0F;AAC1F,yBAAwB,kBAAkB;AAC1C,yBAAwB,WAAW,kBAAkB,GAAG,wBAAwB,EAAE;AAClF,wBAAuB,WAAW,kBAAkB,GAAG,wBAAwB,EAAE;AACjF,wBAAuB,WAAW,kBAAkB,GAAG,wBAAwB;AAC/E;AACA,YAAW;AACX;AACA,wBAAuB,sBAAsB;AAC7C,4BAA2B,WAAW,iBAAiB,GAAG,wBAAwB;AAClF,cAAa;AACb;AACA,YAAW;AACX,UAAS;AACT,QAAO;AACP;AACA;AACA;;;;;;;AClsBA;AACA;AACA;;AAEA;AACA,2BAA0B,KAAK;AAC/B;AACA,gCAA+B,KAAK;AACpC;AACA;AACA;AACA;AACA;;;;;;;ACZA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AClHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB;AACvB;AACA,oBAAmB;AACnB;AACA;AACA;AACA,yBAAwB;AACxB,6BAA4B;AAC5B;AACA,wBAAuB;AACvB;AACA;AACA,kBAAiB;AACjB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,+BAA8B;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mCAAkC;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,4BAA2B,oBAAoB;;AAE/C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAuB;AACvB;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,+BAA8B,cAAc,UAAU,eAAe;AACrE,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAAyB;AACzB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,0CAAyC,8BAA8B,EAAE;AACzE,MAAK;AACL;AACA,MAAK;AACL;AACA;;AAEA;AACA,wCAAuC,kBAAkB,EAAE;AAC3D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,qCAAoC;AACpC;AACA,yCAAwC;AACxC;AACA;;AAEA;AACA,qCAAoC;;AAEpC;AACA;AACA;AACA;AACA;;AAEA,sCAAqC;;AAErC;AACA;AACA,uCAAsC,sBAAsB;AAC5D;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAAyB,0BAA0B;AACnD;AACA,UAAS;AACT;AACA;AACA,0BAAyB,2BAA2B;AACpD;AACA,UAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;ACxeA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,wBAAuB,kBAAkB,EAAE;AAC3C,6BAA4B,4CAA4C,EAAE;AAC1E;AACA,gBAAe;AACf;AACA;AACA;AACA,aAAY,MAAM;AAClB;AACA;AACA;AACA;AACA,MAAK;AACL,yBAAwB,2BAA2B,EAAE;AACrD,yBAAwB,2BAA2B;AACnD;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAkB,YAAY,YAAY;AAC1C;AACA,yCAAwC;;AAExC;AACA;AACA,0BAAyB;;AAEzB;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,4BAA2B;AAC3B;AACA,sDAAqD;AACrD,MAAK;AACL,IAAG;;AAEH;AACA;AACA,+CAA8C;;AAE9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAmB,cAAc;AACjC;AACA;AACA,MAAK;AACL;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,mBAAkB;;AAElB;AACA;AACA;AACA,mBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iCAAgC,KAAK;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uDAAsD;AACtD,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,yCAAwC,sBAAsB,EAAE;AAChE,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0DAAyD;AACzD,yDAAwD;;AAExD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAmB,iBAAiB;AACpC,oBAAmB,iBAAiB;AACpC,qBAAoB;AACpB,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;;;;;;AC5PA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAkB;AAClB;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAQ,YAAY;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA8B,8BAA8B,EAAE;AAC9D;;AAEA;AACA;AACA;AACA;;AAEA,SAAQ,YAAY;AACpB;AACA;;AAEA;AACA,iBAAgB,cAAc,UAAU;AACxC;AACA;;AAEA,6BAA4B,KAAK;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;ACtGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qBAAoB;AACpB;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,+BAA8B,QAAQ,EAAE,OAAO,yBAAyB;AACxE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;AC9DA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAgC,aAAa;AAC7C,IAAG;AACH;AACA;AACA;AACA,iBAAgB;AAChB,iBAAgB;AAChB;AACA;;AAEA,yCAAwC,gCAAgC,EAAE;;AAE1E;AACA;AACA;;AAEA;AACA;AACA,0CAAyC;AACzC,IAAG;;AAEH;AACA,6DAA4D;AAC5D,IAAG;;AAEH;AACA;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+B;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gC;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC,0CAA0C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB;AACpB;AACA,qBAAoB;AACpB;AACA,qBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oC;;;;;;ACrGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB,uBAAuB;AAC3C;AACA;AACA,oBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;ACpIA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC,gDAAgD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC,oCAAoC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,qC;;;;;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,0BAAyB,UAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC,iBAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC,kDAAkD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA4C,kBAAkB,KAAK;AACnE;AACA;AACA;AACA,MAAK,qBAAqB,4BAA4B,KAAK,uBAAuB,gCAAgC,KAAK;AACvH;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK,sBAAsB,gCAAgC,KAAK;AAChE,gBAAe,sBAAsB;AACrC;AACA;AACA,yBAAwB,iBAAiB;AACzC,0BAAyB;AACzB;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oC;;;;;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA,UAAS,IAAI;AACb;AACA;AACA;AACA;AACA,sDAAqD,iHAAiH,oBAAoB;AAC1L;AACA;AACA;AACA,UAAS,IAAI;AACb;AACA;AACA;AACA;AACA,wDAAuD,4CAA4C,sBAAsB;AACzH;AACA;AACA;AACA,UAAS,IAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B,UAAU;AACvC;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA,kC;;;;;;ACzLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC,gDAAgD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC,sCAAsC;AACvC;AACA;AACA;AACA;AACA;AACA,EAAC,0DAA0D;AAC3D;AACA;AACA;AACA;AACA;AACA,EAAC,sDAAsD;AACvD;AACA;AACA;AACA;AACA,EAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,EAAC,kDAAkD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mC;;;;;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC,gDAAgD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA,mC;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC,oCAAoC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK,IAAI;AACT;AACA;AACA,mC;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;AC7FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAoF,iBAAiB,KAAK;AAC1G;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAoC;AACpC;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B,0BAA0B,cAAc,wBAAwB;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mC;;;;;;AC9GA;AACA;AACA;AACA;AACA;AACA,EAAC,8CAA8C;AAC/C;AACA,iC;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA,kCAAiC,qBAAqB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B,iBAAiB;AAC9C;AACA;AACA;AACA,mCAAkC,iBAAiB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;ACzJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAwF,IAAI,iBAAiB;AAC7G,UAAS;AACT,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAiD,iBAAiB;AAClE;AACA,UAAS;AACT;AACA;AACA,gDAA+C,sBAAsB;AACrE;AACA,sDAAqD,sBAAsB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAAyC,gBAAgB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,0CAAyC,oBAAoB;AAC7D;AACA;AACA;AACA;AACA;AACA,0CAAyC,sBAAsB;AAC/D;AACA,8CAA6C,sBAAsB;AACnE;AACA;AACA,UAAS;AACT;AACA,0CAAyC,sBAAsB;AAC/D,UAAS;AACT;AACA;AACA,uCAAsC,sBAAsB;AAC5D,uCAAsC,oBAAoB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,8GAA6G,iBAAiB;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA,8GAA6G,iBAAiB;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA4B;AAC5B;AACA;AACA,yBAAwB;AACxB;AACA;AACA,yBAAwB;AACxB;AACA;AACA,yBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB;AACpB;AACA,qBAAoB;AACpB;AACA;AACA,yBAAwB;AACxB;AACA,qBAAoB;AACpB;AACA,qBAAoB;AACpB;AACA,qBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;AChVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB;AACvB,cAAa;AACb;AACA,0BAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,iEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,eAAe,wBAAwB,EAAE;AACtD,eAAc,qBAAqB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,kCAAiC,oDAAoD;AACrF;AACA,cAAa,kBAAkB;AAC/B;AACA;AACA,iCAAgC;AAChC;AACA;AACA;AACA,qCAAoC;AACpC;AACA;AACA,qCAAoC;AACpC;AACA;AACA;AACA,iCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAwC;AACxC;AACA;AACA;AACA;AACA,oCAAmC;AACnC;AACA;AACA;AACA;AACA,4CAA2C;AAC3C;AACA;AACA,4CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,EAAC,6DAA6D;AAC9D,iC;;;;;;ACnOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB;AACtB;AACA;AACA;AACA;AACA,kCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS,IAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAkD,0BAA0B;AAC5E;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA2D,sBAAsB;AACjF,0DAAyD,oBAAoB;AAC7E,0DAAyD,oBAAoB;AAC7E;AACA,kBAAiB,+BAA+B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA2D,sBAAsB;AACjF,2DAA0D,mCAAmC;AAC7F;AACA,yDAAwD,iCAAiC;AACzF,sBAAqB;AACrB;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS,IAAI;AACb;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,2CAA0C,kBAAkB;AAC5D;AACA,UAAS;AACT;AACA;AACA,EAAC,iDAAiD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAqD,sBAAsB,iCAAiC,sBAAsB;AAClI,sDAAqD,oBAAoB,iCAAiC,oBAAoB;AAC9H,sDAAqD,oBAAoB,iCAAiC,oBAAoB;AAC9H;AACA;AACA,0DAAyD,sBAAsB,iCAAiC,sBAAsB;AACtI;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS,IAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,EAAC,oDAAoD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC,iDAAiD;AAClF,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,EAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B,sBAAqB;AACrB;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,EAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,yDAAwD,iBAAiB;AACzE;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA4C,cAAc;AAC1D,cAAa;AACb;AACA,MAAK;AACL;AACA;AACA,iC;;;;;;ACnSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,MAAK;AACL;AACA,oBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA8B,kCAAkC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAkC,kCAAkC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,mC;;;;;;AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS,IAAI,gDAAgD;AAC7D;AACA;AACA;AACA;AACA,UAAS,IAAI,gDAAgD;AAC7D,iBAAgB,SAAS,sBAAsB,EAAE;AACjD,kBAAiB,SAAS,uBAAuB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,iCAAgC;AAChC,kBAAiB;AACjB;AACA,MAAK,KAAK;AACV;AACA;AACA,yBAAwB,SAAS,sBAAsB,EAAE;AACzD;AACA,6BAA4B;AAC5B,kBAAiB;AACjB;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK,KAAK;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,iCAAgC;AAChC,kBAAiB;AACjB;AACA,MAAK,KAAK;AACV;AACA;AACA;AACA,6BAA4B;AAC5B,kBAAiB;AACjB,0BAAyB,SAAS,uBAAuB,EAAE;AAC3D;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA,UAAS;AACT,MAAK;AACL;AACA,MAAK,KAAK;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB,uDAAuD;AAChF,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,qBAAoB,4CAA4C;AAChE,sBAAqB,SAAS,iBAAiB,kCAAkC;AACjF,0BAAyB,+BAA+B;AACxD,iCAAgC,iCAAiC;AACjE,+BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB,SAAS,kBAAkB,EAAE;AACrD,yBAAwB,4CAA4C;AACpE,0BAAyB,SAAS,iBAAiB,kCAAkC;AACrF,8BAA6B,+BAA+B;AAC5D,qCAAoC,iCAAiC;AACrE,mCAAkC;AAClC;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB,0DAA0D;AACnF,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,qBAAoB,4CAA4C;AAChE,sBAAqB,SAAS,kBAAkB,kCAAkC;AAClF,0BAAyB,+BAA+B;AACxD,iCAAgC,iCAAiC;AACjE,+BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB,SAAS,iBAAiB,EAAE;AACpD,yBAAwB,4CAA4C;AACpE,0BAAyB,SAAS,kBAAkB,kCAAkC;AACtF,8BAA6B,+BAA+B;AAC5D,qCAAoC,iCAAiC;AACrE,mCAAkC;AAClC;AACA;AACA,UAAS;AACT;AACA,kC;;;;;;ACvPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAgD,cAAc,IAAI;AAClE;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAiC;AACjC;AACA;AACA;AACA,kCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAmC;AACnC;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA,2DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC,oEAAoE;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC,gCAAgC;AACjC,mC;;;;;;AC1JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB;AACpB;AACA,4CAA2C,wBAAwB,KAAK;AACxE;AACA,yEAAwE,cAAc,cAAc,sCAAsC,GAAG;AAC7I,0BAAyB;AACzB,UAAS;AACT;AACA,+BAA8B;AAC9B;AACA;AACA,sEAAqE,kCAAkC;AACvG;AACA;AACA;AACA,uDAAsD,cAAc,uBAAuB;AAC3F;AACA;AACA,iCAAgC,SAAS,iBAAiB,EAAE;AAC5D,kCAAiC,SAAS,kBAAkB;AAC5D;AACA,kBAAiB;AACjB;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB;AACpB;AACA;AACA;AACA;AACA,0CAAyC,6BAA6B,KAAK,GAAG,eAAe,oBAAoB,IAAI,iBAAiB,GAAG,cAAc,wCAAwC,EAAE;AACjM;AACA,sCAAqC,wBAAwB,KAAK,GAAG,sCAAsC;AAC3G,+CAA8C;AAC9C,cAAa,6CAA6C;AAC1D;AACA,kBAAiB,cAAc,kCAAkC,GAAG;AACpE,mBAAkB;AAClB,MAAK,KAAK,GAAG,cAAc,+CAA+C,EAAE;AAC5E;AACA;AACA;AACA,8CAA6C,wBAAwB,KAAK,GAAG,eAAe,oBAAoB,IAAI,iBAAiB,GAAG,cAAc,0BAA0B,EAAE;AAClL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,iC;;;;;;AC5HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,kDAAiD,mBAAmB;AACpE;AACA;AACA;AACA,oBAAmB;AACnB;AACA;AACA;AACA;AACA,kDAAiD,oBAAoB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,sDAAqD,iBAAiB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAiD,mBAAmB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAiD,oBAAoB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,sDAAqD,iBAAiB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC,2CAA2C;AAC5C,iC;;;;;;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAiD,mBAAmB;AACpE;AACA;AACA;AACA,kDAAiD,iBAAiB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,sDAAqD,oBAAoB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAqD,sBAAsB;AAC3E;AACA;AACA;AACA;AACA,sDAAqD,oBAAoB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB;AACvB;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAiD,mBAAmB;AACpE;AACA;AACA;AACA,kDAAiD,iBAAiB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,sDAAqD,oBAAoB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAqD,sBAAsB;AAC3E;AACA;AACA;AACA,sDAAqD,oBAAoB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC,wCAAwC;AACzC,gC;;;;;;ACrLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAiD,oBAAoB;AACrE;AACA;AACA;AACA,oBAAmB;AACnB;AACA;AACA;AACA;AACA,kDAAiD,oBAAoB;AACrE;AACA;AACA;AACA,oBAAmB,SAAS,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC,2CAA2C;AAC5C,iC;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAiD,oBAAoB;AACrE;AACA;AACA;AACA,oBAAmB;AACnB;AACA;AACA;AACA;AACA,kDAAiD,oBAAoB;AACrE;AACA;AACA;AACA,oBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB;AACtB;AACA;AACA,wBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB;AACvB;AACA;AACA,wBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC,iDAAiD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC,iDAAiD;AAClD,kC;;;;;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,WAAW;AAC3B,iBAAgB,WAAW;AAC3B,qBAAoB,SAAS,iBAAiB,EAAE;AAChD,sBAAqB,SAAS,kBAAkB,EAAE;AAClD;AACA;AACA,gHAA+G,iBAAiB,KAAK;AACrI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAiD,oBAAoB;AACrE;AACA;AACA;AACA;AACA,wBAAuB,SAAS,iBAAiB;AACjD;AACA;AACA,wBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,kDAAiD,oBAAoB;AACrE;AACA;AACA;AACA,oBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA0B;AAC1B;AACA;AACA,uBAAsB;AACtB;AACA;AACA,8BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA0B;AAC1B;AACA;AACA;AACA,uBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC,2CAA2C;AAC5C,iC;;;;;;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAiD,oBAAoB;AACrE;AACA;AACA;AACA,qBAAoB;AACpB;AACA;AACA;AACA;AACA,kDAAiD,oBAAoB;AACrE;AACA;AACA;AACA,qBAAoB;AACpB;AACA;AACA,wBAAuB;AACvB;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,yBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC,2CAA2C;AAC5C,iC;;;;;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK,IAAI;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,sCAAsC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,iCAAiC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iC;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAwC,2DAA2D;AACnG,0CAAyC,8DAA8D;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;AC3CA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA,qCAAoC,oBAAoB,EAAE;AAC1D,sDAAqD,cAAc,EAAE;AACrE;AACA;;AAEA;;AAEA;AACA;AACA;AACA,gBAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA,oBAAmB,qBAAqB;AACxC,IAAG;AACH;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uCAAsC;AACtC,qCAAoC;AACpC,oCAAmC;AACnC,oCAAmC;AACnC;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA0B,oBAAoB;AAC9C;AACA;;AAEA;AACA;AACA,+BAA8B,iCAAiC,EAAE;AACjE;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA0B,8BAA8B;AACxD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,oCAAmC,kCAAkC,EAAE;AACvE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAG;;AAEH;AACA;AACA;AACA,oBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;ACtLA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACxBA,kD;;;;;;ACAA,kD","file":"index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap e26d0fc250529948c592\n **/","require('./embed.css');\n\nvar embed = require('vega-embed');\nvar $ = require('jquery');\nvar events = require('base/js/events');\n\nfunction render_all() {\n  $('.vega-embed').each(function(i, el) {\n    render($(el));\n  });\n}\n\nfunction render_one(event, type, value, metadata, $toinsert) {\n  var el = $toinsert.find('.vega-embed');\n  render(el);\n}\n\nfunction render(el) {\n  var type = el.attr('data-type');\n\n  if (type) {\n    var embedSpec = {\n      mode: type,\n      spec: JSON.parse(el.text())\n    }\n\n    embed(el[0], embedSpec, function(error, result) {\n      // Callback receiving the View instance and parsed Vega spec\n      // result.view is the View, which resides under the '#vis' element\n    });\n  }\n}\n\nfunction load_extension() {\n  events.on(\"notebook_loaded.Notebook\", render_all);\n  events.on(\"kernel_ready.Kernel\", render_all);\n  events.on(\"output_appended.OutputArea\", render_one);\n  render_all();\n}\n\nexports.load_jupyter_extension = load_extension;\nexports.load_ipython_extension = load_extension;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/index.js\n ** module id = 0\n ** module chunks = 0\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../node_modules/css-loader/index.js!./embed.css\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../node_modules/css-loader/index.js!./embed.css\", function() {\n\t\t\tvar newContent = require(\"!!./../node_modules/css-loader/index.js!./embed.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/embed.css\n ** module id = 1\n ** module chunks = 0\n **/","exports = module.exports = require(\"./../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".vega-embed svg, .vega-embed canvas {\\n  border: 1px dotted gray;\\n}\\n\\n.vega-embed .vega-actions a {\\n  margin-right: 6px;\\n}\\n\", \"\"]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader!./src/embed.css\n ** module id = 2\n ** module chunks = 0\n **/","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader/lib/css-base.js\n ** module id = 3\n ** module chunks = 0\n **/","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nvar stylesInDom = {},\r\n\tmemoize = function(fn) {\r\n\t\tvar memo;\r\n\t\treturn function () {\r\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\treturn memo;\r\n\t\t};\r\n\t},\r\n\tisOldIE = memoize(function() {\r\n\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t}),\r\n\tgetHeadElement = memoize(function () {\r\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t}),\r\n\tsingletonElement = null,\r\n\tsingletonCounter = 0,\r\n\tstyleElementsInsertedAtTop = [];\r\n\r\nmodule.exports = function(list, options) {\r\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\r\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t}\r\n\r\n\toptions = options || {};\r\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t// tags it will allow on a page\r\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\r\n\t// By default, add <style> tags to the bottom of <head>.\r\n\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\r\n\r\n\tvar styles = listToStyles(list);\r\n\taddStylesToDom(styles, options);\r\n\r\n\treturn function update(newList) {\r\n\t\tvar mayRemove = [];\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tdomStyle.refs--;\r\n\t\t\tmayRemove.push(domStyle);\r\n\t\t}\r\n\t\tif(newList) {\r\n\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\taddStylesToDom(newStyles, options);\r\n\t\t}\r\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n}\r\n\r\nfunction addStylesToDom(styles, options) {\r\n\tfor(var i = 0; i < styles.length; i++) {\r\n\t\tvar item = styles[i];\r\n\t\tvar domStyle = stylesInDom[item.id];\r\n\t\tif(domStyle) {\r\n\t\t\tdomStyle.refs++;\r\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t}\r\n\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvar parts = [];\r\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction listToStyles(list) {\r\n\tvar styles = [];\r\n\tvar newStyles = {};\r\n\tfor(var i = 0; i < list.length; i++) {\r\n\t\tvar item = list[i];\r\n\t\tvar id = item[0];\r\n\t\tvar css = item[1];\r\n\t\tvar media = item[2];\r\n\t\tvar sourceMap = item[3];\r\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\tif(!newStyles[id])\r\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\telse\r\n\t\t\tnewStyles[id].parts.push(part);\r\n\t}\r\n\treturn styles;\r\n}\r\n\r\nfunction insertStyleElement(options, styleElement) {\r\n\tvar head = getHeadElement();\r\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\r\n\tif (options.insertAt === \"top\") {\r\n\t\tif(!lastStyleElementInsertedAtTop) {\r\n\t\t\thead.insertBefore(styleElement, head.firstChild);\r\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\r\n\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\r\n\t\t} else {\r\n\t\t\thead.appendChild(styleElement);\r\n\t\t}\r\n\t\tstyleElementsInsertedAtTop.push(styleElement);\r\n\t} else if (options.insertAt === \"bottom\") {\r\n\t\thead.appendChild(styleElement);\r\n\t} else {\r\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\r\n\t}\r\n}\r\n\r\nfunction removeStyleElement(styleElement) {\r\n\tstyleElement.parentNode.removeChild(styleElement);\r\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\r\n\tif(idx >= 0) {\r\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\r\n\t}\r\n}\r\n\r\nfunction createStyleElement(options) {\r\n\tvar styleElement = document.createElement(\"style\");\r\n\tstyleElement.type = \"text/css\";\r\n\tinsertStyleElement(options, styleElement);\r\n\treturn styleElement;\r\n}\r\n\r\nfunction createLinkElement(options) {\r\n\tvar linkElement = document.createElement(\"link\");\r\n\tlinkElement.rel = \"stylesheet\";\r\n\tinsertStyleElement(options, linkElement);\r\n\treturn linkElement;\r\n}\r\n\r\nfunction addStyle(obj, options) {\r\n\tvar styleElement, update, remove;\r\n\r\n\tif (options.singleton) {\r\n\t\tvar styleIndex = singletonCounter++;\r\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\r\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t} else if(obj.sourceMap &&\r\n\t\ttypeof URL === \"function\" &&\r\n\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\ttypeof Blob === \"function\" &&\r\n\t\ttypeof btoa === \"function\") {\r\n\t\tstyleElement = createLinkElement(options);\r\n\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tremoveStyleElement(styleElement);\r\n\t\t\tif(styleElement.href)\r\n\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t};\r\n\t} else {\r\n\t\tstyleElement = createStyleElement(options);\r\n\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tremoveStyleElement(styleElement);\r\n\t\t};\r\n\t}\r\n\r\n\tupdate(obj);\r\n\r\n\treturn function updateStyle(newObj) {\r\n\t\tif(newObj) {\r\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\treturn;\r\n\t\t\tupdate(obj = newObj);\r\n\t\t} else {\r\n\t\t\tremove();\r\n\t\t}\r\n\t};\r\n}\r\n\r\nvar replaceText = (function () {\r\n\tvar textStore = [];\r\n\r\n\treturn function (index, replacement) {\r\n\t\ttextStore[index] = replacement;\r\n\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t};\r\n})();\r\n\r\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\tvar css = remove ? \"\" : obj.css;\r\n\r\n\tif (styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t} else {\r\n\t\tvar cssNode = document.createTextNode(css);\r\n\t\tvar childNodes = styleElement.childNodes;\r\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\tif (childNodes.length) {\r\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t} else {\r\n\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction applyToTag(styleElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar media = obj.media;\r\n\r\n\tif(media) {\r\n\t\tstyleElement.setAttribute(\"media\", media)\r\n\t}\r\n\r\n\tif(styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = css;\r\n\t} else {\r\n\t\twhile(styleElement.firstChild) {\r\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t}\r\n\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t}\r\n}\r\n\r\nfunction updateLink(linkElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar sourceMap = obj.sourceMap;\r\n\r\n\tif(sourceMap) {\r\n\t\t// http://stackoverflow.com/a/26603875\r\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\r\n\t}\r\n\r\n\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\r\n\tvar oldSrc = linkElement.href;\r\n\r\n\tlinkElement.href = URL.createObjectURL(blob);\r\n\r\n\tif(oldSrc)\r\n\t\tURL.revokeObjectURL(oldSrc);\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/style-loader/addStyles.js\n ** module id = 4\n ** module chunks = 0\n **/","!function() {\n  var d3 = {\n    version: \"3.5.16\"\n  };\n  var d3_arraySlice = [].slice, d3_array = function(list) {\n    return d3_arraySlice.call(list);\n  };\n  var d3_document = this.document;\n  function d3_documentElement(node) {\n    return node && (node.ownerDocument || node.document || node).documentElement;\n  }\n  function d3_window(node) {\n    return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);\n  }\n  if (d3_document) {\n    try {\n      d3_array(d3_document.documentElement.childNodes)[0].nodeType;\n    } catch (e) {\n      d3_array = function(list) {\n        var i = list.length, array = new Array(i);\n        while (i--) array[i] = list[i];\n        return array;\n      };\n    }\n  }\n  if (!Date.now) Date.now = function() {\n    return +new Date();\n  };\n  if (d3_document) {\n    try {\n      d3_document.createElement(\"DIV\").style.setProperty(\"opacity\", 0, \"\");\n    } catch (error) {\n      var d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;\n      d3_element_prototype.setAttribute = function(name, value) {\n        d3_element_setAttribute.call(this, name, value + \"\");\n      };\n      d3_element_prototype.setAttributeNS = function(space, local, value) {\n        d3_element_setAttributeNS.call(this, space, local, value + \"\");\n      };\n      d3_style_prototype.setProperty = function(name, value, priority) {\n        d3_style_setProperty.call(this, name, value + \"\", priority);\n      };\n    }\n  }\n  d3.ascending = d3_ascending;\n  function d3_ascending(a, b) {\n    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n  }\n  d3.descending = function(a, b) {\n    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;\n  };\n  d3.min = function(array, f) {\n    var i = -1, n = array.length, a, b;\n    if (arguments.length === 1) {\n      while (++i < n) if ((b = array[i]) != null && b >= b) {\n        a = b;\n        break;\n      }\n      while (++i < n) if ((b = array[i]) != null && a > b) a = b;\n    } else {\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {\n        a = b;\n        break;\n      }\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;\n    }\n    return a;\n  };\n  d3.max = function(array, f) {\n    var i = -1, n = array.length, a, b;\n    if (arguments.length === 1) {\n      while (++i < n) if ((b = array[i]) != null && b >= b) {\n        a = b;\n        break;\n      }\n      while (++i < n) if ((b = array[i]) != null && b > a) a = b;\n    } else {\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {\n        a = b;\n        break;\n      }\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;\n    }\n    return a;\n  };\n  d3.extent = function(array, f) {\n    var i = -1, n = array.length, a, b, c;\n    if (arguments.length === 1) {\n      while (++i < n) if ((b = array[i]) != null && b >= b) {\n        a = c = b;\n        break;\n      }\n      while (++i < n) if ((b = array[i]) != null) {\n        if (a > b) a = b;\n        if (c < b) c = b;\n      }\n    } else {\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {\n        a = c = b;\n        break;\n      }\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null) {\n        if (a > b) a = b;\n        if (c < b) c = b;\n      }\n    }\n    return [ a, c ];\n  };\n  function d3_number(x) {\n    return x === null ? NaN : +x;\n  }\n  function d3_numeric(x) {\n    return !isNaN(x);\n  }\n  d3.sum = function(array, f) {\n    var s = 0, n = array.length, a, i = -1;\n    if (arguments.length === 1) {\n      while (++i < n) if (d3_numeric(a = +array[i])) s += a;\n    } else {\n      while (++i < n) if (d3_numeric(a = +f.call(array, array[i], i))) s += a;\n    }\n    return s;\n  };\n  d3.mean = function(array, f) {\n    var s = 0, n = array.length, a, i = -1, j = n;\n    if (arguments.length === 1) {\n      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) s += a; else --j;\n    } else {\n      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a; else --j;\n    }\n    if (j) return s / j;\n  };\n  d3.quantile = function(values, p) {\n    var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;\n    return e ? v + e * (values[h] - v) : v;\n  };\n  d3.median = function(array, f) {\n    var numbers = [], n = array.length, a, i = -1;\n    if (arguments.length === 1) {\n      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) numbers.push(a);\n    } else {\n      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a);\n    }\n    if (numbers.length) return d3.quantile(numbers.sort(d3_ascending), .5);\n  };\n  d3.variance = function(array, f) {\n    var n = array.length, m = 0, a, d, s = 0, i = -1, j = 0;\n    if (arguments.length === 1) {\n      while (++i < n) {\n        if (d3_numeric(a = d3_number(array[i]))) {\n          d = a - m;\n          m += d / ++j;\n          s += d * (a - m);\n        }\n      }\n    } else {\n      while (++i < n) {\n        if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {\n          d = a - m;\n          m += d / ++j;\n          s += d * (a - m);\n        }\n      }\n    }\n    if (j > 1) return s / (j - 1);\n  };\n  d3.deviation = function() {\n    var v = d3.variance.apply(this, arguments);\n    return v ? Math.sqrt(v) : v;\n  };\n  function d3_bisector(compare) {\n    return {\n      left: function(a, x, lo, hi) {\n        if (arguments.length < 3) lo = 0;\n        if (arguments.length < 4) hi = a.length;\n        while (lo < hi) {\n          var mid = lo + hi >>> 1;\n          if (compare(a[mid], x) < 0) lo = mid + 1; else hi = mid;\n        }\n        return lo;\n      },\n      right: function(a, x, lo, hi) {\n        if (arguments.length < 3) lo = 0;\n        if (arguments.length < 4) hi = a.length;\n        while (lo < hi) {\n          var mid = lo + hi >>> 1;\n          if (compare(a[mid], x) > 0) hi = mid; else lo = mid + 1;\n        }\n        return lo;\n      }\n    };\n  }\n  var d3_bisect = d3_bisector(d3_ascending);\n  d3.bisectLeft = d3_bisect.left;\n  d3.bisect = d3.bisectRight = d3_bisect.right;\n  d3.bisector = function(f) {\n    return d3_bisector(f.length === 1 ? function(d, x) {\n      return d3_ascending(f(d), x);\n    } : f);\n  };\n  d3.shuffle = function(array, i0, i1) {\n    if ((m = arguments.length) < 3) {\n      i1 = array.length;\n      if (m < 2) i0 = 0;\n    }\n    var m = i1 - i0, t, i;\n    while (m) {\n      i = Math.random() * m-- | 0;\n      t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;\n    }\n    return array;\n  };\n  d3.permute = function(array, indexes) {\n    var i = indexes.length, permutes = new Array(i);\n    while (i--) permutes[i] = array[indexes[i]];\n    return permutes;\n  };\n  d3.pairs = function(array) {\n    var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);\n    while (i < n) pairs[i] = [ p0 = p1, p1 = array[++i] ];\n    return pairs;\n  };\n  d3.transpose = function(matrix) {\n    if (!(n = matrix.length)) return [];\n    for (var i = -1, m = d3.min(matrix, d3_transposeLength), transpose = new Array(m); ++i < m; ) {\n      for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n; ) {\n        row[j] = matrix[j][i];\n      }\n    }\n    return transpose;\n  };\n  function d3_transposeLength(d) {\n    return d.length;\n  }\n  d3.zip = function() {\n    return d3.transpose(arguments);\n  };\n  d3.keys = function(map) {\n    var keys = [];\n    for (var key in map) keys.push(key);\n    return keys;\n  };\n  d3.values = function(map) {\n    var values = [];\n    for (var key in map) values.push(map[key]);\n    return values;\n  };\n  d3.entries = function(map) {\n    var entries = [];\n    for (var key in map) entries.push({\n      key: key,\n      value: map[key]\n    });\n    return entries;\n  };\n  d3.merge = function(arrays) {\n    var n = arrays.length, m, i = -1, j = 0, merged, array;\n    while (++i < n) j += arrays[i].length;\n    merged = new Array(j);\n    while (--n >= 0) {\n      array = arrays[n];\n      m = array.length;\n      while (--m >= 0) {\n        merged[--j] = array[m];\n      }\n    }\n    return merged;\n  };\n  var abs = Math.abs;\n  d3.range = function(start, stop, step) {\n    if (arguments.length < 3) {\n      step = 1;\n      if (arguments.length < 2) {\n        stop = start;\n        start = 0;\n      }\n    }\n    if ((stop - start) / step === Infinity) throw new Error(\"infinite range\");\n    var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;\n    start *= k, stop *= k, step *= k;\n    if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);\n    return range;\n  };\n  function d3_range_integerScale(x) {\n    var k = 1;\n    while (x * k % 1) k *= 10;\n    return k;\n  }\n  function d3_class(ctor, properties) {\n    for (var key in properties) {\n      Object.defineProperty(ctor.prototype, key, {\n        value: properties[key],\n        enumerable: false\n      });\n    }\n  }\n  d3.map = function(object, f) {\n    var map = new d3_Map();\n    if (object instanceof d3_Map) {\n      object.forEach(function(key, value) {\n        map.set(key, value);\n      });\n    } else if (Array.isArray(object)) {\n      var i = -1, n = object.length, o;\n      if (arguments.length === 1) while (++i < n) map.set(i, object[i]); else while (++i < n) map.set(f.call(object, o = object[i], i), o);\n    } else {\n      for (var key in object) map.set(key, object[key]);\n    }\n    return map;\n  };\n  function d3_Map() {\n    this._ = Object.create(null);\n  }\n  var d3_map_proto = \"__proto__\", d3_map_zero = \"\\x00\";\n  d3_class(d3_Map, {\n    has: d3_map_has,\n    get: function(key) {\n      return this._[d3_map_escape(key)];\n    },\n    set: function(key, value) {\n      return this._[d3_map_escape(key)] = value;\n    },\n    remove: d3_map_remove,\n    keys: d3_map_keys,\n    values: function() {\n      var values = [];\n      for (var key in this._) values.push(this._[key]);\n      return values;\n    },\n    entries: function() {\n      var entries = [];\n      for (var key in this._) entries.push({\n        key: d3_map_unescape(key),\n        value: this._[key]\n      });\n      return entries;\n    },\n    size: d3_map_size,\n    empty: d3_map_empty,\n    forEach: function(f) {\n      for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);\n    }\n  });\n  function d3_map_escape(key) {\n    return (key += \"\") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;\n  }\n  function d3_map_unescape(key) {\n    return (key += \"\")[0] === d3_map_zero ? key.slice(1) : key;\n  }\n  function d3_map_has(key) {\n    return d3_map_escape(key) in this._;\n  }\n  function d3_map_remove(key) {\n    return (key = d3_map_escape(key)) in this._ && delete this._[key];\n  }\n  function d3_map_keys() {\n    var keys = [];\n    for (var key in this._) keys.push(d3_map_unescape(key));\n    return keys;\n  }\n  function d3_map_size() {\n    var size = 0;\n    for (var key in this._) ++size;\n    return size;\n  }\n  function d3_map_empty() {\n    for (var key in this._) return false;\n    return true;\n  }\n  d3.nest = function() {\n    var nest = {}, keys = [], sortKeys = [], sortValues, rollup;\n    function map(mapType, array, depth) {\n      if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;\n      var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;\n      while (++i < n) {\n        if (values = valuesByKey.get(keyValue = key(object = array[i]))) {\n          values.push(object);\n        } else {\n          valuesByKey.set(keyValue, [ object ]);\n        }\n      }\n      if (mapType) {\n        object = mapType();\n        setter = function(keyValue, values) {\n          object.set(keyValue, map(mapType, values, depth));\n        };\n      } else {\n        object = {};\n        setter = function(keyValue, values) {\n          object[keyValue] = map(mapType, values, depth);\n        };\n      }\n      valuesByKey.forEach(setter);\n      return object;\n    }\n    function entries(map, depth) {\n      if (depth >= keys.length) return map;\n      var array = [], sortKey = sortKeys[depth++];\n      map.forEach(function(key, keyMap) {\n        array.push({\n          key: key,\n          values: entries(keyMap, depth)\n        });\n      });\n      return sortKey ? array.sort(function(a, b) {\n        return sortKey(a.key, b.key);\n      }) : array;\n    }\n    nest.map = function(array, mapType) {\n      return map(mapType, array, 0);\n    };\n    nest.entries = function(array) {\n      return entries(map(d3.map, array, 0), 0);\n    };\n    nest.key = function(d) {\n      keys.push(d);\n      return nest;\n    };\n    nest.sortKeys = function(order) {\n      sortKeys[keys.length - 1] = order;\n      return nest;\n    };\n    nest.sortValues = function(order) {\n      sortValues = order;\n      return nest;\n    };\n    nest.rollup = function(f) {\n      rollup = f;\n      return nest;\n    };\n    return nest;\n  };\n  d3.set = function(array) {\n    var set = new d3_Set();\n    if (array) for (var i = 0, n = array.length; i < n; ++i) set.add(array[i]);\n    return set;\n  };\n  function d3_Set() {\n    this._ = Object.create(null);\n  }\n  d3_class(d3_Set, {\n    has: d3_map_has,\n    add: function(key) {\n      this._[d3_map_escape(key += \"\")] = true;\n      return key;\n    },\n    remove: d3_map_remove,\n    values: d3_map_keys,\n    size: d3_map_size,\n    empty: d3_map_empty,\n    forEach: function(f) {\n      for (var key in this._) f.call(this, d3_map_unescape(key));\n    }\n  });\n  d3.behavior = {};\n  function d3_identity(d) {\n    return d;\n  }\n  d3.rebind = function(target, source) {\n    var i = 1, n = arguments.length, method;\n    while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);\n    return target;\n  };\n  function d3_rebind(target, source, method) {\n    return function() {\n      var value = method.apply(source, arguments);\n      return value === source ? target : value;\n    };\n  }\n  function d3_vendorSymbol(object, name) {\n    if (name in object) return name;\n    name = name.charAt(0).toUpperCase() + name.slice(1);\n    for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {\n      var prefixName = d3_vendorPrefixes[i] + name;\n      if (prefixName in object) return prefixName;\n    }\n  }\n  var d3_vendorPrefixes = [ \"webkit\", \"ms\", \"moz\", \"Moz\", \"o\", \"O\" ];\n  function d3_noop() {}\n  d3.dispatch = function() {\n    var dispatch = new d3_dispatch(), i = -1, n = arguments.length;\n    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);\n    return dispatch;\n  };\n  function d3_dispatch() {}\n  d3_dispatch.prototype.on = function(type, listener) {\n    var i = type.indexOf(\".\"), name = \"\";\n    if (i >= 0) {\n      name = type.slice(i + 1);\n      type = type.slice(0, i);\n    }\n    if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);\n    if (arguments.length === 2) {\n      if (listener == null) for (type in this) {\n        if (this.hasOwnProperty(type)) this[type].on(name, null);\n      }\n      return this;\n    }\n  };\n  function d3_dispatch_event(dispatch) {\n    var listeners = [], listenerByName = new d3_Map();\n    function event() {\n      var z = listeners, i = -1, n = z.length, l;\n      while (++i < n) if (l = z[i].on) l.apply(this, arguments);\n      return dispatch;\n    }\n    event.on = function(name, listener) {\n      var l = listenerByName.get(name), i;\n      if (arguments.length < 2) return l && l.on;\n      if (l) {\n        l.on = null;\n        listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));\n        listenerByName.remove(name);\n      }\n      if (listener) listeners.push(listenerByName.set(name, {\n        on: listener\n      }));\n      return dispatch;\n    };\n    return event;\n  }\n  d3.event = null;\n  function d3_eventPreventDefault() {\n    d3.event.preventDefault();\n  }\n  function d3_eventSource() {\n    var e = d3.event, s;\n    while (s = e.sourceEvent) e = s;\n    return e;\n  }\n  function d3_eventDispatch(target) {\n    var dispatch = new d3_dispatch(), i = 0, n = arguments.length;\n    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);\n    dispatch.of = function(thiz, argumentz) {\n      return function(e1) {\n        try {\n          var e0 = e1.sourceEvent = d3.event;\n          e1.target = target;\n          d3.event = e1;\n          dispatch[e1.type].apply(thiz, argumentz);\n        } finally {\n          d3.event = e0;\n        }\n      };\n    };\n    return dispatch;\n  }\n  d3.requote = function(s) {\n    return s.replace(d3_requote_re, \"\\\\$&\");\n  };\n  var d3_requote_re = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\n  var d3_subclass = {}.__proto__ ? function(object, prototype) {\n    object.__proto__ = prototype;\n  } : function(object, prototype) {\n    for (var property in prototype) object[property] = prototype[property];\n  };\n  function d3_selection(groups) {\n    d3_subclass(groups, d3_selectionPrototype);\n    return groups;\n  }\n  var d3_select = function(s, n) {\n    return n.querySelector(s);\n  }, d3_selectAll = function(s, n) {\n    return n.querySelectorAll(s);\n  }, d3_selectMatches = function(n, s) {\n    var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n    d3_selectMatches = function(n, s) {\n      return d3_selectMatcher.call(n, s);\n    };\n    return d3_selectMatches(n, s);\n  };\n  if (typeof Sizzle === \"function\") {\n    d3_select = function(s, n) {\n      return Sizzle(s, n)[0] || null;\n    };\n    d3_selectAll = Sizzle;\n    d3_selectMatches = Sizzle.matchesSelector;\n  }\n  d3.selection = function() {\n    return d3.select(d3_document.documentElement);\n  };\n  var d3_selectionPrototype = d3.selection.prototype = [];\n  d3_selectionPrototype.select = function(selector) {\n    var subgroups = [], subgroup, subnode, group, node;\n    selector = d3_selection_selector(selector);\n    for (var j = -1, m = this.length; ++j < m; ) {\n      subgroups.push(subgroup = []);\n      subgroup.parentNode = (group = this[j]).parentNode;\n      for (var i = -1, n = group.length; ++i < n; ) {\n        if (node = group[i]) {\n          subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n          if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n        } else {\n          subgroup.push(null);\n        }\n      }\n    }\n    return d3_selection(subgroups);\n  };\n  function d3_selection_selector(selector) {\n    return typeof selector === \"function\" ? selector : function() {\n      return d3_select(selector, this);\n    };\n  }\n  d3_selectionPrototype.selectAll = function(selector) {\n    var subgroups = [], subgroup, node;\n    selector = d3_selection_selectorAll(selector);\n    for (var j = -1, m = this.length; ++j < m; ) {\n      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {\n        if (node = group[i]) {\n          subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n          subgroup.parentNode = node;\n        }\n      }\n    }\n    return d3_selection(subgroups);\n  };\n  function d3_selection_selectorAll(selector) {\n    return typeof selector === \"function\" ? selector : function() {\n      return d3_selectAll(selector, this);\n    };\n  }\n  var d3_nsXhtml = \"http://www.w3.org/1999/xhtml\";\n  var d3_nsPrefix = {\n    svg: \"http://www.w3.org/2000/svg\",\n    xhtml: d3_nsXhtml,\n    xlink: \"http://www.w3.org/1999/xlink\",\n    xml: \"http://www.w3.org/XML/1998/namespace\",\n    xmlns: \"http://www.w3.org/2000/xmlns/\"\n  };\n  d3.ns = {\n    prefix: d3_nsPrefix,\n    qualify: function(name) {\n      var i = name.indexOf(\":\"), prefix = name;\n      if (i >= 0 && (prefix = name.slice(0, i)) !== \"xmlns\") name = name.slice(i + 1);\n      return d3_nsPrefix.hasOwnProperty(prefix) ? {\n        space: d3_nsPrefix[prefix],\n        local: name\n      } : name;\n    }\n  };\n  d3_selectionPrototype.attr = function(name, value) {\n    if (arguments.length < 2) {\n      if (typeof name === \"string\") {\n        var node = this.node();\n        name = d3.ns.qualify(name);\n        return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);\n      }\n      for (value in name) this.each(d3_selection_attr(value, name[value]));\n      return this;\n    }\n    return this.each(d3_selection_attr(name, value));\n  };\n  function d3_selection_attr(name, value) {\n    name = d3.ns.qualify(name);\n    function attrNull() {\n      this.removeAttribute(name);\n    }\n    function attrNullNS() {\n      this.removeAttributeNS(name.space, name.local);\n    }\n    function attrConstant() {\n      this.setAttribute(name, value);\n    }\n    function attrConstantNS() {\n      this.setAttributeNS(name.space, name.local, value);\n    }\n    function attrFunction() {\n      var x = value.apply(this, arguments);\n      if (x == null) this.removeAttribute(name); else this.setAttribute(name, x);\n    }\n    function attrFunctionNS() {\n      var x = value.apply(this, arguments);\n      if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x);\n    }\n    return value == null ? name.local ? attrNullNS : attrNull : typeof value === \"function\" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;\n  }\n  function d3_collapse(s) {\n    return s.trim().replace(/\\s+/g, \" \");\n  }\n  d3_selectionPrototype.classed = function(name, value) {\n    if (arguments.length < 2) {\n      if (typeof name === \"string\") {\n        var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;\n        if (value = node.classList) {\n          while (++i < n) if (!value.contains(name[i])) return false;\n        } else {\n          value = node.getAttribute(\"class\");\n          while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n        }\n        return true;\n      }\n      for (value in name) this.each(d3_selection_classed(value, name[value]));\n      return this;\n    }\n    return this.each(d3_selection_classed(name, value));\n  };\n  function d3_selection_classedRe(name) {\n    return new RegExp(\"(?:^|\\\\s+)\" + d3.requote(name) + \"(?:\\\\s+|$)\", \"g\");\n  }\n  function d3_selection_classes(name) {\n    return (name + \"\").trim().split(/^|\\s+/);\n  }\n  function d3_selection_classed(name, value) {\n    name = d3_selection_classes(name).map(d3_selection_classedName);\n    var n = name.length;\n    function classedConstant() {\n      var i = -1;\n      while (++i < n) name[i](this, value);\n    }\n    function classedFunction() {\n      var i = -1, x = value.apply(this, arguments);\n      while (++i < n) name[i](this, x);\n    }\n    return typeof value === \"function\" ? classedFunction : classedConstant;\n  }\n  function d3_selection_classedName(name) {\n    var re = d3_selection_classedRe(name);\n    return function(node, value) {\n      if (c = node.classList) return value ? c.add(name) : c.remove(name);\n      var c = node.getAttribute(\"class\") || \"\";\n      if (value) {\n        re.lastIndex = 0;\n        if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n      } else {\n        node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n      }\n    };\n  }\n  d3_selectionPrototype.style = function(name, value, priority) {\n    var n = arguments.length;\n    if (n < 3) {\n      if (typeof name !== \"string\") {\n        if (n < 2) value = \"\";\n        for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n        return this;\n      }\n      if (n < 2) {\n        var node = this.node();\n        return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n      }\n      priority = \"\";\n    }\n    return this.each(d3_selection_style(name, value, priority));\n  };\n  function d3_selection_style(name, value, priority) {\n    function styleNull() {\n      this.style.removeProperty(name);\n    }\n    function styleConstant() {\n      this.style.setProperty(name, value, priority);\n    }\n    function styleFunction() {\n      var x = value.apply(this, arguments);\n      if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority);\n    }\n    return value == null ? styleNull : typeof value === \"function\" ? styleFunction : styleConstant;\n  }\n  d3_selectionPrototype.property = function(name, value) {\n    if (arguments.length < 2) {\n      if (typeof name === \"string\") return this.node()[name];\n      for (value in name) this.each(d3_selection_property(value, name[value]));\n      return this;\n    }\n    return this.each(d3_selection_property(name, value));\n  };\n  function d3_selection_property(name, value) {\n    function propertyNull() {\n      delete this[name];\n    }\n    function propertyConstant() {\n      this[name] = value;\n    }\n    function propertyFunction() {\n      var x = value.apply(this, arguments);\n      if (x == null) delete this[name]; else this[name] = x;\n    }\n    return value == null ? propertyNull : typeof value === \"function\" ? propertyFunction : propertyConstant;\n  }\n  d3_selectionPrototype.text = function(value) {\n    return arguments.length ? this.each(typeof value === \"function\" ? function() {\n      var v = value.apply(this, arguments);\n      this.textContent = v == null ? \"\" : v;\n    } : value == null ? function() {\n      this.textContent = \"\";\n    } : function() {\n      this.textContent = value;\n    }) : this.node().textContent;\n  };\n  d3_selectionPrototype.html = function(value) {\n    return arguments.length ? this.each(typeof value === \"function\" ? function() {\n      var v = value.apply(this, arguments);\n      this.innerHTML = v == null ? \"\" : v;\n    } : value == null ? function() {\n      this.innerHTML = \"\";\n    } : function() {\n      this.innerHTML = value;\n    }) : this.node().innerHTML;\n  };\n  d3_selectionPrototype.append = function(name) {\n    name = d3_selection_creator(name);\n    return this.select(function() {\n      return this.appendChild(name.apply(this, arguments));\n    });\n  };\n  function d3_selection_creator(name) {\n    function create() {\n      var document = this.ownerDocument, namespace = this.namespaceURI;\n      return namespace === d3_nsXhtml && document.documentElement.namespaceURI === d3_nsXhtml ? document.createElement(name) : document.createElementNS(namespace, name);\n    }\n    function createNS() {\n      return this.ownerDocument.createElementNS(name.space, name.local);\n    }\n    return typeof name === \"function\" ? name : (name = d3.ns.qualify(name)).local ? createNS : create;\n  }\n  d3_selectionPrototype.insert = function(name, before) {\n    name = d3_selection_creator(name);\n    before = d3_selection_selector(before);\n    return this.select(function() {\n      return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n    });\n  };\n  d3_selectionPrototype.remove = function() {\n    return this.each(d3_selectionRemove);\n  };\n  function d3_selectionRemove() {\n    var parent = this.parentNode;\n    if (parent) parent.removeChild(this);\n  }\n  d3_selectionPrototype.data = function(value, key) {\n    var i = -1, n = this.length, group, node;\n    if (!arguments.length) {\n      value = new Array(n = (group = this[0]).length);\n      while (++i < n) {\n        if (node = group[i]) {\n          value[i] = node.__data__;\n        }\n      }\n      return value;\n    }\n    function bind(group, groupData) {\n      var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;\n      if (key) {\n        var nodeByKeyValue = new d3_Map(), keyValues = new Array(n), keyValue;\n        for (i = -1; ++i < n; ) {\n          if (node = group[i]) {\n            if (nodeByKeyValue.has(keyValue = key.call(node, node.__data__, i))) {\n              exitNodes[i] = node;\n            } else {\n              nodeByKeyValue.set(keyValue, node);\n            }\n            keyValues[i] = keyValue;\n          }\n        }\n        for (i = -1; ++i < m; ) {\n          if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n            enterNodes[i] = d3_selection_dataNode(nodeData);\n          } else if (node !== true) {\n            updateNodes[i] = node;\n            node.__data__ = nodeData;\n          }\n          nodeByKeyValue.set(keyValue, true);\n        }\n        for (i = -1; ++i < n; ) {\n          if (i in keyValues && nodeByKeyValue.get(keyValues[i]) !== true) {\n            exitNodes[i] = group[i];\n          }\n        }\n      } else {\n        for (i = -1; ++i < n0; ) {\n          node = group[i];\n          nodeData = groupData[i];\n          if (node) {\n            node.__data__ = nodeData;\n            updateNodes[i] = node;\n          } else {\n            enterNodes[i] = d3_selection_dataNode(nodeData);\n          }\n        }\n        for (;i < m; ++i) {\n          enterNodes[i] = d3_selection_dataNode(groupData[i]);\n        }\n        for (;i < n; ++i) {\n          exitNodes[i] = group[i];\n        }\n      }\n      enterNodes.update = updateNodes;\n      enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;\n      enter.push(enterNodes);\n      update.push(updateNodes);\n      exit.push(exitNodes);\n    }\n    var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);\n    if (typeof value === \"function\") {\n      while (++i < n) {\n        bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n      }\n    } else {\n      while (++i < n) {\n        bind(group = this[i], value);\n      }\n    }\n    update.enter = function() {\n      return enter;\n    };\n    update.exit = function() {\n      return exit;\n    };\n    return update;\n  };\n  function d3_selection_dataNode(data) {\n    return {\n      __data__: data\n    };\n  }\n  d3_selectionPrototype.datum = function(value) {\n    return arguments.length ? this.property(\"__data__\", value) : this.property(\"__data__\");\n  };\n  d3_selectionPrototype.filter = function(filter) {\n    var subgroups = [], subgroup, group, node;\n    if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n    for (var j = 0, m = this.length; j < m; j++) {\n      subgroups.push(subgroup = []);\n      subgroup.parentNode = (group = this[j]).parentNode;\n      for (var i = 0, n = group.length; i < n; i++) {\n        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n          subgroup.push(node);\n        }\n      }\n    }\n    return d3_selection(subgroups);\n  };\n  function d3_selection_filter(selector) {\n    return function() {\n      return d3_selectMatches(this, selector);\n    };\n  }\n  d3_selectionPrototype.order = function() {\n    for (var j = -1, m = this.length; ++j < m; ) {\n      for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {\n        if (node = group[i]) {\n          if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n          next = node;\n        }\n      }\n    }\n    return this;\n  };\n  d3_selectionPrototype.sort = function(comparator) {\n    comparator = d3_selection_sortComparator.apply(this, arguments);\n    for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);\n    return this.order();\n  };\n  function d3_selection_sortComparator(comparator) {\n    if (!arguments.length) comparator = d3_ascending;\n    return function(a, b) {\n      return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n    };\n  }\n  d3_selectionPrototype.each = function(callback) {\n    return d3_selection_each(this, function(node, i, j) {\n      callback.call(node, node.__data__, i, j);\n    });\n  };\n  function d3_selection_each(groups, callback) {\n    for (var j = 0, m = groups.length; j < m; j++) {\n      for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n        if (node = group[i]) callback(node, i, j);\n      }\n    }\n    return groups;\n  }\n  d3_selectionPrototype.call = function(callback) {\n    var args = d3_array(arguments);\n    callback.apply(args[0] = this, args);\n    return this;\n  };\n  d3_selectionPrototype.empty = function() {\n    return !this.node();\n  };\n  d3_selectionPrototype.node = function() {\n    for (var j = 0, m = this.length; j < m; j++) {\n      for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n        var node = group[i];\n        if (node) return node;\n      }\n    }\n    return null;\n  };\n  d3_selectionPrototype.size = function() {\n    var n = 0;\n    d3_selection_each(this, function() {\n      ++n;\n    });\n    return n;\n  };\n  function d3_selection_enter(selection) {\n    d3_subclass(selection, d3_selection_enterPrototype);\n    return selection;\n  }\n  var d3_selection_enterPrototype = [];\n  d3.selection.enter = d3_selection_enter;\n  d3.selection.enter.prototype = d3_selection_enterPrototype;\n  d3_selection_enterPrototype.append = d3_selectionPrototype.append;\n  d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\n  d3_selection_enterPrototype.node = d3_selectionPrototype.node;\n  d3_selection_enterPrototype.call = d3_selectionPrototype.call;\n  d3_selection_enterPrototype.size = d3_selectionPrototype.size;\n  d3_selection_enterPrototype.select = function(selector) {\n    var subgroups = [], subgroup, subnode, upgroup, group, node;\n    for (var j = -1, m = this.length; ++j < m; ) {\n      upgroup = (group = this[j]).update;\n      subgroups.push(subgroup = []);\n      subgroup.parentNode = group.parentNode;\n      for (var i = -1, n = group.length; ++i < n; ) {\n        if (node = group[i]) {\n          subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n          subnode.__data__ = node.__data__;\n        } else {\n          subgroup.push(null);\n        }\n      }\n    }\n    return d3_selection(subgroups);\n  };\n  d3_selection_enterPrototype.insert = function(name, before) {\n    if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n    return d3_selectionPrototype.insert.call(this, name, before);\n  };\n  function d3_selection_enterInsertBefore(enter) {\n    var i0, j0;\n    return function(d, i, j) {\n      var group = enter[j].update, n = group.length, node;\n      if (j != j0) j0 = j, i0 = 0;\n      if (i >= i0) i0 = i + 1;\n      while (!(node = group[i0]) && ++i0 < n) ;\n      return node;\n    };\n  }\n  d3.select = function(node) {\n    var group;\n    if (typeof node === \"string\") {\n      group = [ d3_select(node, d3_document) ];\n      group.parentNode = d3_document.documentElement;\n    } else {\n      group = [ node ];\n      group.parentNode = d3_documentElement(node);\n    }\n    return d3_selection([ group ]);\n  };\n  d3.selectAll = function(nodes) {\n    var group;\n    if (typeof nodes === \"string\") {\n      group = d3_array(d3_selectAll(nodes, d3_document));\n      group.parentNode = d3_document.documentElement;\n    } else {\n      group = d3_array(nodes);\n      group.parentNode = null;\n    }\n    return d3_selection([ group ]);\n  };\n  d3_selectionPrototype.on = function(type, listener, capture) {\n    var n = arguments.length;\n    if (n < 3) {\n      if (typeof type !== \"string\") {\n        if (n < 2) listener = false;\n        for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n        return this;\n      }\n      if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n      capture = false;\n    }\n    return this.each(d3_selection_on(type, listener, capture));\n  };\n  function d3_selection_on(type, listener, capture) {\n    var name = \"__on\" + type, i = type.indexOf(\".\"), wrap = d3_selection_onListener;\n    if (i > 0) type = type.slice(0, i);\n    var filter = d3_selection_onFilters.get(type);\n    if (filter) type = filter, wrap = d3_selection_onFilter;\n    function onRemove() {\n      var l = this[name];\n      if (l) {\n        this.removeEventListener(type, l, l.$);\n        delete this[name];\n      }\n    }\n    function onAdd() {\n      var l = wrap(listener, d3_array(arguments));\n      onRemove.call(this);\n      this.addEventListener(type, this[name] = l, l.$ = capture);\n      l._ = listener;\n    }\n    function removeAll() {\n      var re = new RegExp(\"^__on([^.]+)\" + d3.requote(type) + \"$\"), match;\n      for (var name in this) {\n        if (match = name.match(re)) {\n          var l = this[name];\n          this.removeEventListener(match[1], l, l.$);\n          delete this[name];\n        }\n      }\n    }\n    return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;\n  }\n  var d3_selection_onFilters = d3.map({\n    mouseenter: \"mouseover\",\n    mouseleave: \"mouseout\"\n  });\n  if (d3_document) {\n    d3_selection_onFilters.forEach(function(k) {\n      if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n    });\n  }\n  function d3_selection_onListener(listener, argumentz) {\n    return function(e) {\n      var o = d3.event;\n      d3.event = e;\n      argumentz[0] = this.__data__;\n      try {\n        listener.apply(this, argumentz);\n      } finally {\n        d3.event = o;\n      }\n    };\n  }\n  function d3_selection_onFilter(listener, argumentz) {\n    var l = d3_selection_onListener(listener, argumentz);\n    return function(e) {\n      var target = this, related = e.relatedTarget;\n      if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {\n        l.call(target, e);\n      }\n    };\n  }\n  var d3_event_dragSelect, d3_event_dragId = 0;\n  function d3_event_dragSuppress(node) {\n    var name = \".dragsuppress-\" + ++d3_event_dragId, click = \"click\" + name, w = d3.select(d3_window(node)).on(\"touchmove\" + name, d3_eventPreventDefault).on(\"dragstart\" + name, d3_eventPreventDefault).on(\"selectstart\" + name, d3_eventPreventDefault);\n    if (d3_event_dragSelect == null) {\n      d3_event_dragSelect = \"onselectstart\" in node ? false : d3_vendorSymbol(node.style, \"userSelect\");\n    }\n    if (d3_event_dragSelect) {\n      var style = d3_documentElement(node).style, select = style[d3_event_dragSelect];\n      style[d3_event_dragSelect] = \"none\";\n    }\n    return function(suppressClick) {\n      w.on(name, null);\n      if (d3_event_dragSelect) style[d3_event_dragSelect] = select;\n      if (suppressClick) {\n        var off = function() {\n          w.on(click, null);\n        };\n        w.on(click, function() {\n          d3_eventPreventDefault();\n          off();\n        }, true);\n        setTimeout(off, 0);\n      }\n    };\n  }\n  d3.mouse = function(container) {\n    return d3_mousePoint(container, d3_eventSource());\n  };\n  var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;\n  function d3_mousePoint(container, e) {\n    if (e.changedTouches) e = e.changedTouches[0];\n    var svg = container.ownerSVGElement || container;\n    if (svg.createSVGPoint) {\n      var point = svg.createSVGPoint();\n      if (d3_mouse_bug44083 < 0) {\n        var window = d3_window(container);\n        if (window.scrollX || window.scrollY) {\n          svg = d3.select(\"body\").append(\"svg\").style({\n            position: \"absolute\",\n            top: 0,\n            left: 0,\n            margin: 0,\n            padding: 0,\n            border: \"none\"\n          }, \"important\");\n          var ctm = svg[0][0].getScreenCTM();\n          d3_mouse_bug44083 = !(ctm.f || ctm.e);\n          svg.remove();\n        }\n      }\n      if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY; else point.x = e.clientX, \n      point.y = e.clientY;\n      point = point.matrixTransform(container.getScreenCTM().inverse());\n      return [ point.x, point.y ];\n    }\n    var rect = container.getBoundingClientRect();\n    return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ];\n  }\n  d3.touch = function(container, touches, identifier) {\n    if (arguments.length < 3) identifier = touches, touches = d3_eventSource().changedTouches;\n    if (touches) for (var i = 0, n = touches.length, touch; i < n; ++i) {\n      if ((touch = touches[i]).identifier === identifier) {\n        return d3_mousePoint(container, touch);\n      }\n    }\n  };\n  d3.behavior.drag = function() {\n    var event = d3_eventDispatch(drag, \"drag\", \"dragstart\", \"dragend\"), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_window, \"mousemove\", \"mouseup\"), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, \"touchmove\", \"touchend\");\n    function drag() {\n      this.on(\"mousedown.drag\", mousedown).on(\"touchstart.drag\", touchstart);\n    }\n    function dragstart(id, position, subject, move, end) {\n      return function() {\n        var that = this, target = d3.event.target.correspondingElement || d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = \".drag\" + (dragId == null ? \"\" : \"-\" + dragId), dragOffset, dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(target), position0 = position(parent, dragId);\n        if (origin) {\n          dragOffset = origin.apply(that, arguments);\n          dragOffset = [ dragOffset.x - position0[0], dragOffset.y - position0[1] ];\n        } else {\n          dragOffset = [ 0, 0 ];\n        }\n        dispatch({\n          type: \"dragstart\"\n        });\n        function moved() {\n          var position1 = position(parent, dragId), dx, dy;\n          if (!position1) return;\n          dx = position1[0] - position0[0];\n          dy = position1[1] - position0[1];\n          dragged |= dx | dy;\n          position0 = position1;\n          dispatch({\n            type: \"drag\",\n            x: position1[0] + dragOffset[0],\n            y: position1[1] + dragOffset[1],\n            dx: dx,\n            dy: dy\n          });\n        }\n        function ended() {\n          if (!position(parent, dragId)) return;\n          dragSubject.on(move + dragName, null).on(end + dragName, null);\n          dragRestore(dragged);\n          dispatch({\n            type: \"dragend\"\n          });\n        }\n      };\n    }\n    drag.origin = function(x) {\n      if (!arguments.length) return origin;\n      origin = x;\n      return drag;\n    };\n    return d3.rebind(drag, event, \"on\");\n  };\n  function d3_behavior_dragTouchId() {\n    return d3.event.changedTouches[0].identifier;\n  }\n  d3.touches = function(container, touches) {\n    if (arguments.length < 2) touches = d3_eventSource().touches;\n    return touches ? d3_array(touches).map(function(touch) {\n      var point = d3_mousePoint(container, touch);\n      point.identifier = touch.identifier;\n      return point;\n    }) : [];\n  };\n  var  = 1e-6, 2 =  * ,  = Math.PI,  = 2 * ,  =  - , half =  / 2, d3_radians =  / 180, d3_degrees = 180 / ;\n  function d3_sgn(x) {\n    return x > 0 ? 1 : x < 0 ? -1 : 0;\n  }\n  function d3_cross2d(a, b, c) {\n    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);\n  }\n  function d3_acos(x) {\n    return x > 1 ? 0 : x < -1 ?  : Math.acos(x);\n  }\n  function d3_asin(x) {\n    return x > 1 ? half : x < -1 ? -half : Math.asin(x);\n  }\n  function d3_sinh(x) {\n    return ((x = Math.exp(x)) - 1 / x) / 2;\n  }\n  function d3_cosh(x) {\n    return ((x = Math.exp(x)) + 1 / x) / 2;\n  }\n  function d3_tanh(x) {\n    return ((x = Math.exp(2 * x)) - 1) / (x + 1);\n  }\n  function d3_haversin(x) {\n    return (x = Math.sin(x / 2)) * x;\n  }\n  var  = Math.SQRT2, 2 = 2, 4 = 4;\n  d3.interpolateZoom = function(p0, p1) {\n    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;\n    if (d2 < 2) {\n      S = Math.log(w1 / w0) / ;\n      i = function(t) {\n        return [ ux0 + t * dx, uy0 + t * dy, w0 * Math.exp( * t * S) ];\n      };\n    } else {\n      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + 4 * d2) / (2 * w0 * 2 * d1), b1 = (w1 * w1 - w0 * w0 - 4 * d2) / (2 * w1 * 2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);\n      S = (r1 - r0) / ;\n      i = function(t) {\n        var s = t * S, coshr0 = d3_cosh(r0), u = w0 / (2 * d1) * (coshr0 * d3_tanh( * s + r0) - d3_sinh(r0));\n        return [ ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh( * s + r0) ];\n      };\n    }\n    i.duration = S * 1e3;\n    return i;\n  };\n  d3.behavior.zoom = function() {\n    var view = {\n      x: 0,\n      y: 0,\n      k: 1\n    }, translate0, center0, center, size = [ 960, 500 ], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = \"mousedown.zoom\", mousemove = \"mousemove.zoom\", mouseup = \"mouseup.zoom\", mousewheelTimer, touchstart = \"touchstart.zoom\", touchtime, event = d3_eventDispatch(zoom, \"zoomstart\", \"zoom\", \"zoomend\"), x0, x1, y0, y1;\n    if (!d3_behavior_zoomWheel) {\n      d3_behavior_zoomWheel = \"onwheel\" in d3_document ? (d3_behavior_zoomDelta = function() {\n        return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);\n      }, \"wheel\") : \"onmousewheel\" in d3_document ? (d3_behavior_zoomDelta = function() {\n        return d3.event.wheelDelta;\n      }, \"mousewheel\") : (d3_behavior_zoomDelta = function() {\n        return -d3.event.detail;\n      }, \"MozMousePixelScroll\");\n    }\n    function zoom(g) {\n      g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + \".zoom\", mousewheeled).on(\"dblclick.zoom\", dblclicked).on(touchstart, touchstarted);\n    }\n    zoom.event = function(g) {\n      g.each(function() {\n        var dispatch = event.of(this, arguments), view1 = view;\n        if (d3_transitionInheritId) {\n          d3.select(this).transition().each(\"start.zoom\", function() {\n            view = this.__chart__ || {\n              x: 0,\n              y: 0,\n              k: 1\n            };\n            zoomstarted(dispatch);\n          }).tween(\"zoom:zoom\", function() {\n            var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom([ (cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k ], [ (cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k ]);\n            return function(t) {\n              var l = i(t), k = dx / l[2];\n              this.__chart__ = view = {\n                x: cx - l[0] * k,\n                y: cy - l[1] * k,\n                k: k\n              };\n              zoomed(dispatch);\n            };\n          }).each(\"interrupt.zoom\", function() {\n            zoomended(dispatch);\n          }).each(\"end.zoom\", function() {\n            zoomended(dispatch);\n          });\n        } else {\n          this.__chart__ = view;\n          zoomstarted(dispatch);\n          zoomed(dispatch);\n          zoomended(dispatch);\n        }\n      });\n    };\n    zoom.translate = function(_) {\n      if (!arguments.length) return [ view.x, view.y ];\n      view = {\n        x: +_[0],\n        y: +_[1],\n        k: view.k\n      };\n      rescale();\n      return zoom;\n    };\n    zoom.scale = function(_) {\n      if (!arguments.length) return view.k;\n      view = {\n        x: view.x,\n        y: view.y,\n        k: null\n      };\n      scaleTo(+_);\n      rescale();\n      return zoom;\n    };\n    zoom.scaleExtent = function(_) {\n      if (!arguments.length) return scaleExtent;\n      scaleExtent = _ == null ? d3_behavior_zoomInfinity : [ +_[0], +_[1] ];\n      return zoom;\n    };\n    zoom.center = function(_) {\n      if (!arguments.length) return center;\n      center = _ && [ +_[0], +_[1] ];\n      return zoom;\n    };\n    zoom.size = function(_) {\n      if (!arguments.length) return size;\n      size = _ && [ +_[0], +_[1] ];\n      return zoom;\n    };\n    zoom.duration = function(_) {\n      if (!arguments.length) return duration;\n      duration = +_;\n      return zoom;\n    };\n    zoom.x = function(z) {\n      if (!arguments.length) return x1;\n      x1 = z;\n      x0 = z.copy();\n      view = {\n        x: 0,\n        y: 0,\n        k: 1\n      };\n      return zoom;\n    };\n    zoom.y = function(z) {\n      if (!arguments.length) return y1;\n      y1 = z;\n      y0 = z.copy();\n      view = {\n        x: 0,\n        y: 0,\n        k: 1\n      };\n      return zoom;\n    };\n    function location(p) {\n      return [ (p[0] - view.x) / view.k, (p[1] - view.y) / view.k ];\n    }\n    function point(l) {\n      return [ l[0] * view.k + view.x, l[1] * view.k + view.y ];\n    }\n    function scaleTo(s) {\n      view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));\n    }\n    function translateTo(p, l) {\n      l = point(l);\n      view.x += p[0] - l[0];\n      view.y += p[1] - l[1];\n    }\n    function zoomTo(that, p, l, k) {\n      that.__chart__ = {\n        x: view.x,\n        y: view.y,\n        k: view.k\n      };\n      scaleTo(Math.pow(2, k));\n      translateTo(center0 = p, l);\n      that = d3.select(that);\n      if (duration > 0) that = that.transition().duration(duration);\n      that.call(zoom.event);\n    }\n    function rescale() {\n      if (x1) x1.domain(x0.range().map(function(x) {\n        return (x - view.x) / view.k;\n      }).map(x0.invert));\n      if (y1) y1.domain(y0.range().map(function(y) {\n        return (y - view.y) / view.k;\n      }).map(y0.invert));\n    }\n    function zoomstarted(dispatch) {\n      if (!zooming++) dispatch({\n        type: \"zoomstart\"\n      });\n    }\n    function zoomed(dispatch) {\n      rescale();\n      dispatch({\n        type: \"zoom\",\n        scale: view.k,\n        translate: [ view.x, view.y ]\n      });\n    }\n    function zoomended(dispatch) {\n      if (!--zooming) dispatch({\n        type: \"zoomend\"\n      }), center0 = null;\n    }\n    function mousedowned() {\n      var that = this, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress(that);\n      d3_selection_interrupt.call(that);\n      zoomstarted(dispatch);\n      function moved() {\n        dragged = 1;\n        translateTo(d3.mouse(that), location0);\n        zoomed(dispatch);\n      }\n      function ended() {\n        subject.on(mousemove, null).on(mouseup, null);\n        dragRestore(dragged);\n        zoomended(dispatch);\n      }\n    }\n    function touchstarted() {\n      var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = \".zoom-\" + d3.event.changedTouches[0].identifier, touchmove = \"touchmove\" + zoomName, touchend = \"touchend\" + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress(that);\n      started();\n      zoomstarted(dispatch);\n      subject.on(mousedown, null).on(touchstart, started);\n      function relocate() {\n        var touches = d3.touches(that);\n        scale0 = view.k;\n        touches.forEach(function(t) {\n          if (t.identifier in locations0) locations0[t.identifier] = location(t);\n        });\n        return touches;\n      }\n      function started() {\n        var target = d3.event.target;\n        d3.select(target).on(touchmove, moved).on(touchend, ended);\n        targets.push(target);\n        var changed = d3.event.changedTouches;\n        for (var i = 0, n = changed.length; i < n; ++i) {\n          locations0[changed[i].identifier] = null;\n        }\n        var touches = relocate(), now = Date.now();\n        if (touches.length === 1) {\n          if (now - touchtime < 500) {\n            var p = touches[0];\n            zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);\n            d3_eventPreventDefault();\n          }\n          touchtime = now;\n        } else if (touches.length > 1) {\n          var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];\n          distance0 = dx * dx + dy * dy;\n        }\n      }\n      function moved() {\n        var touches = d3.touches(that), p0, l0, p1, l1;\n        d3_selection_interrupt.call(that);\n        for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {\n          p1 = touches[i];\n          if (l1 = locations0[p1.identifier]) {\n            if (l0) break;\n            p0 = p1, l0 = l1;\n          }\n        }\n        if (l1) {\n          var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);\n          p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ];\n          l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ];\n          scaleTo(scale1 * scale0);\n        }\n        touchtime = null;\n        translateTo(p0, l0);\n        zoomed(dispatch);\n      }\n      function ended() {\n        if (d3.event.touches.length) {\n          var changed = d3.event.changedTouches;\n          for (var i = 0, n = changed.length; i < n; ++i) {\n            delete locations0[changed[i].identifier];\n          }\n          for (var identifier in locations0) {\n            return void relocate();\n          }\n        }\n        d3.selectAll(targets).on(zoomName, null);\n        subject.on(mousedown, mousedowned).on(touchstart, touchstarted);\n        dragRestore();\n        zoomended(dispatch);\n      }\n    }\n    function mousewheeled() {\n      var dispatch = event.of(this, arguments);\n      if (mousewheelTimer) clearTimeout(mousewheelTimer); else d3_selection_interrupt.call(this), \n      translate0 = location(center0 = center || d3.mouse(this)), zoomstarted(dispatch);\n      mousewheelTimer = setTimeout(function() {\n        mousewheelTimer = null;\n        zoomended(dispatch);\n      }, 50);\n      d3_eventPreventDefault();\n      scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);\n      translateTo(center0, translate0);\n      zoomed(dispatch);\n    }\n    function dblclicked() {\n      var p = d3.mouse(this), k = Math.log(view.k) / Math.LN2;\n      zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);\n    }\n    return d3.rebind(zoom, event, \"on\");\n  };\n  var d3_behavior_zoomInfinity = [ 0, Infinity ], d3_behavior_zoomDelta, d3_behavior_zoomWheel;\n  d3.color = d3_color;\n  function d3_color() {}\n  d3_color.prototype.toString = function() {\n    return this.rgb() + \"\";\n  };\n  d3.hsl = d3_hsl;\n  function d3_hsl(h, s, l) {\n    return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse(\"\" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);\n  }\n  var d3_hslPrototype = d3_hsl.prototype = new d3_color();\n  d3_hslPrototype.brighter = function(k) {\n    k = Math.pow(.7, arguments.length ? k : 1);\n    return new d3_hsl(this.h, this.s, this.l / k);\n  };\n  d3_hslPrototype.darker = function(k) {\n    k = Math.pow(.7, arguments.length ? k : 1);\n    return new d3_hsl(this.h, this.s, k * this.l);\n  };\n  d3_hslPrototype.rgb = function() {\n    return d3_hsl_rgb(this.h, this.s, this.l);\n  };\n  function d3_hsl_rgb(h, s, l) {\n    var m1, m2;\n    h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;\n    s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;\n    l = l < 0 ? 0 : l > 1 ? 1 : l;\n    m2 = l <= .5 ? l * (1 + s) : l + s - l * s;\n    m1 = 2 * l - m2;\n    function v(h) {\n      if (h > 360) h -= 360; else if (h < 0) h += 360;\n      if (h < 60) return m1 + (m2 - m1) * h / 60;\n      if (h < 180) return m2;\n      if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;\n      return m1;\n    }\n    function vv(h) {\n      return Math.round(v(h) * 255);\n    }\n    return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));\n  }\n  d3.hcl = d3_hcl;\n  function d3_hcl(h, c, l) {\n    return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);\n  }\n  var d3_hclPrototype = d3_hcl.prototype = new d3_color();\n  d3_hclPrototype.brighter = function(k) {\n    return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));\n  };\n  d3_hclPrototype.darker = function(k) {\n    return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));\n  };\n  d3_hclPrototype.rgb = function() {\n    return d3_hcl_lab(this.h, this.c, this.l).rgb();\n  };\n  function d3_hcl_lab(h, c, l) {\n    if (isNaN(h)) h = 0;\n    if (isNaN(c)) c = 0;\n    return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);\n  }\n  d3.lab = d3_lab;\n  function d3_lab(l, a, b) {\n    return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);\n  }\n  var d3_lab_K = 18;\n  var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;\n  var d3_labPrototype = d3_lab.prototype = new d3_color();\n  d3_labPrototype.brighter = function(k) {\n    return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);\n  };\n  d3_labPrototype.darker = function(k) {\n    return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);\n  };\n  d3_labPrototype.rgb = function() {\n    return d3_lab_rgb(this.l, this.a, this.b);\n  };\n  function d3_lab_rgb(l, a, b) {\n    var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;\n    x = d3_lab_xyz(x) * d3_lab_X;\n    y = d3_lab_xyz(y) * d3_lab_Y;\n    z = d3_lab_xyz(z) * d3_lab_Z;\n    return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));\n  }\n  function d3_lab_hcl(l, a, b) {\n    return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);\n  }\n  function d3_lab_xyz(x) {\n    return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;\n  }\n  function d3_xyz_lab(x) {\n    return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;\n  }\n  function d3_xyz_rgb(r) {\n    return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));\n  }\n  d3.rgb = d3_rgb;\n  function d3_rgb(r, g, b) {\n    return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse(\"\" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);\n  }\n  function d3_rgbNumber(value) {\n    return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);\n  }\n  function d3_rgbString(value) {\n    return d3_rgbNumber(value) + \"\";\n  }\n  var d3_rgbPrototype = d3_rgb.prototype = new d3_color();\n  d3_rgbPrototype.brighter = function(k) {\n    k = Math.pow(.7, arguments.length ? k : 1);\n    var r = this.r, g = this.g, b = this.b, i = 30;\n    if (!r && !g && !b) return new d3_rgb(i, i, i);\n    if (r && r < i) r = i;\n    if (g && g < i) g = i;\n    if (b && b < i) b = i;\n    return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));\n  };\n  d3_rgbPrototype.darker = function(k) {\n    k = Math.pow(.7, arguments.length ? k : 1);\n    return new d3_rgb(k * this.r, k * this.g, k * this.b);\n  };\n  d3_rgbPrototype.hsl = function() {\n    return d3_rgb_hsl(this.r, this.g, this.b);\n  };\n  d3_rgbPrototype.toString = function() {\n    return \"#\" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);\n  };\n  function d3_rgb_hex(v) {\n    return v < 16 ? \"0\" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);\n  }\n  function d3_rgb_parse(format, rgb, hsl) {\n    var r = 0, g = 0, b = 0, m1, m2, color;\n    m1 = /([a-z]+)\\((.*)\\)/.exec(format = format.toLowerCase());\n    if (m1) {\n      m2 = m1[2].split(\",\");\n      switch (m1[1]) {\n       case \"hsl\":\n        {\n          return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);\n        }\n\n       case \"rgb\":\n        {\n          return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));\n        }\n      }\n    }\n    if (color = d3_rgb_names.get(format)) {\n      return rgb(color.r, color.g, color.b);\n    }\n    if (format != null && format.charAt(0) === \"#\" && !isNaN(color = parseInt(format.slice(1), 16))) {\n      if (format.length === 4) {\n        r = (color & 3840) >> 4;\n        r = r >> 4 | r;\n        g = color & 240;\n        g = g >> 4 | g;\n        b = color & 15;\n        b = b << 4 | b;\n      } else if (format.length === 7) {\n        r = (color & 16711680) >> 16;\n        g = (color & 65280) >> 8;\n        b = color & 255;\n      }\n    }\n    return rgb(r, g, b);\n  }\n  function d3_rgb_hsl(r, g, b) {\n    var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;\n    if (d) {\n      s = l < .5 ? d / (max + min) : d / (2 - max - min);\n      if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4;\n      h *= 60;\n    } else {\n      h = NaN;\n      s = l > 0 && l < 1 ? 0 : h;\n    }\n    return new d3_hsl(h, s, l);\n  }\n  function d3_rgb_lab(r, g, b) {\n    r = d3_rgb_xyz(r);\n    g = d3_rgb_xyz(g);\n    b = d3_rgb_xyz(b);\n    var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);\n    return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));\n  }\n  function d3_rgb_xyz(r) {\n    return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);\n  }\n  function d3_rgb_parseNumber(c) {\n    var f = parseFloat(c);\n    return c.charAt(c.length - 1) === \"%\" ? Math.round(f * 2.55) : f;\n  }\n  var d3_rgb_names = d3.map({\n    aliceblue: 15792383,\n    antiquewhite: 16444375,\n    aqua: 65535,\n    aquamarine: 8388564,\n    azure: 15794175,\n    beige: 16119260,\n    bisque: 16770244,\n    black: 0,\n    blanchedalmond: 16772045,\n    blue: 255,\n    blueviolet: 9055202,\n    brown: 10824234,\n    burlywood: 14596231,\n    cadetblue: 6266528,\n    chartreuse: 8388352,\n    chocolate: 13789470,\n    coral: 16744272,\n    cornflowerblue: 6591981,\n    cornsilk: 16775388,\n    crimson: 14423100,\n    cyan: 65535,\n    darkblue: 139,\n    darkcyan: 35723,\n    darkgoldenrod: 12092939,\n    darkgray: 11119017,\n    darkgreen: 25600,\n    darkgrey: 11119017,\n    darkkhaki: 12433259,\n    darkmagenta: 9109643,\n    darkolivegreen: 5597999,\n    darkorange: 16747520,\n    darkorchid: 10040012,\n    darkred: 9109504,\n    darksalmon: 15308410,\n    darkseagreen: 9419919,\n    darkslateblue: 4734347,\n    darkslategray: 3100495,\n    darkslategrey: 3100495,\n    darkturquoise: 52945,\n    darkviolet: 9699539,\n    deeppink: 16716947,\n    deepskyblue: 49151,\n    dimgray: 6908265,\n    dimgrey: 6908265,\n    dodgerblue: 2003199,\n    firebrick: 11674146,\n    floralwhite: 16775920,\n    forestgreen: 2263842,\n    fuchsia: 16711935,\n    gainsboro: 14474460,\n    ghostwhite: 16316671,\n    gold: 16766720,\n    goldenrod: 14329120,\n    gray: 8421504,\n    green: 32768,\n    greenyellow: 11403055,\n    grey: 8421504,\n    honeydew: 15794160,\n    hotpink: 16738740,\n    indianred: 13458524,\n    indigo: 4915330,\n    ivory: 16777200,\n    khaki: 15787660,\n    lavender: 15132410,\n    lavenderblush: 16773365,\n    lawngreen: 8190976,\n    lemonchiffon: 16775885,\n    lightblue: 11393254,\n    lightcoral: 15761536,\n    lightcyan: 14745599,\n    lightgoldenrodyellow: 16448210,\n    lightgray: 13882323,\n    lightgreen: 9498256,\n    lightgrey: 13882323,\n    lightpink: 16758465,\n    lightsalmon: 16752762,\n    lightseagreen: 2142890,\n    lightskyblue: 8900346,\n    lightslategray: 7833753,\n    lightslategrey: 7833753,\n    lightsteelblue: 11584734,\n    lightyellow: 16777184,\n    lime: 65280,\n    limegreen: 3329330,\n    linen: 16445670,\n    magenta: 16711935,\n    maroon: 8388608,\n    mediumaquamarine: 6737322,\n    mediumblue: 205,\n    mediumorchid: 12211667,\n    mediumpurple: 9662683,\n    mediumseagreen: 3978097,\n    mediumslateblue: 8087790,\n    mediumspringgreen: 64154,\n    mediumturquoise: 4772300,\n    mediumvioletred: 13047173,\n    midnightblue: 1644912,\n    mintcream: 16121850,\n    mistyrose: 16770273,\n    moccasin: 16770229,\n    navajowhite: 16768685,\n    navy: 128,\n    oldlace: 16643558,\n    olive: 8421376,\n    olivedrab: 7048739,\n    orange: 16753920,\n    orangered: 16729344,\n    orchid: 14315734,\n    palegoldenrod: 15657130,\n    palegreen: 10025880,\n    paleturquoise: 11529966,\n    palevioletred: 14381203,\n    papayawhip: 16773077,\n    peachpuff: 16767673,\n    peru: 13468991,\n    pink: 16761035,\n    plum: 14524637,\n    powderblue: 11591910,\n    purple: 8388736,\n    rebeccapurple: 6697881,\n    red: 16711680,\n    rosybrown: 12357519,\n    royalblue: 4286945,\n    saddlebrown: 9127187,\n    salmon: 16416882,\n    sandybrown: 16032864,\n    seagreen: 3050327,\n    seashell: 16774638,\n    sienna: 10506797,\n    silver: 12632256,\n    skyblue: 8900331,\n    slateblue: 6970061,\n    slategray: 7372944,\n    slategrey: 7372944,\n    snow: 16775930,\n    springgreen: 65407,\n    steelblue: 4620980,\n    tan: 13808780,\n    teal: 32896,\n    thistle: 14204888,\n    tomato: 16737095,\n    turquoise: 4251856,\n    violet: 15631086,\n    wheat: 16113331,\n    white: 16777215,\n    whitesmoke: 16119285,\n    yellow: 16776960,\n    yellowgreen: 10145074\n  });\n  d3_rgb_names.forEach(function(key, value) {\n    d3_rgb_names.set(key, d3_rgbNumber(value));\n  });\n  function d3_functor(v) {\n    return typeof v === \"function\" ? v : function() {\n      return v;\n    };\n  }\n  d3.functor = d3_functor;\n  d3.xhr = d3_xhrType(d3_identity);\n  function d3_xhrType(response) {\n    return function(url, mimeType, callback) {\n      if (arguments.length === 2 && typeof mimeType === \"function\") callback = mimeType, \n      mimeType = null;\n      return d3_xhr(url, mimeType, response, callback);\n    };\n  }\n  function d3_xhr(url, mimeType, response, callback) {\n    var xhr = {}, dispatch = d3.dispatch(\"beforesend\", \"progress\", \"load\", \"error\"), headers = {}, request = new XMLHttpRequest(), responseType = null;\n    if (this.XDomainRequest && !(\"withCredentials\" in request) && /^(http(s)?:)?\\/\\//.test(url)) request = new XDomainRequest();\n    \"onload\" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {\n      request.readyState > 3 && respond();\n    };\n    function respond() {\n      var status = request.status, result;\n      if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {\n        try {\n          result = response.call(xhr, request);\n        } catch (e) {\n          dispatch.error.call(xhr, e);\n          return;\n        }\n        dispatch.load.call(xhr, result);\n      } else {\n        dispatch.error.call(xhr, request);\n      }\n    }\n    request.onprogress = function(event) {\n      var o = d3.event;\n      d3.event = event;\n      try {\n        dispatch.progress.call(xhr, request);\n      } finally {\n        d3.event = o;\n      }\n    };\n    xhr.header = function(name, value) {\n      name = (name + \"\").toLowerCase();\n      if (arguments.length < 2) return headers[name];\n      if (value == null) delete headers[name]; else headers[name] = value + \"\";\n      return xhr;\n    };\n    xhr.mimeType = function(value) {\n      if (!arguments.length) return mimeType;\n      mimeType = value == null ? null : value + \"\";\n      return xhr;\n    };\n    xhr.responseType = function(value) {\n      if (!arguments.length) return responseType;\n      responseType = value;\n      return xhr;\n    };\n    xhr.response = function(value) {\n      response = value;\n      return xhr;\n    };\n    [ \"get\", \"post\" ].forEach(function(method) {\n      xhr[method] = function() {\n        return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments)));\n      };\n    });\n    xhr.send = function(method, data, callback) {\n      if (arguments.length === 2 && typeof data === \"function\") callback = data, data = null;\n      request.open(method, url, true);\n      if (mimeType != null && !(\"accept\" in headers)) headers[\"accept\"] = mimeType + \",*/*\";\n      if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);\n      if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);\n      if (responseType != null) request.responseType = responseType;\n      if (callback != null) xhr.on(\"error\", callback).on(\"load\", function(request) {\n        callback(null, request);\n      });\n      dispatch.beforesend.call(xhr, request);\n      request.send(data == null ? null : data);\n      return xhr;\n    };\n    xhr.abort = function() {\n      request.abort();\n      return xhr;\n    };\n    d3.rebind(xhr, dispatch, \"on\");\n    return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));\n  }\n  function d3_xhr_fixCallback(callback) {\n    return callback.length === 1 ? function(error, request) {\n      callback(error == null ? request : null);\n    } : callback;\n  }\n  function d3_xhrHasResponse(request) {\n    var type = request.responseType;\n    return type && type !== \"text\" ? request.response : request.responseText;\n  }\n  d3.dsv = function(delimiter, mimeType) {\n    var reFormat = new RegExp('[\"' + delimiter + \"\\n]\"), delimiterCode = delimiter.charCodeAt(0);\n    function dsv(url, row, callback) {\n      if (arguments.length < 3) callback = row, row = null;\n      var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);\n      xhr.row = function(_) {\n        return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;\n      };\n      return xhr;\n    }\n    function response(request) {\n      return dsv.parse(request.responseText);\n    }\n    function typedResponse(f) {\n      return function(request) {\n        return dsv.parse(request.responseText, f);\n      };\n    }\n    dsv.parse = function(text, f) {\n      var o;\n      return dsv.parseRows(text, function(row, i) {\n        if (o) return o(row, i - 1);\n        var a = new Function(\"d\", \"return {\" + row.map(function(name, i) {\n          return JSON.stringify(name) + \": d[\" + i + \"]\";\n        }).join(\",\") + \"}\");\n        o = f ? function(row, i) {\n          return f(a(row), i);\n        } : a;\n      });\n    };\n    dsv.parseRows = function(text, f) {\n      var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;\n      function token() {\n        if (I >= N) return EOF;\n        if (eol) return eol = false, EOL;\n        var j = I;\n        if (text.charCodeAt(j) === 34) {\n          var i = j;\n          while (i++ < N) {\n            if (text.charCodeAt(i) === 34) {\n              if (text.charCodeAt(i + 1) !== 34) break;\n              ++i;\n            }\n          }\n          I = i + 2;\n          var c = text.charCodeAt(i + 1);\n          if (c === 13) {\n            eol = true;\n            if (text.charCodeAt(i + 2) === 10) ++I;\n          } else if (c === 10) {\n            eol = true;\n          }\n          return text.slice(j + 1, i).replace(/\"\"/g, '\"');\n        }\n        while (I < N) {\n          var c = text.charCodeAt(I++), k = 1;\n          if (c === 10) eol = true; else if (c === 13) {\n            eol = true;\n            if (text.charCodeAt(I) === 10) ++I, ++k;\n          } else if (c !== delimiterCode) continue;\n          return text.slice(j, I - k);\n        }\n        return text.slice(j);\n      }\n      while ((t = token()) !== EOF) {\n        var a = [];\n        while (t !== EOL && t !== EOF) {\n          a.push(t);\n          t = token();\n        }\n        if (f && (a = f(a, n++)) == null) continue;\n        rows.push(a);\n      }\n      return rows;\n    };\n    dsv.format = function(rows) {\n      if (Array.isArray(rows[0])) return dsv.formatRows(rows);\n      var fieldSet = new d3_Set(), fields = [];\n      rows.forEach(function(row) {\n        for (var field in row) {\n          if (!fieldSet.has(field)) {\n            fields.push(fieldSet.add(field));\n          }\n        }\n      });\n      return [ fields.map(formatValue).join(delimiter) ].concat(rows.map(function(row) {\n        return fields.map(function(field) {\n          return formatValue(row[field]);\n        }).join(delimiter);\n      })).join(\"\\n\");\n    };\n    dsv.formatRows = function(rows) {\n      return rows.map(formatRow).join(\"\\n\");\n    };\n    function formatRow(row) {\n      return row.map(formatValue).join(delimiter);\n    }\n    function formatValue(text) {\n      return reFormat.test(text) ? '\"' + text.replace(/\\\"/g, '\"\"') + '\"' : text;\n    }\n    return dsv;\n  };\n  d3.csv = d3.dsv(\",\", \"text/csv\");\n  d3.tsv = d3.dsv(\"\t\", \"text/tab-separated-values\");\n  var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_frame = this[d3_vendorSymbol(this, \"requestAnimationFrame\")] || function(callback) {\n    setTimeout(callback, 17);\n  };\n  d3.timer = function() {\n    d3_timer.apply(this, arguments);\n  };\n  function d3_timer(callback, delay, then) {\n    var n = arguments.length;\n    if (n < 2) delay = 0;\n    if (n < 3) then = Date.now();\n    var time = then + delay, timer = {\n      c: callback,\n      t: time,\n      n: null\n    };\n    if (d3_timer_queueTail) d3_timer_queueTail.n = timer; else d3_timer_queueHead = timer;\n    d3_timer_queueTail = timer;\n    if (!d3_timer_interval) {\n      d3_timer_timeout = clearTimeout(d3_timer_timeout);\n      d3_timer_interval = 1;\n      d3_timer_frame(d3_timer_step);\n    }\n    return timer;\n  }\n  function d3_timer_step() {\n    var now = d3_timer_mark(), delay = d3_timer_sweep() - now;\n    if (delay > 24) {\n      if (isFinite(delay)) {\n        clearTimeout(d3_timer_timeout);\n        d3_timer_timeout = setTimeout(d3_timer_step, delay);\n      }\n      d3_timer_interval = 0;\n    } else {\n      d3_timer_interval = 1;\n      d3_timer_frame(d3_timer_step);\n    }\n  }\n  d3.timer.flush = function() {\n    d3_timer_mark();\n    d3_timer_sweep();\n  };\n  function d3_timer_mark() {\n    var now = Date.now(), timer = d3_timer_queueHead;\n    while (timer) {\n      if (now >= timer.t && timer.c(now - timer.t)) timer.c = null;\n      timer = timer.n;\n    }\n    return now;\n  }\n  function d3_timer_sweep() {\n    var t0, t1 = d3_timer_queueHead, time = Infinity;\n    while (t1) {\n      if (t1.c) {\n        if (t1.t < time) time = t1.t;\n        t1 = (t0 = t1).n;\n      } else {\n        t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;\n      }\n    }\n    d3_timer_queueTail = t0;\n    return time;\n  }\n  function d3_format_precision(x, p) {\n    return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);\n  }\n  d3.round = function(x, n) {\n    return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);\n  };\n  var d3_formatPrefixes = [ \"y\", \"z\", \"a\", \"f\", \"p\", \"n\", \"\", \"m\", \"\", \"k\", \"M\", \"G\", \"T\", \"P\", \"E\", \"Z\", \"Y\" ].map(d3_formatPrefix);\n  d3.formatPrefix = function(value, precision) {\n    var i = 0;\n    if (value = +value) {\n      if (value < 0) value *= -1;\n      if (precision) value = d3.round(value, d3_format_precision(value, precision));\n      i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);\n      i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));\n    }\n    return d3_formatPrefixes[8 + i / 3];\n  };\n  function d3_formatPrefix(d, i) {\n    var k = Math.pow(10, abs(8 - i) * 3);\n    return {\n      scale: i > 8 ? function(d) {\n        return d / k;\n      } : function(d) {\n        return d * k;\n      },\n      symbol: d\n    };\n  }\n  function d3_locale_numberFormat(locale) {\n    var locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping && locale_thousands ? function(value, width) {\n      var i = value.length, t = [], j = 0, g = locale_grouping[0], length = 0;\n      while (i > 0 && g > 0) {\n        if (length + g + 1 > width) g = Math.max(1, width - length);\n        t.push(value.substring(i -= g, i + g));\n        if ((length += g + 1) > width) break;\n        g = locale_grouping[j = (j + 1) % locale_grouping.length];\n      }\n      return t.reverse().join(locale_thousands);\n    } : d3_identity;\n    return function(specifier) {\n      var match = d3_format_re.exec(specifier), fill = match[1] || \" \", align = match[2] || \">\", sign = match[3] || \"-\", symbol = match[4] || \"\", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = \"\", suffix = \"\", integer = false, exponent = true;\n      if (precision) precision = +precision.substring(1);\n      if (zfill || fill === \"0\" && align === \"=\") {\n        zfill = fill = \"0\";\n        align = \"=\";\n      }\n      switch (type) {\n       case \"n\":\n        comma = true;\n        type = \"g\";\n        break;\n\n       case \"%\":\n        scale = 100;\n        suffix = \"%\";\n        type = \"f\";\n        break;\n\n       case \"p\":\n        scale = 100;\n        suffix = \"%\";\n        type = \"r\";\n        break;\n\n       case \"b\":\n       case \"o\":\n       case \"x\":\n       case \"X\":\n        if (symbol === \"#\") prefix = \"0\" + type.toLowerCase();\n\n       case \"c\":\n        exponent = false;\n\n       case \"d\":\n        integer = true;\n        precision = 0;\n        break;\n\n       case \"s\":\n        scale = -1;\n        type = \"r\";\n        break;\n      }\n      if (symbol === \"$\") prefix = locale_currency[0], suffix = locale_currency[1];\n      if (type == \"r\" && !precision) type = \"g\";\n      if (precision != null) {\n        if (type == \"g\") precision = Math.max(1, Math.min(21, precision)); else if (type == \"e\" || type == \"f\") precision = Math.max(0, Math.min(20, precision));\n      }\n      type = d3_format_types.get(type) || d3_format_typeDefault;\n      var zcomma = zfill && comma;\n      return function(value) {\n        var fullSuffix = suffix;\n        if (integer && value % 1) return \"\";\n        var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, \"-\") : sign === \"-\" ? \"\" : sign;\n        if (scale < 0) {\n          var unit = d3.formatPrefix(value, precision);\n          value = unit.scale(value);\n          fullSuffix = unit.symbol + suffix;\n        } else {\n          value *= scale;\n        }\n        value = type(value, precision);\n        var i = value.lastIndexOf(\".\"), before, after;\n        if (i < 0) {\n          var j = exponent ? value.lastIndexOf(\"e\") : -1;\n          if (j < 0) before = value, after = \"\"; else before = value.substring(0, j), after = value.substring(j);\n        } else {\n          before = value.substring(0, i);\n          after = locale_decimal + value.substring(i + 1);\n        }\n        if (!zfill && comma) before = formatGroup(before, Infinity);\n        var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : \"\";\n        if (zcomma) before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);\n        negative += prefix;\n        value = before + after;\n        return (align === \"<\" ? negative + value + padding : align === \">\" ? padding + negative + value : align === \"^\" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;\n      };\n    };\n  }\n  var d3_format_re = /(?:([^{])?([<>=^]))?([+\\- ])?([$#])?(0)?(\\d+)?(,)?(\\.-?\\d+)?([a-z%])?/i;\n  var d3_format_types = d3.map({\n    b: function(x) {\n      return x.toString(2);\n    },\n    c: function(x) {\n      return String.fromCharCode(x);\n    },\n    o: function(x) {\n      return x.toString(8);\n    },\n    x: function(x) {\n      return x.toString(16);\n    },\n    X: function(x) {\n      return x.toString(16).toUpperCase();\n    },\n    g: function(x, p) {\n      return x.toPrecision(p);\n    },\n    e: function(x, p) {\n      return x.toExponential(p);\n    },\n    f: function(x, p) {\n      return x.toFixed(p);\n    },\n    r: function(x, p) {\n      return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));\n    }\n  });\n  function d3_format_typeDefault(x) {\n    return x + \"\";\n  }\n  var d3_time = d3.time = {}, d3_date = Date;\n  function d3_date_utc() {\n    this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);\n  }\n  d3_date_utc.prototype = {\n    getDate: function() {\n      return this._.getUTCDate();\n    },\n    getDay: function() {\n      return this._.getUTCDay();\n    },\n    getFullYear: function() {\n      return this._.getUTCFullYear();\n    },\n    getHours: function() {\n      return this._.getUTCHours();\n    },\n    getMilliseconds: function() {\n      return this._.getUTCMilliseconds();\n    },\n    getMinutes: function() {\n      return this._.getUTCMinutes();\n    },\n    getMonth: function() {\n      return this._.getUTCMonth();\n    },\n    getSeconds: function() {\n      return this._.getUTCSeconds();\n    },\n    getTime: function() {\n      return this._.getTime();\n    },\n    getTimezoneOffset: function() {\n      return 0;\n    },\n    valueOf: function() {\n      return this._.valueOf();\n    },\n    setDate: function() {\n      d3_time_prototype.setUTCDate.apply(this._, arguments);\n    },\n    setDay: function() {\n      d3_time_prototype.setUTCDay.apply(this._, arguments);\n    },\n    setFullYear: function() {\n      d3_time_prototype.setUTCFullYear.apply(this._, arguments);\n    },\n    setHours: function() {\n      d3_time_prototype.setUTCHours.apply(this._, arguments);\n    },\n    setMilliseconds: function() {\n      d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);\n    },\n    setMinutes: function() {\n      d3_time_prototype.setUTCMinutes.apply(this._, arguments);\n    },\n    setMonth: function() {\n      d3_time_prototype.setUTCMonth.apply(this._, arguments);\n    },\n    setSeconds: function() {\n      d3_time_prototype.setUTCSeconds.apply(this._, arguments);\n    },\n    setTime: function() {\n      d3_time_prototype.setTime.apply(this._, arguments);\n    }\n  };\n  var d3_time_prototype = Date.prototype;\n  function d3_time_interval(local, step, number) {\n    function round(date) {\n      var d0 = local(date), d1 = offset(d0, 1);\n      return date - d0 < d1 - date ? d0 : d1;\n    }\n    function ceil(date) {\n      step(date = local(new d3_date(date - 1)), 1);\n      return date;\n    }\n    function offset(date, k) {\n      step(date = new d3_date(+date), k);\n      return date;\n    }\n    function range(t0, t1, dt) {\n      var time = ceil(t0), times = [];\n      if (dt > 1) {\n        while (time < t1) {\n          if (!(number(time) % dt)) times.push(new Date(+time));\n          step(time, 1);\n        }\n      } else {\n        while (time < t1) times.push(new Date(+time)), step(time, 1);\n      }\n      return times;\n    }\n    function range_utc(t0, t1, dt) {\n      try {\n        d3_date = d3_date_utc;\n        var utc = new d3_date_utc();\n        utc._ = t0;\n        return range(utc, t1, dt);\n      } finally {\n        d3_date = Date;\n      }\n    }\n    local.floor = local;\n    local.round = round;\n    local.ceil = ceil;\n    local.offset = offset;\n    local.range = range;\n    var utc = local.utc = d3_time_interval_utc(local);\n    utc.floor = utc;\n    utc.round = d3_time_interval_utc(round);\n    utc.ceil = d3_time_interval_utc(ceil);\n    utc.offset = d3_time_interval_utc(offset);\n    utc.range = range_utc;\n    return local;\n  }\n  function d3_time_interval_utc(method) {\n    return function(date, k) {\n      try {\n        d3_date = d3_date_utc;\n        var utc = new d3_date_utc();\n        utc._ = date;\n        return method(utc, k)._;\n      } finally {\n        d3_date = Date;\n      }\n    };\n  }\n  d3_time.year = d3_time_interval(function(date) {\n    date = d3_time.day(date);\n    date.setMonth(0, 1);\n    return date;\n  }, function(date, offset) {\n    date.setFullYear(date.getFullYear() + offset);\n  }, function(date) {\n    return date.getFullYear();\n  });\n  d3_time.years = d3_time.year.range;\n  d3_time.years.utc = d3_time.year.utc.range;\n  d3_time.day = d3_time_interval(function(date) {\n    var day = new d3_date(2e3, 0);\n    day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());\n    return day;\n  }, function(date, offset) {\n    date.setDate(date.getDate() + offset);\n  }, function(date) {\n    return date.getDate() - 1;\n  });\n  d3_time.days = d3_time.day.range;\n  d3_time.days.utc = d3_time.day.utc.range;\n  d3_time.dayOfYear = function(date) {\n    var year = d3_time.year(date);\n    return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);\n  };\n  [ \"sunday\", \"monday\", \"tuesday\", \"wednesday\", \"thursday\", \"friday\", \"saturday\" ].forEach(function(day, i) {\n    i = 7 - i;\n    var interval = d3_time[day] = d3_time_interval(function(date) {\n      (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);\n      return date;\n    }, function(date, offset) {\n      date.setDate(date.getDate() + Math.floor(offset) * 7);\n    }, function(date) {\n      var day = d3_time.year(date).getDay();\n      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);\n    });\n    d3_time[day + \"s\"] = interval.range;\n    d3_time[day + \"s\"].utc = interval.utc.range;\n    d3_time[day + \"OfYear\"] = function(date) {\n      var day = d3_time.year(date).getDay();\n      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);\n    };\n  });\n  d3_time.week = d3_time.sunday;\n  d3_time.weeks = d3_time.sunday.range;\n  d3_time.weeks.utc = d3_time.sunday.utc.range;\n  d3_time.weekOfYear = d3_time.sundayOfYear;\n  function d3_locale_timeFormat(locale) {\n    var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;\n    function d3_time_format(template) {\n      var n = template.length;\n      function format(date) {\n        var string = [], i = -1, j = 0, c, p, f;\n        while (++i < n) {\n          if (template.charCodeAt(i) === 37) {\n            string.push(template.slice(j, i));\n            if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);\n            if (f = d3_time_formats[c]) c = f(date, p == null ? c === \"e\" ? \" \" : \"0\" : p);\n            string.push(c);\n            j = i + 1;\n          }\n        }\n        string.push(template.slice(j, i));\n        return string.join(\"\");\n      }\n      format.parse = function(string) {\n        var d = {\n          y: 1900,\n          m: 0,\n          d: 1,\n          H: 0,\n          M: 0,\n          S: 0,\n          L: 0,\n          Z: null\n        }, i = d3_time_parse(d, template, string, 0);\n        if (i != string.length) return null;\n        if (\"p\" in d) d.H = d.H % 12 + d.p * 12;\n        var localZ = d.Z != null && d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)();\n        if (\"j\" in d) date.setFullYear(d.y, 0, d.j); else if (\"W\" in d || \"U\" in d) {\n          if (!(\"w\" in d)) d.w = \"W\" in d ? 1 : 0;\n          date.setFullYear(d.y, 0, 1);\n          date.setFullYear(d.y, 0, \"W\" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);\n        } else date.setFullYear(d.y, d.m, d.d);\n        date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);\n        return localZ ? date._ : date;\n      };\n      format.toString = function() {\n        return template;\n      };\n      return format;\n    }\n    function d3_time_parse(date, template, string, j) {\n      var c, p, t, i = 0, n = template.length, m = string.length;\n      while (i < n) {\n        if (j >= m) return -1;\n        c = template.charCodeAt(i++);\n        if (c === 37) {\n          t = template.charAt(i++);\n          p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];\n          if (!p || (j = p(date, string, j)) < 0) return -1;\n        } else if (c != string.charCodeAt(j++)) {\n          return -1;\n        }\n      }\n      return j;\n    }\n    d3_time_format.utc = function(template) {\n      var local = d3_time_format(template);\n      function format(date) {\n        try {\n          d3_date = d3_date_utc;\n          var utc = new d3_date();\n          utc._ = date;\n          return local(utc);\n        } finally {\n          d3_date = Date;\n        }\n      }\n      format.parse = function(string) {\n        try {\n          d3_date = d3_date_utc;\n          var date = local.parse(string);\n          return date && date._;\n        } finally {\n          d3_date = Date;\n        }\n      };\n      format.toString = local.toString;\n      return format;\n    };\n    d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;\n    var d3_time_periodLookup = d3.map(), d3_time_dayRe = d3_time_formatRe(locale_days), d3_time_dayLookup = d3_time_formatLookup(locale_days), d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays), d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays), d3_time_monthRe = d3_time_formatRe(locale_months), d3_time_monthLookup = d3_time_formatLookup(locale_months), d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths), d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);\n    locale_periods.forEach(function(p, i) {\n      d3_time_periodLookup.set(p.toLowerCase(), i);\n    });\n    var d3_time_formats = {\n      a: function(d) {\n        return locale_shortDays[d.getDay()];\n      },\n      A: function(d) {\n        return locale_days[d.getDay()];\n      },\n      b: function(d) {\n        return locale_shortMonths[d.getMonth()];\n      },\n      B: function(d) {\n        return locale_months[d.getMonth()];\n      },\n      c: d3_time_format(locale_dateTime),\n      d: function(d, p) {\n        return d3_time_formatPad(d.getDate(), p, 2);\n      },\n      e: function(d, p) {\n        return d3_time_formatPad(d.getDate(), p, 2);\n      },\n      H: function(d, p) {\n        return d3_time_formatPad(d.getHours(), p, 2);\n      },\n      I: function(d, p) {\n        return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);\n      },\n      j: function(d, p) {\n        return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);\n      },\n      L: function(d, p) {\n        return d3_time_formatPad(d.getMilliseconds(), p, 3);\n      },\n      m: function(d, p) {\n        return d3_time_formatPad(d.getMonth() + 1, p, 2);\n      },\n      M: function(d, p) {\n        return d3_time_formatPad(d.getMinutes(), p, 2);\n      },\n      p: function(d) {\n        return locale_periods[+(d.getHours() >= 12)];\n      },\n      S: function(d, p) {\n        return d3_time_formatPad(d.getSeconds(), p, 2);\n      },\n      U: function(d, p) {\n        return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);\n      },\n      w: function(d) {\n        return d.getDay();\n      },\n      W: function(d, p) {\n        return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);\n      },\n      x: d3_time_format(locale_date),\n      X: d3_time_format(locale_time),\n      y: function(d, p) {\n        return d3_time_formatPad(d.getFullYear() % 100, p, 2);\n      },\n      Y: function(d, p) {\n        return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);\n      },\n      Z: d3_time_zone,\n      \"%\": function() {\n        return \"%\";\n      }\n    };\n    var d3_time_parsers = {\n      a: d3_time_parseWeekdayAbbrev,\n      A: d3_time_parseWeekday,\n      b: d3_time_parseMonthAbbrev,\n      B: d3_time_parseMonth,\n      c: d3_time_parseLocaleFull,\n      d: d3_time_parseDay,\n      e: d3_time_parseDay,\n      H: d3_time_parseHour24,\n      I: d3_time_parseHour24,\n      j: d3_time_parseDayOfYear,\n      L: d3_time_parseMilliseconds,\n      m: d3_time_parseMonthNumber,\n      M: d3_time_parseMinutes,\n      p: d3_time_parseAmPm,\n      S: d3_time_parseSeconds,\n      U: d3_time_parseWeekNumberSunday,\n      w: d3_time_parseWeekdayNumber,\n      W: d3_time_parseWeekNumberMonday,\n      x: d3_time_parseLocaleDate,\n      X: d3_time_parseLocaleTime,\n      y: d3_time_parseYear,\n      Y: d3_time_parseFullYear,\n      Z: d3_time_parseZone,\n      \"%\": d3_time_parseLiteralPercent\n    };\n    function d3_time_parseWeekdayAbbrev(date, string, i) {\n      d3_time_dayAbbrevRe.lastIndex = 0;\n      var n = d3_time_dayAbbrevRe.exec(string.slice(i));\n      return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n    function d3_time_parseWeekday(date, string, i) {\n      d3_time_dayRe.lastIndex = 0;\n      var n = d3_time_dayRe.exec(string.slice(i));\n      return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n    function d3_time_parseMonthAbbrev(date, string, i) {\n      d3_time_monthAbbrevRe.lastIndex = 0;\n      var n = d3_time_monthAbbrevRe.exec(string.slice(i));\n      return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n    function d3_time_parseMonth(date, string, i) {\n      d3_time_monthRe.lastIndex = 0;\n      var n = d3_time_monthRe.exec(string.slice(i));\n      return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n    function d3_time_parseLocaleFull(date, string, i) {\n      return d3_time_parse(date, d3_time_formats.c.toString(), string, i);\n    }\n    function d3_time_parseLocaleDate(date, string, i) {\n      return d3_time_parse(date, d3_time_formats.x.toString(), string, i);\n    }\n    function d3_time_parseLocaleTime(date, string, i) {\n      return d3_time_parse(date, d3_time_formats.X.toString(), string, i);\n    }\n    function d3_time_parseAmPm(date, string, i) {\n      var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());\n      return n == null ? -1 : (date.p = n, i);\n    }\n    return d3_time_format;\n  }\n  var d3_time_formatPads = {\n    \"-\": \"\",\n    _: \" \",\n    \"0\": \"0\"\n  }, d3_time_numberRe = /^\\s*\\d+/, d3_time_percentRe = /^%/;\n  function d3_time_formatPad(value, fill, width) {\n    var sign = value < 0 ? \"-\" : \"\", string = (sign ? -value : value) + \"\", length = string.length;\n    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);\n  }\n  function d3_time_formatRe(names) {\n    return new RegExp(\"^(?:\" + names.map(d3.requote).join(\"|\") + \")\", \"i\");\n  }\n  function d3_time_formatLookup(names) {\n    var map = new d3_Map(), i = -1, n = names.length;\n    while (++i < n) map.set(names[i].toLowerCase(), i);\n    return map;\n  }\n  function d3_time_parseWeekdayNumber(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 1));\n    return n ? (date.w = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseWeekNumberSunday(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i));\n    return n ? (date.U = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseWeekNumberMonday(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i));\n    return n ? (date.W = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseFullYear(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 4));\n    return n ? (date.y = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseYear(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 2));\n    return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;\n  }\n  function d3_time_parseZone(date, string, i) {\n    return /^[+-]\\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, \n    i + 5) : -1;\n  }\n  function d3_time_expandYear(d) {\n    return d + (d > 68 ? 1900 : 2e3);\n  }\n  function d3_time_parseMonthNumber(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 2));\n    return n ? (date.m = n[0] - 1, i + n[0].length) : -1;\n  }\n  function d3_time_parseDay(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 2));\n    return n ? (date.d = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseDayOfYear(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 3));\n    return n ? (date.j = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseHour24(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 2));\n    return n ? (date.H = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseMinutes(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 2));\n    return n ? (date.M = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseSeconds(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 2));\n    return n ? (date.S = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseMilliseconds(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 3));\n    return n ? (date.L = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_zone(d) {\n    var z = d.getTimezoneOffset(), zs = z > 0 ? \"-\" : \"+\", zh = abs(z) / 60 | 0, zm = abs(z) % 60;\n    return zs + d3_time_formatPad(zh, \"0\", 2) + d3_time_formatPad(zm, \"0\", 2);\n  }\n  function d3_time_parseLiteralPercent(date, string, i) {\n    d3_time_percentRe.lastIndex = 0;\n    var n = d3_time_percentRe.exec(string.slice(i, i + 1));\n    return n ? i + n[0].length : -1;\n  }\n  function d3_time_formatMulti(formats) {\n    var n = formats.length, i = -1;\n    while (++i < n) formats[i][0] = this(formats[i][0]);\n    return function(date) {\n      var i = 0, f = formats[i];\n      while (!f[1](date)) f = formats[++i];\n      return f[0](date);\n    };\n  }\n  d3.locale = function(locale) {\n    return {\n      numberFormat: d3_locale_numberFormat(locale),\n      timeFormat: d3_locale_timeFormat(locale)\n    };\n  };\n  var d3_locale_enUS = d3.locale({\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [ 3 ],\n    currency: [ \"$\", \"\" ],\n    dateTime: \"%a %b %e %X %Y\",\n    date: \"%m/%d/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [ \"AM\", \"PM\" ],\n    days: [ \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\" ],\n    shortDays: [ \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\" ],\n    months: [ \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\" ],\n    shortMonths: [ \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\" ]\n  });\n  d3.format = d3_locale_enUS.numberFormat;\n  d3.geo = {};\n  function d3_adder() {}\n  d3_adder.prototype = {\n    s: 0,\n    t: 0,\n    add: function(y) {\n      d3_adderSum(y, this.t, d3_adderTemp);\n      d3_adderSum(d3_adderTemp.s, this.s, this);\n      if (this.s) this.t += d3_adderTemp.t; else this.s = d3_adderTemp.t;\n    },\n    reset: function() {\n      this.s = this.t = 0;\n    },\n    valueOf: function() {\n      return this.s;\n    }\n  };\n  var d3_adderTemp = new d3_adder();\n  function d3_adderSum(a, b, o) {\n    var x = o.s = a + b, bv = x - a, av = x - bv;\n    o.t = a - av + (b - bv);\n  }\n  d3.geo.stream = function(object, listener) {\n    if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {\n      d3_geo_streamObjectType[object.type](object, listener);\n    } else {\n      d3_geo_streamGeometry(object, listener);\n    }\n  };\n  function d3_geo_streamGeometry(geometry, listener) {\n    if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {\n      d3_geo_streamGeometryType[geometry.type](geometry, listener);\n    }\n  }\n  var d3_geo_streamObjectType = {\n    Feature: function(feature, listener) {\n      d3_geo_streamGeometry(feature.geometry, listener);\n    },\n    FeatureCollection: function(object, listener) {\n      var features = object.features, i = -1, n = features.length;\n      while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);\n    }\n  };\n  var d3_geo_streamGeometryType = {\n    Sphere: function(object, listener) {\n      listener.sphere();\n    },\n    Point: function(object, listener) {\n      object = object.coordinates;\n      listener.point(object[0], object[1], object[2]);\n    },\n    MultiPoint: function(object, listener) {\n      var coordinates = object.coordinates, i = -1, n = coordinates.length;\n      while (++i < n) object = coordinates[i], listener.point(object[0], object[1], object[2]);\n    },\n    LineString: function(object, listener) {\n      d3_geo_streamLine(object.coordinates, listener, 0);\n    },\n    MultiLineString: function(object, listener) {\n      var coordinates = object.coordinates, i = -1, n = coordinates.length;\n      while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);\n    },\n    Polygon: function(object, listener) {\n      d3_geo_streamPolygon(object.coordinates, listener);\n    },\n    MultiPolygon: function(object, listener) {\n      var coordinates = object.coordinates, i = -1, n = coordinates.length;\n      while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);\n    },\n    GeometryCollection: function(object, listener) {\n      var geometries = object.geometries, i = -1, n = geometries.length;\n      while (++i < n) d3_geo_streamGeometry(geometries[i], listener);\n    }\n  };\n  function d3_geo_streamLine(coordinates, listener, closed) {\n    var i = -1, n = coordinates.length - closed, coordinate;\n    listener.lineStart();\n    while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);\n    listener.lineEnd();\n  }\n  function d3_geo_streamPolygon(coordinates, listener) {\n    var i = -1, n = coordinates.length;\n    listener.polygonStart();\n    while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);\n    listener.polygonEnd();\n  }\n  d3.geo.area = function(object) {\n    d3_geo_areaSum = 0;\n    d3.geo.stream(object, d3_geo_area);\n    return d3_geo_areaSum;\n  };\n  var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder();\n  var d3_geo_area = {\n    sphere: function() {\n      d3_geo_areaSum += 4 * ;\n    },\n    point: d3_noop,\n    lineStart: d3_noop,\n    lineEnd: d3_noop,\n    polygonStart: function() {\n      d3_geo_areaRingSum.reset();\n      d3_geo_area.lineStart = d3_geo_areaRingStart;\n    },\n    polygonEnd: function() {\n      var area = 2 * d3_geo_areaRingSum;\n      d3_geo_areaSum += area < 0 ? 4 *  + area : area;\n      d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;\n    }\n  };\n  function d3_geo_areaRingStart() {\n    var 00, 00, 0, cos0, sin0;\n    d3_geo_area.point = function(, ) {\n      d3_geo_area.point = nextPoint;\n      0 = (00 = ) * d3_radians, cos0 = Math.cos( = (00 = ) * d3_radians / 2 +  / 4), \n      sin0 = Math.sin();\n    };\n    function nextPoint(, ) {\n       *= d3_radians;\n       =  * d3_radians / 2 +  / 4;\n      var d =  - 0, sd = d >= 0 ? 1 : -1, ad = sd * d, cos = Math.cos(), sin = Math.sin(), k = sin0 * sin, u = cos0 * cos + k * Math.cos(ad), v = k * sd * Math.sin(ad);\n      d3_geo_areaRingSum.add(Math.atan2(v, u));\n      0 = , cos0 = cos, sin0 = sin;\n    }\n    d3_geo_area.lineEnd = function() {\n      nextPoint(00, 00);\n    };\n  }\n  function d3_geo_cartesian(spherical) {\n    var  = spherical[0],  = spherical[1], cos = Math.cos();\n    return [ cos * Math.cos(), cos * Math.sin(), Math.sin() ];\n  }\n  function d3_geo_cartesianDot(a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n  }\n  function d3_geo_cartesianCross(a, b) {\n    return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];\n  }\n  function d3_geo_cartesianAdd(a, b) {\n    a[0] += b[0];\n    a[1] += b[1];\n    a[2] += b[2];\n  }\n  function d3_geo_cartesianScale(vector, k) {\n    return [ vector[0] * k, vector[1] * k, vector[2] * k ];\n  }\n  function d3_geo_cartesianNormalize(d) {\n    var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);\n    d[0] /= l;\n    d[1] /= l;\n    d[2] /= l;\n  }\n  function d3_geo_spherical(cartesian) {\n    return [ Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2]) ];\n  }\n  function d3_geo_sphericalEqual(a, b) {\n    return abs(a[0] - b[0]) <  && abs(a[1] - b[1]) < ;\n  }\n  d3.geo.bounds = function() {\n    var 0, 0, 1, 1, _, __, __, p0, dSum, ranges, range;\n    var bound = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: function() {\n        bound.point = ringPoint;\n        bound.lineStart = ringStart;\n        bound.lineEnd = ringEnd;\n        dSum = 0;\n        d3_geo_area.polygonStart();\n      },\n      polygonEnd: function() {\n        d3_geo_area.polygonEnd();\n        bound.point = point;\n        bound.lineStart = lineStart;\n        bound.lineEnd = lineEnd;\n        if (d3_geo_areaRingSum < 0) 0 = -(1 = 180), 0 = -(1 = 90); else if (dSum > ) 1 = 90; else if (dSum < -) 0 = -90;\n        range[0] = 0, range[1] = 1;\n      }\n    };\n    function point(, ) {\n      ranges.push(range = [ 0 = , 1 =  ]);\n      if ( < 0) 0 = ;\n      if ( > 1) 1 = ;\n    }\n    function linePoint(, ) {\n      var p = d3_geo_cartesian([  * d3_radians,  * d3_radians ]);\n      if (p0) {\n        var normal = d3_geo_cartesianCross(p0, p), equatorial = [ normal[1], -normal[0], 0 ], inflection = d3_geo_cartesianCross(equatorial, normal);\n        d3_geo_cartesianNormalize(inflection);\n        inflection = d3_geo_spherical(inflection);\n        var d =  - _, s = d > 0 ? 1 : -1, i = inflection[0] * d3_degrees * s, antimeridian = abs(d) > 180;\n        if (antimeridian ^ (s * _ < i && i < s * )) {\n          var i = inflection[1] * d3_degrees;\n          if (i > 1) 1 = i;\n        } else if (i = (i + 360) % 360 - 180, antimeridian ^ (s * _ < i && i < s * )) {\n          var i = -inflection[1] * d3_degrees;\n          if (i < 0) 0 = i;\n        } else {\n          if ( < 0) 0 = ;\n          if ( > 1) 1 = ;\n        }\n        if (antimeridian) {\n          if ( < _) {\n            if (angle(0, ) > angle(0, 1)) 1 = ;\n          } else {\n            if (angle(, 1) > angle(0, 1)) 0 = ;\n          }\n        } else {\n          if (1 >= 0) {\n            if ( < 0) 0 = ;\n            if ( > 1) 1 = ;\n          } else {\n            if ( > _) {\n              if (angle(0, ) > angle(0, 1)) 1 = ;\n            } else {\n              if (angle(, 1) > angle(0, 1)) 0 = ;\n            }\n          }\n        }\n      } else {\n        point(, );\n      }\n      p0 = p, _ = ;\n    }\n    function lineStart() {\n      bound.point = linePoint;\n    }\n    function lineEnd() {\n      range[0] = 0, range[1] = 1;\n      bound.point = point;\n      p0 = null;\n    }\n    function ringPoint(, ) {\n      if (p0) {\n        var d =  - _;\n        dSum += abs(d) > 180 ? d + (d > 0 ? 360 : -360) : d;\n      } else __ = , __ = ;\n      d3_geo_area.point(, );\n      linePoint(, );\n    }\n    function ringStart() {\n      d3_geo_area.lineStart();\n    }\n    function ringEnd() {\n      ringPoint(__, __);\n      d3_geo_area.lineEnd();\n      if (abs(dSum) > ) 0 = -(1 = 180);\n      range[0] = 0, range[1] = 1;\n      p0 = null;\n    }\n    function angle(0, 1) {\n      return (1 -= 0) < 0 ? 1 + 360 : 1;\n    }\n    function compareRanges(a, b) {\n      return a[0] - b[0];\n    }\n    function withinRange(x, range) {\n      return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;\n    }\n    return function(feature) {\n      1 = 1 = -(0 = 0 = Infinity);\n      ranges = [];\n      d3.geo.stream(feature, bound);\n      var n = ranges.length;\n      if (n) {\n        ranges.sort(compareRanges);\n        for (var i = 1, a = ranges[0], b, merged = [ a ]; i < n; ++i) {\n          b = ranges[i];\n          if (withinRange(b[0], a) || withinRange(b[1], a)) {\n            if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];\n            if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];\n          } else {\n            merged.push(a = b);\n          }\n        }\n        var best = -Infinity, d;\n        for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i) {\n          b = merged[i];\n          if ((d = angle(a[1], b[0])) > best) best = d, 0 = b[0], 1 = a[1];\n        }\n      }\n      ranges = range = null;\n      return 0 === Infinity || 0 === Infinity ? [ [ NaN, NaN ], [ NaN, NaN ] ] : [ [ 0, 0 ], [ 1, 1 ] ];\n    };\n  }();\n  d3.geo.centroid = function(object) {\n    d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;\n    d3.geo.stream(object, d3_geo_centroid);\n    var x = d3_geo_centroidX2, y = d3_geo_centroidY2, z = d3_geo_centroidZ2, m = x * x + y * y + z * z;\n    if (m < 2) {\n      x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;\n      if (d3_geo_centroidW1 < ) x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;\n      m = x * x + y * y + z * z;\n      if (m < 2) return [ NaN, NaN ];\n    }\n    return [ Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees ];\n  };\n  var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;\n  var d3_geo_centroid = {\n    sphere: d3_noop,\n    point: d3_geo_centroidPoint,\n    lineStart: d3_geo_centroidLineStart,\n    lineEnd: d3_geo_centroidLineEnd,\n    polygonStart: function() {\n      d3_geo_centroid.lineStart = d3_geo_centroidRingStart;\n    },\n    polygonEnd: function() {\n      d3_geo_centroid.lineStart = d3_geo_centroidLineStart;\n    }\n  };\n  function d3_geo_centroidPoint(, ) {\n     *= d3_radians;\n    var cos = Math.cos( *= d3_radians);\n    d3_geo_centroidPointXYZ(cos * Math.cos(), cos * Math.sin(), Math.sin());\n  }\n  function d3_geo_centroidPointXYZ(x, y, z) {\n    ++d3_geo_centroidW0;\n    d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;\n    d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;\n    d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;\n  }\n  function d3_geo_centroidLineStart() {\n    var x0, y0, z0;\n    d3_geo_centroid.point = function(, ) {\n       *= d3_radians;\n      var cos = Math.cos( *= d3_radians);\n      x0 = cos * Math.cos();\n      y0 = cos * Math.sin();\n      z0 = Math.sin();\n      d3_geo_centroid.point = nextPoint;\n      d3_geo_centroidPointXYZ(x0, y0, z0);\n    };\n    function nextPoint(, ) {\n       *= d3_radians;\n      var cos = Math.cos( *= d3_radians), x = cos * Math.cos(), y = cos * Math.sin(), z = Math.sin(), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);\n      d3_geo_centroidW1 += w;\n      d3_geo_centroidX1 += w * (x0 + (x0 = x));\n      d3_geo_centroidY1 += w * (y0 + (y0 = y));\n      d3_geo_centroidZ1 += w * (z0 + (z0 = z));\n      d3_geo_centroidPointXYZ(x0, y0, z0);\n    }\n  }\n  function d3_geo_centroidLineEnd() {\n    d3_geo_centroid.point = d3_geo_centroidPoint;\n  }\n  function d3_geo_centroidRingStart() {\n    var 00, 00, x0, y0, z0;\n    d3_geo_centroid.point = function(, ) {\n      00 = , 00 = ;\n      d3_geo_centroid.point = nextPoint;\n       *= d3_radians;\n      var cos = Math.cos( *= d3_radians);\n      x0 = cos * Math.cos();\n      y0 = cos * Math.sin();\n      z0 = Math.sin();\n      d3_geo_centroidPointXYZ(x0, y0, z0);\n    };\n    d3_geo_centroid.lineEnd = function() {\n      nextPoint(00, 00);\n      d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;\n      d3_geo_centroid.point = d3_geo_centroidPoint;\n    };\n    function nextPoint(, ) {\n       *= d3_radians;\n      var cos = Math.cos( *= d3_radians), x = cos * Math.cos(), y = cos * Math.sin(), z = Math.sin(), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = Math.sqrt(cx * cx + cy * cy + cz * cz), u = x0 * x + y0 * y + z0 * z, v = m && -d3_acos(u) / m, w = Math.atan2(m, u);\n      d3_geo_centroidX2 += v * cx;\n      d3_geo_centroidY2 += v * cy;\n      d3_geo_centroidZ2 += v * cz;\n      d3_geo_centroidW1 += w;\n      d3_geo_centroidX1 += w * (x0 + (x0 = x));\n      d3_geo_centroidY1 += w * (y0 + (y0 = y));\n      d3_geo_centroidZ1 += w * (z0 + (z0 = z));\n      d3_geo_centroidPointXYZ(x0, y0, z0);\n    }\n  }\n  function d3_geo_compose(a, b) {\n    function compose(x, y) {\n      return x = a(x, y), b(x[0], x[1]);\n    }\n    if (a.invert && b.invert) compose.invert = function(x, y) {\n      return x = b.invert(x, y), x && a.invert(x[0], x[1]);\n    };\n    return compose;\n  }\n  function d3_true() {\n    return true;\n  }\n  function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {\n    var subject = [], clip = [];\n    segments.forEach(function(segment) {\n      if ((n = segment.length - 1) <= 0) return;\n      var n, p0 = segment[0], p1 = segment[n];\n      if (d3_geo_sphericalEqual(p0, p1)) {\n        listener.lineStart();\n        for (var i = 0; i < n; ++i) listener.point((p0 = segment[i])[0], p0[1]);\n        listener.lineEnd();\n        return;\n      }\n      var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true), b = new d3_geo_clipPolygonIntersection(p0, null, a, false);\n      a.o = b;\n      subject.push(a);\n      clip.push(b);\n      a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);\n      b = new d3_geo_clipPolygonIntersection(p1, null, a, true);\n      a.o = b;\n      subject.push(a);\n      clip.push(b);\n    });\n    clip.sort(compare);\n    d3_geo_clipPolygonLinkCircular(subject);\n    d3_geo_clipPolygonLinkCircular(clip);\n    if (!subject.length) return;\n    for (var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i) {\n      clip[i].e = entry = !entry;\n    }\n    var start = subject[0], points, point;\n    while (1) {\n      var current = start, isSubject = true;\n      while (current.v) if ((current = current.n) === start) return;\n      points = current.z;\n      listener.lineStart();\n      do {\n        current.v = current.o.v = true;\n        if (current.e) {\n          if (isSubject) {\n            for (var i = 0, n = points.length; i < n; ++i) listener.point((point = points[i])[0], point[1]);\n          } else {\n            interpolate(current.x, current.n.x, 1, listener);\n          }\n          current = current.n;\n        } else {\n          if (isSubject) {\n            points = current.p.z;\n            for (var i = points.length - 1; i >= 0; --i) listener.point((point = points[i])[0], point[1]);\n          } else {\n            interpolate(current.x, current.p.x, -1, listener);\n          }\n          current = current.p;\n        }\n        current = current.o;\n        points = current.z;\n        isSubject = !isSubject;\n      } while (!current.v);\n      listener.lineEnd();\n    }\n  }\n  function d3_geo_clipPolygonLinkCircular(array) {\n    if (!(n = array.length)) return;\n    var n, i = 0, a = array[0], b;\n    while (++i < n) {\n      a.n = b = array[i];\n      b.p = a;\n      a = b;\n    }\n    a.n = b = array[0];\n    b.p = a;\n  }\n  function d3_geo_clipPolygonIntersection(point, points, other, entry) {\n    this.x = point;\n    this.z = points;\n    this.o = other;\n    this.e = entry;\n    this.v = false;\n    this.n = this.p = null;\n  }\n  function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {\n    return function(rotate, listener) {\n      var line = clipLine(listener), rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);\n      var clip = {\n        point: point,\n        lineStart: lineStart,\n        lineEnd: lineEnd,\n        polygonStart: function() {\n          clip.point = pointRing;\n          clip.lineStart = ringStart;\n          clip.lineEnd = ringEnd;\n          segments = [];\n          polygon = [];\n        },\n        polygonEnd: function() {\n          clip.point = point;\n          clip.lineStart = lineStart;\n          clip.lineEnd = lineEnd;\n          segments = d3.merge(segments);\n          var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);\n          if (segments.length) {\n            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;\n            d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);\n          } else if (clipStartInside) {\n            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;\n            listener.lineStart();\n            interpolate(null, null, 1, listener);\n            listener.lineEnd();\n          }\n          if (polygonStarted) listener.polygonEnd(), polygonStarted = false;\n          segments = polygon = null;\n        },\n        sphere: function() {\n          listener.polygonStart();\n          listener.lineStart();\n          interpolate(null, null, 1, listener);\n          listener.lineEnd();\n          listener.polygonEnd();\n        }\n      };\n      function point(, ) {\n        var point = rotate(, );\n        if (pointVisible( = point[0],  = point[1])) listener.point(, );\n      }\n      function pointLine(, ) {\n        var point = rotate(, );\n        line.point(point[0], point[1]);\n      }\n      function lineStart() {\n        clip.point = pointLine;\n        line.lineStart();\n      }\n      function lineEnd() {\n        clip.point = point;\n        line.lineEnd();\n      }\n      var segments;\n      var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygonStarted = false, polygon, ring;\n      function pointRing(, ) {\n        ring.push([ ,  ]);\n        var point = rotate(, );\n        ringListener.point(point[0], point[1]);\n      }\n      function ringStart() {\n        ringListener.lineStart();\n        ring = [];\n      }\n      function ringEnd() {\n        pointRing(ring[0][0], ring[0][1]);\n        ringListener.lineEnd();\n        var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;\n        ring.pop();\n        polygon.push(ring);\n        ring = null;\n        if (!n) return;\n        if (clean & 1) {\n          segment = ringSegments[0];\n          var n = segment.length - 1, i = -1, point;\n          if (n > 0) {\n            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;\n            listener.lineStart();\n            while (++i < n) listener.point((point = segment[i])[0], point[1]);\n            listener.lineEnd();\n          }\n          return;\n        }\n        if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));\n        segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));\n      }\n      return clip;\n    };\n  }\n  function d3_geo_clipSegmentLength1(segment) {\n    return segment.length > 1;\n  }\n  function d3_geo_clipBufferListener() {\n    var lines = [], line;\n    return {\n      lineStart: function() {\n        lines.push(line = []);\n      },\n      point: function(, ) {\n        line.push([ ,  ]);\n      },\n      lineEnd: d3_noop,\n      buffer: function() {\n        var buffer = lines;\n        lines = [];\n        line = null;\n        return buffer;\n      },\n      rejoin: function() {\n        if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));\n      }\n    };\n  }\n  function d3_geo_clipSort(a, b) {\n    return ((a = a.x)[0] < 0 ? a[1] - half -  : half - a[1]) - ((b = b.x)[0] < 0 ? b[1] - half -  : half - b[1]);\n  }\n  var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [ -, - / 2 ]);\n  function d3_geo_clipAntimeridianLine(listener) {\n    var 0 = NaN, 0 = NaN, s0 = NaN, clean;\n    return {\n      lineStart: function() {\n        listener.lineStart();\n        clean = 1;\n      },\n      point: function(1, 1) {\n        var s1 = 1 > 0 ?  : -, d = abs(1 - 0);\n        if (abs(d - ) < ) {\n          listener.point(0, 0 = (0 + 1) / 2 > 0 ? half : -half);\n          listener.point(s0, 0);\n          listener.lineEnd();\n          listener.lineStart();\n          listener.point(s1, 0);\n          listener.point(1, 0);\n          clean = 0;\n        } else if (s0 !== s1 && d >= ) {\n          if (abs(0 - s0) < ) 0 -= s0 * ;\n          if (abs(1 - s1) < ) 1 -= s1 * ;\n          0 = d3_geo_clipAntimeridianIntersect(0, 0, 1, 1);\n          listener.point(s0, 0);\n          listener.lineEnd();\n          listener.lineStart();\n          listener.point(s1, 0);\n          clean = 0;\n        }\n        listener.point(0 = 1, 0 = 1);\n        s0 = s1;\n      },\n      lineEnd: function() {\n        listener.lineEnd();\n        0 = 0 = NaN;\n      },\n      clean: function() {\n        return 2 - clean;\n      }\n    };\n  }\n  function d3_geo_clipAntimeridianIntersect(0, 0, 1, 1) {\n    var cos0, cos1, sin0_1 = Math.sin(0 - 1);\n    return abs(sin0_1) >  ? Math.atan((Math.sin(0) * (cos1 = Math.cos(1)) * Math.sin(1) - Math.sin(1) * (cos0 = Math.cos(0)) * Math.sin(0)) / (cos0 * cos1 * sin0_1)) : (0 + 1) / 2;\n  }\n  function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {\n    var ;\n    if (from == null) {\n       = direction * half;\n      listener.point(-, );\n      listener.point(0, );\n      listener.point(, );\n      listener.point(, 0);\n      listener.point(, -);\n      listener.point(0, -);\n      listener.point(-, -);\n      listener.point(-, 0);\n      listener.point(-, );\n    } else if (abs(from[0] - to[0]) > ) {\n      var s = from[0] < to[0] ?  : -;\n       = direction * s / 2;\n      listener.point(-s, );\n      listener.point(0, );\n      listener.point(s, );\n    } else {\n      listener.point(to[0], to[1]);\n    }\n  }\n  function d3_geo_pointInPolygon(point, polygon) {\n    var meridian = point[0], parallel = point[1], meridianNormal = [ Math.sin(meridian), -Math.cos(meridian), 0 ], polarAngle = 0, winding = 0;\n    d3_geo_areaRingSum.reset();\n    for (var i = 0, n = polygon.length; i < n; ++i) {\n      var ring = polygon[i], m = ring.length;\n      if (!m) continue;\n      var point0 = ring[0], 0 = point0[0], 0 = point0[1] / 2 +  / 4, sin0 = Math.sin(0), cos0 = Math.cos(0), j = 1;\n      while (true) {\n        if (j === m) j = 0;\n        point = ring[j];\n        var  = point[0],  = point[1] / 2 +  / 4, sin = Math.sin(), cos = Math.cos(), d =  - 0, sd = d >= 0 ? 1 : -1, ad = sd * d, antimeridian = ad > , k = sin0 * sin;\n        d3_geo_areaRingSum.add(Math.atan2(k * sd * Math.sin(ad), cos0 * cos + k * Math.cos(ad)));\n        polarAngle += antimeridian ? d + sd *  : d;\n        if (antimeridian ^ 0 >= meridian ^  >= meridian) {\n          var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));\n          d3_geo_cartesianNormalize(arc);\n          var intersection = d3_geo_cartesianCross(meridianNormal, arc);\n          d3_geo_cartesianNormalize(intersection);\n          var arc = (antimeridian ^ d >= 0 ? -1 : 1) * d3_asin(intersection[2]);\n          if (parallel > arc || parallel === arc && (arc[0] || arc[1])) {\n            winding += antimeridian ^ d >= 0 ? 1 : -1;\n          }\n        }\n        if (!j++) break;\n        0 = , sin0 = sin, cos0 = cos, point0 = point;\n      }\n    }\n    return (polarAngle < - || polarAngle <  && d3_geo_areaRingSum < 0) ^ winding & 1;\n  }\n  function d3_geo_clipCircle(radius) {\n    var cr = Math.cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > , interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);\n    return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [ 0, -radius ] : [ -, radius -  ]);\n    function visible(, ) {\n      return Math.cos() * Math.cos() > cr;\n    }\n    function clipLine(listener) {\n      var point0, c0, v0, v00, clean;\n      return {\n        lineStart: function() {\n          v00 = v0 = false;\n          clean = 1;\n        },\n        point: function(, ) {\n          var point1 = [ ,  ], point2, v = visible(, ), c = smallRadius ? v ? 0 : code(, ) : v ? code( + ( < 0 ?  : -), ) : 0;\n          if (!point0 && (v00 = v0 = v)) listener.lineStart();\n          if (v !== v0) {\n            point2 = intersect(point0, point1);\n            if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {\n              point1[0] += ;\n              point1[1] += ;\n              v = visible(point1[0], point1[1]);\n            }\n          }\n          if (v !== v0) {\n            clean = 0;\n            if (v) {\n              listener.lineStart();\n              point2 = intersect(point1, point0);\n              listener.point(point2[0], point2[1]);\n            } else {\n              point2 = intersect(point0, point1);\n              listener.point(point2[0], point2[1]);\n              listener.lineEnd();\n            }\n            point0 = point2;\n          } else if (notHemisphere && point0 && smallRadius ^ v) {\n            var t;\n            if (!(c & c0) && (t = intersect(point1, point0, true))) {\n              clean = 0;\n              if (smallRadius) {\n                listener.lineStart();\n                listener.point(t[0][0], t[0][1]);\n                listener.point(t[1][0], t[1][1]);\n                listener.lineEnd();\n              } else {\n                listener.point(t[1][0], t[1][1]);\n                listener.lineEnd();\n                listener.lineStart();\n                listener.point(t[0][0], t[0][1]);\n              }\n            }\n          }\n          if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {\n            listener.point(point1[0], point1[1]);\n          }\n          point0 = point1, v0 = v, c0 = c;\n        },\n        lineEnd: function() {\n          if (v0) listener.lineEnd();\n          point0 = null;\n        },\n        clean: function() {\n          return clean | (v00 && v0) << 1;\n        }\n      };\n    }\n    function intersect(a, b, two) {\n      var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b);\n      var n1 = [ 1, 0, 0 ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;\n      if (!determinant) return !two && a;\n      var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);\n      d3_geo_cartesianAdd(A, B);\n      var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);\n      if (t2 < 0) return;\n      var t = Math.sqrt(t2), q = d3_geo_cartesianScale(u, (-w - t) / uu);\n      d3_geo_cartesianAdd(q, A);\n      q = d3_geo_spherical(q);\n      if (!two) return q;\n      var 0 = a[0], 1 = b[0], 0 = a[1], 1 = b[1], z;\n      if (1 < 0) z = 0, 0 = 1, 1 = z;\n      var  = 1 - 0, polar = abs( - ) < , meridian = polar ||  < ;\n      if (!polar && 1 < 0) z = 0, 0 = 1, 1 = z;\n      if (meridian ? polar ? 0 + 1 > 0 ^ q[1] < (abs(q[0] - 0) <  ? 0 : 1) : 0 <= q[1] && q[1] <= 1 :  >  ^ (0 <= q[0] && q[0] <= 1)) {\n        var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);\n        d3_geo_cartesianAdd(q1, A);\n        return [ q, d3_geo_spherical(q1) ];\n      }\n    }\n    function code(, ) {\n      var r = smallRadius ? radius :  - radius, code = 0;\n      if ( < -r) code |= 1; else if ( > r) code |= 2;\n      if ( < -r) code |= 4; else if ( > r) code |= 8;\n      return code;\n    }\n  }\n  function d3_geom_clipLine(x0, y0, x1, y1) {\n    return function(line) {\n      var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;\n      r = x0 - ax;\n      if (!dx && r > 0) return;\n      r /= dx;\n      if (dx < 0) {\n        if (r < t0) return;\n        if (r < t1) t1 = r;\n      } else if (dx > 0) {\n        if (r > t1) return;\n        if (r > t0) t0 = r;\n      }\n      r = x1 - ax;\n      if (!dx && r < 0) return;\n      r /= dx;\n      if (dx < 0) {\n        if (r > t1) return;\n        if (r > t0) t0 = r;\n      } else if (dx > 0) {\n        if (r < t0) return;\n        if (r < t1) t1 = r;\n      }\n      r = y0 - ay;\n      if (!dy && r > 0) return;\n      r /= dy;\n      if (dy < 0) {\n        if (r < t0) return;\n        if (r < t1) t1 = r;\n      } else if (dy > 0) {\n        if (r > t1) return;\n        if (r > t0) t0 = r;\n      }\n      r = y1 - ay;\n      if (!dy && r < 0) return;\n      r /= dy;\n      if (dy < 0) {\n        if (r > t1) return;\n        if (r > t0) t0 = r;\n      } else if (dy > 0) {\n        if (r < t0) return;\n        if (r < t1) t1 = r;\n      }\n      if (t0 > 0) line.a = {\n        x: ax + t0 * dx,\n        y: ay + t0 * dy\n      };\n      if (t1 < 1) line.b = {\n        x: ax + t1 * dx,\n        y: ay + t1 * dy\n      };\n      return line;\n    };\n  }\n  var d3_geo_clipExtentMAX = 1e9;\n  d3.geo.clipExtent = function() {\n    var x0, y0, x1, y1, stream, clip, clipExtent = {\n      stream: function(output) {\n        if (stream) stream.valid = false;\n        stream = clip(output);\n        stream.valid = true;\n        return stream;\n      },\n      extent: function(_) {\n        if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];\n        clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);\n        if (stream) stream.valid = false, stream = null;\n        return clipExtent;\n      }\n    };\n    return clipExtent.extent([ [ 0, 0 ], [ 960, 500 ] ]);\n  };\n  function d3_geo_clipExtent(x0, y0, x1, y1) {\n    return function(listener) {\n      var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), segments, polygon, ring;\n      var clip = {\n        point: point,\n        lineStart: lineStart,\n        lineEnd: lineEnd,\n        polygonStart: function() {\n          listener = bufferListener;\n          segments = [];\n          polygon = [];\n          clean = true;\n        },\n        polygonEnd: function() {\n          listener = listener_;\n          segments = d3.merge(segments);\n          var clipStartInside = insidePolygon([ x0, y1 ]), inside = clean && clipStartInside, visible = segments.length;\n          if (inside || visible) {\n            listener.polygonStart();\n            if (inside) {\n              listener.lineStart();\n              interpolate(null, null, 1, listener);\n              listener.lineEnd();\n            }\n            if (visible) {\n              d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);\n            }\n            listener.polygonEnd();\n          }\n          segments = polygon = ring = null;\n        }\n      };\n      function insidePolygon(p) {\n        var wn = 0, n = polygon.length, y = p[1];\n        for (var i = 0; i < n; ++i) {\n          for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j) {\n            b = v[j];\n            if (a[1] <= y) {\n              if (b[1] > y && d3_cross2d(a, b, p) > 0) ++wn;\n            } else {\n              if (b[1] <= y && d3_cross2d(a, b, p) < 0) --wn;\n            }\n            a = b;\n          }\n        }\n        return wn !== 0;\n      }\n      function interpolate(from, to, direction, listener) {\n        var a = 0, a1 = 0;\n        if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {\n          do {\n            listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);\n          } while ((a = (a + direction + 4) % 4) !== a1);\n        } else {\n          listener.point(to[0], to[1]);\n        }\n      }\n      function pointVisible(x, y) {\n        return x0 <= x && x <= x1 && y0 <= y && y <= y1;\n      }\n      function point(x, y) {\n        if (pointVisible(x, y)) listener.point(x, y);\n      }\n      var x__, y__, v__, x_, y_, v_, first, clean;\n      function lineStart() {\n        clip.point = linePoint;\n        if (polygon) polygon.push(ring = []);\n        first = true;\n        v_ = false;\n        x_ = y_ = NaN;\n      }\n      function lineEnd() {\n        if (segments) {\n          linePoint(x__, y__);\n          if (v__ && v_) bufferListener.rejoin();\n          segments.push(bufferListener.buffer());\n        }\n        clip.point = point;\n        if (v_) listener.lineEnd();\n      }\n      function linePoint(x, y) {\n        x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));\n        y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));\n        var v = pointVisible(x, y);\n        if (polygon) ring.push([ x, y ]);\n        if (first) {\n          x__ = x, y__ = y, v__ = v;\n          first = false;\n          if (v) {\n            listener.lineStart();\n            listener.point(x, y);\n          }\n        } else {\n          if (v && v_) listener.point(x, y); else {\n            var l = {\n              a: {\n                x: x_,\n                y: y_\n              },\n              b: {\n                x: x,\n                y: y\n              }\n            };\n            if (clipLine(l)) {\n              if (!v_) {\n                listener.lineStart();\n                listener.point(l.a.x, l.a.y);\n              }\n              listener.point(l.b.x, l.b.y);\n              if (!v) listener.lineEnd();\n              clean = false;\n            } else if (v) {\n              listener.lineStart();\n              listener.point(x, y);\n              clean = false;\n            }\n          }\n        }\n        x_ = x, y_ = y, v_ = v;\n      }\n      return clip;\n    };\n    function corner(p, direction) {\n      return abs(p[0] - x0) <  ? direction > 0 ? 0 : 3 : abs(p[0] - x1) <  ? direction > 0 ? 2 : 1 : abs(p[1] - y0) <  ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;\n    }\n    function compare(a, b) {\n      return comparePoints(a.x, b.x);\n    }\n    function comparePoints(a, b) {\n      var ca = corner(a, 1), cb = corner(b, 1);\n      return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];\n    }\n  }\n  function d3_geo_conic(projectAt) {\n    var 0 = 0, 1 =  / 3, m = d3_geo_projectionMutator(projectAt), p = m(0, 1);\n    p.parallels = function(_) {\n      if (!arguments.length) return [ 0 /  * 180, 1 /  * 180 ];\n      return m(0 = _[0] *  / 180, 1 = _[1] *  / 180);\n    };\n    return p;\n  }\n  function d3_geo_conicEqualArea(0, 1) {\n    var sin0 = Math.sin(0), n = (sin0 + Math.sin(1)) / 2, C = 1 + sin0 * (2 * n - sin0), 0 = Math.sqrt(C) / n;\n    function forward(, ) {\n      var  = Math.sqrt(C - 2 * n * Math.sin()) / n;\n      return [  * Math.sin( *= n), 0 -  * Math.cos() ];\n    }\n    forward.invert = function(x, y) {\n      var 0_y = 0 - y;\n      return [ Math.atan2(x, 0_y) / n, d3_asin((C - (x * x + 0_y * 0_y) * n * n) / (2 * n)) ];\n    };\n    return forward;\n  }\n  (d3.geo.conicEqualArea = function() {\n    return d3_geo_conic(d3_geo_conicEqualArea);\n  }).raw = d3_geo_conicEqualArea;\n  d3.geo.albers = function() {\n    return d3.geo.conicEqualArea().rotate([ 96, 0 ]).center([ -.6, 38.7 ]).parallels([ 29.5, 45.5 ]).scale(1070);\n  };\n  d3.geo.albersUsa = function() {\n    var lower48 = d3.geo.albers();\n    var alaska = d3.geo.conicEqualArea().rotate([ 154, 0 ]).center([ -2, 58.5 ]).parallels([ 55, 65 ]);\n    var hawaii = d3.geo.conicEqualArea().rotate([ 157, 0 ]).center([ -3, 19.9 ]).parallels([ 8, 18 ]);\n    var point, pointStream = {\n      point: function(x, y) {\n        point = [ x, y ];\n      }\n    }, lower48Point, alaskaPoint, hawaiiPoint;\n    function albersUsa(coordinates) {\n      var x = coordinates[0], y = coordinates[1];\n      point = null;\n      (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);\n      return point;\n    }\n    albersUsa.invert = function(coordinates) {\n      var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;\n      return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);\n    };\n    albersUsa.stream = function(stream) {\n      var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream);\n      return {\n        point: function(x, y) {\n          lower48Stream.point(x, y);\n          alaskaStream.point(x, y);\n          hawaiiStream.point(x, y);\n        },\n        sphere: function() {\n          lower48Stream.sphere();\n          alaskaStream.sphere();\n          hawaiiStream.sphere();\n        },\n        lineStart: function() {\n          lower48Stream.lineStart();\n          alaskaStream.lineStart();\n          hawaiiStream.lineStart();\n        },\n        lineEnd: function() {\n          lower48Stream.lineEnd();\n          alaskaStream.lineEnd();\n          hawaiiStream.lineEnd();\n        },\n        polygonStart: function() {\n          lower48Stream.polygonStart();\n          alaskaStream.polygonStart();\n          hawaiiStream.polygonStart();\n        },\n        polygonEnd: function() {\n          lower48Stream.polygonEnd();\n          alaskaStream.polygonEnd();\n          hawaiiStream.polygonEnd();\n        }\n      };\n    };\n    albersUsa.precision = function(_) {\n      if (!arguments.length) return lower48.precision();\n      lower48.precision(_);\n      alaska.precision(_);\n      hawaii.precision(_);\n      return albersUsa;\n    };\n    albersUsa.scale = function(_) {\n      if (!arguments.length) return lower48.scale();\n      lower48.scale(_);\n      alaska.scale(_ * .35);\n      hawaii.scale(_);\n      return albersUsa.translate(lower48.translate());\n    };\n    albersUsa.translate = function(_) {\n      if (!arguments.length) return lower48.translate();\n      var k = lower48.scale(), x = +_[0], y = +_[1];\n      lower48Point = lower48.translate(_).clipExtent([ [ x - .455 * k, y - .238 * k ], [ x + .455 * k, y + .238 * k ] ]).stream(pointStream).point;\n      alaskaPoint = alaska.translate([ x - .307 * k, y + .201 * k ]).clipExtent([ [ x - .425 * k + , y + .12 * k +  ], [ x - .214 * k - , y + .234 * k -  ] ]).stream(pointStream).point;\n      hawaiiPoint = hawaii.translate([ x - .205 * k, y + .212 * k ]).clipExtent([ [ x - .214 * k + , y + .166 * k +  ], [ x - .115 * k - , y + .234 * k -  ] ]).stream(pointStream).point;\n      return albersUsa;\n    };\n    return albersUsa.scale(1070);\n  };\n  var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {\n    point: d3_noop,\n    lineStart: d3_noop,\n    lineEnd: d3_noop,\n    polygonStart: function() {\n      d3_geo_pathAreaPolygon = 0;\n      d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;\n    },\n    polygonEnd: function() {\n      d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;\n      d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);\n    }\n  };\n  function d3_geo_pathAreaRingStart() {\n    var x00, y00, x0, y0;\n    d3_geo_pathArea.point = function(x, y) {\n      d3_geo_pathArea.point = nextPoint;\n      x00 = x0 = x, y00 = y0 = y;\n    };\n    function nextPoint(x, y) {\n      d3_geo_pathAreaPolygon += y0 * x - x0 * y;\n      x0 = x, y0 = y;\n    }\n    d3_geo_pathArea.lineEnd = function() {\n      nextPoint(x00, y00);\n    };\n  }\n  var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;\n  var d3_geo_pathBounds = {\n    point: d3_geo_pathBoundsPoint,\n    lineStart: d3_noop,\n    lineEnd: d3_noop,\n    polygonStart: d3_noop,\n    polygonEnd: d3_noop\n  };\n  function d3_geo_pathBoundsPoint(x, y) {\n    if (x < d3_geo_pathBoundsX0) d3_geo_pathBoundsX0 = x;\n    if (x > d3_geo_pathBoundsX1) d3_geo_pathBoundsX1 = x;\n    if (y < d3_geo_pathBoundsY0) d3_geo_pathBoundsY0 = y;\n    if (y > d3_geo_pathBoundsY1) d3_geo_pathBoundsY1 = y;\n  }\n  function d3_geo_pathBuffer() {\n    var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = [];\n    var stream = {\n      point: point,\n      lineStart: function() {\n        stream.point = pointLineStart;\n      },\n      lineEnd: lineEnd,\n      polygonStart: function() {\n        stream.lineEnd = lineEndPolygon;\n      },\n      polygonEnd: function() {\n        stream.lineEnd = lineEnd;\n        stream.point = point;\n      },\n      pointRadius: function(_) {\n        pointCircle = d3_geo_pathBufferCircle(_);\n        return stream;\n      },\n      result: function() {\n        if (buffer.length) {\n          var result = buffer.join(\"\");\n          buffer = [];\n          return result;\n        }\n      }\n    };\n    function point(x, y) {\n      buffer.push(\"M\", x, \",\", y, pointCircle);\n    }\n    function pointLineStart(x, y) {\n      buffer.push(\"M\", x, \",\", y);\n      stream.point = pointLine;\n    }\n    function pointLine(x, y) {\n      buffer.push(\"L\", x, \",\", y);\n    }\n    function lineEnd() {\n      stream.point = point;\n    }\n    function lineEndPolygon() {\n      buffer.push(\"Z\");\n    }\n    return stream;\n  }\n  function d3_geo_pathBufferCircle(radius) {\n    return \"m0,\" + radius + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + -2 * radius + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + 2 * radius + \"z\";\n  }\n  var d3_geo_pathCentroid = {\n    point: d3_geo_pathCentroidPoint,\n    lineStart: d3_geo_pathCentroidLineStart,\n    lineEnd: d3_geo_pathCentroidLineEnd,\n    polygonStart: function() {\n      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;\n    },\n    polygonEnd: function() {\n      d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;\n      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;\n      d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;\n    }\n  };\n  function d3_geo_pathCentroidPoint(x, y) {\n    d3_geo_centroidX0 += x;\n    d3_geo_centroidY0 += y;\n    ++d3_geo_centroidZ0;\n  }\n  function d3_geo_pathCentroidLineStart() {\n    var x0, y0;\n    d3_geo_pathCentroid.point = function(x, y) {\n      d3_geo_pathCentroid.point = nextPoint;\n      d3_geo_pathCentroidPoint(x0 = x, y0 = y);\n    };\n    function nextPoint(x, y) {\n      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);\n      d3_geo_centroidX1 += z * (x0 + x) / 2;\n      d3_geo_centroidY1 += z * (y0 + y) / 2;\n      d3_geo_centroidZ1 += z;\n      d3_geo_pathCentroidPoint(x0 = x, y0 = y);\n    }\n  }\n  function d3_geo_pathCentroidLineEnd() {\n    d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;\n  }\n  function d3_geo_pathCentroidRingStart() {\n    var x00, y00, x0, y0;\n    d3_geo_pathCentroid.point = function(x, y) {\n      d3_geo_pathCentroid.point = nextPoint;\n      d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);\n    };\n    function nextPoint(x, y) {\n      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);\n      d3_geo_centroidX1 += z * (x0 + x) / 2;\n      d3_geo_centroidY1 += z * (y0 + y) / 2;\n      d3_geo_centroidZ1 += z;\n      z = y0 * x - x0 * y;\n      d3_geo_centroidX2 += z * (x0 + x);\n      d3_geo_centroidY2 += z * (y0 + y);\n      d3_geo_centroidZ2 += z * 3;\n      d3_geo_pathCentroidPoint(x0 = x, y0 = y);\n    }\n    d3_geo_pathCentroid.lineEnd = function() {\n      nextPoint(x00, y00);\n    };\n  }\n  function d3_geo_pathContext(context) {\n    var pointRadius = 4.5;\n    var stream = {\n      point: point,\n      lineStart: function() {\n        stream.point = pointLineStart;\n      },\n      lineEnd: lineEnd,\n      polygonStart: function() {\n        stream.lineEnd = lineEndPolygon;\n      },\n      polygonEnd: function() {\n        stream.lineEnd = lineEnd;\n        stream.point = point;\n      },\n      pointRadius: function(_) {\n        pointRadius = _;\n        return stream;\n      },\n      result: d3_noop\n    };\n    function point(x, y) {\n      context.moveTo(x + pointRadius, y);\n      context.arc(x, y, pointRadius, 0, );\n    }\n    function pointLineStart(x, y) {\n      context.moveTo(x, y);\n      stream.point = pointLine;\n    }\n    function pointLine(x, y) {\n      context.lineTo(x, y);\n    }\n    function lineEnd() {\n      stream.point = point;\n    }\n    function lineEndPolygon() {\n      context.closePath();\n    }\n    return stream;\n  }\n  function d3_geo_resample(project) {\n    var 2 = .5, cosMinDistance = Math.cos(30 * d3_radians), maxDepth = 16;\n    function resample(stream) {\n      return (maxDepth ? resampleRecursive : resampleNone)(stream);\n    }\n    function resampleNone(stream) {\n      return d3_geo_transformPoint(stream, function(x, y) {\n        x = project(x, y);\n        stream.point(x[0], x[1]);\n      });\n    }\n    function resampleRecursive(stream) {\n      var 00, 00, x00, y00, a00, b00, c00, 0, x0, y0, a0, b0, c0;\n      var resample = {\n        point: point,\n        lineStart: lineStart,\n        lineEnd: lineEnd,\n        polygonStart: function() {\n          stream.polygonStart();\n          resample.lineStart = ringStart;\n        },\n        polygonEnd: function() {\n          stream.polygonEnd();\n          resample.lineStart = lineStart;\n        }\n      };\n      function point(x, y) {\n        x = project(x, y);\n        stream.point(x[0], x[1]);\n      }\n      function lineStart() {\n        x0 = NaN;\n        resample.point = linePoint;\n        stream.lineStart();\n      }\n      function linePoint(, ) {\n        var c = d3_geo_cartesian([ ,  ]), p = project(, );\n        resampleLineTo(x0, y0, 0, a0, b0, c0, x0 = p[0], y0 = p[1], 0 = , a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);\n        stream.point(x0, y0);\n      }\n      function lineEnd() {\n        resample.point = point;\n        stream.lineEnd();\n      }\n      function ringStart() {\n        lineStart();\n        resample.point = ringPoint;\n        resample.lineEnd = ringEnd;\n      }\n      function ringPoint(, ) {\n        linePoint(00 = , 00 = ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;\n        resample.point = linePoint;\n      }\n      function ringEnd() {\n        resampleLineTo(x0, y0, 0, a0, b0, c0, x00, y00, 00, a00, b00, c00, maxDepth, stream);\n        resample.lineEnd = lineEnd;\n        lineEnd();\n      }\n      return resample;\n    }\n    function resampleLineTo(x0, y0, 0, a0, b0, c0, x1, y1, 1, a1, b1, c1, depth, stream) {\n      var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;\n      if (d2 > 4 * 2 && depth--) {\n        var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), 2 = Math.asin(c /= m), 2 = abs(abs(c) - 1) <  || abs(0 - 1) <  ? (0 + 1) / 2 : Math.atan2(b, a), p = project(2, 2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;\n        if (dz * dz / d2 > 2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {\n          resampleLineTo(x0, y0, 0, a0, b0, c0, x2, y2, 2, a /= m, b /= m, c, depth, stream);\n          stream.point(x2, y2);\n          resampleLineTo(x2, y2, 2, a, b, c, x1, y1, 1, a1, b1, c1, depth, stream);\n        }\n      }\n    }\n    resample.precision = function(_) {\n      if (!arguments.length) return Math.sqrt(2);\n      maxDepth = (2 = _ * _) > 0 && 16;\n      return resample;\n    };\n    return resample;\n  }\n  d3.geo.path = function() {\n    var pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream;\n    function path(object) {\n      if (object) {\n        if (typeof pointRadius === \"function\") contextStream.pointRadius(+pointRadius.apply(this, arguments));\n        if (!cacheStream || !cacheStream.valid) cacheStream = projectStream(contextStream);\n        d3.geo.stream(object, cacheStream);\n      }\n      return contextStream.result();\n    }\n    path.area = function(object) {\n      d3_geo_pathAreaSum = 0;\n      d3.geo.stream(object, projectStream(d3_geo_pathArea));\n      return d3_geo_pathAreaSum;\n    };\n    path.centroid = function(object) {\n      d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;\n      d3.geo.stream(object, projectStream(d3_geo_pathCentroid));\n      return d3_geo_centroidZ2 ? [ d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2 ] : d3_geo_centroidZ1 ? [ d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1 ] : d3_geo_centroidZ0 ? [ d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0 ] : [ NaN, NaN ];\n    };\n    path.bounds = function(object) {\n      d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);\n      d3.geo.stream(object, projectStream(d3_geo_pathBounds));\n      return [ [ d3_geo_pathBoundsX0, d3_geo_pathBoundsY0 ], [ d3_geo_pathBoundsX1, d3_geo_pathBoundsY1 ] ];\n    };\n    path.projection = function(_) {\n      if (!arguments.length) return projection;\n      projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;\n      return reset();\n    };\n    path.context = function(_) {\n      if (!arguments.length) return context;\n      contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);\n      if (typeof pointRadius !== \"function\") contextStream.pointRadius(pointRadius);\n      return reset();\n    };\n    path.pointRadius = function(_) {\n      if (!arguments.length) return pointRadius;\n      pointRadius = typeof _ === \"function\" ? _ : (contextStream.pointRadius(+_), +_);\n      return path;\n    };\n    function reset() {\n      cacheStream = null;\n      return path;\n    }\n    return path.projection(d3.geo.albersUsa()).context(null);\n  };\n  function d3_geo_pathProjectStream(project) {\n    var resample = d3_geo_resample(function(x, y) {\n      return project([ x * d3_degrees, y * d3_degrees ]);\n    });\n    return function(stream) {\n      return d3_geo_projectionRadians(resample(stream));\n    };\n  }\n  d3.geo.transform = function(methods) {\n    return {\n      stream: function(stream) {\n        var transform = new d3_geo_transform(stream);\n        for (var k in methods) transform[k] = methods[k];\n        return transform;\n      }\n    };\n  };\n  function d3_geo_transform(stream) {\n    this.stream = stream;\n  }\n  d3_geo_transform.prototype = {\n    point: function(x, y) {\n      this.stream.point(x, y);\n    },\n    sphere: function() {\n      this.stream.sphere();\n    },\n    lineStart: function() {\n      this.stream.lineStart();\n    },\n    lineEnd: function() {\n      this.stream.lineEnd();\n    },\n    polygonStart: function() {\n      this.stream.polygonStart();\n    },\n    polygonEnd: function() {\n      this.stream.polygonEnd();\n    }\n  };\n  function d3_geo_transformPoint(stream, point) {\n    return {\n      point: point,\n      sphere: function() {\n        stream.sphere();\n      },\n      lineStart: function() {\n        stream.lineStart();\n      },\n      lineEnd: function() {\n        stream.lineEnd();\n      },\n      polygonStart: function() {\n        stream.polygonStart();\n      },\n      polygonEnd: function() {\n        stream.polygonEnd();\n      }\n    };\n  }\n  d3.geo.projection = d3_geo_projection;\n  d3.geo.projectionMutator = d3_geo_projectionMutator;\n  function d3_geo_projection(project) {\n    return d3_geo_projectionMutator(function() {\n      return project;\n    })();\n  }\n  function d3_geo_projectionMutator(projectAt) {\n    var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) {\n      x = project(x, y);\n      return [ x[0] * k + x, y - x[1] * k ];\n    }), k = 150, x = 480, y = 250,  = 0,  = 0,  = 0,  = 0,  = 0, x, y, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream;\n    function projection(point) {\n      point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);\n      return [ point[0] * k + x, y - point[1] * k ];\n    }\n    function invert(point) {\n      point = projectRotate.invert((point[0] - x) / k, (y - point[1]) / k);\n      return point && [ point[0] * d3_degrees, point[1] * d3_degrees ];\n    }\n    projection.stream = function(output) {\n      if (stream) stream.valid = false;\n      stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));\n      stream.valid = true;\n      return stream;\n    };\n    projection.clipAngle = function(_) {\n      if (!arguments.length) return clipAngle;\n      preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);\n      return invalidate();\n    };\n    projection.clipExtent = function(_) {\n      if (!arguments.length) return clipExtent;\n      clipExtent = _;\n      postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;\n      return invalidate();\n    };\n    projection.scale = function(_) {\n      if (!arguments.length) return k;\n      k = +_;\n      return reset();\n    };\n    projection.translate = function(_) {\n      if (!arguments.length) return [ x, y ];\n      x = +_[0];\n      y = +_[1];\n      return reset();\n    };\n    projection.center = function(_) {\n      if (!arguments.length) return [  * d3_degrees,  * d3_degrees ];\n       = _[0] % 360 * d3_radians;\n       = _[1] % 360 * d3_radians;\n      return reset();\n    };\n    projection.rotate = function(_) {\n      if (!arguments.length) return [  * d3_degrees,  * d3_degrees,  * d3_degrees ];\n       = _[0] % 360 * d3_radians;\n       = _[1] % 360 * d3_radians;\n       = _.length > 2 ? _[2] % 360 * d3_radians : 0;\n      return reset();\n    };\n    d3.rebind(projection, projectResample, \"precision\");\n    function reset() {\n      projectRotate = d3_geo_compose(rotate = d3_geo_rotation(, , ), project);\n      var center = project(, );\n      x = x - center[0] * k;\n      y = y + center[1] * k;\n      return invalidate();\n    }\n    function invalidate() {\n      if (stream) stream.valid = false, stream = null;\n      return projection;\n    }\n    return function() {\n      project = projectAt.apply(this, arguments);\n      projection.invert = project.invert && invert;\n      return reset();\n    };\n  }\n  function d3_geo_projectionRadians(stream) {\n    return d3_geo_transformPoint(stream, function(x, y) {\n      stream.point(x * d3_radians, y * d3_radians);\n    });\n  }\n  function d3_geo_equirectangular(, ) {\n    return [ ,  ];\n  }\n  (d3.geo.equirectangular = function() {\n    return d3_geo_projection(d3_geo_equirectangular);\n  }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;\n  d3.geo.rotation = function(rotate) {\n    rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);\n    function forward(coordinates) {\n      coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);\n      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;\n    }\n    forward.invert = function(coordinates) {\n      coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);\n      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;\n    };\n    return forward;\n  };\n  function d3_geo_identityRotation(, ) {\n    return [  >  ?  -  :  < - ?  +  : ,  ];\n  }\n  d3_geo_identityRotation.invert = d3_geo_equirectangular;\n  function d3_geo_rotation(, , ) {\n    return  ?  ||  ? d3_geo_compose(d3_geo_rotation(), d3_geo_rotation(, )) : d3_geo_rotation() :  ||  ? d3_geo_rotation(, ) : d3_geo_identityRotation;\n  }\n  function d3_geo_forwardRotation() {\n    return function(, ) {\n      return  += , [  >  ?  -  :  < - ?  +  : ,  ];\n    };\n  }\n  function d3_geo_rotation() {\n    var rotation = d3_geo_forwardRotation();\n    rotation.invert = d3_geo_forwardRotation(-);\n    return rotation;\n  }\n  function d3_geo_rotation(, ) {\n    var cos = Math.cos(), sin = Math.sin(), cos = Math.cos(), sin = Math.sin();\n    function rotation(, ) {\n      var cos = Math.cos(), x = Math.cos() * cos, y = Math.sin() * cos, z = Math.sin(), k = z * cos + x * sin;\n      return [ Math.atan2(y * cos - k * sin, x * cos - z * sin), d3_asin(k * cos + y * sin) ];\n    }\n    rotation.invert = function(, ) {\n      var cos = Math.cos(), x = Math.cos() * cos, y = Math.sin() * cos, z = Math.sin(), k = z * cos - y * sin;\n      return [ Math.atan2(y * cos + z * sin, x * cos + k * sin), d3_asin(k * cos - x * sin) ];\n    };\n    return rotation;\n  }\n  d3.geo.circle = function() {\n    var origin = [ 0, 0 ], angle, precision = 6, interpolate;\n    function circle() {\n      var center = typeof origin === \"function\" ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];\n      interpolate(null, null, 1, {\n        point: function(x, y) {\n          ring.push(x = rotate(x, y));\n          x[0] *= d3_degrees, x[1] *= d3_degrees;\n        }\n      });\n      return {\n        type: \"Polygon\",\n        coordinates: [ ring ]\n      };\n    }\n    circle.origin = function(x) {\n      if (!arguments.length) return origin;\n      origin = x;\n      return circle;\n    };\n    circle.angle = function(x) {\n      if (!arguments.length) return angle;\n      interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);\n      return circle;\n    };\n    circle.precision = function(_) {\n      if (!arguments.length) return precision;\n      interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);\n      return circle;\n    };\n    return circle.angle(90);\n  };\n  function d3_geo_circleInterpolate(radius, precision) {\n    var cr = Math.cos(radius), sr = Math.sin(radius);\n    return function(from, to, direction, listener) {\n      var step = direction * precision;\n      if (from != null) {\n        from = d3_geo_circleAngle(cr, from);\n        to = d3_geo_circleAngle(cr, to);\n        if (direction > 0 ? from < to : from > to) from += direction * ;\n      } else {\n        from = radius + direction * ;\n        to = radius - .5 * step;\n      }\n      for (var point, t = from; direction > 0 ? t > to : t < to; t -= step) {\n        listener.point((point = d3_geo_spherical([ cr, -sr * Math.cos(t), -sr * Math.sin(t) ]))[0], point[1]);\n      }\n    };\n  }\n  function d3_geo_circleAngle(cr, point) {\n    var a = d3_geo_cartesian(point);\n    a[0] -= cr;\n    d3_geo_cartesianNormalize(a);\n    var angle = d3_acos(-a[1]);\n    return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ) % (2 * Math.PI);\n  }\n  d3.geo.distance = function(a, b) {\n    var  = (b[0] - a[0]) * d3_radians, 0 = a[1] * d3_radians, 1 = b[1] * d3_radians, sin = Math.sin(), cos = Math.cos(), sin0 = Math.sin(0), cos0 = Math.cos(0), sin1 = Math.sin(1), cos1 = Math.cos(1), t;\n    return Math.atan2(Math.sqrt((t = cos1 * sin) * t + (t = cos0 * sin1 - sin0 * cos1 * cos) * t), sin0 * sin1 + cos0 * cos1 * cos);\n  };\n  d3.geo.graticule = function() {\n    var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;\n    function graticule() {\n      return {\n        type: \"MultiLineString\",\n        coordinates: lines()\n      };\n    }\n    function lines() {\n      return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function(x) {\n        return abs(x % DX) > ;\n      }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function(y) {\n        return abs(y % DY) > ;\n      }).map(y));\n    }\n    graticule.lines = function() {\n      return lines().map(function(coordinates) {\n        return {\n          type: \"LineString\",\n          coordinates: coordinates\n        };\n      });\n    };\n    graticule.outline = function() {\n      return {\n        type: \"Polygon\",\n        coordinates: [ X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1)) ]\n      };\n    };\n    graticule.extent = function(_) {\n      if (!arguments.length) return graticule.minorExtent();\n      return graticule.majorExtent(_).minorExtent(_);\n    };\n    graticule.majorExtent = function(_) {\n      if (!arguments.length) return [ [ X0, Y0 ], [ X1, Y1 ] ];\n      X0 = +_[0][0], X1 = +_[1][0];\n      Y0 = +_[0][1], Y1 = +_[1][1];\n      if (X0 > X1) _ = X0, X0 = X1, X1 = _;\n      if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;\n      return graticule.precision(precision);\n    };\n    graticule.minorExtent = function(_) {\n      if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];\n      x0 = +_[0][0], x1 = +_[1][0];\n      y0 = +_[0][1], y1 = +_[1][1];\n      if (x0 > x1) _ = x0, x0 = x1, x1 = _;\n      if (y0 > y1) _ = y0, y0 = y1, y1 = _;\n      return graticule.precision(precision);\n    };\n    graticule.step = function(_) {\n      if (!arguments.length) return graticule.minorStep();\n      return graticule.majorStep(_).minorStep(_);\n    };\n    graticule.majorStep = function(_) {\n      if (!arguments.length) return [ DX, DY ];\n      DX = +_[0], DY = +_[1];\n      return graticule;\n    };\n    graticule.minorStep = function(_) {\n      if (!arguments.length) return [ dx, dy ];\n      dx = +_[0], dy = +_[1];\n      return graticule;\n    };\n    graticule.precision = function(_) {\n      if (!arguments.length) return precision;\n      precision = +_;\n      x = d3_geo_graticuleX(y0, y1, 90);\n      y = d3_geo_graticuleY(x0, x1, precision);\n      X = d3_geo_graticuleX(Y0, Y1, 90);\n      Y = d3_geo_graticuleY(X0, X1, precision);\n      return graticule;\n    };\n    return graticule.majorExtent([ [ -180, -90 +  ], [ 180, 90 -  ] ]).minorExtent([ [ -180, -80 -  ], [ 180, 80 +  ] ]);\n  };\n  function d3_geo_graticuleX(y0, y1, dy) {\n    var y = d3.range(y0, y1 - , dy).concat(y1);\n    return function(x) {\n      return y.map(function(y) {\n        return [ x, y ];\n      });\n    };\n  }\n  function d3_geo_graticuleY(x0, x1, dx) {\n    var x = d3.range(x0, x1 - , dx).concat(x1);\n    return function(y) {\n      return x.map(function(x) {\n        return [ x, y ];\n      });\n    };\n  }\n  function d3_source(d) {\n    return d.source;\n  }\n  function d3_target(d) {\n    return d.target;\n  }\n  d3.geo.greatArc = function() {\n    var source = d3_source, source_, target = d3_target, target_;\n    function greatArc() {\n      return {\n        type: \"LineString\",\n        coordinates: [ source_ || source.apply(this, arguments), target_ || target.apply(this, arguments) ]\n      };\n    }\n    greatArc.distance = function() {\n      return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));\n    };\n    greatArc.source = function(_) {\n      if (!arguments.length) return source;\n      source = _, source_ = typeof _ === \"function\" ? null : _;\n      return greatArc;\n    };\n    greatArc.target = function(_) {\n      if (!arguments.length) return target;\n      target = _, target_ = typeof _ === \"function\" ? null : _;\n      return greatArc;\n    };\n    greatArc.precision = function() {\n      return arguments.length ? greatArc : 0;\n    };\n    return greatArc;\n  };\n  d3.geo.interpolate = function(source, target) {\n    return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);\n  };\n  function d3_geo_interpolate(x0, y0, x1, y1) {\n    var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))), k = 1 / Math.sin(d);\n    var interpolate = d ? function(t) {\n      var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;\n      return [ Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees ];\n    } : function() {\n      return [ x0 * d3_degrees, y0 * d3_degrees ];\n    };\n    interpolate.distance = d;\n    return interpolate;\n  }\n  d3.geo.length = function(object) {\n    d3_geo_lengthSum = 0;\n    d3.geo.stream(object, d3_geo_length);\n    return d3_geo_lengthSum;\n  };\n  var d3_geo_lengthSum;\n  var d3_geo_length = {\n    sphere: d3_noop,\n    point: d3_noop,\n    lineStart: d3_geo_lengthLineStart,\n    lineEnd: d3_noop,\n    polygonStart: d3_noop,\n    polygonEnd: d3_noop\n  };\n  function d3_geo_lengthLineStart() {\n    var 0, sin0, cos0;\n    d3_geo_length.point = function(, ) {\n      0 =  * d3_radians, sin0 = Math.sin( *= d3_radians), cos0 = Math.cos();\n      d3_geo_length.point = nextPoint;\n    };\n    d3_geo_length.lineEnd = function() {\n      d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;\n    };\n    function nextPoint(, ) {\n      var sin = Math.sin( *= d3_radians), cos = Math.cos(), t = abs(( *= d3_radians) - 0), cos = Math.cos(t);\n      d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cos * Math.sin(t)) * t + (t = cos0 * sin - sin0 * cos * cos) * t), sin0 * sin + cos0 * cos * cos);\n      0 = , sin0 = sin, cos0 = cos;\n    }\n  }\n  function d3_geo_azimuthal(scale, angle) {\n    function azimuthal(, ) {\n      var cos = Math.cos(), cos = Math.cos(), k = scale(cos * cos);\n      return [ k * cos * Math.sin(), k * Math.sin() ];\n    }\n    azimuthal.invert = function(x, y) {\n      var  = Math.sqrt(x * x + y * y), c = angle(), sinc = Math.sin(c), cosc = Math.cos(c);\n      return [ Math.atan2(x * sinc,  * cosc), Math.asin( && y * sinc / ) ];\n    };\n    return azimuthal;\n  }\n  var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(coscos) {\n    return Math.sqrt(2 / (1 + coscos));\n  }, function() {\n    return 2 * Math.asin( / 2);\n  });\n  (d3.geo.azimuthalEqualArea = function() {\n    return d3_geo_projection(d3_geo_azimuthalEqualArea);\n  }).raw = d3_geo_azimuthalEqualArea;\n  var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(coscos) {\n    var c = Math.acos(coscos);\n    return c && c / Math.sin(c);\n  }, d3_identity);\n  (d3.geo.azimuthalEquidistant = function() {\n    return d3_geo_projection(d3_geo_azimuthalEquidistant);\n  }).raw = d3_geo_azimuthalEquidistant;\n  function d3_geo_conicConformal(0, 1) {\n    var cos0 = Math.cos(0), t = function() {\n      return Math.tan( / 4 +  / 2);\n    }, n = 0 === 1 ? Math.sin(0) : Math.log(cos0 / Math.cos(1)) / Math.log(t(1) / t(0)), F = cos0 * Math.pow(t(0), n) / n;\n    if (!n) return d3_geo_mercator;\n    function forward(, ) {\n      if (F > 0) {\n        if ( < -half + )  = -half + ;\n      } else {\n        if ( > half - )  = half - ;\n      }\n      var  = F / Math.pow(t(), n);\n      return [  * Math.sin(n * ), F -  * Math.cos(n * ) ];\n    }\n    forward.invert = function(x, y) {\n      var 0_y = F - y,  = d3_sgn(n) * Math.sqrt(x * x + 0_y * 0_y);\n      return [ Math.atan2(x, 0_y) / n, 2 * Math.atan(Math.pow(F / , 1 / n)) - half ];\n    };\n    return forward;\n  }\n  (d3.geo.conicConformal = function() {\n    return d3_geo_conic(d3_geo_conicConformal);\n  }).raw = d3_geo_conicConformal;\n  function d3_geo_conicEquidistant(0, 1) {\n    var cos0 = Math.cos(0), n = 0 === 1 ? Math.sin(0) : (cos0 - Math.cos(1)) / (1 - 0), G = cos0 / n + 0;\n    if (abs(n) < ) return d3_geo_equirectangular;\n    function forward(, ) {\n      var  = G - ;\n      return [  * Math.sin(n * ), G -  * Math.cos(n * ) ];\n    }\n    forward.invert = function(x, y) {\n      var 0_y = G - y;\n      return [ Math.atan2(x, 0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + 0_y * 0_y) ];\n    };\n    return forward;\n  }\n  (d3.geo.conicEquidistant = function() {\n    return d3_geo_conic(d3_geo_conicEquidistant);\n  }).raw = d3_geo_conicEquidistant;\n  var d3_geo_gnomonic = d3_geo_azimuthal(function(coscos) {\n    return 1 / coscos;\n  }, Math.atan);\n  (d3.geo.gnomonic = function() {\n    return d3_geo_projection(d3_geo_gnomonic);\n  }).raw = d3_geo_gnomonic;\n  function d3_geo_mercator(, ) {\n    return [ , Math.log(Math.tan( / 4 +  / 2)) ];\n  }\n  d3_geo_mercator.invert = function(x, y) {\n    return [ x, 2 * Math.atan(Math.exp(y)) - half ];\n  };\n  function d3_geo_mercatorProjection(project) {\n    var m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto;\n    m.scale = function() {\n      var v = scale.apply(m, arguments);\n      return v === m ? clipAuto ? m.clipExtent(null) : m : v;\n    };\n    m.translate = function() {\n      var v = translate.apply(m, arguments);\n      return v === m ? clipAuto ? m.clipExtent(null) : m : v;\n    };\n    m.clipExtent = function(_) {\n      var v = clipExtent.apply(m, arguments);\n      if (v === m) {\n        if (clipAuto = _ == null) {\n          var k =  * scale(), t = translate();\n          clipExtent([ [ t[0] - k, t[1] - k ], [ t[0] + k, t[1] + k ] ]);\n        }\n      } else if (clipAuto) {\n        v = null;\n      }\n      return v;\n    };\n    return m.clipExtent(null);\n  }\n  (d3.geo.mercator = function() {\n    return d3_geo_mercatorProjection(d3_geo_mercator);\n  }).raw = d3_geo_mercator;\n  var d3_geo_orthographic = d3_geo_azimuthal(function() {\n    return 1;\n  }, Math.asin);\n  (d3.geo.orthographic = function() {\n    return d3_geo_projection(d3_geo_orthographic);\n  }).raw = d3_geo_orthographic;\n  var d3_geo_stereographic = d3_geo_azimuthal(function(coscos) {\n    return 1 / (1 + coscos);\n  }, function() {\n    return 2 * Math.atan();\n  });\n  (d3.geo.stereographic = function() {\n    return d3_geo_projection(d3_geo_stereographic);\n  }).raw = d3_geo_stereographic;\n  function d3_geo_transverseMercator(, ) {\n    return [ Math.log(Math.tan( / 4 +  / 2)), - ];\n  }\n  d3_geo_transverseMercator.invert = function(x, y) {\n    return [ -y, 2 * Math.atan(Math.exp(x)) - half ];\n  };\n  (d3.geo.transverseMercator = function() {\n    var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator), center = projection.center, rotate = projection.rotate;\n    projection.center = function(_) {\n      return _ ? center([ -_[1], _[0] ]) : (_ = center(), [ _[1], -_[0] ]);\n    };\n    projection.rotate = function(_) {\n      return _ ? rotate([ _[0], _[1], _.length > 2 ? _[2] + 90 : 90 ]) : (_ = rotate(), \n      [ _[0], _[1], _[2] - 90 ]);\n    };\n    return rotate([ 0, 0, 90 ]);\n  }).raw = d3_geo_transverseMercator;\n  d3.geom = {};\n  function d3_geom_pointX(d) {\n    return d[0];\n  }\n  function d3_geom_pointY(d) {\n    return d[1];\n  }\n  d3.geom.hull = function(vertices) {\n    var x = d3_geom_pointX, y = d3_geom_pointY;\n    if (arguments.length) return hull(vertices);\n    function hull(data) {\n      if (data.length < 3) return [];\n      var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = [];\n      for (i = 0; i < n; i++) {\n        points.push([ +fx.call(this, data[i], i), +fy.call(this, data[i], i), i ]);\n      }\n      points.sort(d3_geom_hullOrder);\n      for (i = 0; i < n; i++) flippedPoints.push([ points[i][0], -points[i][1] ]);\n      var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints);\n      var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];\n      for (i = upper.length - 1; i >= 0; --i) polygon.push(data[points[upper[i]][2]]);\n      for (i = +skipLeft; i < lower.length - skipRight; ++i) polygon.push(data[points[lower[i]][2]]);\n      return polygon;\n    }\n    hull.x = function(_) {\n      return arguments.length ? (x = _, hull) : x;\n    };\n    hull.y = function(_) {\n      return arguments.length ? (y = _, hull) : y;\n    };\n    return hull;\n  };\n  function d3_geom_hullUpper(points) {\n    var n = points.length, hull = [ 0, 1 ], hs = 2;\n    for (var i = 2; i < n; i++) {\n      while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0) --hs;\n      hull[hs++] = i;\n    }\n    return hull.slice(0, hs);\n  }\n  function d3_geom_hullOrder(a, b) {\n    return a[0] - b[0] || a[1] - b[1];\n  }\n  d3.geom.polygon = function(coordinates) {\n    d3_subclass(coordinates, d3_geom_polygonPrototype);\n    return coordinates;\n  };\n  var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];\n  d3_geom_polygonPrototype.area = function() {\n    var i = -1, n = this.length, a, b = this[n - 1], area = 0;\n    while (++i < n) {\n      a = b;\n      b = this[i];\n      area += a[1] * b[0] - a[0] * b[1];\n    }\n    return area * .5;\n  };\n  d3_geom_polygonPrototype.centroid = function(k) {\n    var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;\n    if (!arguments.length) k = -1 / (6 * this.area());\n    while (++i < n) {\n      a = b;\n      b = this[i];\n      c = a[0] * b[1] - b[0] * a[1];\n      x += (a[0] + b[0]) * c;\n      y += (a[1] + b[1]) * c;\n    }\n    return [ x * k, y * k ];\n  };\n  d3_geom_polygonPrototype.clip = function(subject) {\n    var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;\n    while (++i < n) {\n      input = subject.slice();\n      subject.length = 0;\n      b = this[i];\n      c = input[(m = input.length - closed) - 1];\n      j = -1;\n      while (++j < m) {\n        d = input[j];\n        if (d3_geom_polygonInside(d, a, b)) {\n          if (!d3_geom_polygonInside(c, a, b)) {\n            subject.push(d3_geom_polygonIntersect(c, d, a, b));\n          }\n          subject.push(d);\n        } else if (d3_geom_polygonInside(c, a, b)) {\n          subject.push(d3_geom_polygonIntersect(c, d, a, b));\n        }\n        c = d;\n      }\n      if (closed) subject.push(subject[0]);\n      a = b;\n    }\n    return subject;\n  };\n  function d3_geom_polygonInside(p, a, b) {\n    return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);\n  }\n  function d3_geom_polygonIntersect(c, d, a, b) {\n    var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);\n    return [ x1 + ua * x21, y1 + ua * y21 ];\n  }\n  function d3_geom_polygonClosed(coordinates) {\n    var a = coordinates[0], b = coordinates[coordinates.length - 1];\n    return !(a[0] - b[0] || a[1] - b[1]);\n  }\n  var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];\n  function d3_geom_voronoiBeach() {\n    d3_geom_voronoiRedBlackNode(this);\n    this.edge = this.site = this.circle = null;\n  }\n  function d3_geom_voronoiCreateBeach(site) {\n    var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();\n    beach.site = site;\n    return beach;\n  }\n  function d3_geom_voronoiDetachBeach(beach) {\n    d3_geom_voronoiDetachCircle(beach);\n    d3_geom_voronoiBeaches.remove(beach);\n    d3_geom_voronoiBeachPool.push(beach);\n    d3_geom_voronoiRedBlackNode(beach);\n  }\n  function d3_geom_voronoiRemoveBeach(beach) {\n    var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {\n      x: x,\n      y: y\n    }, previous = beach.P, next = beach.N, disappearing = [ beach ];\n    d3_geom_voronoiDetachBeach(beach);\n    var lArc = previous;\n    while (lArc.circle && abs(x - lArc.circle.x) <  && abs(y - lArc.circle.cy) < ) {\n      previous = lArc.P;\n      disappearing.unshift(lArc);\n      d3_geom_voronoiDetachBeach(lArc);\n      lArc = previous;\n    }\n    disappearing.unshift(lArc);\n    d3_geom_voronoiDetachCircle(lArc);\n    var rArc = next;\n    while (rArc.circle && abs(x - rArc.circle.x) <  && abs(y - rArc.circle.cy) < ) {\n      next = rArc.N;\n      disappearing.push(rArc);\n      d3_geom_voronoiDetachBeach(rArc);\n      rArc = next;\n    }\n    disappearing.push(rArc);\n    d3_geom_voronoiDetachCircle(rArc);\n    var nArcs = disappearing.length, iArc;\n    for (iArc = 1; iArc < nArcs; ++iArc) {\n      rArc = disappearing[iArc];\n      lArc = disappearing[iArc - 1];\n      d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);\n    }\n    lArc = disappearing[0];\n    rArc = disappearing[nArcs - 1];\n    rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);\n    d3_geom_voronoiAttachCircle(lArc);\n    d3_geom_voronoiAttachCircle(rArc);\n  }\n  function d3_geom_voronoiAddBeach(site) {\n    var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;\n    while (node) {\n      dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;\n      if (dxl > ) node = node.L; else {\n        dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);\n        if (dxr > ) {\n          if (!node.R) {\n            lArc = node;\n            break;\n          }\n          node = node.R;\n        } else {\n          if (dxl > -) {\n            lArc = node.P;\n            rArc = node;\n          } else if (dxr > -) {\n            lArc = node;\n            rArc = node.N;\n          } else {\n            lArc = rArc = node;\n          }\n          break;\n        }\n      }\n    }\n    var newArc = d3_geom_voronoiCreateBeach(site);\n    d3_geom_voronoiBeaches.insert(lArc, newArc);\n    if (!lArc && !rArc) return;\n    if (lArc === rArc) {\n      d3_geom_voronoiDetachCircle(lArc);\n      rArc = d3_geom_voronoiCreateBeach(lArc.site);\n      d3_geom_voronoiBeaches.insert(newArc, rArc);\n      newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);\n      d3_geom_voronoiAttachCircle(lArc);\n      d3_geom_voronoiAttachCircle(rArc);\n      return;\n    }\n    if (!rArc) {\n      newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);\n      return;\n    }\n    d3_geom_voronoiDetachCircle(lArc);\n    d3_geom_voronoiDetachCircle(rArc);\n    var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {\n      x: (cy * hb - by * hc) / d + ax,\n      y: (bx * hc - cx * hb) / d + ay\n    };\n    d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);\n    newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);\n    rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);\n    d3_geom_voronoiAttachCircle(lArc);\n    d3_geom_voronoiAttachCircle(rArc);\n  }\n  function d3_geom_voronoiLeftBreakPoint(arc, directrix) {\n    var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;\n    if (!pby2) return rfocx;\n    var lArc = arc.P;\n    if (!lArc) return -Infinity;\n    site = lArc.site;\n    var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;\n    if (!plby2) return lfocx;\n    var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;\n    if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;\n    return (rfocx + lfocx) / 2;\n  }\n  function d3_geom_voronoiRightBreakPoint(arc, directrix) {\n    var rArc = arc.N;\n    if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix);\n    var site = arc.site;\n    return site.y === directrix ? site.x : Infinity;\n  }\n  function d3_geom_voronoiCell(site) {\n    this.site = site;\n    this.edges = [];\n  }\n  d3_geom_voronoiCell.prototype.prepare = function() {\n    var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;\n    while (iHalfEdge--) {\n      edge = halfEdges[iHalfEdge].edge;\n      if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);\n    }\n    halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);\n    return halfEdges.length;\n  };\n  function d3_geom_voronoiCloseCells(extent) {\n    var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;\n    while (iCell--) {\n      cell = cells[iCell];\n      if (!cell || !cell.prepare()) continue;\n      halfEdges = cell.edges;\n      nHalfEdges = halfEdges.length;\n      iHalfEdge = 0;\n      while (iHalfEdge < nHalfEdges) {\n        end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;\n        start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;\n        if (abs(x3 - x2) >  || abs(y3 - y2) > ) {\n          halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) <  && y1 - y3 >  ? {\n            x: x0,\n            y: abs(x2 - x0) <  ? y2 : y1\n          } : abs(y3 - y1) <  && x1 - x3 >  ? {\n            x: abs(y2 - y1) <  ? x2 : x1,\n            y: y1\n          } : abs(x3 - x1) <  && y3 - y0 >  ? {\n            x: x1,\n            y: abs(x2 - x1) <  ? y2 : y0\n          } : abs(y3 - y0) <  && x3 - x0 >  ? {\n            x: abs(y2 - y0) <  ? x2 : x0,\n            y: y0\n          } : null), cell.site, null));\n          ++nHalfEdges;\n        }\n      }\n    }\n  }\n  function d3_geom_voronoiHalfEdgeOrder(a, b) {\n    return b.angle - a.angle;\n  }\n  function d3_geom_voronoiCircle() {\n    d3_geom_voronoiRedBlackNode(this);\n    this.x = this.y = this.arc = this.site = this.cy = null;\n  }\n  function d3_geom_voronoiAttachCircle(arc) {\n    var lArc = arc.P, rArc = arc.N;\n    if (!lArc || !rArc) return;\n    var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;\n    if (lSite === rSite) return;\n    var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;\n    var d = 2 * (ax * cy - ay * cx);\n    if (d >= -2) return;\n    var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by;\n    var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();\n    circle.arc = arc;\n    circle.site = cSite;\n    circle.x = x + bx;\n    circle.y = cy + Math.sqrt(x * x + y * y);\n    circle.cy = cy;\n    arc.circle = circle;\n    var before = null, node = d3_geom_voronoiCircles._;\n    while (node) {\n      if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {\n        if (node.L) node = node.L; else {\n          before = node.P;\n          break;\n        }\n      } else {\n        if (node.R) node = node.R; else {\n          before = node;\n          break;\n        }\n      }\n    }\n    d3_geom_voronoiCircles.insert(before, circle);\n    if (!before) d3_geom_voronoiFirstCircle = circle;\n  }\n  function d3_geom_voronoiDetachCircle(arc) {\n    var circle = arc.circle;\n    if (circle) {\n      if (!circle.P) d3_geom_voronoiFirstCircle = circle.N;\n      d3_geom_voronoiCircles.remove(circle);\n      d3_geom_voronoiCirclePool.push(circle);\n      d3_geom_voronoiRedBlackNode(circle);\n      arc.circle = null;\n    }\n  }\n  function d3_geom_voronoiClipEdges(extent) {\n    var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;\n    while (i--) {\n      e = edges[i];\n      if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) <  && abs(e.a.y - e.b.y) < ) {\n        e.a = e.b = null;\n        edges.splice(i, 1);\n      }\n    }\n  }\n  function d3_geom_voronoiConnectEdge(edge, extent) {\n    var vb = edge.b;\n    if (vb) return true;\n    var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;\n    if (ry === ly) {\n      if (fx < x0 || fx >= x1) return;\n      if (lx > rx) {\n        if (!va) va = {\n          x: fx,\n          y: y0\n        }; else if (va.y >= y1) return;\n        vb = {\n          x: fx,\n          y: y1\n        };\n      } else {\n        if (!va) va = {\n          x: fx,\n          y: y1\n        }; else if (va.y < y0) return;\n        vb = {\n          x: fx,\n          y: y0\n        };\n      }\n    } else {\n      fm = (lx - rx) / (ry - ly);\n      fb = fy - fm * fx;\n      if (fm < -1 || fm > 1) {\n        if (lx > rx) {\n          if (!va) va = {\n            x: (y0 - fb) / fm,\n            y: y0\n          }; else if (va.y >= y1) return;\n          vb = {\n            x: (y1 - fb) / fm,\n            y: y1\n          };\n        } else {\n          if (!va) va = {\n            x: (y1 - fb) / fm,\n            y: y1\n          }; else if (va.y < y0) return;\n          vb = {\n            x: (y0 - fb) / fm,\n            y: y0\n          };\n        }\n      } else {\n        if (ly < ry) {\n          if (!va) va = {\n            x: x0,\n            y: fm * x0 + fb\n          }; else if (va.x >= x1) return;\n          vb = {\n            x: x1,\n            y: fm * x1 + fb\n          };\n        } else {\n          if (!va) va = {\n            x: x1,\n            y: fm * x1 + fb\n          }; else if (va.x < x0) return;\n          vb = {\n            x: x0,\n            y: fm * x0 + fb\n          };\n        }\n      }\n    }\n    edge.a = va;\n    edge.b = vb;\n    return true;\n  }\n  function d3_geom_voronoiEdge(lSite, rSite) {\n    this.l = lSite;\n    this.r = rSite;\n    this.a = this.b = null;\n  }\n  function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {\n    var edge = new d3_geom_voronoiEdge(lSite, rSite);\n    d3_geom_voronoiEdges.push(edge);\n    if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);\n    if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);\n    d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));\n    d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));\n    return edge;\n  }\n  function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {\n    var edge = new d3_geom_voronoiEdge(lSite, null);\n    edge.a = va;\n    edge.b = vb;\n    d3_geom_voronoiEdges.push(edge);\n    return edge;\n  }\n  function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {\n    if (!edge.a && !edge.b) {\n      edge.a = vertex;\n      edge.l = lSite;\n      edge.r = rSite;\n    } else if (edge.l === rSite) {\n      edge.b = vertex;\n    } else {\n      edge.a = vertex;\n    }\n  }\n  function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {\n    var va = edge.a, vb = edge.b;\n    this.edge = edge;\n    this.site = lSite;\n    this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);\n  }\n  d3_geom_voronoiHalfEdge.prototype = {\n    start: function() {\n      return this.edge.l === this.site ? this.edge.a : this.edge.b;\n    },\n    end: function() {\n      return this.edge.l === this.site ? this.edge.b : this.edge.a;\n    }\n  };\n  function d3_geom_voronoiRedBlackTree() {\n    this._ = null;\n  }\n  function d3_geom_voronoiRedBlackNode(node) {\n    node.U = node.C = node.L = node.R = node.P = node.N = null;\n  }\n  d3_geom_voronoiRedBlackTree.prototype = {\n    insert: function(after, node) {\n      var parent, grandpa, uncle;\n      if (after) {\n        node.P = after;\n        node.N = after.N;\n        if (after.N) after.N.P = node;\n        after.N = node;\n        if (after.R) {\n          after = after.R;\n          while (after.L) after = after.L;\n          after.L = node;\n        } else {\n          after.R = node;\n        }\n        parent = after;\n      } else if (this._) {\n        after = d3_geom_voronoiRedBlackFirst(this._);\n        node.P = null;\n        node.N = after;\n        after.P = after.L = node;\n        parent = after;\n      } else {\n        node.P = node.N = null;\n        this._ = node;\n        parent = null;\n      }\n      node.L = node.R = null;\n      node.U = parent;\n      node.C = true;\n      after = node;\n      while (parent && parent.C) {\n        grandpa = parent.U;\n        if (parent === grandpa.L) {\n          uncle = grandpa.R;\n          if (uncle && uncle.C) {\n            parent.C = uncle.C = false;\n            grandpa.C = true;\n            after = grandpa;\n          } else {\n            if (after === parent.R) {\n              d3_geom_voronoiRedBlackRotateLeft(this, parent);\n              after = parent;\n              parent = after.U;\n            }\n            parent.C = false;\n            grandpa.C = true;\n            d3_geom_voronoiRedBlackRotateRight(this, grandpa);\n          }\n        } else {\n          uncle = grandpa.L;\n          if (uncle && uncle.C) {\n            parent.C = uncle.C = false;\n            grandpa.C = true;\n            after = grandpa;\n          } else {\n            if (after === parent.L) {\n              d3_geom_voronoiRedBlackRotateRight(this, parent);\n              after = parent;\n              parent = after.U;\n            }\n            parent.C = false;\n            grandpa.C = true;\n            d3_geom_voronoiRedBlackRotateLeft(this, grandpa);\n          }\n        }\n        parent = after.U;\n      }\n      this._.C = false;\n    },\n    remove: function(node) {\n      if (node.N) node.N.P = node.P;\n      if (node.P) node.P.N = node.N;\n      node.N = node.P = null;\n      var parent = node.U, sibling, left = node.L, right = node.R, next, red;\n      if (!left) next = right; else if (!right) next = left; else next = d3_geom_voronoiRedBlackFirst(right);\n      if (parent) {\n        if (parent.L === node) parent.L = next; else parent.R = next;\n      } else {\n        this._ = next;\n      }\n      if (left && right) {\n        red = next.C;\n        next.C = node.C;\n        next.L = left;\n        left.U = next;\n        if (next !== right) {\n          parent = next.U;\n          next.U = node.U;\n          node = next.R;\n          parent.L = node;\n          next.R = right;\n          right.U = next;\n        } else {\n          next.U = parent;\n          parent = next;\n          node = next.R;\n        }\n      } else {\n        red = node.C;\n        node = next;\n      }\n      if (node) node.U = parent;\n      if (red) return;\n      if (node && node.C) {\n        node.C = false;\n        return;\n      }\n      do {\n        if (node === this._) break;\n        if (node === parent.L) {\n          sibling = parent.R;\n          if (sibling.C) {\n            sibling.C = false;\n            parent.C = true;\n            d3_geom_voronoiRedBlackRotateLeft(this, parent);\n            sibling = parent.R;\n          }\n          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {\n            if (!sibling.R || !sibling.R.C) {\n              sibling.L.C = false;\n              sibling.C = true;\n              d3_geom_voronoiRedBlackRotateRight(this, sibling);\n              sibling = parent.R;\n            }\n            sibling.C = parent.C;\n            parent.C = sibling.R.C = false;\n            d3_geom_voronoiRedBlackRotateLeft(this, parent);\n            node = this._;\n            break;\n          }\n        } else {\n          sibling = parent.L;\n          if (sibling.C) {\n            sibling.C = false;\n            parent.C = true;\n            d3_geom_voronoiRedBlackRotateRight(this, parent);\n            sibling = parent.L;\n          }\n          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {\n            if (!sibling.L || !sibling.L.C) {\n              sibling.R.C = false;\n              sibling.C = true;\n              d3_geom_voronoiRedBlackRotateLeft(this, sibling);\n              sibling = parent.L;\n            }\n            sibling.C = parent.C;\n            parent.C = sibling.L.C = false;\n            d3_geom_voronoiRedBlackRotateRight(this, parent);\n            node = this._;\n            break;\n          }\n        }\n        sibling.C = true;\n        node = parent;\n        parent = parent.U;\n      } while (!node.C);\n      if (node) node.C = false;\n    }\n  };\n  function d3_geom_voronoiRedBlackRotateLeft(tree, node) {\n    var p = node, q = node.R, parent = p.U;\n    if (parent) {\n      if (parent.L === p) parent.L = q; else parent.R = q;\n    } else {\n      tree._ = q;\n    }\n    q.U = parent;\n    p.U = q;\n    p.R = q.L;\n    if (p.R) p.R.U = p;\n    q.L = p;\n  }\n  function d3_geom_voronoiRedBlackRotateRight(tree, node) {\n    var p = node, q = node.L, parent = p.U;\n    if (parent) {\n      if (parent.L === p) parent.L = q; else parent.R = q;\n    } else {\n      tree._ = q;\n    }\n    q.U = parent;\n    p.U = q;\n    p.L = q.R;\n    if (p.L) p.L.U = p;\n    q.R = p;\n  }\n  function d3_geom_voronoiRedBlackFirst(node) {\n    while (node.L) node = node.L;\n    return node;\n  }\n  function d3_geom_voronoi(sites, bbox) {\n    var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;\n    d3_geom_voronoiEdges = [];\n    d3_geom_voronoiCells = new Array(sites.length);\n    d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();\n    d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();\n    while (true) {\n      circle = d3_geom_voronoiFirstCircle;\n      if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {\n        if (site.x !== x0 || site.y !== y0) {\n          d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);\n          d3_geom_voronoiAddBeach(site);\n          x0 = site.x, y0 = site.y;\n        }\n        site = sites.pop();\n      } else if (circle) {\n        d3_geom_voronoiRemoveBeach(circle.arc);\n      } else {\n        break;\n      }\n    }\n    if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);\n    var diagram = {\n      cells: d3_geom_voronoiCells,\n      edges: d3_geom_voronoiEdges\n    };\n    d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;\n    return diagram;\n  }\n  function d3_geom_voronoiVertexOrder(a, b) {\n    return b.y - a.y || b.x - a.x;\n  }\n  d3.geom.voronoi = function(points) {\n    var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;\n    if (points) return voronoi(points);\n    function voronoi(data) {\n      var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];\n      d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {\n        var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function(e) {\n          var s = e.start();\n          return [ s.x, s.y ];\n        }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [ [ x0, y1 ], [ x1, y1 ], [ x1, y0 ], [ x0, y0 ] ] : [];\n        polygon.point = data[i];\n      });\n      return polygons;\n    }\n    function sites(data) {\n      return data.map(function(d, i) {\n        return {\n          x: Math.round(fx(d, i) / ) * ,\n          y: Math.round(fy(d, i) / ) * ,\n          i: i\n        };\n      });\n    }\n    voronoi.links = function(data) {\n      return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {\n        return edge.l && edge.r;\n      }).map(function(edge) {\n        return {\n          source: data[edge.l.i],\n          target: data[edge.r.i]\n        };\n      });\n    };\n    voronoi.triangles = function(data) {\n      var triangles = [];\n      d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {\n        var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;\n        while (++j < m) {\n          e0 = e1;\n          s0 = s1;\n          e1 = edges[j].edge;\n          s1 = e1.l === site ? e1.r : e1.l;\n          if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {\n            triangles.push([ data[i], data[s0.i], data[s1.i] ]);\n          }\n        }\n      });\n      return triangles;\n    };\n    voronoi.x = function(_) {\n      return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;\n    };\n    voronoi.y = function(_) {\n      return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;\n    };\n    voronoi.clipExtent = function(_) {\n      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;\n      clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;\n      return voronoi;\n    };\n    voronoi.size = function(_) {\n      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];\n      return voronoi.clipExtent(_ && [ [ 0, 0 ], _ ]);\n    };\n    return voronoi;\n  };\n  var d3_geom_voronoiClipExtent = [ [ -1e6, -1e6 ], [ 1e6, 1e6 ] ];\n  function d3_geom_voronoiTriangleArea(a, b, c) {\n    return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);\n  }\n  d3.geom.delaunay = function(vertices) {\n    return d3.geom.voronoi().triangles(vertices);\n  };\n  d3.geom.quadtree = function(points, x1, y1, x2, y2) {\n    var x = d3_geom_pointX, y = d3_geom_pointY, compat;\n    if (compat = arguments.length) {\n      x = d3_geom_quadtreeCompatX;\n      y = d3_geom_quadtreeCompatY;\n      if (compat === 3) {\n        y2 = y1;\n        x2 = x1;\n        y1 = x1 = 0;\n      }\n      return quadtree(points);\n    }\n    function quadtree(data) {\n      var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;\n      if (x1 != null) {\n        x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;\n      } else {\n        x2_ = y2_ = -(x1_ = y1_ = Infinity);\n        xs = [], ys = [];\n        n = data.length;\n        if (compat) for (i = 0; i < n; ++i) {\n          d = data[i];\n          if (d.x < x1_) x1_ = d.x;\n          if (d.y < y1_) y1_ = d.y;\n          if (d.x > x2_) x2_ = d.x;\n          if (d.y > y2_) y2_ = d.y;\n          xs.push(d.x);\n          ys.push(d.y);\n        } else for (i = 0; i < n; ++i) {\n          var x_ = +fx(d = data[i], i), y_ = +fy(d, i);\n          if (x_ < x1_) x1_ = x_;\n          if (y_ < y1_) y1_ = y_;\n          if (x_ > x2_) x2_ = x_;\n          if (y_ > y2_) y2_ = y_;\n          xs.push(x_);\n          ys.push(y_);\n        }\n      }\n      var dx = x2_ - x1_, dy = y2_ - y1_;\n      if (dx > dy) y2_ = y1_ + dx; else x2_ = x1_ + dy;\n      function insert(n, d, x, y, x1, y1, x2, y2) {\n        if (isNaN(x) || isNaN(y)) return;\n        if (n.leaf) {\n          var nx = n.x, ny = n.y;\n          if (nx != null) {\n            if (abs(nx - x) + abs(ny - y) < .01) {\n              insertChild(n, d, x, y, x1, y1, x2, y2);\n            } else {\n              var nPoint = n.point;\n              n.x = n.y = n.point = null;\n              insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);\n              insertChild(n, d, x, y, x1, y1, x2, y2);\n            }\n          } else {\n            n.x = x, n.y = y, n.point = d;\n          }\n        } else {\n          insertChild(n, d, x, y, x1, y1, x2, y2);\n        }\n      }\n      function insertChild(n, d, x, y, x1, y1, x2, y2) {\n        var xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym, i = below << 1 | right;\n        n.leaf = false;\n        n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());\n        if (right) x1 = xm; else x2 = xm;\n        if (below) y1 = ym; else y2 = ym;\n        insert(n, d, x, y, x1, y1, x2, y2);\n      }\n      var root = d3_geom_quadtreeNode();\n      root.add = function(d) {\n        insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);\n      };\n      root.visit = function(f) {\n        d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);\n      };\n      root.find = function(point) {\n        return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);\n      };\n      i = -1;\n      if (x1 == null) {\n        while (++i < n) {\n          insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);\n        }\n        --i;\n      } else data.forEach(root.add);\n      xs = ys = data = d = null;\n      return root;\n    }\n    quadtree.x = function(_) {\n      return arguments.length ? (x = _, quadtree) : x;\n    };\n    quadtree.y = function(_) {\n      return arguments.length ? (y = _, quadtree) : y;\n    };\n    quadtree.extent = function(_) {\n      if (!arguments.length) return x1 == null ? null : [ [ x1, y1 ], [ x2, y2 ] ];\n      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], \n      y2 = +_[1][1];\n      return quadtree;\n    };\n    quadtree.size = function(_) {\n      if (!arguments.length) return x1 == null ? null : [ x2 - x1, y2 - y1 ];\n      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = y1 = 0, x2 = +_[0], y2 = +_[1];\n      return quadtree;\n    };\n    return quadtree;\n  };\n  function d3_geom_quadtreeCompatX(d) {\n    return d.x;\n  }\n  function d3_geom_quadtreeCompatY(d) {\n    return d.y;\n  }\n  function d3_geom_quadtreeNode() {\n    return {\n      leaf: true,\n      nodes: [],\n      point: null,\n      x: null,\n      y: null\n    };\n  }\n  function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {\n    if (!f(node, x1, y1, x2, y2)) {\n      var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;\n      if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);\n      if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);\n      if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);\n      if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);\n    }\n  }\n  function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {\n    var minDistance2 = Infinity, closestPoint;\n    (function find(node, x1, y1, x2, y2) {\n      if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0) return;\n      if (point = node.point) {\n        var point, dx = x - node.x, dy = y - node.y, distance2 = dx * dx + dy * dy;\n        if (distance2 < minDistance2) {\n          var distance = Math.sqrt(minDistance2 = distance2);\n          x0 = x - distance, y0 = y - distance;\n          x3 = x + distance, y3 = y + distance;\n          closestPoint = point;\n        }\n      }\n      var children = node.nodes, xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym;\n      for (var i = below << 1 | right, j = i + 4; i < j; ++i) {\n        if (node = children[i & 3]) switch (i & 3) {\n         case 0:\n          find(node, x1, y1, xm, ym);\n          break;\n\n         case 1:\n          find(node, xm, y1, x2, ym);\n          break;\n\n         case 2:\n          find(node, x1, ym, xm, y2);\n          break;\n\n         case 3:\n          find(node, xm, ym, x2, y2);\n          break;\n        }\n      }\n    })(root, x0, y0, x3, y3);\n    return closestPoint;\n  }\n  d3.interpolateRgb = d3_interpolateRgb;\n  function d3_interpolateRgb(a, b) {\n    a = d3.rgb(a);\n    b = d3.rgb(b);\n    var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;\n    return function(t) {\n      return \"#\" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));\n    };\n  }\n  d3.interpolateObject = d3_interpolateObject;\n  function d3_interpolateObject(a, b) {\n    var i = {}, c = {}, k;\n    for (k in a) {\n      if (k in b) {\n        i[k] = d3_interpolate(a[k], b[k]);\n      } else {\n        c[k] = a[k];\n      }\n    }\n    for (k in b) {\n      if (!(k in a)) {\n        c[k] = b[k];\n      }\n    }\n    return function(t) {\n      for (k in i) c[k] = i[k](t);\n      return c;\n    };\n  }\n  d3.interpolateNumber = d3_interpolateNumber;\n  function d3_interpolateNumber(a, b) {\n    a = +a, b = +b;\n    return function(t) {\n      return a * (1 - t) + b * t;\n    };\n  }\n  d3.interpolateString = d3_interpolateString;\n  function d3_interpolateString(a, b) {\n    var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];\n    a = a + \"\", b = b + \"\";\n    while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {\n      if ((bs = bm.index) > bi) {\n        bs = b.slice(bi, bs);\n        if (s[i]) s[i] += bs; else s[++i] = bs;\n      }\n      if ((am = am[0]) === (bm = bm[0])) {\n        if (s[i]) s[i] += bm; else s[++i] = bm;\n      } else {\n        s[++i] = null;\n        q.push({\n          i: i,\n          x: d3_interpolateNumber(am, bm)\n        });\n      }\n      bi = d3_interpolate_numberB.lastIndex;\n    }\n    if (bi < b.length) {\n      bs = b.slice(bi);\n      if (s[i]) s[i] += bs; else s[++i] = bs;\n    }\n    return s.length < 2 ? q[0] ? (b = q[0].x, function(t) {\n      return b(t) + \"\";\n    }) : function() {\n      return b;\n    } : (b = q.length, function(t) {\n      for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);\n      return s.join(\"\");\n    });\n  }\n  var d3_interpolate_numberA = /[-+]?(?:\\d+\\.?\\d*|\\.?\\d+)(?:[eE][-+]?\\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, \"g\");\n  d3.interpolate = d3_interpolate;\n  function d3_interpolate(a, b) {\n    var i = d3.interpolators.length, f;\n    while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;\n    return f;\n  }\n  d3.interpolators = [ function(a, b) {\n    var t = typeof b;\n    return (t === \"string\" ? d3_rgb_names.has(b.toLowerCase()) || /^(#|rgb\\(|hsl\\()/i.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === \"object\" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);\n  } ];\n  d3.interpolateArray = d3_interpolateArray;\n  function d3_interpolateArray(a, b) {\n    var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;\n    for (i = 0; i < n0; ++i) x.push(d3_interpolate(a[i], b[i]));\n    for (;i < na; ++i) c[i] = a[i];\n    for (;i < nb; ++i) c[i] = b[i];\n    return function(t) {\n      for (i = 0; i < n0; ++i) c[i] = x[i](t);\n      return c;\n    };\n  }\n  var d3_ease_default = function() {\n    return d3_identity;\n  };\n  var d3_ease = d3.map({\n    linear: d3_ease_default,\n    poly: d3_ease_poly,\n    quad: function() {\n      return d3_ease_quad;\n    },\n    cubic: function() {\n      return d3_ease_cubic;\n    },\n    sin: function() {\n      return d3_ease_sin;\n    },\n    exp: function() {\n      return d3_ease_exp;\n    },\n    circle: function() {\n      return d3_ease_circle;\n    },\n    elastic: d3_ease_elastic,\n    back: d3_ease_back,\n    bounce: function() {\n      return d3_ease_bounce;\n    }\n  });\n  var d3_ease_mode = d3.map({\n    \"in\": d3_identity,\n    out: d3_ease_reverse,\n    \"in-out\": d3_ease_reflect,\n    \"out-in\": function(f) {\n      return d3_ease_reflect(d3_ease_reverse(f));\n    }\n  });\n  d3.ease = function(name) {\n    var i = name.indexOf(\"-\"), t = i >= 0 ? name.slice(0, i) : name, m = i >= 0 ? name.slice(i + 1) : \"in\";\n    t = d3_ease.get(t) || d3_ease_default;\n    m = d3_ease_mode.get(m) || d3_identity;\n    return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));\n  };\n  function d3_ease_clamp(f) {\n    return function(t) {\n      return t <= 0 ? 0 : t >= 1 ? 1 : f(t);\n    };\n  }\n  function d3_ease_reverse(f) {\n    return function(t) {\n      return 1 - f(1 - t);\n    };\n  }\n  function d3_ease_reflect(f) {\n    return function(t) {\n      return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));\n    };\n  }\n  function d3_ease_quad(t) {\n    return t * t;\n  }\n  function d3_ease_cubic(t) {\n    return t * t * t;\n  }\n  function d3_ease_cubicInOut(t) {\n    if (t <= 0) return 0;\n    if (t >= 1) return 1;\n    var t2 = t * t, t3 = t2 * t;\n    return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);\n  }\n  function d3_ease_poly(e) {\n    return function(t) {\n      return Math.pow(t, e);\n    };\n  }\n  function d3_ease_sin(t) {\n    return 1 - Math.cos(t * half);\n  }\n  function d3_ease_exp(t) {\n    return Math.pow(2, 10 * (t - 1));\n  }\n  function d3_ease_circle(t) {\n    return 1 - Math.sqrt(1 - t * t);\n  }\n  function d3_ease_elastic(a, p) {\n    var s;\n    if (arguments.length < 2) p = .45;\n    if (arguments.length) s = p /  * Math.asin(1 / a); else a = 1, s = p / 4;\n    return function(t) {\n      return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) *  / p);\n    };\n  }\n  function d3_ease_back(s) {\n    if (!s) s = 1.70158;\n    return function(t) {\n      return t * t * ((s + 1) * t - s);\n    };\n  }\n  function d3_ease_bounce(t) {\n    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;\n  }\n  d3.interpolateHcl = d3_interpolateHcl;\n  function d3_interpolateHcl(a, b) {\n    a = d3.hcl(a);\n    b = d3.hcl(b);\n    var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;\n    if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;\n    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;\n    return function(t) {\n      return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + \"\";\n    };\n  }\n  d3.interpolateHsl = d3_interpolateHsl;\n  function d3_interpolateHsl(a, b) {\n    a = d3.hsl(a);\n    b = d3.hsl(b);\n    var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;\n    if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;\n    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;\n    return function(t) {\n      return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + \"\";\n    };\n  }\n  d3.interpolateLab = d3_interpolateLab;\n  function d3_interpolateLab(a, b) {\n    a = d3.lab(a);\n    b = d3.lab(b);\n    var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;\n    return function(t) {\n      return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + \"\";\n    };\n  }\n  d3.interpolateRound = d3_interpolateRound;\n  function d3_interpolateRound(a, b) {\n    b -= a;\n    return function(t) {\n      return Math.round(a + b * t);\n    };\n  }\n  d3.transform = function(string) {\n    var g = d3_document.createElementNS(d3.ns.prefix.svg, \"g\");\n    return (d3.transform = function(string) {\n      if (string != null) {\n        g.setAttribute(\"transform\", string);\n        var t = g.transform.baseVal.consolidate();\n      }\n      return new d3_transform(t ? t.matrix : d3_transformIdentity);\n    })(string);\n  };\n  function d3_transform(m) {\n    var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;\n    if (r0[0] * r1[1] < r1[0] * r0[1]) {\n      r0[0] *= -1;\n      r0[1] *= -1;\n      kx *= -1;\n      kz *= -1;\n    }\n    this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;\n    this.translate = [ m.e, m.f ];\n    this.scale = [ kx, ky ];\n    this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;\n  }\n  d3_transform.prototype.toString = function() {\n    return \"translate(\" + this.translate + \")rotate(\" + this.rotate + \")skewX(\" + this.skew + \")scale(\" + this.scale + \")\";\n  };\n  function d3_transformDot(a, b) {\n    return a[0] * b[0] + a[1] * b[1];\n  }\n  function d3_transformNormalize(a) {\n    var k = Math.sqrt(d3_transformDot(a, a));\n    if (k) {\n      a[0] /= k;\n      a[1] /= k;\n    }\n    return k;\n  }\n  function d3_transformCombine(a, b, k) {\n    a[0] += k * b[0];\n    a[1] += k * b[1];\n    return a;\n  }\n  var d3_transformIdentity = {\n    a: 1,\n    b: 0,\n    c: 0,\n    d: 1,\n    e: 0,\n    f: 0\n  };\n  d3.interpolateTransform = d3_interpolateTransform;\n  function d3_interpolateTransformPop(s) {\n    return s.length ? s.pop() + \",\" : \"\";\n  }\n  function d3_interpolateTranslate(ta, tb, s, q) {\n    if (ta[0] !== tb[0] || ta[1] !== tb[1]) {\n      var i = s.push(\"translate(\", null, \",\", null, \")\");\n      q.push({\n        i: i - 4,\n        x: d3_interpolateNumber(ta[0], tb[0])\n      }, {\n        i: i - 2,\n        x: d3_interpolateNumber(ta[1], tb[1])\n      });\n    } else if (tb[0] || tb[1]) {\n      s.push(\"translate(\" + tb + \")\");\n    }\n  }\n  function d3_interpolateRotate(ra, rb, s, q) {\n    if (ra !== rb) {\n      if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360;\n      q.push({\n        i: s.push(d3_interpolateTransformPop(s) + \"rotate(\", null, \")\") - 2,\n        x: d3_interpolateNumber(ra, rb)\n      });\n    } else if (rb) {\n      s.push(d3_interpolateTransformPop(s) + \"rotate(\" + rb + \")\");\n    }\n  }\n  function d3_interpolateSkew(wa, wb, s, q) {\n    if (wa !== wb) {\n      q.push({\n        i: s.push(d3_interpolateTransformPop(s) + \"skewX(\", null, \")\") - 2,\n        x: d3_interpolateNumber(wa, wb)\n      });\n    } else if (wb) {\n      s.push(d3_interpolateTransformPop(s) + \"skewX(\" + wb + \")\");\n    }\n  }\n  function d3_interpolateScale(ka, kb, s, q) {\n    if (ka[0] !== kb[0] || ka[1] !== kb[1]) {\n      var i = s.push(d3_interpolateTransformPop(s) + \"scale(\", null, \",\", null, \")\");\n      q.push({\n        i: i - 4,\n        x: d3_interpolateNumber(ka[0], kb[0])\n      }, {\n        i: i - 2,\n        x: d3_interpolateNumber(ka[1], kb[1])\n      });\n    } else if (kb[0] !== 1 || kb[1] !== 1) {\n      s.push(d3_interpolateTransformPop(s) + \"scale(\" + kb + \")\");\n    }\n  }\n  function d3_interpolateTransform(a, b) {\n    var s = [], q = [];\n    a = d3.transform(a), b = d3.transform(b);\n    d3_interpolateTranslate(a.translate, b.translate, s, q);\n    d3_interpolateRotate(a.rotate, b.rotate, s, q);\n    d3_interpolateSkew(a.skew, b.skew, s, q);\n    d3_interpolateScale(a.scale, b.scale, s, q);\n    a = b = null;\n    return function(t) {\n      var i = -1, n = q.length, o;\n      while (++i < n) s[(o = q[i]).i] = o.x(t);\n      return s.join(\"\");\n    };\n  }\n  function d3_uninterpolateNumber(a, b) {\n    b = (b -= a = +a) || 1 / b;\n    return function(x) {\n      return (x - a) / b;\n    };\n  }\n  function d3_uninterpolateClamp(a, b) {\n    b = (b -= a = +a) || 1 / b;\n    return function(x) {\n      return Math.max(0, Math.min(1, (x - a) / b));\n    };\n  }\n  d3.layout = {};\n  d3.layout.bundle = function() {\n    return function(links) {\n      var paths = [], i = -1, n = links.length;\n      while (++i < n) paths.push(d3_layout_bundlePath(links[i]));\n      return paths;\n    };\n  };\n  function d3_layout_bundlePath(link) {\n    var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ];\n    while (start !== lca) {\n      start = start.parent;\n      points.push(start);\n    }\n    var k = points.length;\n    while (end !== lca) {\n      points.splice(k, 0, end);\n      end = end.parent;\n    }\n    return points;\n  }\n  function d3_layout_bundleAncestors(node) {\n    var ancestors = [], parent = node.parent;\n    while (parent != null) {\n      ancestors.push(node);\n      node = parent;\n      parent = parent.parent;\n    }\n    ancestors.push(node);\n    return ancestors;\n  }\n  function d3_layout_bundleLeastCommonAncestor(a, b) {\n    if (a === b) return a;\n    var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;\n    while (aNode === bNode) {\n      sharedNode = aNode;\n      aNode = aNodes.pop();\n      bNode = bNodes.pop();\n    }\n    return sharedNode;\n  }\n  d3.layout.chord = function() {\n    var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;\n    function relayout() {\n      var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;\n      chords = [];\n      groups = [];\n      k = 0, i = -1;\n      while (++i < n) {\n        x = 0, j = -1;\n        while (++j < n) {\n          x += matrix[i][j];\n        }\n        groupSums.push(x);\n        subgroupIndex.push(d3.range(n));\n        k += x;\n      }\n      if (sortGroups) {\n        groupIndex.sort(function(a, b) {\n          return sortGroups(groupSums[a], groupSums[b]);\n        });\n      }\n      if (sortSubgroups) {\n        subgroupIndex.forEach(function(d, i) {\n          d.sort(function(a, b) {\n            return sortSubgroups(matrix[i][a], matrix[i][b]);\n          });\n        });\n      }\n      k = ( - padding * n) / k;\n      x = 0, i = -1;\n      while (++i < n) {\n        x0 = x, j = -1;\n        while (++j < n) {\n          var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;\n          subgroups[di + \"-\" + dj] = {\n            index: di,\n            subindex: dj,\n            startAngle: a0,\n            endAngle: a1,\n            value: v\n          };\n        }\n        groups[di] = {\n          index: di,\n          startAngle: x0,\n          endAngle: x,\n          value: groupSums[di]\n        };\n        x += padding;\n      }\n      i = -1;\n      while (++i < n) {\n        j = i - 1;\n        while (++j < n) {\n          var source = subgroups[i + \"-\" + j], target = subgroups[j + \"-\" + i];\n          if (source.value || target.value) {\n            chords.push(source.value < target.value ? {\n              source: target,\n              target: source\n            } : {\n              source: source,\n              target: target\n            });\n          }\n        }\n      }\n      if (sortChords) resort();\n    }\n    function resort() {\n      chords.sort(function(a, b) {\n        return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);\n      });\n    }\n    chord.matrix = function(x) {\n      if (!arguments.length) return matrix;\n      n = (matrix = x) && matrix.length;\n      chords = groups = null;\n      return chord;\n    };\n    chord.padding = function(x) {\n      if (!arguments.length) return padding;\n      padding = x;\n      chords = groups = null;\n      return chord;\n    };\n    chord.sortGroups = function(x) {\n      if (!arguments.length) return sortGroups;\n      sortGroups = x;\n      chords = groups = null;\n      return chord;\n    };\n    chord.sortSubgroups = function(x) {\n      if (!arguments.length) return sortSubgroups;\n      sortSubgroups = x;\n      chords = null;\n      return chord;\n    };\n    chord.sortChords = function(x) {\n      if (!arguments.length) return sortChords;\n      sortChords = x;\n      if (chords) resort();\n      return chord;\n    };\n    chord.chords = function() {\n      if (!chords) relayout();\n      return chords;\n    };\n    chord.groups = function() {\n      if (!groups) relayout();\n      return groups;\n    };\n    return chord;\n  };\n  d3.layout.force = function() {\n    var force = {}, event = d3.dispatch(\"start\", \"tick\", \"end\"), timer, size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = .1, theta2 = .64, nodes = [], links = [], distances, strengths, charges;\n    function repulse(node) {\n      return function(quad, x1, _, x2) {\n        if (quad.point !== node) {\n          var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;\n          if (dw * dw / theta2 < dn) {\n            if (dn < chargeDistance2) {\n              var k = quad.charge / dn;\n              node.px -= dx * k;\n              node.py -= dy * k;\n            }\n            return true;\n          }\n          if (quad.point && dn && dn < chargeDistance2) {\n            var k = quad.pointCharge / dn;\n            node.px -= dx * k;\n            node.py -= dy * k;\n          }\n        }\n        return !quad.charge;\n      };\n    }\n    force.tick = function() {\n      if ((alpha *= .99) < .005) {\n        timer = null;\n        event.end({\n          type: \"end\",\n          alpha: alpha = 0\n        });\n        return true;\n      }\n      var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;\n      for (i = 0; i < m; ++i) {\n        o = links[i];\n        s = o.source;\n        t = o.target;\n        x = t.x - s.x;\n        y = t.y - s.y;\n        if (l = x * x + y * y) {\n          l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;\n          x *= l;\n          y *= l;\n          t.x -= x * (k = s.weight + t.weight ? s.weight / (s.weight + t.weight) : .5);\n          t.y -= y * k;\n          s.x += x * (k = 1 - k);\n          s.y += y * k;\n        }\n      }\n      if (k = alpha * gravity) {\n        x = size[0] / 2;\n        y = size[1] / 2;\n        i = -1;\n        if (k) while (++i < n) {\n          o = nodes[i];\n          o.x += (x - o.x) * k;\n          o.y += (y - o.y) * k;\n        }\n      }\n      if (charge) {\n        d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);\n        i = -1;\n        while (++i < n) {\n          if (!(o = nodes[i]).fixed) {\n            q.visit(repulse(o));\n          }\n        }\n      }\n      i = -1;\n      while (++i < n) {\n        o = nodes[i];\n        if (o.fixed) {\n          o.x = o.px;\n          o.y = o.py;\n        } else {\n          o.x -= (o.px - (o.px = o.x)) * friction;\n          o.y -= (o.py - (o.py = o.y)) * friction;\n        }\n      }\n      event.tick({\n        type: \"tick\",\n        alpha: alpha\n      });\n    };\n    force.nodes = function(x) {\n      if (!arguments.length) return nodes;\n      nodes = x;\n      return force;\n    };\n    force.links = function(x) {\n      if (!arguments.length) return links;\n      links = x;\n      return force;\n    };\n    force.size = function(x) {\n      if (!arguments.length) return size;\n      size = x;\n      return force;\n    };\n    force.linkDistance = function(x) {\n      if (!arguments.length) return linkDistance;\n      linkDistance = typeof x === \"function\" ? x : +x;\n      return force;\n    };\n    force.distance = force.linkDistance;\n    force.linkStrength = function(x) {\n      if (!arguments.length) return linkStrength;\n      linkStrength = typeof x === \"function\" ? x : +x;\n      return force;\n    };\n    force.friction = function(x) {\n      if (!arguments.length) return friction;\n      friction = +x;\n      return force;\n    };\n    force.charge = function(x) {\n      if (!arguments.length) return charge;\n      charge = typeof x === \"function\" ? x : +x;\n      return force;\n    };\n    force.chargeDistance = function(x) {\n      if (!arguments.length) return Math.sqrt(chargeDistance2);\n      chargeDistance2 = x * x;\n      return force;\n    };\n    force.gravity = function(x) {\n      if (!arguments.length) return gravity;\n      gravity = +x;\n      return force;\n    };\n    force.theta = function(x) {\n      if (!arguments.length) return Math.sqrt(theta2);\n      theta2 = x * x;\n      return force;\n    };\n    force.alpha = function(x) {\n      if (!arguments.length) return alpha;\n      x = +x;\n      if (alpha) {\n        if (x > 0) {\n          alpha = x;\n        } else {\n          timer.c = null, timer.t = NaN, timer = null;\n          event.end({\n            type: \"end\",\n            alpha: alpha = 0\n          });\n        }\n      } else if (x > 0) {\n        event.start({\n          type: \"start\",\n          alpha: alpha = x\n        });\n        timer = d3_timer(force.tick);\n      }\n      return force;\n    };\n    force.start = function() {\n      var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;\n      for (i = 0; i < n; ++i) {\n        (o = nodes[i]).index = i;\n        o.weight = 0;\n      }\n      for (i = 0; i < m; ++i) {\n        o = links[i];\n        if (typeof o.source == \"number\") o.source = nodes[o.source];\n        if (typeof o.target == \"number\") o.target = nodes[o.target];\n        ++o.source.weight;\n        ++o.target.weight;\n      }\n      for (i = 0; i < n; ++i) {\n        o = nodes[i];\n        if (isNaN(o.x)) o.x = position(\"x\", w);\n        if (isNaN(o.y)) o.y = position(\"y\", h);\n        if (isNaN(o.px)) o.px = o.x;\n        if (isNaN(o.py)) o.py = o.y;\n      }\n      distances = [];\n      if (typeof linkDistance === \"function\") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i); else for (i = 0; i < m; ++i) distances[i] = linkDistance;\n      strengths = [];\n      if (typeof linkStrength === \"function\") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i); else for (i = 0; i < m; ++i) strengths[i] = linkStrength;\n      charges = [];\n      if (typeof charge === \"function\") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i); else for (i = 0; i < n; ++i) charges[i] = charge;\n      function position(dimension, size) {\n        if (!neighbors) {\n          neighbors = new Array(n);\n          for (j = 0; j < n; ++j) {\n            neighbors[j] = [];\n          }\n          for (j = 0; j < m; ++j) {\n            var o = links[j];\n            neighbors[o.source.index].push(o.target);\n            neighbors[o.target.index].push(o.source);\n          }\n        }\n        var candidates = neighbors[i], j = -1, l = candidates.length, x;\n        while (++j < l) if (!isNaN(x = candidates[j][dimension])) return x;\n        return Math.random() * size;\n      }\n      return force.resume();\n    };\n    force.resume = function() {\n      return force.alpha(.1);\n    };\n    force.stop = function() {\n      return force.alpha(0);\n    };\n    force.drag = function() {\n      if (!drag) drag = d3.behavior.drag().origin(d3_identity).on(\"dragstart.force\", d3_layout_forceDragstart).on(\"drag.force\", dragmove).on(\"dragend.force\", d3_layout_forceDragend);\n      if (!arguments.length) return drag;\n      this.on(\"mouseover.force\", d3_layout_forceMouseover).on(\"mouseout.force\", d3_layout_forceMouseout).call(drag);\n    };\n    function dragmove(d) {\n      d.px = d3.event.x, d.py = d3.event.y;\n      force.resume();\n    }\n    return d3.rebind(force, event, \"on\");\n  };\n  function d3_layout_forceDragstart(d) {\n    d.fixed |= 2;\n  }\n  function d3_layout_forceDragend(d) {\n    d.fixed &= ~6;\n  }\n  function d3_layout_forceMouseover(d) {\n    d.fixed |= 4;\n    d.px = d.x, d.py = d.y;\n  }\n  function d3_layout_forceMouseout(d) {\n    d.fixed &= ~4;\n  }\n  function d3_layout_forceAccumulate(quad, alpha, charges) {\n    var cx = 0, cy = 0;\n    quad.charge = 0;\n    if (!quad.leaf) {\n      var nodes = quad.nodes, n = nodes.length, i = -1, c;\n      while (++i < n) {\n        c = nodes[i];\n        if (c == null) continue;\n        d3_layout_forceAccumulate(c, alpha, charges);\n        quad.charge += c.charge;\n        cx += c.charge * c.cx;\n        cy += c.charge * c.cy;\n      }\n    }\n    if (quad.point) {\n      if (!quad.leaf) {\n        quad.point.x += Math.random() - .5;\n        quad.point.y += Math.random() - .5;\n      }\n      var k = alpha * charges[quad.point.index];\n      quad.charge += quad.pointCharge = k;\n      cx += k * quad.point.x;\n      cy += k * quad.point.y;\n    }\n    quad.cx = cx / quad.charge;\n    quad.cy = cy / quad.charge;\n  }\n  var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;\n  d3.layout.hierarchy = function() {\n    var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;\n    function hierarchy(root) {\n      var stack = [ root ], nodes = [], node;\n      root.depth = 0;\n      while ((node = stack.pop()) != null) {\n        nodes.push(node);\n        if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {\n          var n, childs, child;\n          while (--n >= 0) {\n            stack.push(child = childs[n]);\n            child.parent = node;\n            child.depth = node.depth + 1;\n          }\n          if (value) node.value = 0;\n          node.children = childs;\n        } else {\n          if (value) node.value = +value.call(hierarchy, node, node.depth) || 0;\n          delete node.children;\n        }\n      }\n      d3_layout_hierarchyVisitAfter(root, function(node) {\n        var childs, parent;\n        if (sort && (childs = node.children)) childs.sort(sort);\n        if (value && (parent = node.parent)) parent.value += node.value;\n      });\n      return nodes;\n    }\n    hierarchy.sort = function(x) {\n      if (!arguments.length) return sort;\n      sort = x;\n      return hierarchy;\n    };\n    hierarchy.children = function(x) {\n      if (!arguments.length) return children;\n      children = x;\n      return hierarchy;\n    };\n    hierarchy.value = function(x) {\n      if (!arguments.length) return value;\n      value = x;\n      return hierarchy;\n    };\n    hierarchy.revalue = function(root) {\n      if (value) {\n        d3_layout_hierarchyVisitBefore(root, function(node) {\n          if (node.children) node.value = 0;\n        });\n        d3_layout_hierarchyVisitAfter(root, function(node) {\n          var parent;\n          if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;\n          if (parent = node.parent) parent.value += node.value;\n        });\n      }\n      return root;\n    };\n    return hierarchy;\n  };\n  function d3_layout_hierarchyRebind(object, hierarchy) {\n    d3.rebind(object, hierarchy, \"sort\", \"children\", \"value\");\n    object.nodes = object;\n    object.links = d3_layout_hierarchyLinks;\n    return object;\n  }\n  function d3_layout_hierarchyVisitBefore(node, callback) {\n    var nodes = [ node ];\n    while ((node = nodes.pop()) != null) {\n      callback(node);\n      if ((children = node.children) && (n = children.length)) {\n        var n, children;\n        while (--n >= 0) nodes.push(children[n]);\n      }\n    }\n  }\n  function d3_layout_hierarchyVisitAfter(node, callback) {\n    var nodes = [ node ], nodes2 = [];\n    while ((node = nodes.pop()) != null) {\n      nodes2.push(node);\n      if ((children = node.children) && (n = children.length)) {\n        var i = -1, n, children;\n        while (++i < n) nodes.push(children[i]);\n      }\n    }\n    while ((node = nodes2.pop()) != null) {\n      callback(node);\n    }\n  }\n  function d3_layout_hierarchyChildren(d) {\n    return d.children;\n  }\n  function d3_layout_hierarchyValue(d) {\n    return d.value;\n  }\n  function d3_layout_hierarchySort(a, b) {\n    return b.value - a.value;\n  }\n  function d3_layout_hierarchyLinks(nodes) {\n    return d3.merge(nodes.map(function(parent) {\n      return (parent.children || []).map(function(child) {\n        return {\n          source: parent,\n          target: child\n        };\n      });\n    }));\n  }\n  d3.layout.partition = function() {\n    var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ];\n    function position(node, x, dx, dy) {\n      var children = node.children;\n      node.x = x;\n      node.y = node.depth * dy;\n      node.dx = dx;\n      node.dy = dy;\n      if (children && (n = children.length)) {\n        var i = -1, n, c, d;\n        dx = node.value ? dx / node.value : 0;\n        while (++i < n) {\n          position(c = children[i], x, d = c.value * dx, dy);\n          x += d;\n        }\n      }\n    }\n    function depth(node) {\n      var children = node.children, d = 0;\n      if (children && (n = children.length)) {\n        var i = -1, n;\n        while (++i < n) d = Math.max(d, depth(children[i]));\n      }\n      return 1 + d;\n    }\n    function partition(d, i) {\n      var nodes = hierarchy.call(this, d, i);\n      position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));\n      return nodes;\n    }\n    partition.size = function(x) {\n      if (!arguments.length) return size;\n      size = x;\n      return partition;\n    };\n    return d3_layout_hierarchyRebind(partition, hierarchy);\n  };\n  d3.layout.pie = function() {\n    var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = , padAngle = 0;\n    function pie(data) {\n      var n = data.length, values = data.map(function(d, i) {\n        return +value.call(pie, d, i);\n      }), a = +(typeof startAngle === \"function\" ? startAngle.apply(this, arguments) : startAngle), da = (typeof endAngle === \"function\" ? endAngle.apply(this, arguments) : endAngle) - a, p = Math.min(Math.abs(da) / n, +(typeof padAngle === \"function\" ? padAngle.apply(this, arguments) : padAngle)), pa = p * (da < 0 ? -1 : 1), sum = d3.sum(values), k = sum ? (da - n * pa) / sum : 0, index = d3.range(n), arcs = [], v;\n      if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {\n        return values[j] - values[i];\n      } : function(i, j) {\n        return sort(data[i], data[j]);\n      });\n      index.forEach(function(i) {\n        arcs[i] = {\n          data: data[i],\n          value: v = values[i],\n          startAngle: a,\n          endAngle: a += v * k + pa,\n          padAngle: p\n        };\n      });\n      return arcs;\n    }\n    pie.value = function(_) {\n      if (!arguments.length) return value;\n      value = _;\n      return pie;\n    };\n    pie.sort = function(_) {\n      if (!arguments.length) return sort;\n      sort = _;\n      return pie;\n    };\n    pie.startAngle = function(_) {\n      if (!arguments.length) return startAngle;\n      startAngle = _;\n      return pie;\n    };\n    pie.endAngle = function(_) {\n      if (!arguments.length) return endAngle;\n      endAngle = _;\n      return pie;\n    };\n    pie.padAngle = function(_) {\n      if (!arguments.length) return padAngle;\n      padAngle = _;\n      return pie;\n    };\n    return pie;\n  };\n  var d3_layout_pieSortByValue = {};\n  d3.layout.stack = function() {\n    var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;\n    function stack(data, index) {\n      if (!(n = data.length)) return data;\n      var series = data.map(function(d, i) {\n        return values.call(stack, d, i);\n      });\n      var points = series.map(function(d) {\n        return d.map(function(v, i) {\n          return [ x.call(stack, v, i), y.call(stack, v, i) ];\n        });\n      });\n      var orders = order.call(stack, points, index);\n      series = d3.permute(series, orders);\n      points = d3.permute(points, orders);\n      var offsets = offset.call(stack, points, index);\n      var m = series[0].length, n, i, j, o;\n      for (j = 0; j < m; ++j) {\n        out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);\n        for (i = 1; i < n; ++i) {\n          out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);\n        }\n      }\n      return data;\n    }\n    stack.values = function(x) {\n      if (!arguments.length) return values;\n      values = x;\n      return stack;\n    };\n    stack.order = function(x) {\n      if (!arguments.length) return order;\n      order = typeof x === \"function\" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;\n      return stack;\n    };\n    stack.offset = function(x) {\n      if (!arguments.length) return offset;\n      offset = typeof x === \"function\" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;\n      return stack;\n    };\n    stack.x = function(z) {\n      if (!arguments.length) return x;\n      x = z;\n      return stack;\n    };\n    stack.y = function(z) {\n      if (!arguments.length) return y;\n      y = z;\n      return stack;\n    };\n    stack.out = function(z) {\n      if (!arguments.length) return out;\n      out = z;\n      return stack;\n    };\n    return stack;\n  };\n  function d3_layout_stackX(d) {\n    return d.x;\n  }\n  function d3_layout_stackY(d) {\n    return d.y;\n  }\n  function d3_layout_stackOut(d, y0, y) {\n    d.y0 = y0;\n    d.y = y;\n  }\n  var d3_layout_stackOrders = d3.map({\n    \"inside-out\": function(data) {\n      var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {\n        return max[a] - max[b];\n      }), top = 0, bottom = 0, tops = [], bottoms = [];\n      for (i = 0; i < n; ++i) {\n        j = index[i];\n        if (top < bottom) {\n          top += sums[j];\n          tops.push(j);\n        } else {\n          bottom += sums[j];\n          bottoms.push(j);\n        }\n      }\n      return bottoms.reverse().concat(tops);\n    },\n    reverse: function(data) {\n      return d3.range(data.length).reverse();\n    },\n    \"default\": d3_layout_stackOrderDefault\n  });\n  var d3_layout_stackOffsets = d3.map({\n    silhouette: function(data) {\n      var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];\n      for (j = 0; j < m; ++j) {\n        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];\n        if (o > max) max = o;\n        sums.push(o);\n      }\n      for (j = 0; j < m; ++j) {\n        y0[j] = (max - sums[j]) / 2;\n      }\n      return y0;\n    },\n    wiggle: function(data) {\n      var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];\n      y0[0] = o = o0 = 0;\n      for (j = 1; j < m; ++j) {\n        for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];\n        for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {\n          for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {\n            s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;\n          }\n          s2 += s3 * data[i][j][1];\n        }\n        y0[j] = o -= s1 ? s2 / s1 * dx : 0;\n        if (o < o0) o0 = o;\n      }\n      for (j = 0; j < m; ++j) y0[j] -= o0;\n      return y0;\n    },\n    expand: function(data) {\n      var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];\n      for (j = 0; j < m; ++j) {\n        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];\n        if (o) for (i = 0; i < n; i++) data[i][j][1] /= o; else for (i = 0; i < n; i++) data[i][j][1] = k;\n      }\n      for (j = 0; j < m; ++j) y0[j] = 0;\n      return y0;\n    },\n    zero: d3_layout_stackOffsetZero\n  });\n  function d3_layout_stackOrderDefault(data) {\n    return d3.range(data.length);\n  }\n  function d3_layout_stackOffsetZero(data) {\n    var j = -1, m = data[0].length, y0 = [];\n    while (++j < m) y0[j] = 0;\n    return y0;\n  }\n  function d3_layout_stackMaxIndex(array) {\n    var i = 1, j = 0, v = array[0][1], k, n = array.length;\n    for (;i < n; ++i) {\n      if ((k = array[i][1]) > v) {\n        j = i;\n        v = k;\n      }\n    }\n    return j;\n  }\n  function d3_layout_stackReduceSum(d) {\n    return d.reduce(d3_layout_stackSum, 0);\n  }\n  function d3_layout_stackSum(p, d) {\n    return p + d[1];\n  }\n  d3.layout.histogram = function() {\n    var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;\n    function histogram(data, i) {\n      var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;\n      while (++i < m) {\n        bin = bins[i] = [];\n        bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);\n        bin.y = 0;\n      }\n      if (m > 0) {\n        i = -1;\n        while (++i < n) {\n          x = values[i];\n          if (x >= range[0] && x <= range[1]) {\n            bin = bins[d3.bisect(thresholds, x, 1, m) - 1];\n            bin.y += k;\n            bin.push(data[i]);\n          }\n        }\n      }\n      return bins;\n    }\n    histogram.value = function(x) {\n      if (!arguments.length) return valuer;\n      valuer = x;\n      return histogram;\n    };\n    histogram.range = function(x) {\n      if (!arguments.length) return ranger;\n      ranger = d3_functor(x);\n      return histogram;\n    };\n    histogram.bins = function(x) {\n      if (!arguments.length) return binner;\n      binner = typeof x === \"number\" ? function(range) {\n        return d3_layout_histogramBinFixed(range, x);\n      } : d3_functor(x);\n      return histogram;\n    };\n    histogram.frequency = function(x) {\n      if (!arguments.length) return frequency;\n      frequency = !!x;\n      return histogram;\n    };\n    return histogram;\n  };\n  function d3_layout_histogramBinSturges(range, values) {\n    return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));\n  }\n  function d3_layout_histogramBinFixed(range, n) {\n    var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];\n    while (++x <= n) f[x] = m * x + b;\n    return f;\n  }\n  function d3_layout_histogramRange(values) {\n    return [ d3.min(values), d3.max(values) ];\n  }\n  d3.layout.pack = function() {\n    var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ], radius;\n    function pack(d, i) {\n      var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === \"function\" ? radius : function() {\n        return radius;\n      };\n      root.x = root.y = 0;\n      d3_layout_hierarchyVisitAfter(root, function(d) {\n        d.r = +r(d.value);\n      });\n      d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);\n      if (padding) {\n        var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;\n        d3_layout_hierarchyVisitAfter(root, function(d) {\n          d.r += dr;\n        });\n        d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);\n        d3_layout_hierarchyVisitAfter(root, function(d) {\n          d.r -= dr;\n        });\n      }\n      d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));\n      return nodes;\n    }\n    pack.size = function(_) {\n      if (!arguments.length) return size;\n      size = _;\n      return pack;\n    };\n    pack.radius = function(_) {\n      if (!arguments.length) return radius;\n      radius = _ == null || typeof _ === \"function\" ? _ : +_;\n      return pack;\n    };\n    pack.padding = function(_) {\n      if (!arguments.length) return padding;\n      padding = +_;\n      return pack;\n    };\n    return d3_layout_hierarchyRebind(pack, hierarchy);\n  };\n  function d3_layout_packSort(a, b) {\n    return a.value - b.value;\n  }\n  function d3_layout_packInsert(a, b) {\n    var c = a._pack_next;\n    a._pack_next = b;\n    b._pack_prev = a;\n    b._pack_next = c;\n    c._pack_prev = b;\n  }\n  function d3_layout_packSplice(a, b) {\n    a._pack_next = b;\n    b._pack_prev = a;\n  }\n  function d3_layout_packIntersects(a, b) {\n    var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;\n    return .999 * dr * dr > dx * dx + dy * dy;\n  }\n  function d3_layout_packSiblings(node) {\n    if (!(nodes = node.children) || !(n = nodes.length)) return;\n    var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;\n    function bound(node) {\n      xMin = Math.min(node.x - node.r, xMin);\n      xMax = Math.max(node.x + node.r, xMax);\n      yMin = Math.min(node.y - node.r, yMin);\n      yMax = Math.max(node.y + node.r, yMax);\n    }\n    nodes.forEach(d3_layout_packLink);\n    a = nodes[0];\n    a.x = -a.r;\n    a.y = 0;\n    bound(a);\n    if (n > 1) {\n      b = nodes[1];\n      b.x = b.r;\n      b.y = 0;\n      bound(b);\n      if (n > 2) {\n        c = nodes[2];\n        d3_layout_packPlace(a, b, c);\n        bound(c);\n        d3_layout_packInsert(a, c);\n        a._pack_prev = c;\n        d3_layout_packInsert(c, b);\n        b = a._pack_next;\n        for (i = 3; i < n; i++) {\n          d3_layout_packPlace(a, b, c = nodes[i]);\n          var isect = 0, s1 = 1, s2 = 1;\n          for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {\n            if (d3_layout_packIntersects(j, c)) {\n              isect = 1;\n              break;\n            }\n          }\n          if (isect == 1) {\n            for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {\n              if (d3_layout_packIntersects(k, c)) {\n                break;\n              }\n            }\n          }\n          if (isect) {\n            if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b);\n            i--;\n          } else {\n            d3_layout_packInsert(a, c);\n            b = c;\n            bound(c);\n          }\n        }\n      }\n    }\n    var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;\n    for (i = 0; i < n; i++) {\n      c = nodes[i];\n      c.x -= cx;\n      c.y -= cy;\n      cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));\n    }\n    node.r = cr;\n    nodes.forEach(d3_layout_packUnlink);\n  }\n  function d3_layout_packLink(node) {\n    node._pack_next = node._pack_prev = node;\n  }\n  function d3_layout_packUnlink(node) {\n    delete node._pack_next;\n    delete node._pack_prev;\n  }\n  function d3_layout_packTransform(node, x, y, k) {\n    var children = node.children;\n    node.x = x += k * node.x;\n    node.y = y += k * node.y;\n    node.r *= k;\n    if (children) {\n      var i = -1, n = children.length;\n      while (++i < n) d3_layout_packTransform(children[i], x, y, k);\n    }\n  }\n  function d3_layout_packPlace(a, b, c) {\n    var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;\n    if (db && (dx || dy)) {\n      var da = b.r + c.r, dc = dx * dx + dy * dy;\n      da *= da;\n      db *= db;\n      var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);\n      c.x = a.x + x * dx + y * dy;\n      c.y = a.y + x * dy - y * dx;\n    } else {\n      c.x = a.x + db;\n      c.y = a.y;\n    }\n  }\n  d3.layout.tree = function() {\n    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = null;\n    function tree(d, i) {\n      var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);\n      d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;\n      d3_layout_hierarchyVisitBefore(root1, secondWalk);\n      if (nodeSize) d3_layout_hierarchyVisitBefore(root0, sizeNode); else {\n        var left = root0, right = root0, bottom = root0;\n        d3_layout_hierarchyVisitBefore(root0, function(node) {\n          if (node.x < left.x) left = node;\n          if (node.x > right.x) right = node;\n          if (node.depth > bottom.depth) bottom = node;\n        });\n        var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);\n        d3_layout_hierarchyVisitBefore(root0, function(node) {\n          node.x = (node.x + tx) * kx;\n          node.y = node.depth * ky;\n        });\n      }\n      return nodes;\n    }\n    function wrapTree(root0) {\n      var root1 = {\n        A: null,\n        children: [ root0 ]\n      }, queue = [ root1 ], node1;\n      while ((node1 = queue.pop()) != null) {\n        for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {\n          queue.push((children[i] = child = {\n            _: children[i],\n            parent: node1,\n            children: (child = children[i].children) && child.slice() || [],\n            A: null,\n            a: null,\n            z: 0,\n            m: 0,\n            c: 0,\n            s: 0,\n            t: null,\n            i: i\n          }).a = child);\n        }\n      }\n      return root1.children[0];\n    }\n    function firstWalk(v) {\n      var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;\n      if (children.length) {\n        d3_layout_treeShift(v);\n        var midpoint = (children[0].z + children[children.length - 1].z) / 2;\n        if (w) {\n          v.z = w.z + separation(v._, w._);\n          v.m = v.z - midpoint;\n        } else {\n          v.z = midpoint;\n        }\n      } else if (w) {\n        v.z = w.z + separation(v._, w._);\n      }\n      v.parent.A = apportion(v, w, v.parent.A || siblings[0]);\n    }\n    function secondWalk(v) {\n      v._.x = v.z + v.parent.m;\n      v.m += v.parent.m;\n    }\n    function apportion(v, w, ancestor) {\n      if (w) {\n        var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;\n        while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {\n          vom = d3_layout_treeLeft(vom);\n          vop = d3_layout_treeRight(vop);\n          vop.a = v;\n          shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);\n          if (shift > 0) {\n            d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);\n            sip += shift;\n            sop += shift;\n          }\n          sim += vim.m;\n          sip += vip.m;\n          som += vom.m;\n          sop += vop.m;\n        }\n        if (vim && !d3_layout_treeRight(vop)) {\n          vop.t = vim;\n          vop.m += sim - sop;\n        }\n        if (vip && !d3_layout_treeLeft(vom)) {\n          vom.t = vip;\n          vom.m += sip - som;\n          ancestor = v;\n        }\n      }\n      return ancestor;\n    }\n    function sizeNode(node) {\n      node.x *= size[0];\n      node.y = node.depth * size[1];\n    }\n    tree.separation = function(x) {\n      if (!arguments.length) return separation;\n      separation = x;\n      return tree;\n    };\n    tree.size = function(x) {\n      if (!arguments.length) return nodeSize ? null : size;\n      nodeSize = (size = x) == null ? sizeNode : null;\n      return tree;\n    };\n    tree.nodeSize = function(x) {\n      if (!arguments.length) return nodeSize ? size : null;\n      nodeSize = (size = x) == null ? null : sizeNode;\n      return tree;\n    };\n    return d3_layout_hierarchyRebind(tree, hierarchy);\n  };\n  function d3_layout_treeSeparation(a, b) {\n    return a.parent == b.parent ? 1 : 2;\n  }\n  function d3_layout_treeLeft(v) {\n    var children = v.children;\n    return children.length ? children[0] : v.t;\n  }\n  function d3_layout_treeRight(v) {\n    var children = v.children, n;\n    return (n = children.length) ? children[n - 1] : v.t;\n  }\n  function d3_layout_treeMove(wm, wp, shift) {\n    var change = shift / (wp.i - wm.i);\n    wp.c -= change;\n    wp.s += shift;\n    wm.c += change;\n    wp.z += shift;\n    wp.m += shift;\n  }\n  function d3_layout_treeShift(v) {\n    var shift = 0, change = 0, children = v.children, i = children.length, w;\n    while (--i >= 0) {\n      w = children[i];\n      w.z += shift;\n      w.m += shift;\n      shift += w.s + (change += w.c);\n    }\n  }\n  function d3_layout_treeAncestor(vim, v, ancestor) {\n    return vim.a.parent === v.parent ? vim.a : ancestor;\n  }\n  d3.layout.cluster = function() {\n    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = false;\n    function cluster(d, i) {\n      var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;\n      d3_layout_hierarchyVisitAfter(root, function(node) {\n        var children = node.children;\n        if (children && children.length) {\n          node.x = d3_layout_clusterX(children);\n          node.y = d3_layout_clusterY(children);\n        } else {\n          node.x = previousNode ? x += separation(node, previousNode) : 0;\n          node.y = 0;\n          previousNode = node;\n        }\n      });\n      var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;\n      d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) {\n        node.x = (node.x - root.x) * size[0];\n        node.y = (root.y - node.y) * size[1];\n      } : function(node) {\n        node.x = (node.x - x0) / (x1 - x0) * size[0];\n        node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];\n      });\n      return nodes;\n    }\n    cluster.separation = function(x) {\n      if (!arguments.length) return separation;\n      separation = x;\n      return cluster;\n    };\n    cluster.size = function(x) {\n      if (!arguments.length) return nodeSize ? null : size;\n      nodeSize = (size = x) == null;\n      return cluster;\n    };\n    cluster.nodeSize = function(x) {\n      if (!arguments.length) return nodeSize ? size : null;\n      nodeSize = (size = x) != null;\n      return cluster;\n    };\n    return d3_layout_hierarchyRebind(cluster, hierarchy);\n  };\n  function d3_layout_clusterY(children) {\n    return 1 + d3.max(children, function(child) {\n      return child.y;\n    });\n  }\n  function d3_layout_clusterX(children) {\n    return children.reduce(function(x, child) {\n      return x + child.x;\n    }, 0) / children.length;\n  }\n  function d3_layout_clusterLeft(node) {\n    var children = node.children;\n    return children && children.length ? d3_layout_clusterLeft(children[0]) : node;\n  }\n  function d3_layout_clusterRight(node) {\n    var children = node.children, n;\n    return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;\n  }\n  d3.layout.treemap = function() {\n    var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = \"squarify\", ratio = .5 * (1 + Math.sqrt(5));\n    function scale(children, k) {\n      var i = -1, n = children.length, child, area;\n      while (++i < n) {\n        area = (child = children[i]).value * (k < 0 ? 0 : k);\n        child.area = isNaN(area) || area <= 0 ? 0 : area;\n      }\n    }\n    function squarify(node) {\n      var children = node.children;\n      if (children && children.length) {\n        var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === \"slice\" ? rect.dx : mode === \"dice\" ? rect.dy : mode === \"slice-dice\" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;\n        scale(remaining, rect.dx * rect.dy / node.value);\n        row.area = 0;\n        while ((n = remaining.length) > 0) {\n          row.push(child = remaining[n - 1]);\n          row.area += child.area;\n          if (mode !== \"squarify\" || (score = worst(row, u)) <= best) {\n            remaining.pop();\n            best = score;\n          } else {\n            row.area -= row.pop().area;\n            position(row, u, rect, false);\n            u = Math.min(rect.dx, rect.dy);\n            row.length = row.area = 0;\n            best = Infinity;\n          }\n        }\n        if (row.length) {\n          position(row, u, rect, true);\n          row.length = row.area = 0;\n        }\n        children.forEach(squarify);\n      }\n    }\n    function stickify(node) {\n      var children = node.children;\n      if (children && children.length) {\n        var rect = pad(node), remaining = children.slice(), child, row = [];\n        scale(remaining, rect.dx * rect.dy / node.value);\n        row.area = 0;\n        while (child = remaining.pop()) {\n          row.push(child);\n          row.area += child.area;\n          if (child.z != null) {\n            position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);\n            row.length = row.area = 0;\n          }\n        }\n        children.forEach(stickify);\n      }\n    }\n    function worst(row, u) {\n      var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;\n      while (++i < n) {\n        if (!(r = row[i].area)) continue;\n        if (r < rmin) rmin = r;\n        if (r > rmax) rmax = r;\n      }\n      s *= s;\n      u *= u;\n      return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;\n    }\n    function position(row, u, rect, flush) {\n      var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;\n      if (u == rect.dx) {\n        if (flush || v > rect.dy) v = rect.dy;\n        while (++i < n) {\n          o = row[i];\n          o.x = x;\n          o.y = y;\n          o.dy = v;\n          x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);\n        }\n        o.z = true;\n        o.dx += rect.x + rect.dx - x;\n        rect.y += v;\n        rect.dy -= v;\n      } else {\n        if (flush || v > rect.dx) v = rect.dx;\n        while (++i < n) {\n          o = row[i];\n          o.x = x;\n          o.y = y;\n          o.dx = v;\n          y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);\n        }\n        o.z = false;\n        o.dy += rect.y + rect.dy - y;\n        rect.x += v;\n        rect.dx -= v;\n      }\n    }\n    function treemap(d) {\n      var nodes = stickies || hierarchy(d), root = nodes[0];\n      root.x = root.y = 0;\n      if (root.value) root.dx = size[0], root.dy = size[1]; else root.dx = root.dy = 0;\n      if (stickies) hierarchy.revalue(root);\n      scale([ root ], root.dx * root.dy / root.value);\n      (stickies ? stickify : squarify)(root);\n      if (sticky) stickies = nodes;\n      return nodes;\n    }\n    treemap.size = function(x) {\n      if (!arguments.length) return size;\n      size = x;\n      return treemap;\n    };\n    treemap.padding = function(x) {\n      if (!arguments.length) return padding;\n      function padFunction(node) {\n        var p = x.call(treemap, node, node.depth);\n        return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === \"number\" ? [ p, p, p, p ] : p);\n      }\n      function padConstant(node) {\n        return d3_layout_treemapPad(node, x);\n      }\n      var type;\n      pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === \"function\" ? padFunction : type === \"number\" ? (x = [ x, x, x, x ], \n      padConstant) : padConstant;\n      return treemap;\n    };\n    treemap.round = function(x) {\n      if (!arguments.length) return round != Number;\n      round = x ? Math.round : Number;\n      return treemap;\n    };\n    treemap.sticky = function(x) {\n      if (!arguments.length) return sticky;\n      sticky = x;\n      stickies = null;\n      return treemap;\n    };\n    treemap.ratio = function(x) {\n      if (!arguments.length) return ratio;\n      ratio = x;\n      return treemap;\n    };\n    treemap.mode = function(x) {\n      if (!arguments.length) return mode;\n      mode = x + \"\";\n      return treemap;\n    };\n    return d3_layout_hierarchyRebind(treemap, hierarchy);\n  };\n  function d3_layout_treemapPadNull(node) {\n    return {\n      x: node.x,\n      y: node.y,\n      dx: node.dx,\n      dy: node.dy\n    };\n  }\n  function d3_layout_treemapPad(node, padding) {\n    var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];\n    if (dx < 0) {\n      x += dx / 2;\n      dx = 0;\n    }\n    if (dy < 0) {\n      y += dy / 2;\n      dy = 0;\n    }\n    return {\n      x: x,\n      y: y,\n      dx: dx,\n      dy: dy\n    };\n  }\n  d3.random = {\n    normal: function(, ) {\n      var n = arguments.length;\n      if (n < 2)  = 1;\n      if (n < 1)  = 0;\n      return function() {\n        var x, y, r;\n        do {\n          x = Math.random() * 2 - 1;\n          y = Math.random() * 2 - 1;\n          r = x * x + y * y;\n        } while (!r || r > 1);\n        return  +  * x * Math.sqrt(-2 * Math.log(r) / r);\n      };\n    },\n    logNormal: function() {\n      var random = d3.random.normal.apply(d3, arguments);\n      return function() {\n        return Math.exp(random());\n      };\n    },\n    bates: function(m) {\n      var random = d3.random.irwinHall(m);\n      return function() {\n        return random() / m;\n      };\n    },\n    irwinHall: function(m) {\n      return function() {\n        for (var s = 0, j = 0; j < m; j++) s += Math.random();\n        return s;\n      };\n    }\n  };\n  d3.scale = {};\n  function d3_scaleExtent(domain) {\n    var start = domain[0], stop = domain[domain.length - 1];\n    return start < stop ? [ start, stop ] : [ stop, start ];\n  }\n  function d3_scaleRange(scale) {\n    return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());\n  }\n  function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {\n    var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);\n    return function(x) {\n      return i(u(x));\n    };\n  }\n  function d3_scale_nice(domain, nice) {\n    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;\n    if (x1 < x0) {\n      dx = i0, i0 = i1, i1 = dx;\n      dx = x0, x0 = x1, x1 = dx;\n    }\n    domain[i0] = nice.floor(x0);\n    domain[i1] = nice.ceil(x1);\n    return domain;\n  }\n  function d3_scale_niceStep(step) {\n    return step ? {\n      floor: function(x) {\n        return Math.floor(x / step) * step;\n      },\n      ceil: function(x) {\n        return Math.ceil(x / step) * step;\n      }\n    } : d3_scale_niceIdentity;\n  }\n  var d3_scale_niceIdentity = {\n    floor: d3_identity,\n    ceil: d3_identity\n  };\n  function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {\n    var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;\n    if (domain[k] < domain[0]) {\n      domain = domain.slice().reverse();\n      range = range.slice().reverse();\n    }\n    while (++j <= k) {\n      u.push(uninterpolate(domain[j - 1], domain[j]));\n      i.push(interpolate(range[j - 1], range[j]));\n    }\n    return function(x) {\n      var j = d3.bisect(domain, x, 1, k) - 1;\n      return i[j](u[j](x));\n    };\n  }\n  d3.scale.linear = function() {\n    return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3_interpolate, false);\n  };\n  function d3_scale_linear(domain, range, interpolate, clamp) {\n    var output, input;\n    function rescale() {\n      var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;\n      output = linear(domain, range, uninterpolate, interpolate);\n      input = linear(range, domain, uninterpolate, d3_interpolate);\n      return scale;\n    }\n    function scale(x) {\n      return output(x);\n    }\n    scale.invert = function(y) {\n      return input(y);\n    };\n    scale.domain = function(x) {\n      if (!arguments.length) return domain;\n      domain = x.map(Number);\n      return rescale();\n    };\n    scale.range = function(x) {\n      if (!arguments.length) return range;\n      range = x;\n      return rescale();\n    };\n    scale.rangeRound = function(x) {\n      return scale.range(x).interpolate(d3_interpolateRound);\n    };\n    scale.clamp = function(x) {\n      if (!arguments.length) return clamp;\n      clamp = x;\n      return rescale();\n    };\n    scale.interpolate = function(x) {\n      if (!arguments.length) return interpolate;\n      interpolate = x;\n      return rescale();\n    };\n    scale.ticks = function(m) {\n      return d3_scale_linearTicks(domain, m);\n    };\n    scale.tickFormat = function(m, format) {\n      return d3_scale_linearTickFormat(domain, m, format);\n    };\n    scale.nice = function(m) {\n      d3_scale_linearNice(domain, m);\n      return rescale();\n    };\n    scale.copy = function() {\n      return d3_scale_linear(domain, range, interpolate, clamp);\n    };\n    return rescale();\n  }\n  function d3_scale_linearRebind(scale, linear) {\n    return d3.rebind(scale, linear, \"range\", \"rangeRound\", \"interpolate\", \"clamp\");\n  }\n  function d3_scale_linearNice(domain, m) {\n    d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));\n    d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));\n    return domain;\n  }\n  function d3_scale_linearTickRange(domain, m) {\n    if (m == null) m = 10;\n    var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;\n    if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;\n    extent[0] = Math.ceil(extent[0] / step) * step;\n    extent[1] = Math.floor(extent[1] / step) * step + step * .5;\n    extent[2] = step;\n    return extent;\n  }\n  function d3_scale_linearTicks(domain, m) {\n    return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));\n  }\n  function d3_scale_linearTickFormat(domain, m, format) {\n    var range = d3_scale_linearTickRange(domain, m);\n    if (format) {\n      var match = d3_format_re.exec(format);\n      match.shift();\n      if (match[8] === \"s\") {\n        var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));\n        if (!match[7]) match[7] = \".\" + d3_scale_linearPrecision(prefix.scale(range[2]));\n        match[8] = \"f\";\n        format = d3.format(match.join(\"\"));\n        return function(d) {\n          return format(prefix.scale(d)) + prefix.symbol;\n        };\n      }\n      if (!match[7]) match[7] = \".\" + d3_scale_linearFormatPrecision(match[8], range);\n      format = match.join(\"\");\n    } else {\n      format = \",.\" + d3_scale_linearPrecision(range[2]) + \"f\";\n    }\n    return d3.format(format);\n  }\n  var d3_scale_linearFormatSignificant = {\n    s: 1,\n    g: 1,\n    p: 1,\n    r: 1,\n    e: 1\n  };\n  function d3_scale_linearPrecision(value) {\n    return -Math.floor(Math.log(value) / Math.LN10 + .01);\n  }\n  function d3_scale_linearFormatPrecision(type, range) {\n    var p = d3_scale_linearPrecision(range[2]);\n    return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== \"e\") : p - (type === \"%\") * 2;\n  }\n  d3.scale.log = function() {\n    return d3_scale_log(d3.scale.linear().domain([ 0, 1 ]), 10, true, [ 1, 10 ]);\n  };\n  function d3_scale_log(linear, base, positive, domain) {\n    function log(x) {\n      return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);\n    }\n    function pow(x) {\n      return positive ? Math.pow(base, x) : -Math.pow(base, -x);\n    }\n    function scale(x) {\n      return linear(log(x));\n    }\n    scale.invert = function(x) {\n      return pow(linear.invert(x));\n    };\n    scale.domain = function(x) {\n      if (!arguments.length) return domain;\n      positive = x[0] >= 0;\n      linear.domain((domain = x.map(Number)).map(log));\n      return scale;\n    };\n    scale.base = function(_) {\n      if (!arguments.length) return base;\n      base = +_;\n      linear.domain(domain.map(log));\n      return scale;\n    };\n    scale.nice = function() {\n      var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);\n      linear.domain(niced);\n      domain = niced.map(pow);\n      return scale;\n    };\n    scale.ticks = function() {\n      var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;\n      if (isFinite(j - i)) {\n        if (positive) {\n          for (;i < j; i++) for (var k = 1; k < n; k++) ticks.push(pow(i) * k);\n          ticks.push(pow(i));\n        } else {\n          ticks.push(pow(i));\n          for (;i++ < j; ) for (var k = n - 1; k > 0; k--) ticks.push(pow(i) * k);\n        }\n        for (i = 0; ticks[i] < u; i++) {}\n        for (j = ticks.length; ticks[j - 1] > v; j--) {}\n        ticks = ticks.slice(i, j);\n      }\n      return ticks;\n    };\n    scale.tickFormat = function(n, format) {\n      if (!arguments.length) return d3_scale_logFormat;\n      if (arguments.length < 2) format = d3_scale_logFormat; else if (typeof format !== \"function\") format = d3.format(format);\n      var k = Math.max(1, base * n / scale.ticks().length);\n      return function(d) {\n        var i = d / pow(Math.round(log(d)));\n        if (i * base < base - .5) i *= base;\n        return i <= k ? format(d) : \"\";\n      };\n    };\n    scale.copy = function() {\n      return d3_scale_log(linear.copy(), base, positive, domain);\n    };\n    return d3_scale_linearRebind(scale, linear);\n  }\n  var d3_scale_logFormat = d3.format(\".0e\"), d3_scale_logNiceNegative = {\n    floor: function(x) {\n      return -Math.ceil(-x);\n    },\n    ceil: function(x) {\n      return -Math.floor(-x);\n    }\n  };\n  d3.scale.pow = function() {\n    return d3_scale_pow(d3.scale.linear(), 1, [ 0, 1 ]);\n  };\n  function d3_scale_pow(linear, exponent, domain) {\n    var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);\n    function scale(x) {\n      return linear(powp(x));\n    }\n    scale.invert = function(x) {\n      return powb(linear.invert(x));\n    };\n    scale.domain = function(x) {\n      if (!arguments.length) return domain;\n      linear.domain((domain = x.map(Number)).map(powp));\n      return scale;\n    };\n    scale.ticks = function(m) {\n      return d3_scale_linearTicks(domain, m);\n    };\n    scale.tickFormat = function(m, format) {\n      return d3_scale_linearTickFormat(domain, m, format);\n    };\n    scale.nice = function(m) {\n      return scale.domain(d3_scale_linearNice(domain, m));\n    };\n    scale.exponent = function(x) {\n      if (!arguments.length) return exponent;\n      powp = d3_scale_powPow(exponent = x);\n      powb = d3_scale_powPow(1 / exponent);\n      linear.domain(domain.map(powp));\n      return scale;\n    };\n    scale.copy = function() {\n      return d3_scale_pow(linear.copy(), exponent, domain);\n    };\n    return d3_scale_linearRebind(scale, linear);\n  }\n  function d3_scale_powPow(e) {\n    return function(x) {\n      return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);\n    };\n  }\n  d3.scale.sqrt = function() {\n    return d3.scale.pow().exponent(.5);\n  };\n  d3.scale.ordinal = function() {\n    return d3_scale_ordinal([], {\n      t: \"range\",\n      a: [ [] ]\n    });\n  };\n  function d3_scale_ordinal(domain, ranger) {\n    var index, range, rangeBand;\n    function scale(x) {\n      return range[((index.get(x) || (ranger.t === \"range\" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];\n    }\n    function steps(start, step) {\n      return d3.range(domain.length).map(function(i) {\n        return start + step * i;\n      });\n    }\n    scale.domain = function(x) {\n      if (!arguments.length) return domain;\n      domain = [];\n      index = new d3_Map();\n      var i = -1, n = x.length, xi;\n      while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));\n      return scale[ranger.t].apply(scale, ranger.a);\n    };\n    scale.range = function(x) {\n      if (!arguments.length) return range;\n      range = x;\n      rangeBand = 0;\n      ranger = {\n        t: \"range\",\n        a: arguments\n      };\n      return scale;\n    };\n    scale.rangePoints = function(x, padding) {\n      if (arguments.length < 2) padding = 0;\n      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = (start + stop) / 2, \n      0) : (stop - start) / (domain.length - 1 + padding);\n      range = steps(start + step * padding / 2, step);\n      rangeBand = 0;\n      ranger = {\n        t: \"rangePoints\",\n        a: arguments\n      };\n      return scale;\n    };\n    scale.rangeRoundPoints = function(x, padding) {\n      if (arguments.length < 2) padding = 0;\n      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2), \n      0) : (stop - start) / (domain.length - 1 + padding) | 0;\n      range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);\n      rangeBand = 0;\n      ranger = {\n        t: \"rangeRoundPoints\",\n        a: arguments\n      };\n      return scale;\n    };\n    scale.rangeBands = function(x, padding, outerPadding) {\n      if (arguments.length < 2) padding = 0;\n      if (arguments.length < 3) outerPadding = padding;\n      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);\n      range = steps(start + step * outerPadding, step);\n      if (reverse) range.reverse();\n      rangeBand = step * (1 - padding);\n      ranger = {\n        t: \"rangeBands\",\n        a: arguments\n      };\n      return scale;\n    };\n    scale.rangeRoundBands = function(x, padding, outerPadding) {\n      if (arguments.length < 2) padding = 0;\n      if (arguments.length < 3) outerPadding = padding;\n      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));\n      range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);\n      if (reverse) range.reverse();\n      rangeBand = Math.round(step * (1 - padding));\n      ranger = {\n        t: \"rangeRoundBands\",\n        a: arguments\n      };\n      return scale;\n    };\n    scale.rangeBand = function() {\n      return rangeBand;\n    };\n    scale.rangeExtent = function() {\n      return d3_scaleExtent(ranger.a[0]);\n    };\n    scale.copy = function() {\n      return d3_scale_ordinal(domain, ranger);\n    };\n    return scale.domain(domain);\n  }\n  d3.scale.category10 = function() {\n    return d3.scale.ordinal().range(d3_category10);\n  };\n  d3.scale.category20 = function() {\n    return d3.scale.ordinal().range(d3_category20);\n  };\n  d3.scale.category20b = function() {\n    return d3.scale.ordinal().range(d3_category20b);\n  };\n  d3.scale.category20c = function() {\n    return d3.scale.ordinal().range(d3_category20c);\n  };\n  var d3_category10 = [ 2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175 ].map(d3_rgbString);\n  var d3_category20 = [ 2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725 ].map(d3_rgbString);\n  var d3_category20b = [ 3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654 ].map(d3_rgbString);\n  var d3_category20c = [ 3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081 ].map(d3_rgbString);\n  d3.scale.quantile = function() {\n    return d3_scale_quantile([], []);\n  };\n  function d3_scale_quantile(domain, range) {\n    var thresholds;\n    function rescale() {\n      var k = 0, q = range.length;\n      thresholds = [];\n      while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);\n      return scale;\n    }\n    function scale(x) {\n      if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)];\n    }\n    scale.domain = function(x) {\n      if (!arguments.length) return domain;\n      domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);\n      return rescale();\n    };\n    scale.range = function(x) {\n      if (!arguments.length) return range;\n      range = x;\n      return rescale();\n    };\n    scale.quantiles = function() {\n      return thresholds;\n    };\n    scale.invertExtent = function(y) {\n      y = range.indexOf(y);\n      return y < 0 ? [ NaN, NaN ] : [ y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1] ];\n    };\n    scale.copy = function() {\n      return d3_scale_quantile(domain, range);\n    };\n    return rescale();\n  }\n  d3.scale.quantize = function() {\n    return d3_scale_quantize(0, 1, [ 0, 1 ]);\n  };\n  function d3_scale_quantize(x0, x1, range) {\n    var kx, i;\n    function scale(x) {\n      return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];\n    }\n    function rescale() {\n      kx = range.length / (x1 - x0);\n      i = range.length - 1;\n      return scale;\n    }\n    scale.domain = function(x) {\n      if (!arguments.length) return [ x0, x1 ];\n      x0 = +x[0];\n      x1 = +x[x.length - 1];\n      return rescale();\n    };\n    scale.range = function(x) {\n      if (!arguments.length) return range;\n      range = x;\n      return rescale();\n    };\n    scale.invertExtent = function(y) {\n      y = range.indexOf(y);\n      y = y < 0 ? NaN : y / kx + x0;\n      return [ y, y + 1 / kx ];\n    };\n    scale.copy = function() {\n      return d3_scale_quantize(x0, x1, range);\n    };\n    return rescale();\n  }\n  d3.scale.threshold = function() {\n    return d3_scale_threshold([ .5 ], [ 0, 1 ]);\n  };\n  function d3_scale_threshold(domain, range) {\n    function scale(x) {\n      if (x <= x) return range[d3.bisect(domain, x)];\n    }\n    scale.domain = function(_) {\n      if (!arguments.length) return domain;\n      domain = _;\n      return scale;\n    };\n    scale.range = function(_) {\n      if (!arguments.length) return range;\n      range = _;\n      return scale;\n    };\n    scale.invertExtent = function(y) {\n      y = range.indexOf(y);\n      return [ domain[y - 1], domain[y] ];\n    };\n    scale.copy = function() {\n      return d3_scale_threshold(domain, range);\n    };\n    return scale;\n  }\n  d3.scale.identity = function() {\n    return d3_scale_identity([ 0, 1 ]);\n  };\n  function d3_scale_identity(domain) {\n    function identity(x) {\n      return +x;\n    }\n    identity.invert = identity;\n    identity.domain = identity.range = function(x) {\n      if (!arguments.length) return domain;\n      domain = x.map(identity);\n      return identity;\n    };\n    identity.ticks = function(m) {\n      return d3_scale_linearTicks(domain, m);\n    };\n    identity.tickFormat = function(m, format) {\n      return d3_scale_linearTickFormat(domain, m, format);\n    };\n    identity.copy = function() {\n      return d3_scale_identity(domain);\n    };\n    return identity;\n  }\n  d3.svg = {};\n  function d3_zero() {\n    return 0;\n  }\n  d3.svg.arc = function() {\n    var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle;\n    function arc() {\n      var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - half, a1 = endAngle.apply(this, arguments) - half, da = Math.abs(a1 - a0), cw = a0 > a1 ? 0 : 1;\n      if (r1 < r0) rc = r1, r1 = r0, r0 = rc;\n      if (da >= ) return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : \"\") + \"Z\";\n      var rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x2, y2, x3, y3, path = [];\n      if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {\n        rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);\n        if (!cw) p1 *= -1;\n        if (r1) p1 = d3_asin(rp / r1 * Math.sin(ap));\n        if (r0) p0 = d3_asin(rp / r0 * Math.sin(ap));\n      }\n      if (r1) {\n        x0 = r1 * Math.cos(a0 + p1);\n        y0 = r1 * Math.sin(a0 + p1);\n        x1 = r1 * Math.cos(a1 - p1);\n        y1 = r1 * Math.sin(a1 - p1);\n        var l1 = Math.abs(a1 - a0 - 2 * p1) <=  ? 0 : 1;\n        if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {\n          var h1 = (a0 + a1) / 2;\n          x0 = r1 * Math.cos(h1);\n          y0 = r1 * Math.sin(h1);\n          x1 = y1 = null;\n        }\n      } else {\n        x0 = y0 = 0;\n      }\n      if (r0) {\n        x2 = r0 * Math.cos(a1 - p0);\n        y2 = r0 * Math.sin(a1 - p0);\n        x3 = r0 * Math.cos(a0 + p0);\n        y3 = r0 * Math.sin(a0 + p0);\n        var l0 = Math.abs(a0 - a1 + 2 * p0) <=  ? 0 : 1;\n        if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {\n          var h0 = (a0 + a1) / 2;\n          x2 = r0 * Math.cos(h0);\n          y2 = r0 * Math.sin(h0);\n          x3 = y3 = null;\n        }\n      } else {\n        x2 = y2 = 0;\n      }\n      if (da >  && (rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > .001) {\n        cr = r0 < r1 ^ cw ? 0 : 1;\n        var rc1 = rc, rc0 = rc;\n        if (da < ) {\n          var oc = x3 == null ? [ x2, y2 ] : x1 == null ? [ x0, y0 ] : d3_geom_polygonIntersect([ x0, y0 ], [ x3, y3 ], [ x1, y1 ], [ x2, y2 ]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2), lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);\n          rc0 = Math.min(rc, (r0 - lc) / (kc - 1));\n          rc1 = Math.min(rc, (r1 - lc) / (kc + 1));\n        }\n        if (x1 != null) {\n          var t30 = d3_svg_arcCornerTangents(x3 == null ? [ x2, y2 ] : [ x3, y3 ], [ x0, y0 ], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([ x1, y1 ], [ x2, y2 ], r1, rc1, cw);\n          if (rc === rc1) {\n            path.push(\"M\", t30[0], \"A\", rc1, \",\", rc1, \" 0 0,\", cr, \" \", t30[1], \"A\", r1, \",\", r1, \" 0 \", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), \",\", cw, \" \", t12[1], \"A\", rc1, \",\", rc1, \" 0 0,\", cr, \" \", t12[0]);\n          } else {\n            path.push(\"M\", t30[0], \"A\", rc1, \",\", rc1, \" 0 1,\", cr, \" \", t12[0]);\n          }\n        } else {\n          path.push(\"M\", x0, \",\", y0);\n        }\n        if (x3 != null) {\n          var t03 = d3_svg_arcCornerTangents([ x0, y0 ], [ x3, y3 ], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([ x2, y2 ], x1 == null ? [ x0, y0 ] : [ x1, y1 ], r0, -rc0, cw);\n          if (rc === rc0) {\n            path.push(\"L\", t21[0], \"A\", rc0, \",\", rc0, \" 0 0,\", cr, \" \", t21[1], \"A\", r0, \",\", r0, \" 0 \", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), \",\", 1 - cw, \" \", t03[1], \"A\", rc0, \",\", rc0, \" 0 0,\", cr, \" \", t03[0]);\n          } else {\n            path.push(\"L\", t21[0], \"A\", rc0, \",\", rc0, \" 0 0,\", cr, \" \", t03[0]);\n          }\n        } else {\n          path.push(\"L\", x2, \",\", y2);\n        }\n      } else {\n        path.push(\"M\", x0, \",\", y0);\n        if (x1 != null) path.push(\"A\", r1, \",\", r1, \" 0 \", l1, \",\", cw, \" \", x1, \",\", y1);\n        path.push(\"L\", x2, \",\", y2);\n        if (x3 != null) path.push(\"A\", r0, \",\", r0, \" 0 \", l0, \",\", 1 - cw, \" \", x3, \",\", y3);\n      }\n      path.push(\"Z\");\n      return path.join(\"\");\n    }\n    function circleSegment(r1, cw) {\n      return \"M0,\" + r1 + \"A\" + r1 + \",\" + r1 + \" 0 1,\" + cw + \" 0,\" + -r1 + \"A\" + r1 + \",\" + r1 + \" 0 1,\" + cw + \" 0,\" + r1;\n    }\n    arc.innerRadius = function(v) {\n      if (!arguments.length) return innerRadius;\n      innerRadius = d3_functor(v);\n      return arc;\n    };\n    arc.outerRadius = function(v) {\n      if (!arguments.length) return outerRadius;\n      outerRadius = d3_functor(v);\n      return arc;\n    };\n    arc.cornerRadius = function(v) {\n      if (!arguments.length) return cornerRadius;\n      cornerRadius = d3_functor(v);\n      return arc;\n    };\n    arc.padRadius = function(v) {\n      if (!arguments.length) return padRadius;\n      padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);\n      return arc;\n    };\n    arc.startAngle = function(v) {\n      if (!arguments.length) return startAngle;\n      startAngle = d3_functor(v);\n      return arc;\n    };\n    arc.endAngle = function(v) {\n      if (!arguments.length) return endAngle;\n      endAngle = d3_functor(v);\n      return arc;\n    };\n    arc.padAngle = function(v) {\n      if (!arguments.length) return padAngle;\n      padAngle = d3_functor(v);\n      return arc;\n    };\n    arc.centroid = function() {\n      var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - half;\n      return [ Math.cos(a) * r, Math.sin(a) * r ];\n    };\n    return arc;\n  };\n  var d3_svg_arcAuto = \"auto\";\n  function d3_svg_arcInnerRadius(d) {\n    return d.innerRadius;\n  }\n  function d3_svg_arcOuterRadius(d) {\n    return d.outerRadius;\n  }\n  function d3_svg_arcStartAngle(d) {\n    return d.startAngle;\n  }\n  function d3_svg_arcEndAngle(d) {\n    return d.endAngle;\n  }\n  function d3_svg_arcPadAngle(d) {\n    return d && d.padAngle;\n  }\n  function d3_svg_arcSweep(x0, y0, x1, y1) {\n    return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;\n  }\n  function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {\n    var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx * dx + dy * dy, r = r1 - rc, D = x1 * y2 - x2 * y1, d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;\n    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;\n    return [ [ cx0 - ox, cy0 - oy ], [ cx0 * r1 / r, cy0 * r1 / r ] ];\n  }\n  function d3_svg_line(projection) {\n    var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;\n    function line(data) {\n      var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);\n      function segment() {\n        segments.push(\"M\", interpolate(projection(points), tension));\n      }\n      while (++i < n) {\n        if (defined.call(this, d = data[i], i)) {\n          points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);\n        } else if (points.length) {\n          segment();\n          points = [];\n        }\n      }\n      if (points.length) segment();\n      return segments.length ? segments.join(\"\") : null;\n    }\n    line.x = function(_) {\n      if (!arguments.length) return x;\n      x = _;\n      return line;\n    };\n    line.y = function(_) {\n      if (!arguments.length) return y;\n      y = _;\n      return line;\n    };\n    line.defined = function(_) {\n      if (!arguments.length) return defined;\n      defined = _;\n      return line;\n    };\n    line.interpolate = function(_) {\n      if (!arguments.length) return interpolateKey;\n      if (typeof _ === \"function\") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;\n      return line;\n    };\n    line.tension = function(_) {\n      if (!arguments.length) return tension;\n      tension = _;\n      return line;\n    };\n    return line;\n  }\n  d3.svg.line = function() {\n    return d3_svg_line(d3_identity);\n  };\n  var d3_svg_lineInterpolators = d3.map({\n    linear: d3_svg_lineLinear,\n    \"linear-closed\": d3_svg_lineLinearClosed,\n    step: d3_svg_lineStep,\n    \"step-before\": d3_svg_lineStepBefore,\n    \"step-after\": d3_svg_lineStepAfter,\n    basis: d3_svg_lineBasis,\n    \"basis-open\": d3_svg_lineBasisOpen,\n    \"basis-closed\": d3_svg_lineBasisClosed,\n    bundle: d3_svg_lineBundle,\n    cardinal: d3_svg_lineCardinal,\n    \"cardinal-open\": d3_svg_lineCardinalOpen,\n    \"cardinal-closed\": d3_svg_lineCardinalClosed,\n    monotone: d3_svg_lineMonotone\n  });\n  d3_svg_lineInterpolators.forEach(function(key, value) {\n    value.key = key;\n    value.closed = /-closed$/.test(key);\n  });\n  function d3_svg_lineLinear(points) {\n    return points.length > 1 ? points.join(\"L\") : points + \"Z\";\n  }\n  function d3_svg_lineLinearClosed(points) {\n    return points.join(\"L\") + \"Z\";\n  }\n  function d3_svg_lineStep(points) {\n    var i = 0, n = points.length, p = points[0], path = [ p[0], \",\", p[1] ];\n    while (++i < n) path.push(\"H\", (p[0] + (p = points[i])[0]) / 2, \"V\", p[1]);\n    if (n > 1) path.push(\"H\", p[0]);\n    return path.join(\"\");\n  }\n  function d3_svg_lineStepBefore(points) {\n    var i = 0, n = points.length, p = points[0], path = [ p[0], \",\", p[1] ];\n    while (++i < n) path.push(\"V\", (p = points[i])[1], \"H\", p[0]);\n    return path.join(\"\");\n  }\n  function d3_svg_lineStepAfter(points) {\n    var i = 0, n = points.length, p = points[0], path = [ p[0], \",\", p[1] ];\n    while (++i < n) path.push(\"H\", (p = points[i])[0], \"V\", p[1]);\n    return path.join(\"\");\n  }\n  function d3_svg_lineCardinalOpen(points, tension) {\n    return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));\n  }\n  function d3_svg_lineCardinalClosed(points, tension) {\n    return points.length < 3 ? d3_svg_lineLinearClosed(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), \n    points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));\n  }\n  function d3_svg_lineCardinal(points, tension) {\n    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));\n  }\n  function d3_svg_lineHermite(points, tangents) {\n    if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {\n      return d3_svg_lineLinear(points);\n    }\n    var quad = points.length != tangents.length, path = \"\", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;\n    if (quad) {\n      path += \"Q\" + (p[0] - t0[0] * 2 / 3) + \",\" + (p[1] - t0[1] * 2 / 3) + \",\" + p[0] + \",\" + p[1];\n      p0 = points[1];\n      pi = 2;\n    }\n    if (tangents.length > 1) {\n      t = tangents[1];\n      p = points[pi];\n      pi++;\n      path += \"C\" + (p0[0] + t0[0]) + \",\" + (p0[1] + t0[1]) + \",\" + (p[0] - t[0]) + \",\" + (p[1] - t[1]) + \",\" + p[0] + \",\" + p[1];\n      for (var i = 2; i < tangents.length; i++, pi++) {\n        p = points[pi];\n        t = tangents[i];\n        path += \"S\" + (p[0] - t[0]) + \",\" + (p[1] - t[1]) + \",\" + p[0] + \",\" + p[1];\n      }\n    }\n    if (quad) {\n      var lp = points[pi];\n      path += \"Q\" + (p[0] + t[0] * 2 / 3) + \",\" + (p[1] + t[1] * 2 / 3) + \",\" + lp[0] + \",\" + lp[1];\n    }\n    return path;\n  }\n  function d3_svg_lineCardinalTangents(points, tension) {\n    var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;\n    while (++i < n) {\n      p0 = p1;\n      p1 = p2;\n      p2 = points[i];\n      tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);\n    }\n    return tangents;\n  }\n  function d3_svg_lineBasis(points) {\n    if (points.length < 3) return d3_svg_lineLinear(points);\n    var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, \",\", y0, \"L\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];\n    points.push(points[n - 1]);\n    while (++i <= n) {\n      pi = points[i];\n      px.shift();\n      px.push(pi[0]);\n      py.shift();\n      py.push(pi[1]);\n      d3_svg_lineBasisBezier(path, px, py);\n    }\n    points.pop();\n    path.push(\"L\", pi);\n    return path.join(\"\");\n  }\n  function d3_svg_lineBasisOpen(points) {\n    if (points.length < 4) return d3_svg_lineLinear(points);\n    var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];\n    while (++i < 3) {\n      pi = points[i];\n      px.push(pi[0]);\n      py.push(pi[1]);\n    }\n    path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + \",\" + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));\n    --i;\n    while (++i < n) {\n      pi = points[i];\n      px.shift();\n      px.push(pi[0]);\n      py.shift();\n      py.push(pi[1]);\n      d3_svg_lineBasisBezier(path, px, py);\n    }\n    return path.join(\"\");\n  }\n  function d3_svg_lineBasisClosed(points) {\n    var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];\n    while (++i < 4) {\n      pi = points[i % n];\n      px.push(pi[0]);\n      py.push(pi[1]);\n    }\n    path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];\n    --i;\n    while (++i < m) {\n      pi = points[i % n];\n      px.shift();\n      px.push(pi[0]);\n      py.shift();\n      py.push(pi[1]);\n      d3_svg_lineBasisBezier(path, px, py);\n    }\n    return path.join(\"\");\n  }\n  function d3_svg_lineBundle(points, tension) {\n    var n = points.length - 1;\n    if (n) {\n      var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;\n      while (++i <= n) {\n        p = points[i];\n        t = i / n;\n        p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);\n        p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);\n      }\n    }\n    return d3_svg_lineBasis(points);\n  }\n  function d3_svg_lineDot4(a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n  }\n  var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];\n  function d3_svg_lineBasisBezier(path, x, y) {\n    path.push(\"C\", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));\n  }\n  function d3_svg_lineSlope(p0, p1) {\n    return (p1[1] - p0[1]) / (p1[0] - p0[0]);\n  }\n  function d3_svg_lineFiniteDifferences(points) {\n    var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);\n    while (++i < j) {\n      m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;\n    }\n    m[i] = d;\n    return m;\n  }\n  function d3_svg_lineMonotoneTangents(points) {\n    var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;\n    while (++i < j) {\n      d = d3_svg_lineSlope(points[i], points[i + 1]);\n      if (abs(d) < ) {\n        m[i] = m[i + 1] = 0;\n      } else {\n        a = m[i] / d;\n        b = m[i + 1] / d;\n        s = a * a + b * b;\n        if (s > 9) {\n          s = d * 3 / Math.sqrt(s);\n          m[i] = s * a;\n          m[i + 1] = s * b;\n        }\n      }\n    }\n    i = -1;\n    while (++i <= j) {\n      s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));\n      tangents.push([ s || 0, m[i] * s || 0 ]);\n    }\n    return tangents;\n  }\n  function d3_svg_lineMonotone(points) {\n    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));\n  }\n  d3.svg.line.radial = function() {\n    var line = d3_svg_line(d3_svg_lineRadial);\n    line.radius = line.x, delete line.x;\n    line.angle = line.y, delete line.y;\n    return line;\n  };\n  function d3_svg_lineRadial(points) {\n    var point, i = -1, n = points.length, r, a;\n    while (++i < n) {\n      point = points[i];\n      r = point[0];\n      a = point[1] - half;\n      point[0] = r * Math.cos(a);\n      point[1] = r * Math.sin(a);\n    }\n    return points;\n  }\n  function d3_svg_area(projection) {\n    var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = \"L\", tension = .7;\n    function area(data) {\n      var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {\n        return x;\n      } : d3_functor(x1), fy1 = y0 === y1 ? function() {\n        return y;\n      } : d3_functor(y1), x, y;\n      function segment() {\n        segments.push(\"M\", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), \"Z\");\n      }\n      while (++i < n) {\n        if (defined.call(this, d = data[i], i)) {\n          points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);\n          points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);\n        } else if (points0.length) {\n          segment();\n          points0 = [];\n          points1 = [];\n        }\n      }\n      if (points0.length) segment();\n      return segments.length ? segments.join(\"\") : null;\n    }\n    area.x = function(_) {\n      if (!arguments.length) return x1;\n      x0 = x1 = _;\n      return area;\n    };\n    area.x0 = function(_) {\n      if (!arguments.length) return x0;\n      x0 = _;\n      return area;\n    };\n    area.x1 = function(_) {\n      if (!arguments.length) return x1;\n      x1 = _;\n      return area;\n    };\n    area.y = function(_) {\n      if (!arguments.length) return y1;\n      y0 = y1 = _;\n      return area;\n    };\n    area.y0 = function(_) {\n      if (!arguments.length) return y0;\n      y0 = _;\n      return area;\n    };\n    area.y1 = function(_) {\n      if (!arguments.length) return y1;\n      y1 = _;\n      return area;\n    };\n    area.defined = function(_) {\n      if (!arguments.length) return defined;\n      defined = _;\n      return area;\n    };\n    area.interpolate = function(_) {\n      if (!arguments.length) return interpolateKey;\n      if (typeof _ === \"function\") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;\n      interpolateReverse = interpolate.reverse || interpolate;\n      L = interpolate.closed ? \"M\" : \"L\";\n      return area;\n    };\n    area.tension = function(_) {\n      if (!arguments.length) return tension;\n      tension = _;\n      return area;\n    };\n    return area;\n  }\n  d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;\n  d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;\n  d3.svg.area = function() {\n    return d3_svg_area(d3_identity);\n  };\n  d3.svg.area.radial = function() {\n    var area = d3_svg_area(d3_svg_lineRadial);\n    area.radius = area.x, delete area.x;\n    area.innerRadius = area.x0, delete area.x0;\n    area.outerRadius = area.x1, delete area.x1;\n    area.angle = area.y, delete area.y;\n    area.startAngle = area.y0, delete area.y0;\n    area.endAngle = area.y1, delete area.y1;\n    return area;\n  };\n  d3.svg.chord = function() {\n    var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;\n    function chord(d, i) {\n      var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);\n      return \"M\" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + \"Z\";\n    }\n    function subgroup(self, f, d, i) {\n      var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) - half, a1 = endAngle.call(self, subgroup, i) - half;\n      return {\n        r: r,\n        a0: a0,\n        a1: a1,\n        p0: [ r * Math.cos(a0), r * Math.sin(a0) ],\n        p1: [ r * Math.cos(a1), r * Math.sin(a1) ]\n      };\n    }\n    function equals(a, b) {\n      return a.a0 == b.a0 && a.a1 == b.a1;\n    }\n    function arc(r, p, a) {\n      return \"A\" + r + \",\" + r + \" 0 \" + +(a > ) + \",1 \" + p;\n    }\n    function curve(r0, p0, r1, p1) {\n      return \"Q 0,0 \" + p1;\n    }\n    chord.radius = function(v) {\n      if (!arguments.length) return radius;\n      radius = d3_functor(v);\n      return chord;\n    };\n    chord.source = function(v) {\n      if (!arguments.length) return source;\n      source = d3_functor(v);\n      return chord;\n    };\n    chord.target = function(v) {\n      if (!arguments.length) return target;\n      target = d3_functor(v);\n      return chord;\n    };\n    chord.startAngle = function(v) {\n      if (!arguments.length) return startAngle;\n      startAngle = d3_functor(v);\n      return chord;\n    };\n    chord.endAngle = function(v) {\n      if (!arguments.length) return endAngle;\n      endAngle = d3_functor(v);\n      return chord;\n    };\n    return chord;\n  };\n  function d3_svg_chordRadius(d) {\n    return d.radius;\n  }\n  d3.svg.diagonal = function() {\n    var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;\n    function diagonal(d, i) {\n      var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {\n        x: p0.x,\n        y: m\n      }, {\n        x: p3.x,\n        y: m\n      }, p3 ];\n      p = p.map(projection);\n      return \"M\" + p[0] + \"C\" + p[1] + \" \" + p[2] + \" \" + p[3];\n    }\n    diagonal.source = function(x) {\n      if (!arguments.length) return source;\n      source = d3_functor(x);\n      return diagonal;\n    };\n    diagonal.target = function(x) {\n      if (!arguments.length) return target;\n      target = d3_functor(x);\n      return diagonal;\n    };\n    diagonal.projection = function(x) {\n      if (!arguments.length) return projection;\n      projection = x;\n      return diagonal;\n    };\n    return diagonal;\n  };\n  function d3_svg_diagonalProjection(d) {\n    return [ d.x, d.y ];\n  }\n  d3.svg.diagonal.radial = function() {\n    var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;\n    diagonal.projection = function(x) {\n      return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;\n    };\n    return diagonal;\n  };\n  function d3_svg_diagonalRadialProjection(projection) {\n    return function() {\n      var d = projection.apply(this, arguments), r = d[0], a = d[1] - half;\n      return [ r * Math.cos(a), r * Math.sin(a) ];\n    };\n  }\n  d3.svg.symbol = function() {\n    var type = d3_svg_symbolType, size = d3_svg_symbolSize;\n    function symbol(d, i) {\n      return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));\n    }\n    symbol.type = function(x) {\n      if (!arguments.length) return type;\n      type = d3_functor(x);\n      return symbol;\n    };\n    symbol.size = function(x) {\n      if (!arguments.length) return size;\n      size = d3_functor(x);\n      return symbol;\n    };\n    return symbol;\n  };\n  function d3_svg_symbolSize() {\n    return 64;\n  }\n  function d3_svg_symbolType() {\n    return \"circle\";\n  }\n  function d3_svg_symbolCircle(size) {\n    var r = Math.sqrt(size / );\n    return \"M0,\" + r + \"A\" + r + \",\" + r + \" 0 1,1 0,\" + -r + \"A\" + r + \",\" + r + \" 0 1,1 0,\" + r + \"Z\";\n  }\n  var d3_svg_symbols = d3.map({\n    circle: d3_svg_symbolCircle,\n    cross: function(size) {\n      var r = Math.sqrt(size / 5) / 2;\n      return \"M\" + -3 * r + \",\" + -r + \"H\" + -r + \"V\" + -3 * r + \"H\" + r + \"V\" + -r + \"H\" + 3 * r + \"V\" + r + \"H\" + r + \"V\" + 3 * r + \"H\" + -r + \"V\" + r + \"H\" + -3 * r + \"Z\";\n    },\n    diamond: function(size) {\n      var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;\n      return \"M0,\" + -ry + \"L\" + rx + \",0\" + \" 0,\" + ry + \" \" + -rx + \",0\" + \"Z\";\n    },\n    square: function(size) {\n      var r = Math.sqrt(size) / 2;\n      return \"M\" + -r + \",\" + -r + \"L\" + r + \",\" + -r + \" \" + r + \",\" + r + \" \" + -r + \",\" + r + \"Z\";\n    },\n    \"triangle-down\": function(size) {\n      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;\n      return \"M0,\" + ry + \"L\" + rx + \",\" + -ry + \" \" + -rx + \",\" + -ry + \"Z\";\n    },\n    \"triangle-up\": function(size) {\n      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;\n      return \"M0,\" + -ry + \"L\" + rx + \",\" + ry + \" \" + -rx + \",\" + ry + \"Z\";\n    }\n  });\n  d3.svg.symbolTypes = d3_svg_symbols.keys();\n  var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);\n  d3_selectionPrototype.transition = function(name) {\n    var id = d3_transitionInheritId || ++d3_transitionId, ns = d3_transitionNamespace(name), subgroups = [], subgroup, node, transition = d3_transitionInherit || {\n      time: Date.now(),\n      ease: d3_ease_cubicInOut,\n      delay: 0,\n      duration: 250\n    };\n    for (var j = -1, m = this.length; ++j < m; ) {\n      subgroups.push(subgroup = []);\n      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {\n        if (node = group[i]) d3_transitionNode(node, i, ns, id, transition);\n        subgroup.push(node);\n      }\n    }\n    return d3_transition(subgroups, ns, id);\n  };\n  d3_selectionPrototype.interrupt = function(name) {\n    return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));\n  };\n  var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());\n  function d3_selection_interruptNS(ns) {\n    return function() {\n      var lock, activeId, active;\n      if ((lock = this[ns]) && (active = lock[activeId = lock.active])) {\n        active.timer.c = null;\n        active.timer.t = NaN;\n        if (--lock.count) delete lock[activeId]; else delete this[ns];\n        lock.active += .5;\n        active.event && active.event.interrupt.call(this, this.__data__, active.index);\n      }\n    };\n  }\n  function d3_transition(groups, ns, id) {\n    d3_subclass(groups, d3_transitionPrototype);\n    groups.namespace = ns;\n    groups.id = id;\n    return groups;\n  }\n  var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;\n  d3_transitionPrototype.call = d3_selectionPrototype.call;\n  d3_transitionPrototype.empty = d3_selectionPrototype.empty;\n  d3_transitionPrototype.node = d3_selectionPrototype.node;\n  d3_transitionPrototype.size = d3_selectionPrototype.size;\n  d3.transition = function(selection, name) {\n    return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection);\n  };\n  d3.transition.prototype = d3_transitionPrototype;\n  d3_transitionPrototype.select = function(selector) {\n    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnode, node;\n    selector = d3_selection_selector(selector);\n    for (var j = -1, m = this.length; ++j < m; ) {\n      subgroups.push(subgroup = []);\n      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {\n        if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {\n          if (\"__data__\" in node) subnode.__data__ = node.__data__;\n          d3_transitionNode(subnode, i, ns, id, node[ns][id]);\n          subgroup.push(subnode);\n        } else {\n          subgroup.push(null);\n        }\n      }\n    }\n    return d3_transition(subgroups, ns, id);\n  };\n  d3_transitionPrototype.selectAll = function(selector) {\n    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnodes, node, subnode, transition;\n    selector = d3_selection_selectorAll(selector);\n    for (var j = -1, m = this.length; ++j < m; ) {\n      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {\n        if (node = group[i]) {\n          transition = node[ns][id];\n          subnodes = selector.call(node, node.__data__, i, j);\n          subgroups.push(subgroup = []);\n          for (var k = -1, o = subnodes.length; ++k < o; ) {\n            if (subnode = subnodes[k]) d3_transitionNode(subnode, k, ns, id, transition);\n            subgroup.push(subnode);\n          }\n        }\n      }\n    }\n    return d3_transition(subgroups, ns, id);\n  };\n  d3_transitionPrototype.filter = function(filter) {\n    var subgroups = [], subgroup, group, node;\n    if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n    for (var j = 0, m = this.length; j < m; j++) {\n      subgroups.push(subgroup = []);\n      for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n          subgroup.push(node);\n        }\n      }\n    }\n    return d3_transition(subgroups, this.namespace, this.id);\n  };\n  d3_transitionPrototype.tween = function(name, tween) {\n    var id = this.id, ns = this.namespace;\n    if (arguments.length < 2) return this.node()[ns][id].tween.get(name);\n    return d3_selection_each(this, tween == null ? function(node) {\n      node[ns][id].tween.remove(name);\n    } : function(node) {\n      node[ns][id].tween.set(name, tween);\n    });\n  };\n  function d3_transition_tween(groups, name, value, tween) {\n    var id = groups.id, ns = groups.namespace;\n    return d3_selection_each(groups, typeof value === \"function\" ? function(node, i, j) {\n      node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));\n    } : (value = tween(value), function(node) {\n      node[ns][id].tween.set(name, value);\n    }));\n  }\n  d3_transitionPrototype.attr = function(nameNS, value) {\n    if (arguments.length < 2) {\n      for (value in nameNS) this.attr(value, nameNS[value]);\n      return this;\n    }\n    var interpolate = nameNS == \"transform\" ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);\n    function attrNull() {\n      this.removeAttribute(name);\n    }\n    function attrNullNS() {\n      this.removeAttributeNS(name.space, name.local);\n    }\n    function attrTween(b) {\n      return b == null ? attrNull : (b += \"\", function() {\n        var a = this.getAttribute(name), i;\n        return a !== b && (i = interpolate(a, b), function(t) {\n          this.setAttribute(name, i(t));\n        });\n      });\n    }\n    function attrTweenNS(b) {\n      return b == null ? attrNullNS : (b += \"\", function() {\n        var a = this.getAttributeNS(name.space, name.local), i;\n        return a !== b && (i = interpolate(a, b), function(t) {\n          this.setAttributeNS(name.space, name.local, i(t));\n        });\n      });\n    }\n    return d3_transition_tween(this, \"attr.\" + nameNS, value, name.local ? attrTweenNS : attrTween);\n  };\n  d3_transitionPrototype.attrTween = function(nameNS, tween) {\n    var name = d3.ns.qualify(nameNS);\n    function attrTween(d, i) {\n      var f = tween.call(this, d, i, this.getAttribute(name));\n      return f && function(t) {\n        this.setAttribute(name, f(t));\n      };\n    }\n    function attrTweenNS(d, i) {\n      var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));\n      return f && function(t) {\n        this.setAttributeNS(name.space, name.local, f(t));\n      };\n    }\n    return this.tween(\"attr.\" + nameNS, name.local ? attrTweenNS : attrTween);\n  };\n  d3_transitionPrototype.style = function(name, value, priority) {\n    var n = arguments.length;\n    if (n < 3) {\n      if (typeof name !== \"string\") {\n        if (n < 2) value = \"\";\n        for (priority in name) this.style(priority, name[priority], value);\n        return this;\n      }\n      priority = \"\";\n    }\n    function styleNull() {\n      this.style.removeProperty(name);\n    }\n    function styleString(b) {\n      return b == null ? styleNull : (b += \"\", function() {\n        var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name), i;\n        return a !== b && (i = d3_interpolate(a, b), function(t) {\n          this.style.setProperty(name, i(t), priority);\n        });\n      });\n    }\n    return d3_transition_tween(this, \"style.\" + name, value, styleString);\n  };\n  d3_transitionPrototype.styleTween = function(name, tween, priority) {\n    if (arguments.length < 3) priority = \"\";\n    function styleTween(d, i) {\n      var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));\n      return f && function(t) {\n        this.style.setProperty(name, f(t), priority);\n      };\n    }\n    return this.tween(\"style.\" + name, styleTween);\n  };\n  d3_transitionPrototype.text = function(value) {\n    return d3_transition_tween(this, \"text\", value, d3_transition_text);\n  };\n  function d3_transition_text(b) {\n    if (b == null) b = \"\";\n    return function() {\n      this.textContent = b;\n    };\n  }\n  d3_transitionPrototype.remove = function() {\n    var ns = this.namespace;\n    return this.each(\"end.transition\", function() {\n      var p;\n      if (this[ns].count < 2 && (p = this.parentNode)) p.removeChild(this);\n    });\n  };\n  d3_transitionPrototype.ease = function(value) {\n    var id = this.id, ns = this.namespace;\n    if (arguments.length < 1) return this.node()[ns][id].ease;\n    if (typeof value !== \"function\") value = d3.ease.apply(d3, arguments);\n    return d3_selection_each(this, function(node) {\n      node[ns][id].ease = value;\n    });\n  };\n  d3_transitionPrototype.delay = function(value) {\n    var id = this.id, ns = this.namespace;\n    if (arguments.length < 1) return this.node()[ns][id].delay;\n    return d3_selection_each(this, typeof value === \"function\" ? function(node, i, j) {\n      node[ns][id].delay = +value.call(node, node.__data__, i, j);\n    } : (value = +value, function(node) {\n      node[ns][id].delay = value;\n    }));\n  };\n  d3_transitionPrototype.duration = function(value) {\n    var id = this.id, ns = this.namespace;\n    if (arguments.length < 1) return this.node()[ns][id].duration;\n    return d3_selection_each(this, typeof value === \"function\" ? function(node, i, j) {\n      node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));\n    } : (value = Math.max(1, value), function(node) {\n      node[ns][id].duration = value;\n    }));\n  };\n  d3_transitionPrototype.each = function(type, listener) {\n    var id = this.id, ns = this.namespace;\n    if (arguments.length < 2) {\n      var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;\n      try {\n        d3_transitionInheritId = id;\n        d3_selection_each(this, function(node, i, j) {\n          d3_transitionInherit = node[ns][id];\n          type.call(node, node.__data__, i, j);\n        });\n      } finally {\n        d3_transitionInherit = inherit;\n        d3_transitionInheritId = inheritId;\n      }\n    } else {\n      d3_selection_each(this, function(node) {\n        var transition = node[ns][id];\n        (transition.event || (transition.event = d3.dispatch(\"start\", \"end\", \"interrupt\"))).on(type, listener);\n      });\n    }\n    return this;\n  };\n  d3_transitionPrototype.transition = function() {\n    var id0 = this.id, id1 = ++d3_transitionId, ns = this.namespace, subgroups = [], subgroup, group, node, transition;\n    for (var j = 0, m = this.length; j < m; j++) {\n      subgroups.push(subgroup = []);\n      for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n        if (node = group[i]) {\n          transition = node[ns][id0];\n          d3_transitionNode(node, i, ns, id1, {\n            time: transition.time,\n            ease: transition.ease,\n            delay: transition.delay + transition.duration,\n            duration: transition.duration\n          });\n        }\n        subgroup.push(node);\n      }\n    }\n    return d3_transition(subgroups, ns, id1);\n  };\n  function d3_transitionNamespace(name) {\n    return name == null ? \"__transition__\" : \"__transition_\" + name + \"__\";\n  }\n  function d3_transitionNode(node, i, ns, id, inherit) {\n    var lock = node[ns] || (node[ns] = {\n      active: 0,\n      count: 0\n    }), transition = lock[id], time, timer, duration, ease, tweens;\n    function schedule(elapsed) {\n      var delay = transition.delay;\n      timer.t = delay + time;\n      if (delay <= elapsed) return start(elapsed - delay);\n      timer.c = start;\n    }\n    function start(elapsed) {\n      var activeId = lock.active, active = lock[activeId];\n      if (active) {\n        active.timer.c = null;\n        active.timer.t = NaN;\n        --lock.count;\n        delete lock[activeId];\n        active.event && active.event.interrupt.call(node, node.__data__, active.index);\n      }\n      for (var cancelId in lock) {\n        if (+cancelId < id) {\n          var cancel = lock[cancelId];\n          cancel.timer.c = null;\n          cancel.timer.t = NaN;\n          --lock.count;\n          delete lock[cancelId];\n        }\n      }\n      timer.c = tick;\n      d3_timer(function() {\n        if (timer.c && tick(elapsed || 1)) {\n          timer.c = null;\n          timer.t = NaN;\n        }\n        return 1;\n      }, 0, time);\n      lock.active = id;\n      transition.event && transition.event.start.call(node, node.__data__, i);\n      tweens = [];\n      transition.tween.forEach(function(key, value) {\n        if (value = value.call(node, node.__data__, i)) {\n          tweens.push(value);\n        }\n      });\n      ease = transition.ease;\n      duration = transition.duration;\n    }\n    function tick(elapsed) {\n      var t = elapsed / duration, e = ease(t), n = tweens.length;\n      while (n > 0) {\n        tweens[--n].call(node, e);\n      }\n      if (t >= 1) {\n        transition.event && transition.event.end.call(node, node.__data__, i);\n        if (--lock.count) delete lock[id]; else delete node[ns];\n        return 1;\n      }\n    }\n    if (!transition) {\n      time = inherit.time;\n      timer = d3_timer(schedule, 0, time);\n      transition = lock[id] = {\n        tween: new d3_Map(),\n        time: time,\n        timer: timer,\n        delay: inherit.delay,\n        duration: inherit.duration,\n        ease: inherit.ease,\n        index: i\n      };\n      inherit = null;\n      ++lock.count;\n    }\n  }\n  d3.svg.axis = function() {\n    var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_;\n    function axis(g) {\n      g.each(function() {\n        var g = d3.select(this);\n        var scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();\n        var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll(\".tick\").data(ticks, scale1), tickEnter = tick.enter().insert(\"g\", \".domain\").attr(\"class\", \"tick\").style(\"opacity\", ), tickExit = d3.transition(tick.exit()).style(\"opacity\", ).remove(), tickUpdate = d3.transition(tick.order()).style(\"opacity\", 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, tickTransform;\n        var range = d3_scaleRange(scale1), path = g.selectAll(\".domain\").data([ 0 ]), pathUpdate = (path.enter().append(\"path\").attr(\"class\", \"domain\"), \n        d3.transition(path));\n        tickEnter.append(\"line\");\n        tickEnter.append(\"text\");\n        var lineEnter = tickEnter.select(\"line\"), lineUpdate = tickUpdate.select(\"line\"), text = tick.select(\"text\").text(tickFormat), textEnter = tickEnter.select(\"text\"), textUpdate = tickUpdate.select(\"text\"), sign = orient === \"top\" || orient === \"left\" ? -1 : 1, x1, x2, y1, y2;\n        if (orient === \"bottom\" || orient === \"top\") {\n          tickTransform = d3_svg_axisX, x1 = \"x\", y1 = \"y\", x2 = \"x2\", y2 = \"y2\";\n          text.attr(\"dy\", sign < 0 ? \"0em\" : \".71em\").style(\"text-anchor\", \"middle\");\n          pathUpdate.attr(\"d\", \"M\" + range[0] + \",\" + sign * outerTickSize + \"V0H\" + range[1] + \"V\" + sign * outerTickSize);\n        } else {\n          tickTransform = d3_svg_axisY, x1 = \"y\", y1 = \"x\", x2 = \"y2\", y2 = \"x2\";\n          text.attr(\"dy\", \".32em\").style(\"text-anchor\", sign < 0 ? \"end\" : \"start\");\n          pathUpdate.attr(\"d\", \"M\" + sign * outerTickSize + \",\" + range[0] + \"H0V\" + range[1] + \"H\" + sign * outerTickSize);\n        }\n        lineEnter.attr(y2, sign * innerTickSize);\n        textEnter.attr(y1, sign * tickSpacing);\n        lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);\n        textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);\n        if (scale1.rangeBand) {\n          var x = scale1, dx = x.rangeBand() / 2;\n          scale0 = scale1 = function(d) {\n            return x(d) + dx;\n          };\n        } else if (scale0.rangeBand) {\n          scale0 = scale1;\n        } else {\n          tickExit.call(tickTransform, scale1, scale0);\n        }\n        tickEnter.call(tickTransform, scale0, scale1);\n        tickUpdate.call(tickTransform, scale1, scale1);\n      });\n    }\n    axis.scale = function(x) {\n      if (!arguments.length) return scale;\n      scale = x;\n      return axis;\n    };\n    axis.orient = function(x) {\n      if (!arguments.length) return orient;\n      orient = x in d3_svg_axisOrients ? x + \"\" : d3_svg_axisDefaultOrient;\n      return axis;\n    };\n    axis.ticks = function() {\n      if (!arguments.length) return tickArguments_;\n      tickArguments_ = d3_array(arguments);\n      return axis;\n    };\n    axis.tickValues = function(x) {\n      if (!arguments.length) return tickValues;\n      tickValues = x;\n      return axis;\n    };\n    axis.tickFormat = function(x) {\n      if (!arguments.length) return tickFormat_;\n      tickFormat_ = x;\n      return axis;\n    };\n    axis.tickSize = function(x) {\n      var n = arguments.length;\n      if (!n) return innerTickSize;\n      innerTickSize = +x;\n      outerTickSize = +arguments[n - 1];\n      return axis;\n    };\n    axis.innerTickSize = function(x) {\n      if (!arguments.length) return innerTickSize;\n      innerTickSize = +x;\n      return axis;\n    };\n    axis.outerTickSize = function(x) {\n      if (!arguments.length) return outerTickSize;\n      outerTickSize = +x;\n      return axis;\n    };\n    axis.tickPadding = function(x) {\n      if (!arguments.length) return tickPadding;\n      tickPadding = +x;\n      return axis;\n    };\n    axis.tickSubdivide = function() {\n      return arguments.length && axis;\n    };\n    return axis;\n  };\n  var d3_svg_axisDefaultOrient = \"bottom\", d3_svg_axisOrients = {\n    top: 1,\n    right: 1,\n    bottom: 1,\n    left: 1\n  };\n  function d3_svg_axisX(selection, x0, x1) {\n    selection.attr(\"transform\", function(d) {\n      var v0 = x0(d);\n      return \"translate(\" + (isFinite(v0) ? v0 : x1(d)) + \",0)\";\n    });\n  }\n  function d3_svg_axisY(selection, y0, y1) {\n    selection.attr(\"transform\", function(d) {\n      var v0 = y0(d);\n      return \"translate(0,\" + (isFinite(v0) ? v0 : y1(d)) + \")\";\n    });\n  }\n  d3.svg.brush = function() {\n    var event = d3_eventDispatch(brush, \"brushstart\", \"brush\", \"brushend\"), x = null, y = null, xExtent = [ 0, 0 ], yExtent = [ 0, 0 ], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];\n    function brush(g) {\n      g.each(function() {\n        var g = d3.select(this).style(\"pointer-events\", \"all\").style(\"-webkit-tap-highlight-color\", \"rgba(0,0,0,0)\").on(\"mousedown.brush\", brushstart).on(\"touchstart.brush\", brushstart);\n        var background = g.selectAll(\".background\").data([ 0 ]);\n        background.enter().append(\"rect\").attr(\"class\", \"background\").style(\"visibility\", \"hidden\").style(\"cursor\", \"crosshair\");\n        g.selectAll(\".extent\").data([ 0 ]).enter().append(\"rect\").attr(\"class\", \"extent\").style(\"cursor\", \"move\");\n        var resize = g.selectAll(\".resize\").data(resizes, d3_identity);\n        resize.exit().remove();\n        resize.enter().append(\"g\").attr(\"class\", function(d) {\n          return \"resize \" + d;\n        }).style(\"cursor\", function(d) {\n          return d3_svg_brushCursor[d];\n        }).append(\"rect\").attr(\"x\", function(d) {\n          return /[ew]$/.test(d) ? -3 : null;\n        }).attr(\"y\", function(d) {\n          return /^[ns]/.test(d) ? -3 : null;\n        }).attr(\"width\", 6).attr(\"height\", 6).style(\"visibility\", \"hidden\");\n        resize.style(\"display\", brush.empty() ? \"none\" : null);\n        var gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background), range;\n        if (x) {\n          range = d3_scaleRange(x);\n          backgroundUpdate.attr(\"x\", range[0]).attr(\"width\", range[1] - range[0]);\n          redrawX(gUpdate);\n        }\n        if (y) {\n          range = d3_scaleRange(y);\n          backgroundUpdate.attr(\"y\", range[0]).attr(\"height\", range[1] - range[0]);\n          redrawY(gUpdate);\n        }\n        redraw(gUpdate);\n      });\n    }\n    brush.event = function(g) {\n      g.each(function() {\n        var event_ = event.of(this, arguments), extent1 = {\n          x: xExtent,\n          y: yExtent,\n          i: xExtentDomain,\n          j: yExtentDomain\n        }, extent0 = this.__chart__ || extent1;\n        this.__chart__ = extent1;\n        if (d3_transitionInheritId) {\n          d3.select(this).transition().each(\"start.brush\", function() {\n            xExtentDomain = extent0.i;\n            yExtentDomain = extent0.j;\n            xExtent = extent0.x;\n            yExtent = extent0.y;\n            event_({\n              type: \"brushstart\"\n            });\n          }).tween(\"brush:brush\", function() {\n            var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);\n            xExtentDomain = yExtentDomain = null;\n            return function(t) {\n              xExtent = extent1.x = xi(t);\n              yExtent = extent1.y = yi(t);\n              event_({\n                type: \"brush\",\n                mode: \"resize\"\n              });\n            };\n          }).each(\"end.brush\", function() {\n            xExtentDomain = extent1.i;\n            yExtentDomain = extent1.j;\n            event_({\n              type: \"brush\",\n              mode: \"resize\"\n            });\n            event_({\n              type: \"brushend\"\n            });\n          });\n        } else {\n          event_({\n            type: \"brushstart\"\n          });\n          event_({\n            type: \"brush\",\n            mode: \"resize\"\n          });\n          event_({\n            type: \"brushend\"\n          });\n        }\n      });\n    };\n    function redraw(g) {\n      g.selectAll(\".resize\").attr(\"transform\", function(d) {\n        return \"translate(\" + xExtent[+/e$/.test(d)] + \",\" + yExtent[+/^s/.test(d)] + \")\";\n      });\n    }\n    function redrawX(g) {\n      g.select(\".extent\").attr(\"x\", xExtent[0]);\n      g.selectAll(\".extent,.n>rect,.s>rect\").attr(\"width\", xExtent[1] - xExtent[0]);\n    }\n    function redrawY(g) {\n      g.select(\".extent\").attr(\"y\", yExtent[0]);\n      g.selectAll(\".extent,.e>rect,.w>rect\").attr(\"height\", yExtent[1] - yExtent[0]);\n    }\n    function brushstart() {\n      var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed(\"extent\"), dragRestore = d3_event_dragSuppress(target), center, origin = d3.mouse(target), offset;\n      var w = d3.select(d3_window(target)).on(\"keydown.brush\", keydown).on(\"keyup.brush\", keyup);\n      if (d3.event.changedTouches) {\n        w.on(\"touchmove.brush\", brushmove).on(\"touchend.brush\", brushend);\n      } else {\n        w.on(\"mousemove.brush\", brushmove).on(\"mouseup.brush\", brushend);\n      }\n      g.interrupt().selectAll(\"*\").interrupt();\n      if (dragging) {\n        origin[0] = xExtent[0] - origin[0];\n        origin[1] = yExtent[0] - origin[1];\n      } else if (resizing) {\n        var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);\n        offset = [ xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1] ];\n        origin[0] = xExtent[ex];\n        origin[1] = yExtent[ey];\n      } else if (d3.event.altKey) center = origin.slice();\n      g.style(\"pointer-events\", \"none\").selectAll(\".resize\").style(\"display\", null);\n      d3.select(\"body\").style(\"cursor\", eventTarget.style(\"cursor\"));\n      event_({\n        type: \"brushstart\"\n      });\n      brushmove();\n      function keydown() {\n        if (d3.event.keyCode == 32) {\n          if (!dragging) {\n            center = null;\n            origin[0] -= xExtent[1];\n            origin[1] -= yExtent[1];\n            dragging = 2;\n          }\n          d3_eventPreventDefault();\n        }\n      }\n      function keyup() {\n        if (d3.event.keyCode == 32 && dragging == 2) {\n          origin[0] += xExtent[1];\n          origin[1] += yExtent[1];\n          dragging = 0;\n          d3_eventPreventDefault();\n        }\n      }\n      function brushmove() {\n        var point = d3.mouse(target), moved = false;\n        if (offset) {\n          point[0] += offset[0];\n          point[1] += offset[1];\n        }\n        if (!dragging) {\n          if (d3.event.altKey) {\n            if (!center) center = [ (xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2 ];\n            origin[0] = xExtent[+(point[0] < center[0])];\n            origin[1] = yExtent[+(point[1] < center[1])];\n          } else center = null;\n        }\n        if (resizingX && move1(point, x, 0)) {\n          redrawX(g);\n          moved = true;\n        }\n        if (resizingY && move1(point, y, 1)) {\n          redrawY(g);\n          moved = true;\n        }\n        if (moved) {\n          redraw(g);\n          event_({\n            type: \"brush\",\n            mode: dragging ? \"move\" : \"resize\"\n          });\n        }\n      }\n      function move1(point, scale, i) {\n        var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;\n        if (dragging) {\n          r0 -= position;\n          r1 -= size + position;\n        }\n        min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];\n        if (dragging) {\n          max = (min += position) + size;\n        } else {\n          if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));\n          if (position < min) {\n            max = min;\n            min = position;\n          } else {\n            max = position;\n          }\n        }\n        if (extent[0] != min || extent[1] != max) {\n          if (i) yExtentDomain = null; else xExtentDomain = null;\n          extent[0] = min;\n          extent[1] = max;\n          return true;\n        }\n      }\n      function brushend() {\n        brushmove();\n        g.style(\"pointer-events\", \"all\").selectAll(\".resize\").style(\"display\", brush.empty() ? \"none\" : null);\n        d3.select(\"body\").style(\"cursor\", null);\n        w.on(\"mousemove.brush\", null).on(\"mouseup.brush\", null).on(\"touchmove.brush\", null).on(\"touchend.brush\", null).on(\"keydown.brush\", null).on(\"keyup.brush\", null);\n        dragRestore();\n        event_({\n          type: \"brushend\"\n        });\n      }\n    }\n    brush.x = function(z) {\n      if (!arguments.length) return x;\n      x = z;\n      resizes = d3_svg_brushResizes[!x << 1 | !y];\n      return brush;\n    };\n    brush.y = function(z) {\n      if (!arguments.length) return y;\n      y = z;\n      resizes = d3_svg_brushResizes[!x << 1 | !y];\n      return brush;\n    };\n    brush.clamp = function(z) {\n      if (!arguments.length) return x && y ? [ xClamp, yClamp ] : x ? xClamp : y ? yClamp : null;\n      if (x && y) xClamp = !!z[0], yClamp = !!z[1]; else if (x) xClamp = !!z; else if (y) yClamp = !!z;\n      return brush;\n    };\n    brush.extent = function(z) {\n      var x0, x1, y0, y1, t;\n      if (!arguments.length) {\n        if (x) {\n          if (xExtentDomain) {\n            x0 = xExtentDomain[0], x1 = xExtentDomain[1];\n          } else {\n            x0 = xExtent[0], x1 = xExtent[1];\n            if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);\n            if (x1 < x0) t = x0, x0 = x1, x1 = t;\n          }\n        }\n        if (y) {\n          if (yExtentDomain) {\n            y0 = yExtentDomain[0], y1 = yExtentDomain[1];\n          } else {\n            y0 = yExtent[0], y1 = yExtent[1];\n            if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);\n            if (y1 < y0) t = y0, y0 = y1, y1 = t;\n          }\n        }\n        return x && y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y && [ y0, y1 ];\n      }\n      if (x) {\n        x0 = z[0], x1 = z[1];\n        if (y) x0 = x0[0], x1 = x1[0];\n        xExtentDomain = [ x0, x1 ];\n        if (x.invert) x0 = x(x0), x1 = x(x1);\n        if (x1 < x0) t = x0, x0 = x1, x1 = t;\n        if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [ x0, x1 ];\n      }\n      if (y) {\n        y0 = z[0], y1 = z[1];\n        if (x) y0 = y0[1], y1 = y1[1];\n        yExtentDomain = [ y0, y1 ];\n        if (y.invert) y0 = y(y0), y1 = y(y1);\n        if (y1 < y0) t = y0, y0 = y1, y1 = t;\n        if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [ y0, y1 ];\n      }\n      return brush;\n    };\n    brush.clear = function() {\n      if (!brush.empty()) {\n        xExtent = [ 0, 0 ], yExtent = [ 0, 0 ];\n        xExtentDomain = yExtentDomain = null;\n      }\n      return brush;\n    };\n    brush.empty = function() {\n      return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];\n    };\n    return d3.rebind(brush, event, \"on\");\n  };\n  var d3_svg_brushCursor = {\n    n: \"ns-resize\",\n    e: \"ew-resize\",\n    s: \"ns-resize\",\n    w: \"ew-resize\",\n    nw: \"nwse-resize\",\n    ne: \"nesw-resize\",\n    se: \"nwse-resize\",\n    sw: \"nesw-resize\"\n  };\n  var d3_svg_brushResizes = [ [ \"n\", \"e\", \"s\", \"w\", \"nw\", \"ne\", \"se\", \"sw\" ], [ \"e\", \"w\" ], [ \"n\", \"s\" ], [] ];\n  var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;\n  var d3_time_formatUtc = d3_time_format.utc;\n  var d3_time_formatIso = d3_time_formatUtc(\"%Y-%m-%dT%H:%M:%S.%LZ\");\n  d3_time_format.iso = Date.prototype.toISOString && +new Date(\"2000-01-01T00:00:00.000Z\") ? d3_time_formatIsoNative : d3_time_formatIso;\n  function d3_time_formatIsoNative(date) {\n    return date.toISOString();\n  }\n  d3_time_formatIsoNative.parse = function(string) {\n    var date = new Date(string);\n    return isNaN(date) ? null : date;\n  };\n  d3_time_formatIsoNative.toString = d3_time_formatIso.toString;\n  d3_time.second = d3_time_interval(function(date) {\n    return new d3_date(Math.floor(date / 1e3) * 1e3);\n  }, function(date, offset) {\n    date.setTime(date.getTime() + Math.floor(offset) * 1e3);\n  }, function(date) {\n    return date.getSeconds();\n  });\n  d3_time.seconds = d3_time.second.range;\n  d3_time.seconds.utc = d3_time.second.utc.range;\n  d3_time.minute = d3_time_interval(function(date) {\n    return new d3_date(Math.floor(date / 6e4) * 6e4);\n  }, function(date, offset) {\n    date.setTime(date.getTime() + Math.floor(offset) * 6e4);\n  }, function(date) {\n    return date.getMinutes();\n  });\n  d3_time.minutes = d3_time.minute.range;\n  d3_time.minutes.utc = d3_time.minute.utc.range;\n  d3_time.hour = d3_time_interval(function(date) {\n    var timezone = date.getTimezoneOffset() / 60;\n    return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);\n  }, function(date, offset) {\n    date.setTime(date.getTime() + Math.floor(offset) * 36e5);\n  }, function(date) {\n    return date.getHours();\n  });\n  d3_time.hours = d3_time.hour.range;\n  d3_time.hours.utc = d3_time.hour.utc.range;\n  d3_time.month = d3_time_interval(function(date) {\n    date = d3_time.day(date);\n    date.setDate(1);\n    return date;\n  }, function(date, offset) {\n    date.setMonth(date.getMonth() + offset);\n  }, function(date) {\n    return date.getMonth();\n  });\n  d3_time.months = d3_time.month.range;\n  d3_time.months.utc = d3_time.month.utc.range;\n  function d3_time_scale(linear, methods, format) {\n    function scale(x) {\n      return linear(x);\n    }\n    scale.invert = function(x) {\n      return d3_time_scaleDate(linear.invert(x));\n    };\n    scale.domain = function(x) {\n      if (!arguments.length) return linear.domain().map(d3_time_scaleDate);\n      linear.domain(x);\n      return scale;\n    };\n    function tickMethod(extent, count) {\n      var span = extent[1] - extent[0], target = span / count, i = d3.bisect(d3_time_scaleSteps, target);\n      return i == d3_time_scaleSteps.length ? [ methods.year, d3_scale_linearTickRange(extent.map(function(d) {\n        return d / 31536e6;\n      }), count)[2] ] : !i ? [ d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2] ] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];\n    }\n    scale.nice = function(interval, skip) {\n      var domain = scale.domain(), extent = d3_scaleExtent(domain), method = interval == null ? tickMethod(extent, 10) : typeof interval === \"number\" && tickMethod(extent, interval);\n      if (method) interval = method[0], skip = method[1];\n      function skipped(date) {\n        return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;\n      }\n      return scale.domain(d3_scale_nice(domain, skip > 1 ? {\n        floor: function(date) {\n          while (skipped(date = interval.floor(date))) date = d3_time_scaleDate(date - 1);\n          return date;\n        },\n        ceil: function(date) {\n          while (skipped(date = interval.ceil(date))) date = d3_time_scaleDate(+date + 1);\n          return date;\n        }\n      } : interval));\n    };\n    scale.ticks = function(interval, skip) {\n      var extent = d3_scaleExtent(scale.domain()), method = interval == null ? tickMethod(extent, 10) : typeof interval === \"number\" ? tickMethod(extent, interval) : !interval.range && [ {\n        range: interval\n      }, skip ];\n      if (method) interval = method[0], skip = method[1];\n      return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);\n    };\n    scale.tickFormat = function() {\n      return format;\n    };\n    scale.copy = function() {\n      return d3_time_scale(linear.copy(), methods, format);\n    };\n    return d3_scale_linearRebind(scale, linear);\n  }\n  function d3_time_scaleDate(t) {\n    return new Date(t);\n  }\n  var d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ];\n  var d3_time_scaleLocalMethods = [ [ d3_time.second, 1 ], [ d3_time.second, 5 ], [ d3_time.second, 15 ], [ d3_time.second, 30 ], [ d3_time.minute, 1 ], [ d3_time.minute, 5 ], [ d3_time.minute, 15 ], [ d3_time.minute, 30 ], [ d3_time.hour, 1 ], [ d3_time.hour, 3 ], [ d3_time.hour, 6 ], [ d3_time.hour, 12 ], [ d3_time.day, 1 ], [ d3_time.day, 2 ], [ d3_time.week, 1 ], [ d3_time.month, 1 ], [ d3_time.month, 3 ], [ d3_time.year, 1 ] ];\n  var d3_time_scaleLocalFormat = d3_time_format.multi([ [ \".%L\", function(d) {\n    return d.getMilliseconds();\n  } ], [ \":%S\", function(d) {\n    return d.getSeconds();\n  } ], [ \"%I:%M\", function(d) {\n    return d.getMinutes();\n  } ], [ \"%I %p\", function(d) {\n    return d.getHours();\n  } ], [ \"%a %d\", function(d) {\n    return d.getDay() && d.getDate() != 1;\n  } ], [ \"%b %d\", function(d) {\n    return d.getDate() != 1;\n  } ], [ \"%B\", function(d) {\n    return d.getMonth();\n  } ], [ \"%Y\", d3_true ] ]);\n  var d3_time_scaleMilliseconds = {\n    range: function(start, stop, step) {\n      return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);\n    },\n    floor: d3_identity,\n    ceil: d3_identity\n  };\n  d3_time_scaleLocalMethods.year = d3_time.year;\n  d3_time.scale = function() {\n    return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);\n  };\n  var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function(m) {\n    return [ m[0].utc, m[1] ];\n  });\n  var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([ [ \".%L\", function(d) {\n    return d.getUTCMilliseconds();\n  } ], [ \":%S\", function(d) {\n    return d.getUTCSeconds();\n  } ], [ \"%I:%M\", function(d) {\n    return d.getUTCMinutes();\n  } ], [ \"%I %p\", function(d) {\n    return d.getUTCHours();\n  } ], [ \"%a %d\", function(d) {\n    return d.getUTCDay() && d.getUTCDate() != 1;\n  } ], [ \"%b %d\", function(d) {\n    return d.getUTCDate() != 1;\n  } ], [ \"%B\", function(d) {\n    return d.getUTCMonth();\n  } ], [ \"%Y\", d3_true ] ]);\n  d3_time_scaleUtcMethods.year = d3_time.year.utc;\n  d3_time.scale.utc = function() {\n    return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);\n  };\n  d3.text = d3_xhrType(function(request) {\n    return request.responseText;\n  });\n  d3.json = function(url, callback) {\n    return d3_xhr(url, \"application/json\", d3_json, callback);\n  };\n  function d3_json(request) {\n    return JSON.parse(request.responseText);\n  }\n  d3.html = function(url, callback) {\n    return d3_xhr(url, \"text/html\", d3_html, callback);\n  };\n  function d3_html(request) {\n    var range = d3_document.createRange();\n    range.selectNode(d3_document.body);\n    return range.createContextualFragment(request.responseText);\n  }\n  d3.xml = d3_xhrType(function(request) {\n    return request.responseXML;\n  });\n  if (typeof define === \"function\" && define.amd) this.d3 = d3, define(d3); else if (typeof module === \"object\" && module.exports) module.exports = d3; else this.d3 = d3;\n}();\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/d3/d3.js\n ** module id = 5\n ** module chunks = 0\n **/","var d3 = require('d3'),\n    vg = require('vega'),\n    vl = require('vega-lite'),\n    parameter = require('./parameter'),\n    post = require('./post');\n\nvar config = {\n  // URL for loading specs into editor\n  editor_url: 'http://vega.github.io/vega-editor/',\n\n  // HTML to inject within view source head element\n  source_header: '',\n\n  // HTML to inject before view source closing body tag\n  source_footer: ''\n};\n\nvar MODES = {\n  'vega':      'vega',\n  'vega-lite': 'vega-lite'\n};\n\nvar PREPROCESSOR = {\n  'vega':      function(vgjson) { return vgjson; },\n  'vega-lite': function(vljson) { return vl.compile(vljson).spec; }\n};\n\nfunction load(url, arg, el, callback) {\n  vg.util.load({url: url}, function(err, data) {\n    if (err || !data) {\n      console.error(err || ('No data found at ' + url));\n    } else {\n      // marshal embedding spec and restart\n      var opt = !arg ? JSON.parse(data) : vg.util.extend({source: data}, arg);\n      embed(el, opt, callback);\n    }\n  });\n}\n\n// Embed a Vega visualization component in a web page.\n// el: DOM element in which to place component (DOM node or CSS selector)\n// opt: Embedding specification (parsed JSON or URL string)\n// callback: invoked with the generated Vega View instance\nfunction embed(el, opt, callback) {\n  var cb = callback || function(){},\n      params = [], source, spec, mode;\n\n  try {\n    if (vg.util.isString(opt)) {\n      return load(opt, null, el, callback);\n    } else if (opt.source) {\n      source = opt.source;\n      spec = JSON.parse(source);\n    } else if (opt.spec) {\n      spec = opt.spec;\n      source = JSON.stringify(spec, null, 2);\n    } else if (opt.url) {\n      return load(opt.url, opt, el, callback);\n    } else {\n      spec = opt;\n      source = JSON.stringify(spec, null, 2);\n      opt = {spec: spec, actions: false};\n    }\n    mode = MODES[opt.mode] || MODES.vega;\n    spec = PREPROCESSOR[mode](spec);\n\n    // ensure container div has class 'vega-embed'\n    var div = d3.select(el)\n      .classed('vega-embed', true)\n      .html(''); // clear container\n\n    // handle parameters\n    if (opt.parameters) {\n      var elp = opt.parameter_el ? d3.select(opt.parameter_el) : div;\n      var pdiv = elp.append('div')\n        .attr('class', 'vega-params');\n      params = opt.parameters.map(function(p) {\n        return parameter.init(pdiv, p, spec);\n      });\n    }\n  } catch (err) { cb(err); }\n\n  vg.parse.spec(spec, function(error, chart) {\n    if (error) { cb(error); return; }\n    try {\n      var renderer = opt.renderer || 'canvas',\n          actions  = opt.actions || {};\n\n      var view = chart({\n        el: el,\n        data: opt.data || undefined,\n        renderer: renderer\n      });\n\n      if (opt.actions !== false) {\n        // add child div to house action links\n        var ctrl = div.append('div')\n          .attr('class', 'vega-actions');\n\n        // add 'Export' action\n        if (actions.export !== false) {\n          var ext = (renderer==='canvas' ? 'png' : 'svg');\n          ctrl.append('a')\n            .text('Export as ' + ext.toUpperCase())\n            .attr('href', '#')\n            .attr('target', '_blank')\n            .attr('download', (spec.name || 'vega') + '.' + ext)\n            .on('mousedown', function() {\n              this.href = view.toImageURL(ext);\n              d3.event.preventDefault();\n            });\n        }\n\n        // add 'View Source' action\n        if (actions.source !== false) {\n          ctrl.append('a')\n            .text('View Source')\n            .attr('href', '#')\n            .on('click', function() {\n              viewSource(source);\n              d3.event.preventDefault();\n            });\n        }\n\n        // add 'Open in Vega Editor' action\n        if (actions.editor !== false) {\n          ctrl.append('a')\n            .text('Open in Vega Editor')\n            .attr('href', '#')\n            .on('click', function() {\n              post(window, embed.config.editor_url, {spec: source, mode: mode});\n              d3.event.preventDefault();\n            });\n        }\n      }\n\n      // bind all parameter elements\n      params.forEach(function(p) { parameter.bind(p, view); });\n\n      // initialize and return visualization\n      view.update();\n      cb(null, {view: view, spec: spec});\n    } catch (err) { cb(err); }\n  });\n}\n\nfunction viewSource(source) {\n  var header = '<html><head>' + config.source_header + '</head>' + '<body><pre><code class=\"json\">';\n  var footer = '</code></pre>' + config.source_footer + '</body></html>';\n  var win = window.open('');\n  win.document.write(header + source + footer);\n  win.document.title = 'Vega JSON Source';\n}\n\n// make config externally visible\nembed.config = config;\n\nmodule.exports = embed;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-embed/src/embed.js\n ** module id = 6\n ** module chunks = 0\n **/","module.exports = {\n  version: '__VERSION__',\n  dataflow: require('vega-dataflow'),\n  parse: require('./src/parse/'),\n  scene: {\n    Bounder: require('./src/scene/Bounder'),\n    Builder: require('./src/scene/Builder'),\n    Encoder: require('./src/scene/Encoder'),\n    GroupBuilder: require('./src/scene/GroupBuilder'),\n    visit: require('./src/scene/visit')\n  },\n  transforms: require('./src/transforms'),\n  Transform: require('./src/transforms/Transform'),\n  BatchTransform: require('./src/transforms/BatchTransform'),\n  Parameter: require('./src/transforms/Parameter'),\n  schema: require('./src/core/schema'),\n  config: require('./src/core/config'),\n  util: require('./src/util'),\n  logging: require('vega-logging'),\n  debug: require('vega-logging').debug\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/index.js\n ** module id = 7\n ** module chunks = 0\n **/","module.exports = {\n  ChangeSet:    require('./ChangeSet'),\n  Collector:    require('./Collector'),\n  DataSource:   require('./DataSource'),\n  Dependencies: require('./Dependencies'),\n  Graph:        require('./Graph'),\n  Node:         require('./Node'),\n  Signal:       require('./Signal'),\n  Tuple:        require('./Tuple'),\n  debug:        require('vega-logging').debug\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-dataflow/src/index.js\n ** module id = 8\n ** module chunks = 0\n **/","var DEPS = require('./Dependencies').ALL;\n\nfunction create(cs, reflow) {\n  var out = {};\n  copy(cs, out);\n\n  out.add = [];\n  out.mod = [];\n  out.rem = [];\n\n  out.reflow = reflow;\n\n  return out;\n}\n\nfunction copy(a, b) {\n  b.stamp = a ? a.stamp : 0;\n  b.sort  = a ? a.sort  : null;\n  b.facet = a ? a.facet : null;\n  b.trans = a ? a.trans : null;\n  b.dirty = a ? a.dirty : [];\n  b.request = a ? a.request : null;\n  for (var d, i=0, n=DEPS.length; i<n; ++i) {\n    b[d=DEPS[i]] = a ? a[d] : {};\n  }\n}\n\nmodule.exports = {\n  create: create,\n  copy: copy\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-dataflow/src/ChangeSet.js\n ** module id = 9\n ** module chunks = 0\n **/","var deps = module.exports = {\n  ALL: ['data', 'fields', 'scales', 'signals']\n};\ndeps.ALL.forEach(function(k) { deps[k.toUpperCase()] = k; });\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-dataflow/src/Dependencies.js\n ** module id = 10\n ** module chunks = 0\n **/","var log = require('vega-logging'),\n    Tuple = require('./Tuple'),\n    Base = require('./Node').prototype,\n    ChangeSet = require('./ChangeSet');\n\nfunction Collector(graph) {\n  Base.init.call(this, graph);\n  this._data = [];\n  this.router(true).collector(true);\n}\n\nvar prototype = (Collector.prototype = Object.create(Base));\nprototype.constructor = Collector;\n\nprototype.data = function() {\n  return this._data;\n};\n\nprototype.evaluate = function(input) {\n  log.debug(input, [\"collecting\"]);\n\n  // Create a new output changeset to prevent pollution when the Graph\n  // merges reflow and regular changesets.\n  var output = ChangeSet.create(input);\n\n  if (input.rem.length) {\n    this._data = Tuple.idFilter(this._data, input.rem);\n    output.rem = input.rem.slice(0);\n  }\n\n  if (input.add.length) {\n    this._data = this._data.concat(input.add);\n    output.add = input.add.slice(0);\n  }\n\n  if (input.mod.length) {\n    output.mod = input.mod.slice(0);\n  }\n\n  if (input.sort) {\n    this._data.sort(input.sort);\n  }\n\n  if (input.reflow) {\n    output.mod = output.mod.concat(\n      Tuple.idFilter(this._data, output.add, output.mod, output.rem));\n    output.reflow = false;\n  }\n\n  return output;\n};\n\nmodule.exports = Collector;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-dataflow/src/Collector.js\n ** module id = 11\n ** module chunks = 0\n **/","var ts = Date.now();\n\nfunction write(msg) {\n  console.log('[Vega Log]', msg);\n}\n\nfunction error(msg) {\n  console.error('[Vega Err]', msg);\n}\n\nfunction debug(input, args) {\n  if (!debug.enable) return;\n  var log = Function.prototype.bind.call(console.log, console);\n  var state = {\n    prevTime:  Date.now() - ts,\n    stamp: input.stamp\n  };\n\n  if (input.add) {\n    state.add = input.add.length;\n    state.mod = input.mod.length;\n    state.rem = input.rem.length;\n    state.reflow = !!input.reflow;\n  }\n\n  log.apply(console, (args.push(JSON.stringify(state)), args));\n  ts = Date.now();\n}\n\nmodule.exports = {\n  log:   write,\n  error: error,\n  debug: (debug.enable = false, debug)\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-logging/index.js\n ** module id = 12\n ** module chunks = 0\n **/","var tupleID = 0;\n\nfunction ingest(datum) {\n  datum = (datum === Object(datum)) ? datum : {data: datum};\n  datum._id = ++tupleID;\n  if (datum._prev) datum._prev = null;\n  return datum;\n}\n\nfunction idMap(a, ids) {\n  ids = ids || {};\n  for (var i=0, n=a.length; i<n; ++i) {\n    ids[a[i]._id] = 1;\n  }\n  return ids;\n}\n\nfunction copy(t, c) {\n  c = c || {};\n  for (var k in t) {\n    if (k !== '_prev' && k !== '_id') c[k] = t[k];\n  }\n  return c;\n}\n\nmodule.exports = {\n  ingest: ingest,\n  idMap: idMap,\n\n  derive: function(d) {\n    return ingest(copy(d));\n  },\n\n  rederive: function(d, t) {\n    return copy(d, t);\n  },\n\n  set: function(t, k, v) {\n    return t[k] === v ? 0 : (t[k] = v, 1);\n  },\n\n  prev: function(t) {\n    return t._prev || t;\n  },\n\n  prev_init: function(t) {\n    if (!t._prev) { t._prev = {_id: t._id}; }\n  },\n\n  prev_update: function(t) {\n    var p = t._prev, k, v;\n    if (p) for (k in t) {\n      if (k !== '_prev' && k !== '_id') {\n        p[k] = ((v=t[k]) instanceof Object && v._prev) ? v._prev : v;\n      }\n    }\n  },\n\n  reset: function() { tupleID = 0; },\n\n  idFilter: function(data) {\n    var ids = {};\n    for (var i=arguments.length; --i>0;) {\n      idMap(arguments[i], ids);\n    }\n    return data.filter(function(x) { return !ids[x._id]; });\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-dataflow/src/Tuple.js\n ** module id = 13\n ** module chunks = 0\n **/","var DEPS = require('./Dependencies').ALL,\n    nodeID = 0;\n\nfunction Node(graph) {\n  if (graph) this.init(graph);\n}\n\nvar Flags = Node.Flags = {\n  Router:     0x01, // Responsible for propagating tuples, cannot be skipped.\n  Collector:  0x02, // Holds a materialized dataset, pulse node to reflow.\n  Produces:   0x04, // Produces new tuples. \n  Mutates:    0x08, // Sets properties of incoming tuples.\n  Reflows:    0x10, // Forwards a reflow pulse.\n  Batch:      0x20  // Performs batch data processing, needs collector.\n};\n\nvar prototype = Node.prototype;\n\nprototype.init = function(graph) {\n  this._id = ++nodeID;\n  this._graph = graph;\n  this._rank  = graph.rank(); // Topological sort by rank\n  this._qrank = null; // Rank when enqueued for propagation\n  this._stamp = 0;    // Last stamp seen\n\n  this._listeners = [];\n  this._listeners._ids = {}; // To prevent duplicate listeners\n\n  // Initialize dependencies.\n  this._deps = {};\n  for (var i=0, n=DEPS.length; i<n; ++i) {\n    this._deps[DEPS[i]] = [];\n  }\n\n  // Initialize status flags.\n  this._flags = 0;\n\n  return this;\n};\n\nprototype.rank = function() {\n  return this._rank;\n};\n\nprototype.rerank = function() {\n  var g = this._graph, \n      q = [this],\n      cur;\n\n  while (q.length) {\n    cur = q.shift();\n    cur._rank = g.rank();\n    q.unshift.apply(q, cur.listeners());\n  }\n\n  return this;\n};\n\nprototype.qrank = function(/* set */) {\n  if (!arguments.length) return this._qrank;\n  return (this._qrank = this._rank, this);\n};\n\nprototype.last = function(stamp) { \n  if (!arguments.length) return this._stamp;\n  return (this._stamp = stamp, this);\n};\n\n// -- status flags ---\n\nprototype._setf = function(v, b) {\n  if (b) { this._flags |= v; } else { this._flags &= ~v; }\n  return this;\n};\n\nprototype.router = function(state) {\n  if (!arguments.length) return (this._flags & Flags.Router);\n  return this._setf(Flags.Router, state);\n};\n\nprototype.collector = function(state) {\n  if (!arguments.length) return (this._flags & Flags.Collector);\n  return this._setf(Flags.Collector, state);\n};\n\nprototype.produces = function(state) {\n  if (!arguments.length) return (this._flags & Flags.Produces);\n  return this._setf(Flags.Produces, state);\n};\n\nprototype.mutates = function(state) {\n  if (!arguments.length) return (this._flags & Flags.Mutates);\n  return this._setf(Flags.Mutates, state);\n};\n\nprototype.reflows = function(state) {\n  if (!arguments.length) return (this._flags & Flags.Reflows);\n  return this._setf(Flags.Reflows, state);\n};\n\nprototype.batch = function(state) {\n  if (!arguments.length) return (this._flags & Flags.Batch);\n  return this._setf(Flags.Batch, state);\n};\n\nprototype.dependency = function(type, deps) {\n  var d = this._deps[type],\n      n = d._names || (d._names = {});  // To prevent dupe deps\n\n  // Get dependencies of the given type\n  if (arguments.length === 1) {\n    return d;\n  }\n\n  if (deps === null) {\n    // Clear dependencies of the given type\n    d.splice(0, d.length);\n    d._names = {};\n  } else if (!Array.isArray(deps)) {\n    // Separate this case to avoid cost of array creation\n    if (n[deps]) return this;\n    d.push(deps);\n    n[deps] = 1;\n  } else {\n    for (var i=0, len=deps.length, dep; i<len; ++i) {\n      dep = deps[i];\n      if (n[dep]) continue;\n      d.push(dep);\n      n[dep] = 1;\n    }\n  }\n\n  return this;\n};\n\nprototype.listeners = function() {\n  return this._listeners;\n};\n\nprototype.addListener = function(l) {\n  if (!(l instanceof Node)) {\n    throw Error('Listener is not a Node');\n  }\n  if (this._listeners._ids[l._id]) return this;\n\n  this._listeners.push(l);\n  this._listeners._ids[l._id] = 1;\n  if (this._rank > l._rank) {\n    l.rerank();\n  }\n\n  return this;\n};\n\nprototype.removeListener = function(l) {\n  if (!this._listeners._ids[l._id]) return false;\n  \n  var idx = this._listeners.indexOf(l),\n      b = idx >= 0;\n\n  if (b) {\n    this._listeners.splice(idx, 1);\n    this._listeners._ids[l._id] = null;\n  }\n  return b;\n};\n\nprototype.disconnect = function() {\n  this._listeners = [];\n  this._listeners._ids = {};\n};\n\n// Evaluate this dataflow node for the current pulse.\n// Subclasses should override to perform custom processing.\nprototype.evaluate = function(pulse) {\n  return pulse;\n};\n\n// Should this node be re-evaluated for the current pulse?\n// Searches pulse to see if any dependencies have updated.\nprototype.reevaluate = function(pulse) {\n  var prop, dep, i, n, j, m;\n\n  for (i=0, n=DEPS.length; i<n; ++i) {\n    prop = DEPS[i];\n    dep = this._deps[prop];\n    for (j=0, m=dep.length; j<m; ++j) {\n      if (pulse[prop][dep[j]]) return true;\n    }\n  }\n\n  return false;\n};\n\nNode.reset = function() { nodeID = 0; };\n\nmodule.exports = Node;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-dataflow/src/Node.js\n ** module id = 14\n ** module chunks = 0\n **/","var dl = require('datalib'),\n    log = require('vega-logging'),\n    ChangeSet = require('./ChangeSet'),\n    Collector = require('./Collector'),\n    Tuple = require('./Tuple'),\n    Node = require('./Node'); // jshint ignore:line\n\nfunction DataSource(graph, name, facet) {\n  this._graph = graph;\n  this._name = name;\n  this._data = [];\n  this._source = null;\n  this._facet  = facet;\n  this._input  = ChangeSet.create();\n  this._output = null; // Output changeset\n  this._indexes = {};\n  this._indexFields = [];\n\n  this._inputNode  = null;\n  this._outputNode = null;\n  this._pipeline  = null; // Pipeline of transformations.\n  this._collector = null; // Collector to materialize output of pipeline.\n  this._mutates = false;  // Does any pipeline operator mutate tuples?\n}\n\nvar prototype = DataSource.prototype;\n\nprototype.name = function(name) {\n  if (!arguments.length) return this._name;\n  return (this._name = name, this);\n};\n\nprototype.source = function(src) {\n  if (!arguments.length) return this._source;\n  return (this._source = this._graph.data(src));\n};\n\nprototype.insert = function(tuples) {\n  this._input.add = this._input.add.concat(tuples.map(Tuple.ingest));\n  return this;\n};\n\nprototype.remove = function(where) {\n  var remove = this._data.filter(where);\n  this._input.rem = this._input.rem.concat(remove);\n  return this;\n};\n\nprototype.update = function(where, field, func) {\n  var mod = this._input.mod,\n      ids = Tuple.idMap(mod);\n\n  this._input.fields[field] = 1;\n\n  this._data.filter(where).forEach(function(x) {\n    var prev = x[field],\n        next = func(x);\n    if (prev !== next) {\n      Tuple.set(x, field, next);\n      if (ids[x._id] !== 1) {\n        mod.push(x);\n        ids[x._id] = 1;\n      }\n    }\n  });\n\n  return this;\n};\n\nprototype.values = function(data) {\n  if (!arguments.length) return this._collector.data();\n\n  // Replace backing data\n  this._input.rem = this._data.slice();\n  if (data) { this.insert(data); }\n  return this;\n};\n\nprototype.mutates = function(m) {\n  if (!arguments.length) return this._mutates;\n  this._mutates = this._mutates || m;\n  return this;\n};\n\nprototype.last = function() {\n  return this._output;\n};\n\nprototype.fire = function(input) {\n  if (input) this._input = input;\n  this._graph.propagate(this._input, this._pipeline[0]);\n  return this;\n};\n\nprototype.pipeline = function(pipeline) {\n  if (!arguments.length) return this._pipeline;\n\n  var graph = this._graph,\n      status;\n\n  pipeline.unshift(this._inputNode = DataSourceInput(this));\n  status = graph.preprocess(pipeline);\n\n  if (status.router) {\n    pipeline.push(status.collector = new Collector(graph));\n  }\n\n  pipeline.push(this._outputNode = DataSourceOutput(this));\n  this._collector = status.collector;\n  this._mutates = !!status.mutates;\n  graph.connect(this._pipeline = pipeline);\n\n  return this;\n};\n\nprototype.synchronize = function() {\n  this._graph.synchronize(this._pipeline);\n  return this;\n};\n\nprototype.getIndex = function(field) {\n  var data = this.values(),\n      indexes = this._indexes,\n      fields  = this._indexFields,\n      f = dl.$(field),\n      index, i, len, value;\n\n  if (!indexes[field]) {\n    indexes[field] = index = {};\n    fields.push(field);\n    for (i=0, len=data.length; i<len; ++i) {\n      value = f(data[i]);\n      index[value] = (index[value] || 0) + 1;\n      Tuple.prev_init(data[i]);\n    }\n  }\n  return indexes[field];\n};\n\nprototype.listener = function() {\n  return DataSourceListener(this).addListener(this._inputNode);\n};\n\nprototype.addListener = function(l) {\n  if (l instanceof DataSource) {\n    this._collector.addListener(l.listener());\n  } else {\n    this._outputNode.addListener(l);\n  }\n  return this;\n};\n\nprototype.removeListener = function(l) {\n  this._outputNode.removeListener(l);\n};\n\nprototype.listeners = function(ds) {\n  return (ds ? this._collector : this._outputNode).listeners();\n};\n\n// Input node applies the datasource's delta, and propagates it to\n// the rest of the pipeline. It receives touches to reflow data.\nfunction DataSourceInput(ds) {\n  var input = new Node(ds._graph)\n    .router(true)\n    .collector(true);\n\n  input.data = function() {\n    return ds._data;\n  };\n\n  input.evaluate = function(input) {\n    log.debug(input, ['input', ds._name]);\n\n    var delta = ds._input,\n        out = ChangeSet.create(input), f;\n\n    // Delta might contain fields updated through API\n    for (f in delta.fields) {\n      out.fields[f] = 1;\n    }\n\n    // update data\n    if (delta.rem.length) {\n      ds._data = Tuple.idFilter(ds._data, delta.rem);\n    }\n\n    if (delta.add.length) {\n      ds._data = ds._data.concat(delta.add);\n    }\n\n    if (delta.sort) {\n      ds._data.sort(delta.sort);\n    }\n\n    // if reflowing, add any other tuples not currently in changeset\n    if (input.reflow) {\n      delta.mod = delta.mod.concat(\n        Tuple.idFilter(ds._data, delta.add, delta.mod, delta.rem));\n    }\n\n    // reset change list\n    ds._input = ChangeSet.create();\n\n    out.add = delta.add;\n    out.mod = delta.mod;\n    out.rem = delta.rem;\n    out.facet = ds._facet;\n    return out;\n  };\n\n  return input;\n}\n\n// Output node captures the last changeset seen by this datasource\n// (needed for joins and builds) and materializes any nested data.\n// If this datasource is faceted, materializes the values in the facet.\nfunction DataSourceOutput(ds) {\n  var output = new Node(ds._graph)\n    .router(true)\n    .reflows(true)\n    .collector(true);\n\n  function updateIndices(pulse) {\n    var fields = ds._indexFields,\n        i, j, f, key, index, value;\n\n    for (i=0; i<fields.length; ++i) {\n      key = fields[i];\n      index = ds._indexes[key];\n      f = dl.$(key);\n\n      for (j=0; j<pulse.add.length; ++j) {\n        value = f(pulse.add[j]);\n        Tuple.prev_init(pulse.add[j]);\n        index[value] = (index[value] || 0) + 1;\n      }\n      for (j=0; j<pulse.rem.length; ++j) {\n        value = f(pulse.rem[j]);\n        index[value] = (index[value] || 0) - 1;\n      }\n      for (j=0; j<pulse.mod.length; ++j) {\n        value = f(pulse.mod[j]._prev);\n        index[value] = (index[value] || 0) - 1;\n        value = f(pulse.mod[j]);\n        index[value] = (index[value] || 0) + 1;\n      }\n    }\n  }\n\n  output.data = function() {\n    return ds._collector ? ds._collector.data() : ds._data;\n  };\n\n  output.evaluate = function(input) {\n    log.debug(input, ['output', ds._name]);\n\n    updateIndices(input);\n    var out = ChangeSet.create(input, true);\n\n    if (ds._facet) {\n      ds._facet.values = ds.values();\n      input.facet = null;\n    }\n\n    ds._output = input;\n    out.data[ds._name] = 1;\n    return out;\n  };\n\n  return output;\n}\n\nfunction DataSourceListener(ds) {\n  var l = new Node(ds._graph).router(true);\n\n  l.evaluate = function(input) {\n    // Tuple derivation carries a cost. So only derive if the pipeline has\n    // operators that mutate, and thus would override the source data.\n    if (ds.mutates()) {\n      var map = ds._srcMap || (ds._srcMap = {}), // to propagate tuples correctly\n          output = ChangeSet.create(input);\n\n      output.add = input.add.map(function(t) {\n        return (map[t._id] = Tuple.derive(t));\n      });\n\n      output.mod = input.mod.map(function(t) {\n        return Tuple.rederive(t, map[t._id]);\n      });\n\n      output.rem = input.rem.map(function(t) {\n        var o = map[t._id];\n        return (map[t._id] = null, o);\n      });\n\n      return (ds._input = output);\n    } else {\n      return (ds._input = input);\n    }\n  };\n\n  return l;\n}\n\nmodule.exports = DataSource;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-dataflow/src/DataSource.js\n ** module id = 15\n ** module chunks = 0\n **/","var util = require('./util');\n\nvar dl = {\n  version:    '__VERSION__',\n  load:       require('./import/load'),\n  read:       require('./import/read'),\n  type:       require('./import/type'),\n  Aggregator: require('./aggregate/aggregator'),\n  groupby:    require('./aggregate/groupby'),\n  bins:       require('./bins/bins'),\n  $bin:       require('./bins/histogram').$bin,\n  histogram:  require('./bins/histogram').histogram,\n  format:     require('./format'),\n  template:   require('./template'),\n  time:       require('./time')\n};\n\nutil.extend(dl, util);\nutil.extend(dl, require('./accessor'));\nutil.extend(dl, require('./generate'));\nutil.extend(dl, require('./stats'));\nutil.extend(dl, require('./import/readers'));\nutil.extend(dl.format, require('./format-tables'));\n\n// backwards-compatible, deprecated API\n// will remove in the future\ndl.print = {\n  table:   dl.format.table,\n  summary: dl.format.summary\n};\n\nmodule.exports = dl;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/datalib/src/index.js\n ** module id = 16\n ** module chunks = 0\n **/","var u = module.exports;\n\n// utility functions\n\nvar FNAME = '__name__';\n\nu.namedfunc = function(name, f) { return (f[FNAME] = name, f); };\n\nu.name = function(f) { return f==null ? null : f[FNAME]; };\n\nu.identity = function(x) { return x; };\n\nu.true = u.namedfunc('true', function() { return true; });\n\nu.false = u.namedfunc('false', function() { return false; });\n\nu.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nu.equal = function(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\nu.extend = function(obj) {\n  for (var x, name, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (name in x) { obj[name] = x[name]; }\n  }\n  return obj;\n};\n\nu.length = function(x) {\n  return x != null && x.length != null ? x.length : null;\n};\n\nu.keys = function(x) {\n  var keys = [], k;\n  for (k in x) keys.push(k);\n  return keys;\n};\n\nu.vals = function(x) {\n  var vals = [], k;\n  for (k in x) vals.push(x[k]);\n  return vals;\n};\n\nu.toMap = function(list, f) {\n  return (f = u.$(f)) ?\n    list.reduce(function(obj, x) { return (obj[f(x)] = 1, obj); }, {}) :\n    list.reduce(function(obj, x) { return (obj[x] = 1, obj); }, {});\n};\n\nu.keystr = function(values) {\n  // use to ensure consistent key generation across modules\n  var n = values.length;\n  if (!n) return '';\n  for (var s=String(values[0]), i=1; i<n; ++i) {\n    s += '|' + String(values[i]);\n  }\n  return s;\n};\n\n// type checking functions\n\nvar toString = Object.prototype.toString;\n\nu.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\nu.isFunction = function(obj) {\n  return toString.call(obj) === '[object Function]';\n};\n\nu.isString = function(obj) {\n  return typeof value === 'string' || toString.call(obj) === '[object String]';\n};\n\nu.isArray = Array.isArray || function(obj) {\n  return toString.call(obj) === '[object Array]';\n};\n\nu.isNumber = function(obj) {\n  return typeof obj === 'number' || toString.call(obj) === '[object Number]';\n};\n\nu.isBoolean = function(obj) {\n  return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n};\n\nu.isDate = function(obj) {\n  return toString.call(obj) === '[object Date]';\n};\n\nu.isValid = function(obj) {\n  return obj != null && obj === obj;\n};\n\nu.isBuffer = (typeof Buffer === 'function' && Buffer.isBuffer) || u.false;\n\n// type coercion functions\n\nu.number = function(s) {\n  return s == null || s === '' ? null : +s;\n};\n\nu.boolean = function(s) {\n  return s == null || s === '' ? null : s==='false' ? false : !!s;\n};\n\n// parse a date with optional d3.time-format format\nu.date = function(s, format) {\n  var d = format ? format : Date;\n  return s == null || s === '' ? null : d.parse(s);\n};\n\nu.array = function(x) {\n  return x != null ? (u.isArray(x) ? x : [x]) : [];\n};\n\nu.str = function(x) {\n  return u.isArray(x) ? '[' + x.map(u.str) + ']'\n    : u.isObject(x) || u.isString(x) ?\n      // Output valid JSON and JS source strings.\n      // See http://timelessrepo.com/json-isnt-a-javascript-subset\n      JSON.stringify(x).replace('\\u2028','\\\\u2028').replace('\\u2029', '\\\\u2029')\n    : x;\n};\n\n// data access functions\n\nvar field_re = /\\[(.*?)\\]|[^.\\[]+/g;\n\nu.field = function(f) {\n  return String(f).match(field_re).map(function(d) {\n    return d[0] !== '[' ? d :\n      d[1] !== \"'\" && d[1] !== '\"' ? d.slice(1, -1) :\n      d.slice(2, -2).replace(/\\\\([\"'])/g, '$1');\n  });\n};\n\nu.accessor = function(f) {\n  /* jshint evil: true */\n  return f==null || u.isFunction(f) ? f :\n    u.namedfunc(f, Function('x', 'return x[' + u.field(f).map(u.str).join('][') + '];'));\n};\n\n// short-cut for accessor\nu.$ = u.accessor;\n\nu.mutator = function(f) {\n  var s;\n  return u.isString(f) && (s=u.field(f)).length > 1 ?\n    function(x, v) {\n      for (var i=0; i<s.length-1; ++i) x = x[s[i]];\n      x[s[i]] = v;\n    } :\n    function(x, v) { x[f] = v; };\n};\n\n\nu.$func = function(name, op) {\n  return function(f) {\n    f = u.$(f) || u.identity;\n    var n = name + (u.name(f) ? '_'+u.name(f) : '');\n    return u.namedfunc(n, function(d) { return op(f(d)); });\n  };\n};\n\nu.$valid  = u.$func('valid', u.isValid);\nu.$length = u.$func('length', u.length);\n\nu.$in = function(f, values) {\n  f = u.$(f);\n  var map = u.isArray(values) ? u.toMap(values) : values;\n  return function(d) { return !!map[f(d)]; };\n};\n\n// comparison / sorting functions\n\nu.comparator = function(sort) {\n  var sign = [];\n  if (sort === undefined) sort = [];\n  sort = u.array(sort).map(function(f) {\n    var s = 1;\n    if      (f[0] === '-') { s = -1; f = f.slice(1); }\n    else if (f[0] === '+') { s = +1; f = f.slice(1); }\n    sign.push(s);\n    return u.accessor(f);\n  });\n  return function(a,b) {\n    var i, n, f, x, y;\n    for (i=0, n=sort.length; i<n; ++i) {\n      f = sort[i]; x = f(a); y = f(b);\n      if (x < y) return -1 * sign[i];\n      if (x > y) return sign[i];\n    }\n    return 0;\n  };\n};\n\nu.cmp = function(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else if (a >= b) {\n    return 0;\n  } else if (a === null) {\n    return -1;\n  } else if (b === null) {\n    return 1;\n  }\n  return NaN;\n};\n\nu.numcmp = function(a, b) { return a - b; };\n\nu.stablesort = function(array, sortBy, keyFn) {\n  var indices = array.reduce(function(idx, v, i) {\n    return (idx[keyFn(v)] = i, idx);\n  }, {});\n\n  array.sort(function(a, b) {\n    var sa = sortBy(a),\n        sb = sortBy(b);\n    return sa < sb ? -1 : sa > sb ? 1\n         : (indices[keyFn(a)] - indices[keyFn(b)]);\n  });\n\n  return array;\n};\n\n\n// string functions\n\nu.pad = function(s, length, pos, padchar) {\n  padchar = padchar || \" \";\n  var d = length - s.length;\n  if (d <= 0) return s;\n  switch (pos) {\n    case 'left':\n      return strrep(d, padchar) + s;\n    case 'middle':\n    case 'center':\n      return strrep(Math.floor(d/2), padchar) +\n         s + strrep(Math.ceil(d/2), padchar);\n    default:\n      return s + strrep(d, padchar);\n  }\n};\n\nfunction strrep(n, str) {\n  var s = \"\", i;\n  for (i=0; i<n; ++i) s += str;\n  return s;\n}\n\nu.truncate = function(s, length, pos, word, ellipsis) {\n  var len = s.length;\n  if (len <= length) return s;\n  ellipsis = ellipsis !== undefined ? String(ellipsis) : '\\u2026';\n  var l = Math.max(0, length - ellipsis.length);\n\n  switch (pos) {\n    case 'left':\n      return ellipsis + (word ? truncateOnWord(s,l,1) : s.slice(len-l));\n    case 'middle':\n    case 'center':\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\n      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) +\n        ellipsis + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));\n    default:\n      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\n  }\n};\n\nfunction truncateOnWord(s, len, rev) {\n  var cnt = 0, tok = s.split(truncate_word_re);\n  if (rev) {\n    s = (tok = tok.reverse())\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\n      .reverse();\n  } else {\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\n  }\n  return s.length ? s.join('').trim() : tok[0].slice(0, len);\n}\n\nvar truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/datalib/src/util.js\n ** module id = 17\n ** module chunks = 0\n **/","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\nBuffer.poolSize = 8192 // not used by this implementation\n\nvar rootParent = {}\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property\n *     on objects.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\nfunction typedArraySupport () {\n  function Bar () {}\n  try {\n    var arr = new Uint8Array(1)\n    arr.foo = function () { return 42 }\n    arr.constructor = Bar\n    return arr.foo() === 42 && // typed array instances can be augmented\n        arr.constructor === Bar && // constructor can be set\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\n/**\n * Class: Buffer\n * =============\n *\n * The Buffer constructor returns instances of `Uint8Array` that are augmented\n * with function properties for all the node `Buffer` API functions. We use\n * `Uint8Array` so that square bracket notation works as expected -- it returns\n * a single octet.\n *\n * By augmenting the instances, we can avoid modifying the `Uint8Array`\n * prototype.\n */\nfunction Buffer (arg) {\n  if (!(this instanceof Buffer)) {\n    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.\n    if (arguments.length > 1) return new Buffer(arg, arguments[1])\n    return new Buffer(arg)\n  }\n\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    this.length = 0\n    this.parent = undefined\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    return fromNumber(this, arg)\n  }\n\n  // Slightly less common case.\n  if (typeof arg === 'string') {\n    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')\n  }\n\n  // Unusual.\n  return fromObject(this, arg)\n}\n\nfunction fromNumber (that, length) {\n  that = allocate(that, length < 0 ? 0 : checked(length) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < length; i++) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'\n\n  // Assumption: byteLength() return value is always < kMaxLength.\n  var length = byteLength(string, encoding) | 0\n  that = allocate(that, length)\n\n  that.write(string, encoding)\n  return that\n}\n\nfunction fromObject (that, object) {\n  if (Buffer.isBuffer(object)) return fromBuffer(that, object)\n\n  if (isArray(object)) return fromArray(that, object)\n\n  if (object == null) {\n    throw new TypeError('must start with number, buffer, array or string')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined') {\n    if (object.buffer instanceof ArrayBuffer) {\n      return fromTypedArray(that, object)\n    }\n    if (object instanceof ArrayBuffer) {\n      return fromArrayBuffer(that, object)\n    }\n  }\n\n  if (object.length) return fromArrayLike(that, object)\n\n  return fromJsonObject(that, object)\n}\n\nfunction fromBuffer (that, buffer) {\n  var length = checked(buffer.length) | 0\n  that = allocate(that, length)\n  buffer.copy(that, 0, 0, length)\n  return that\n}\n\nfunction fromArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Duplicate of fromArray() to keep fromArray() monomorphic.\nfunction fromTypedArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  // Truncating the elements is probably not what people expect from typed\n  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior\n  // of the old Buffer constructor.\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array) {\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    array.byteLength\n    that = Buffer._augment(new Uint8Array(array))\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromTypedArray(that, new Uint8Array(array))\n  }\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.\n// Returns a zero-length buffer for inputs that don't conform to the spec.\nfunction fromJsonObject (that, object) {\n  var array\n  var length = 0\n\n  if (object.type === 'Buffer' && isArray(object.data)) {\n    array = object.data\n    length = checked(array.length) | 0\n  }\n  that = allocate(that, length)\n\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n} else {\n  // pre-set for values that may exist in the future\n  Buffer.prototype.length = undefined\n  Buffer.prototype.parent = undefined\n}\n\nfunction allocate (that, length) {\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = Buffer._augment(new Uint8Array(length))\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that.length = length\n    that._isBuffer = true\n  }\n\n  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1\n  if (fromPool) that.parent = rootParent\n\n  return that\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (subject, encoding) {\n  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)\n\n  var buf = new Buffer(subject, encoding)\n  delete buf.parent\n  return buf\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  var i = 0\n  var len = Math.min(x, y)\n  while (i < len) {\n    if (a[i] !== b[i]) break\n\n    ++i\n  }\n\n  if (i !== len) {\n    x = a[i]\n    y = b[i]\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'binary':\n    case 'base64':\n    case 'raw':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')\n\n  if (list.length === 0) {\n    return new Buffer(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; i++) {\n      length += list[i].length\n    }\n  }\n\n  var buf = new Buffer(length)\n  var pos = 0\n  for (i = 0; i < list.length; i++) {\n    var item = list[i]\n    item.copy(buf, pos)\n    pos += item.length\n  }\n  return buf\n}\n\nfunction byteLength (string, encoding) {\n  if (typeof string !== 'string') string = '' + string\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'binary':\n      // Deprecated\n      case 'raw':\n      case 'raws':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  start = start | 0\n  end = end === undefined || end === Infinity ? this.length : end | 0\n\n  if (!encoding) encoding = 'utf8'\n  if (start < 0) start = 0\n  if (end > this.length) end = this.length\n  if (end <= start) return ''\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'binary':\n        return binarySlice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return 0\n  return Buffer.compare(this, b)\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset) {\n  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff\n  else if (byteOffset < -0x80000000) byteOffset = -0x80000000\n  byteOffset >>= 0\n\n  if (this.length === 0) return -1\n  if (byteOffset >= this.length) return -1\n\n  // Negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)\n\n  if (typeof val === 'string') {\n    if (val.length === 0) return -1 // special case: looking for empty string always fails\n    return String.prototype.indexOf.call(this, val, byteOffset)\n  }\n  if (Buffer.isBuffer(val)) {\n    return arrayIndexOf(this, val, byteOffset)\n  }\n  if (typeof val === 'number') {\n    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {\n      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)\n    }\n    return arrayIndexOf(this, [ val ], byteOffset)\n  }\n\n  function arrayIndexOf (arr, val, byteOffset) {\n    var foundIndex = -1\n    for (var i = 0; byteOffset + i < arr.length; i++) {\n      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex\n      } else {\n        foundIndex = -1\n      }\n    }\n    return -1\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\n// `get` is deprecated\nBuffer.prototype.get = function get (offset) {\n  console.log('.get() is deprecated. Access using array indexes instead.')\n  return this.readUInt8(offset)\n}\n\n// `set` is deprecated\nBuffer.prototype.set = function set (v, offset) {\n  console.log('.set() is deprecated. Access using array indexes instead.')\n  return this.writeUInt8(v, offset)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new Error('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; i++) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) throw new Error('Invalid hex string')\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction binaryWrite (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    var swap = encoding\n    encoding = offset\n    offset = length | 0\n    length = swap\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'binary':\n        return binaryWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction binarySlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; i++) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = Buffer._augment(this.subarray(start, end))\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; i++) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  if (newBuf.length) newBuf.parent = this.parent || this\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n  if (offset < 0) throw new RangeError('index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; i--) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; i++) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    target._set(this.subarray(start, start + len), targetStart)\n  }\n\n  return len\n}\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill (value, start, end) {\n  if (!value) value = 0\n  if (!start) start = 0\n  if (!end) end = this.length\n\n  if (end < start) throw new RangeError('end < start')\n\n  // Fill 0 bytes; we're done\n  if (end === start) return\n  if (this.length === 0) return\n\n  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')\n  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')\n\n  var i\n  if (typeof value === 'number') {\n    for (i = start; i < end; i++) {\n      this[i] = value\n    }\n  } else {\n    var bytes = utf8ToBytes(value.toString())\n    var len = bytes.length\n    for (i = start; i < end; i++) {\n      this[i] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n/**\n * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.\n * Added in Node 0.12. Only available in browsers that support ArrayBuffer.\n */\nBuffer.prototype.toArrayBuffer = function toArrayBuffer () {\n  if (typeof Uint8Array !== 'undefined') {\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n      return (new Buffer(this)).buffer\n    } else {\n      var buf = new Uint8Array(this.length)\n      for (var i = 0, len = buf.length; i < len; i += 1) {\n        buf[i] = this[i]\n      }\n      return buf.buffer\n    }\n  } else {\n    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')\n  }\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar BP = Buffer.prototype\n\n/**\n * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods\n */\nBuffer._augment = function _augment (arr) {\n  arr.constructor = Buffer\n  arr._isBuffer = true\n\n  // save reference to original Uint8Array set method before overwriting\n  arr._set = arr.set\n\n  // deprecated\n  arr.get = BP.get\n  arr.set = BP.set\n\n  arr.write = BP.write\n  arr.toString = BP.toString\n  arr.toLocaleString = BP.toString\n  arr.toJSON = BP.toJSON\n  arr.equals = BP.equals\n  arr.compare = BP.compare\n  arr.indexOf = BP.indexOf\n  arr.copy = BP.copy\n  arr.slice = BP.slice\n  arr.readUIntLE = BP.readUIntLE\n  arr.readUIntBE = BP.readUIntBE\n  arr.readUInt8 = BP.readUInt8\n  arr.readUInt16LE = BP.readUInt16LE\n  arr.readUInt16BE = BP.readUInt16BE\n  arr.readUInt32LE = BP.readUInt32LE\n  arr.readUInt32BE = BP.readUInt32BE\n  arr.readIntLE = BP.readIntLE\n  arr.readIntBE = BP.readIntBE\n  arr.readInt8 = BP.readInt8\n  arr.readInt16LE = BP.readInt16LE\n  arr.readInt16BE = BP.readInt16BE\n  arr.readInt32LE = BP.readInt32LE\n  arr.readInt32BE = BP.readInt32BE\n  arr.readFloatLE = BP.readFloatLE\n  arr.readFloatBE = BP.readFloatBE\n  arr.readDoubleLE = BP.readDoubleLE\n  arr.readDoubleBE = BP.readDoubleBE\n  arr.writeUInt8 = BP.writeUInt8\n  arr.writeUIntLE = BP.writeUIntLE\n  arr.writeUIntBE = BP.writeUIntBE\n  arr.writeUInt16LE = BP.writeUInt16LE\n  arr.writeUInt16BE = BP.writeUInt16BE\n  arr.writeUInt32LE = BP.writeUInt32LE\n  arr.writeUInt32BE = BP.writeUInt32BE\n  arr.writeIntLE = BP.writeIntLE\n  arr.writeIntBE = BP.writeIntBE\n  arr.writeInt8 = BP.writeInt8\n  arr.writeInt16LE = BP.writeInt16LE\n  arr.writeInt16BE = BP.writeInt16BE\n  arr.writeInt32LE = BP.writeInt32LE\n  arr.writeInt32BE = BP.writeInt32BE\n  arr.writeFloatLE = BP.writeFloatLE\n  arr.writeFloatBE = BP.writeFloatBE\n  arr.writeDoubleLE = BP.writeDoubleLE\n  arr.writeDoubleBE = BP.writeDoubleBE\n  arr.fill = BP.fill\n  arr.inspect = BP.inspect\n  arr.toArrayBuffer = BP.toArrayBuffer\n\n  return arr\n}\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; i++) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; i++) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/node-libs-browser/~/buffer/index.js\n ** module id = 18\n ** module chunks = 0\n **/","var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n;(function (exports) {\n\t'use strict';\n\n  var Arr = (typeof Uint8Array !== 'undefined')\n    ? Uint8Array\n    : Array\n\n\tvar PLUS   = '+'.charCodeAt(0)\n\tvar SLASH  = '/'.charCodeAt(0)\n\tvar NUMBER = '0'.charCodeAt(0)\n\tvar LOWER  = 'a'.charCodeAt(0)\n\tvar UPPER  = 'A'.charCodeAt(0)\n\tvar PLUS_URL_SAFE = '-'.charCodeAt(0)\n\tvar SLASH_URL_SAFE = '_'.charCodeAt(0)\n\n\tfunction decode (elt) {\n\t\tvar code = elt.charCodeAt(0)\n\t\tif (code === PLUS ||\n\t\t    code === PLUS_URL_SAFE)\n\t\t\treturn 62 // '+'\n\t\tif (code === SLASH ||\n\t\t    code === SLASH_URL_SAFE)\n\t\t\treturn 63 // '/'\n\t\tif (code < NUMBER)\n\t\t\treturn -1 //no match\n\t\tif (code < NUMBER + 10)\n\t\t\treturn code - NUMBER + 26 + 26\n\t\tif (code < UPPER + 26)\n\t\t\treturn code - UPPER\n\t\tif (code < LOWER + 26)\n\t\t\treturn code - LOWER + 26\n\t}\n\n\tfunction b64ToByteArray (b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr\n\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow new Error('Invalid string. Length must be a multiple of 4')\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tvar len = b64.length\n\t\tplaceHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = new Arr(b64.length * 3 / 4 - placeHolders)\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length\n\n\t\tvar L = 0\n\n\t\tfunction push (v) {\n\t\t\tarr[L++] = v\n\t\t}\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\n\t\t\tpush((tmp & 0xFF0000) >> 16)\n\t\t\tpush((tmp & 0xFF00) >> 8)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\n\t\t\tpush(tmp & 0xFF)\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\n\t\t\tpush((tmp >> 8) & 0xFF)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\treturn arr\n\t}\n\n\tfunction uint8ToBase64 (uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = \"\",\n\t\t\ttemp, length\n\n\t\tfunction encode (num) {\n\t\t\treturn lookup.charAt(num)\n\t\t}\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)\n\t\t}\n\n\t\t// go through the array every three bytes, we'll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n\t\t\toutput += tripletToBase64(temp)\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1]\n\t\t\t\toutput += encode(temp >> 2)\n\t\t\t\toutput += encode((temp << 4) & 0x3F)\n\t\t\t\toutput += '=='\n\t\t\t\tbreak\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])\n\t\t\t\toutput += encode(temp >> 10)\n\t\t\t\toutput += encode((temp >> 4) & 0x3F)\n\t\t\t\toutput += encode((temp << 2) & 0x3F)\n\t\t\t\toutput += '='\n\t\t\t\tbreak\n\t\t}\n\n\t\treturn output\n\t}\n\n\texports.toByteArray = b64ToByteArray\n\texports.fromByteArray = uint8ToBase64\n}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/node-libs-browser/~/base64-js/lib/b64.js\n ** module id = 19\n ** module chunks = 0\n **/","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ieee754/index.js\n ** module id = 20\n ** module chunks = 0\n **/","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/isarray/index.js\n ** module id = 21\n ** module chunks = 0\n **/","var util = require('../util');\n\n// Matches absolute URLs with optional protocol\n//   https://...    file://...    //...\nvar protocol_re = /^([A-Za-z]+:)?\\/\\//;\n\n// Special treatment in node.js for the file: protocol\nvar fileProtocol = 'file://';\n\n// Validate and cleanup URL to ensure that it is allowed to be accessed\n// Returns cleaned up URL, or false if access is not allowed\nfunction sanitizeUrl(opt) {\n  var url = opt.url;\n  if (!url && opt.file) { return fileProtocol + opt.file; }\n\n  // In case this is a relative url (has no host), prepend opt.baseURL\n  if (opt.baseURL && !protocol_re.test(url)) {\n    if (!startsWith(url, '/') && opt.baseURL[opt.baseURL.length-1] !== '/') {\n      url = '/' + url; // Ensure that there is a slash between the baseURL (e.g. hostname) and url\n    }\n    url = opt.baseURL + url;\n  }\n  // relative protocol, starts with '//'\n  if (!load.useXHR && startsWith(url, '//')) {\n    url = (opt.defaultProtocol || 'http') + ':' + url;\n  }\n  // If opt.domainWhiteList is set, only allows url, whose hostname\n  // * Is the same as the origin (window.location.hostname)\n  // * Equals one of the values in the whitelist\n  // * Is a proper subdomain of one of the values in the whitelist\n  if (opt.domainWhiteList) {\n    var domain, origin;\n    if (load.useXHR) {\n      var a = document.createElement('a');\n      a.href = url;\n      // From http://stackoverflow.com/questions/736513/how-do-i-parse-a-url-into-hostname-and-path-in-javascript\n      // IE doesn't populate all link properties when setting .href with a relative URL,\n      // however .href will return an absolute URL which then can be used on itself\n      // to populate these additional fields.\n      if (a.host === '') {\n        a.href = a.href;\n      }\n      domain = a.hostname.toLowerCase();\n      origin = window.location.hostname;\n    } else {\n      // relative protocol is broken: https://github.com/defunctzombie/node-url/issues/5\n      var parts = require('url').parse(url);\n      domain = parts.hostname;\n      origin = null;\n    }\n\n    if (origin !== domain) {\n      var whiteListed = opt.domainWhiteList.some(function(d) {\n        var idx = domain.length - d.length;\n        return d === domain ||\n          (idx > 1 && domain[idx-1] === '.' && domain.lastIndexOf(d) === idx);\n      });\n      if (!whiteListed) {\n        throw 'URL is not whitelisted: ' + url;\n      }\n    }\n  }\n  return url;\n}\n\nfunction load(opt, callback) {\n  return load.loader(opt, callback);\n}\n\nfunction loader(opt, callback) {\n  var error = callback || function(e) { throw e; }, url;\n\n  try {\n    url = load.sanitizeUrl(opt); // enable override\n  } catch (err) {\n    error(err);\n    return;\n  }\n\n  if (!url) {\n    error('Invalid URL: ' + opt.url);\n  } else if (load.useXHR) {\n    // on client, use xhr\n    return load.xhr(url, opt, callback);\n  } else if (startsWith(url, fileProtocol)) {\n    // on server, if url starts with 'file://', strip it and load from file\n    return load.file(url.slice(fileProtocol.length), opt, callback);\n  } else if (url.indexOf('://') < 0) { // TODO better protocol check?\n    // on server, if no protocol assume file\n    return load.file(url, opt, callback);\n  } else {\n    // for regular URLs on server\n    return load.http(url, opt, callback);\n  }\n}\n\nfunction xhrHasResponse(request) {\n  var type = request.responseType;\n  return type && type !== 'text' ?\n    request.response : // null on error\n    request.responseText; // '' on error\n}\n\nfunction xhr(url, opt, callback) {\n  var async = !!callback;\n  var request = new XMLHttpRequest();\n  // If IE does not support CORS, use XDomainRequest (copied from d3.xhr)\n  if (typeof XDomainRequest !== 'undefined' &&\n      !('withCredentials' in request) &&\n      /^(http(s)?:)?\\/\\//.test(url)) request = new XDomainRequest();\n\n  function respond() {\n    var status = request.status;\n    if (!status && xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {\n      callback(null, request.responseText);\n    } else {\n      callback(request, null);\n    }\n  }\n\n  if (async) {\n    if ('onload' in request) {\n      request.onload = request.onerror = respond;\n    } else {\n      request.onreadystatechange = function() {\n        if (request.readyState > 3) respond();\n      };\n    }\n  }\n\n  request.open('GET', url, async);\n  /* istanbul ignore else */\n  if (request.setRequestHeader) {\n    var headers = util.extend({}, load.headers, opt.headers);\n    for (var name in headers) {\n      request.setRequestHeader(name, headers[name]);\n    }\n  }\n  request.send();\n\n  if (!async && xhrHasResponse(request)) {\n    return request.responseText;\n  }\n}\n\nfunction file(filename, opt, callback) {\n  var fs = require('fs');\n  if (!callback) {\n    return fs.readFileSync(filename, 'utf8');\n  }\n  fs.readFile(filename, callback);\n}\n\nfunction http(url, opt, callback) {\n  var headers = util.extend({}, load.headers, opt.headers);\n\n  if (!callback) {\n    return require('sync-request')('GET', url, {headers: headers}).getBody();\n  }\n\n  var options = {url: url, encoding: null, gzip: true, headers: headers};\n  require('request')(options, function(error, response, body) {\n    if (!error && response.statusCode === 200) {\n      callback(null, body);\n    } else {\n      error = error ||\n        'Load failed with response code ' + response.statusCode + '.';\n      callback(error, null);\n    }\n  });\n}\n\nfunction startsWith(string, searchString) {\n  return string == null ? false : string.lastIndexOf(searchString, 0) === 0;\n}\n\n// Allow these functions to be overriden by the user of the library\nload.loader = loader;\nload.sanitizeUrl = sanitizeUrl;\nload.xhr = xhr;\nload.file = file;\nload.http = http;\n\n// Default settings\nload.useXHR = (typeof XMLHttpRequest !== 'undefined');\nload.headers = {};\n\nmodule.exports = load;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/datalib/src/import/load.js\n ** module id = 22\n ** module chunks = 0\n **/","/* (ignored) */\n\n\n/*****************\n ** WEBPACK FOOTER\n ** url (ignored)\n ** module id = 23\n ** module chunks = 0\n **/","/* (ignored) */\n\n\n/*****************\n ** WEBPACK FOOTER\n ** fs (ignored)\n ** module id = 24\n ** module chunks = 0\n **/","/* (ignored) */\n\n\n/*****************\n ** WEBPACK FOOTER\n ** sync-request (ignored)\n ** module id = 25\n ** module chunks = 0\n **/","/* (ignored) */\n\n\n/*****************\n ** WEBPACK FOOTER\n ** request (ignored)\n ** module id = 26\n ** module chunks = 0\n **/","var util = require('../util'),\n  type = require('./type'),\n  formats = require('./formats'),\n  timeF = require('../format').time;\n\nfunction read(data, format) {\n  var type = (format && format.type) || 'json';\n  data = formats[type](data, format);\n  if (format && format.parse) parse(data, format.parse);\n  return data;\n}\n\nfunction parse(data, types) {\n  var cols, parsers, d, i, j, clen, len = data.length;\n\n  types = (types==='auto') ? type.inferAll(data) : util.duplicate(types);\n  cols = util.keys(types);\n  parsers = cols.map(function(c) {\n    var t = types[c];\n    if (t && t.indexOf('date:') === 0) {\n      var parts = t.split(':', 2),\n          pattern = parts[1];\n      if ((pattern[0] === '\\'' && pattern[pattern.length-1] === '\\'') ||\n          (pattern[0] === '\"'  && pattern[pattern.length-1] === '\"')) {\n        pattern = pattern.slice(1, -1);\n      } else {\n        throw Error('Format pattern must be quoted: ' + pattern);\n      }\n      pattern = timeF(pattern);\n      return function(v) { return pattern.parse(v); };\n    }\n    if (!type.parsers[t]) {\n      throw Error('Illegal format pattern: ' + c + ':' + t);\n    }\n    return type.parsers[t];\n  });\n\n  for (i=0, clen=cols.length; i<len; ++i) {\n    d = data[i];\n    for (j=0; j<clen; ++j) {\n      d[cols[j]] = parsers[j](d[cols[j]]);\n    }\n  }\n  type.annotation(data, types);\n}\n\nread.formats = formats;\nmodule.exports = read;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/datalib/src/import/read.js\n ** module id = 27\n ** module chunks = 0\n **/","var util = require('../util');\n\nvar TYPES = '__types__';\n\nvar PARSERS = {\n  boolean: util.boolean,\n  integer: util.number,\n  number:  util.number,\n  date:    util.date,\n  string:  function(x) { return x==='' ? null : x; }\n};\n\nvar TESTS = {\n  boolean: function(x) { return x==='true' || x==='false' || util.isBoolean(x); },\n  integer: function(x) { return TESTS.number(x) && (x=+x) === ~~x; },\n  number: function(x) { return !isNaN(+x) && !util.isDate(x); },\n  date: function(x) { return !isNaN(Date.parse(x)); }\n};\n\nfunction annotation(data, types) {\n  if (!types) return data && data[TYPES] || null;\n  data[TYPES] = types;\n}\n\nfunction type(values, f) {\n  values = util.array(values);\n  f = util.$(f);\n  var v, i, n;\n\n  // if data array has type annotations, use them\n  if (values[TYPES]) {\n    v = f(values[TYPES]);\n    if (util.isString(v)) return v;\n  }\n\n  for (i=0, n=values.length; !util.isValid(v) && i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n  }\n\n  return util.isDate(v) ? 'date' :\n    util.isNumber(v)    ? 'number' :\n    util.isBoolean(v)   ? 'boolean' :\n    util.isString(v)    ? 'string' : null;\n}\n\nfunction typeAll(data, fields) {\n  if (!data.length) return;\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    return (types[f] = type(data, f), types);\n  }, {});\n}\n\nfunction infer(values, f) {\n  values = util.array(values);\n  f = util.$(f);\n  var i, j, v;\n\n  // types to test for, in precedence order\n  var types = ['boolean', 'integer', 'number', 'date'];\n\n  for (i=0; i<values.length; ++i) {\n    // get next value to test\n    v = f ? f(values[i]) : values[i];\n    // test value against remaining types\n    for (j=0; j<types.length; ++j) {\n      if (util.isValid(v) && !TESTS[types[j]](v)) {\n        types.splice(j, 1);\n        j -= 1;\n      }\n    }\n    // if no types left, return 'string'\n    if (types.length === 0) return 'string';\n  }\n\n  return types[0];\n}\n\nfunction inferAll(data, fields) {\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    types[f] = infer(data, f);\n    return types;\n  }, {});\n}\n\ntype.annotation = annotation;\ntype.all = typeAll;\ntype.infer = infer;\ntype.inferAll = inferAll;\ntype.parsers = PARSERS;\nmodule.exports = type;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/datalib/src/import/type.js\n ** module id = 28\n ** module chunks = 0\n **/","var dsv = require('./dsv');\n\nmodule.exports = {\n  json: require('./json'),\n  topojson: require('./topojson'),\n  treejson: require('./treejson'),\n  dsv: dsv,\n  csv: dsv.delimiter(','),\n  tsv: dsv.delimiter('\\t')\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/datalib/src/import/formats/index.js\n ** module id = 29\n ** module chunks = 0\n **/","var util = require('../../util');\nvar d3_dsv = require('d3-dsv');\n\nfunction dsv(data, format) {\n  if (data) {\n    var h = format.header;\n    data = (h ? h.join(format.delimiter) + '\\n' : '') + data;\n  }\n  return d3_dsv.dsv(format.delimiter).parse(data);\n}\n\ndsv.delimiter = function(delim) {\n  var fmt = {delimiter: delim};\n  return function(data, format) {\n    return dsv(data, format ? util.extend(format, fmt) : fmt);\n  };\n};\n\nmodule.exports = dsv;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/datalib/src/import/formats/dsv.js\n ** module id = 30\n ** module chunks = 0\n **/","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.d3_dsv = {})));\n}(this, function (exports) { 'use strict';\n\n  function dsv(delimiter) {\n    return new Dsv(delimiter);\n  }\n\n  function objectConverter(columns) {\n    return new Function(\"d\", \"return {\" + columns.map(function(name, i) {\n      return JSON.stringify(name) + \": d[\" + i + \"]\";\n    }).join(\",\") + \"}\");\n  }\n\n  function customConverter(columns, f) {\n    var object = objectConverter(columns);\n    return function(row, i) {\n      return f(object(row), i, columns);\n    };\n  }\n\n  // Compute unique columns in order of discovery.\n  function inferColumns(rows) {\n    var columnSet = Object.create(null),\n        columns = [];\n\n    rows.forEach(function(row) {\n      for (var column in row) {\n        if (!(column in columnSet)) {\n          columns.push(columnSet[column] = column);\n        }\n      }\n    });\n\n    return columns;\n  }\n\n  function Dsv(delimiter) {\n    var reFormat = new RegExp(\"[\\\"\" + delimiter + \"\\n]\"),\n        delimiterCode = delimiter.charCodeAt(0);\n\n    this.parse = function(text, f) {\n      var convert, columns, rows = this.parseRows(text, function(row, i) {\n        if (convert) return convert(row, i - 1);\n        columns = row, convert = f ? customConverter(row, f) : objectConverter(row);\n      });\n      rows.columns = columns;\n      return rows;\n    };\n\n    this.parseRows = function(text, f) {\n      var EOL = {}, // sentinel value for end-of-line\n          EOF = {}, // sentinel value for end-of-file\n          rows = [], // output rows\n          N = text.length,\n          I = 0, // current character index\n          n = 0, // the current line number\n          t, // the current token\n          eol; // is the current token followed by EOL?\n\n      function token() {\n        if (I >= N) return EOF; // special case: end of file\n        if (eol) return eol = false, EOL; // special case: end of line\n\n        // special case: quotes\n        var j = I, c;\n        if (text.charCodeAt(j) === 34) {\n          var i = j;\n          while (i++ < N) {\n            if (text.charCodeAt(i) === 34) {\n              if (text.charCodeAt(i + 1) !== 34) break;\n              ++i;\n            }\n          }\n          I = i + 2;\n          c = text.charCodeAt(i + 1);\n          if (c === 13) {\n            eol = true;\n            if (text.charCodeAt(i + 2) === 10) ++I;\n          } else if (c === 10) {\n            eol = true;\n          }\n          return text.slice(j + 1, i).replace(/\"\"/g, \"\\\"\");\n        }\n\n        // common case: find next delimiter or newline\n        while (I < N) {\n          var k = 1;\n          c = text.charCodeAt(I++);\n          if (c === 10) eol = true; // \\n\n          else if (c === 13) { eol = true; if (text.charCodeAt(I) === 10) ++I, ++k; } // \\r|\\r\\n\n          else if (c !== delimiterCode) continue;\n          return text.slice(j, I - k);\n        }\n\n        // special case: last token before EOF\n        return text.slice(j);\n      }\n\n      while ((t = token()) !== EOF) {\n        var a = [];\n        while (t !== EOL && t !== EOF) {\n          a.push(t);\n          t = token();\n        }\n        if (f && (a = f(a, n++)) == null) continue;\n        rows.push(a);\n      }\n\n      return rows;\n    }\n\n    this.format = function(rows, columns) {\n      if (columns == null) columns = inferColumns(rows);\n      return [columns.map(formatValue).join(delimiter)].concat(rows.map(function(row) {\n        return columns.map(function(column) {\n          return formatValue(row[column]);\n        }).join(delimiter);\n      })).join(\"\\n\");\n    };\n\n    this.formatRows = function(rows) {\n      return rows.map(formatRow).join(\"\\n\");\n    };\n\n    function formatRow(row) {\n      return row.map(formatValue).join(delimiter);\n    }\n\n    function formatValue(text) {\n      return reFormat.test(text) ? \"\\\"\" + text.replace(/\\\"/g, \"\\\"\\\"\") + \"\\\"\" : text;\n    }\n  }\n\n  dsv.prototype = Dsv.prototype;\n\n  var csv = dsv(\",\");\n  var tsv = dsv(\"\\t\");\n\n  var version = \"0.1.14\";\n\n  exports.version = version;\n  exports.dsv = dsv;\n  exports.csv = csv;\n  exports.tsv = tsv;\n\n}));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/d3-dsv/build/d3-dsv.js\n ** module id = 31\n ** module chunks = 0\n **/","var util = require('../../util');\n\nmodule.exports = function(data, format) {\n  var d = util.isObject(data) && !util.isBuffer(data) ?\n    data : JSON.parse(data);\n  if (format && format.property) {\n    d = util.accessor(format.property)(d);\n  }\n  return d;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/datalib/src/import/formats/json.js\n ** module id = 32\n ** module chunks = 0\n **/","var json = require('./json');\n\nvar reader = function(data, format) {\n  var topojson = reader.topojson;\n  if (topojson == null) { throw Error('TopoJSON library not loaded.'); }\n\n  var t = json(data, format), obj;\n\n  if (format && format.feature) {\n    if ((obj = t.objects[format.feature])) {\n      return topojson.feature(t, obj).features;\n    } else {\n      throw Error('Invalid TopoJSON object: ' + format.feature);\n    }\n  } else if (format && format.mesh) {\n    if ((obj = t.objects[format.mesh])) {\n      return [topojson.mesh(t, t.objects[format.mesh])];\n    } else {\n      throw Error('Invalid TopoJSON object: ' + format.mesh);\n    }\n  } else {\n    throw Error('Missing TopoJSON feature or mesh parameter.');\n  }\n};\n\nreader.topojson = require('topojson');\nmodule.exports = reader;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/datalib/src/import/formats/topojson.js\n ** module id = 33\n ** module chunks = 0\n **/","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.topojson = {})));\n}(this, function (exports) { 'use strict';\n\n  function noop() {}\n\n  function absolute(transform) {\n    if (!transform) return noop;\n    var x0,\n        y0,\n        kx = transform.scale[0],\n        ky = transform.scale[1],\n        dx = transform.translate[0],\n        dy = transform.translate[1];\n    return function(point, i) {\n      if (!i) x0 = y0 = 0;\n      point[0] = (x0 += point[0]) * kx + dx;\n      point[1] = (y0 += point[1]) * ky + dy;\n    };\n  }\n\n  function relative(transform) {\n    if (!transform) return noop;\n    var x0,\n        y0,\n        kx = transform.scale[0],\n        ky = transform.scale[1],\n        dx = transform.translate[0],\n        dy = transform.translate[1];\n    return function(point, i) {\n      if (!i) x0 = y0 = 0;\n      var x1 = (point[0] - dx) / kx | 0,\n          y1 = (point[1] - dy) / ky | 0;\n      point[0] = x1 - x0;\n      point[1] = y1 - y0;\n      x0 = x1;\n      y0 = y1;\n    };\n  }\n\n  function reverse(array, n) {\n    var t, j = array.length, i = j - n;\n    while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;\n  }\n\n  function bisect(a, x) {\n    var lo = 0, hi = a.length;\n    while (lo < hi) {\n      var mid = lo + hi >>> 1;\n      if (a[mid] < x) lo = mid + 1;\n      else hi = mid;\n    }\n    return lo;\n  }\n\n  function feature(topology, o) {\n    return o.type === \"GeometryCollection\" ? {\n      type: \"FeatureCollection\",\n      features: o.geometries.map(function(o) { return feature$1(topology, o); })\n    } : feature$1(topology, o);\n  }\n\n  function feature$1(topology, o) {\n    var f = {\n      type: \"Feature\",\n      id: o.id,\n      properties: o.properties || {},\n      geometry: object(topology, o)\n    };\n    if (o.id == null) delete f.id;\n    return f;\n  }\n\n  function object(topology, o) {\n    var absolute$$ = absolute(topology.transform),\n        arcs = topology.arcs;\n\n    function arc(i, points) {\n      if (points.length) points.pop();\n      for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length, p; k < n; ++k) {\n        points.push(p = a[k].slice());\n        absolute$$(p, k);\n      }\n      if (i < 0) reverse(points, n);\n    }\n\n    function point(p) {\n      p = p.slice();\n      absolute$$(p, 0);\n      return p;\n    }\n\n    function line(arcs) {\n      var points = [];\n      for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);\n      if (points.length < 2) points.push(points[0].slice());\n      return points;\n    }\n\n    function ring(arcs) {\n      var points = line(arcs);\n      while (points.length < 4) points.push(points[0].slice());\n      return points;\n    }\n\n    function polygon(arcs) {\n      return arcs.map(ring);\n    }\n\n    function geometry(o) {\n      var t = o.type;\n      return t === \"GeometryCollection\" ? {type: t, geometries: o.geometries.map(geometry)}\n          : t in geometryType ? {type: t, coordinates: geometryType[t](o)}\n          : null;\n    }\n\n    var geometryType = {\n      Point: function(o) { return point(o.coordinates); },\n      MultiPoint: function(o) { return o.coordinates.map(point); },\n      LineString: function(o) { return line(o.arcs); },\n      MultiLineString: function(o) { return o.arcs.map(line); },\n      Polygon: function(o) { return polygon(o.arcs); },\n      MultiPolygon: function(o) { return o.arcs.map(polygon); }\n    };\n\n    return geometry(o);\n  }\n\n  function stitchArcs(topology, arcs) {\n    var stitchedArcs = {},\n        fragmentByStart = {},\n        fragmentByEnd = {},\n        fragments = [],\n        emptyIndex = -1;\n\n    // Stitch empty arcs first, since they may be subsumed by other arcs.\n    arcs.forEach(function(i, j) {\n      var arc = topology.arcs[i < 0 ? ~i : i], t;\n      if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {\n        t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;\n      }\n    });\n\n    arcs.forEach(function(i) {\n      var e = ends(i),\n          start = e[0],\n          end = e[1],\n          f, g;\n\n      if (f = fragmentByEnd[start]) {\n        delete fragmentByEnd[f.end];\n        f.push(i);\n        f.end = end;\n        if (g = fragmentByStart[end]) {\n          delete fragmentByStart[g.start];\n          var fg = g === f ? f : f.concat(g);\n          fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;\n        } else {\n          fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n        }\n      } else if (f = fragmentByStart[end]) {\n        delete fragmentByStart[f.start];\n        f.unshift(i);\n        f.start = start;\n        if (g = fragmentByEnd[start]) {\n          delete fragmentByEnd[g.end];\n          var gf = g === f ? f : g.concat(f);\n          fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;\n        } else {\n          fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n        }\n      } else {\n        f = [i];\n        fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;\n      }\n    });\n\n    function ends(i) {\n      var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;\n      if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; });\n      else p1 = arc[arc.length - 1];\n      return i < 0 ? [p1, p0] : [p0, p1];\n    }\n\n    function flush(fragmentByEnd, fragmentByStart) {\n      for (var k in fragmentByEnd) {\n        var f = fragmentByEnd[k];\n        delete fragmentByStart[f.start];\n        delete f.start;\n        delete f.end;\n        f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });\n        fragments.push(f);\n      }\n    }\n\n    flush(fragmentByEnd, fragmentByStart);\n    flush(fragmentByStart, fragmentByEnd);\n    arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]); });\n\n    return fragments;\n  }\n\n  function mesh(topology) {\n    return object(topology, meshArcs.apply(this, arguments));\n  }\n\n  function meshArcs(topology, o, filter) {\n    var arcs = [];\n\n    function arc(i) {\n      var j = i < 0 ? ~i : i;\n      (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});\n    }\n\n    function line(arcs) {\n      arcs.forEach(arc);\n    }\n\n    function polygon(arcs) {\n      arcs.forEach(line);\n    }\n\n    function geometry(o) {\n      if (o.type === \"GeometryCollection\") o.geometries.forEach(geometry);\n      else if (o.type in geometryType) geom = o, geometryType[o.type](o.arcs);\n    }\n\n    if (arguments.length > 1) {\n      var geomsByArc = [],\n          geom;\n\n      var geometryType = {\n        LineString: line,\n        MultiLineString: polygon,\n        Polygon: polygon,\n        MultiPolygon: function(arcs) { arcs.forEach(polygon); }\n      };\n\n      geometry(o);\n\n      geomsByArc.forEach(arguments.length < 3\n          ? function(geoms) { arcs.push(geoms[0].i); }\n          : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i); });\n    } else {\n      for (var i = 0, n = topology.arcs.length; i < n; ++i) arcs.push(i);\n    }\n\n    return {type: \"MultiLineString\", arcs: stitchArcs(topology, arcs)};\n  }\n\n  function triangle(triangle) {\n    var a = triangle[0], b = triangle[1], c = triangle[2];\n    return Math.abs((a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]));\n  }\n\n  function ring(ring) {\n    var i = -1,\n        n = ring.length,\n        a,\n        b = ring[n - 1],\n        area = 0;\n\n    while (++i < n) {\n      a = b;\n      b = ring[i];\n      area += a[0] * b[1] - a[1] * b[0];\n    }\n\n    return area / 2;\n  }\n\n  function merge(topology) {\n    return object(topology, mergeArcs.apply(this, arguments));\n  }\n\n  function mergeArcs(topology, objects) {\n    var polygonsByArc = {},\n        polygons = [],\n        components = [];\n\n    objects.forEach(function(o) {\n      if (o.type === \"Polygon\") register(o.arcs);\n      else if (o.type === \"MultiPolygon\") o.arcs.forEach(register);\n    });\n\n    function register(polygon) {\n      polygon.forEach(function(ring$$) {\n        ring$$.forEach(function(arc) {\n          (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);\n        });\n      });\n      polygons.push(polygon);\n    }\n\n    function exterior(ring$$) {\n      return ring(object(topology, {type: \"Polygon\", arcs: [ring$$]}).coordinates[0]) > 0; // TODO allow spherical?\n    }\n\n    polygons.forEach(function(polygon) {\n      if (!polygon._) {\n        var component = [],\n            neighbors = [polygon];\n        polygon._ = 1;\n        components.push(component);\n        while (polygon = neighbors.pop()) {\n          component.push(polygon);\n          polygon.forEach(function(ring$$) {\n            ring$$.forEach(function(arc) {\n              polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {\n                if (!polygon._) {\n                  polygon._ = 1;\n                  neighbors.push(polygon);\n                }\n              });\n            });\n          });\n        }\n      }\n    });\n\n    polygons.forEach(function(polygon) {\n      delete polygon._;\n    });\n\n    return {\n      type: \"MultiPolygon\",\n      arcs: components.map(function(polygons) {\n        var arcs = [], n;\n\n        // Extract the exterior (unique) arcs.\n        polygons.forEach(function(polygon) {\n          polygon.forEach(function(ring$$) {\n            ring$$.forEach(function(arc) {\n              if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {\n                arcs.push(arc);\n              }\n            });\n          });\n        });\n\n        // Stitch the arcs into one or more rings.\n        arcs = stitchArcs(topology, arcs);\n\n        // If more than one ring is returned,\n        // at most one of these rings can be the exterior;\n        // this exterior ring has the same winding order\n        // as any exterior ring in the original polygons.\n        if ((n = arcs.length) > 1) {\n          var sgn = exterior(polygons[0][0]);\n          for (var i = 0, t; i < n; ++i) {\n            if (sgn === exterior(arcs[i])) {\n              t = arcs[0], arcs[0] = arcs[i], arcs[i] = t;\n              break;\n            }\n          }\n        }\n\n        return arcs;\n      })\n    };\n  }\n\n  function neighbors(objects) {\n    var indexesByArc = {}, // arc index -> array of object indexes\n        neighbors = objects.map(function() { return []; });\n\n    function line(arcs, i) {\n      arcs.forEach(function(a) {\n        if (a < 0) a = ~a;\n        var o = indexesByArc[a];\n        if (o) o.push(i);\n        else indexesByArc[a] = [i];\n      });\n    }\n\n    function polygon(arcs, i) {\n      arcs.forEach(function(arc) { line(arc, i); });\n    }\n\n    function geometry(o, i) {\n      if (o.type === \"GeometryCollection\") o.geometries.forEach(function(o) { geometry(o, i); });\n      else if (o.type in geometryType) geometryType[o.type](o.arcs, i);\n    }\n\n    var geometryType = {\n      LineString: line,\n      MultiLineString: polygon,\n      Polygon: polygon,\n      MultiPolygon: function(arcs, i) { arcs.forEach(function(arc) { polygon(arc, i); }); }\n    };\n\n    objects.forEach(geometry);\n\n    for (var i in indexesByArc) {\n      for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {\n        for (var k = j + 1; k < m; ++k) {\n          var ij = indexes[j], ik = indexes[k], n;\n          if ((n = neighbors[ij])[i = bisect(n, ik)] !== ik) n.splice(i, 0, ik);\n          if ((n = neighbors[ik])[i = bisect(n, ij)] !== ij) n.splice(i, 0, ij);\n        }\n      }\n    }\n\n    return neighbors;\n  }\n\n  function compareArea(a, b) {\n    return a[1][2] - b[1][2];\n  }\n\n  function minAreaHeap() {\n    var heap = {},\n        array = [],\n        size = 0;\n\n    heap.push = function(object) {\n      up(array[object._ = size] = object, size++);\n      return size;\n    };\n\n    heap.pop = function() {\n      if (size <= 0) return;\n      var removed = array[0], object;\n      if (--size > 0) object = array[size], down(array[object._ = 0] = object, 0);\n      return removed;\n    };\n\n    heap.remove = function(removed) {\n      var i = removed._, object;\n      if (array[i] !== removed) return; // invalid request\n      if (i !== --size) object = array[size], (compareArea(object, removed) < 0 ? up : down)(array[object._ = i] = object, i);\n      return i;\n    };\n\n    function up(object, i) {\n      while (i > 0) {\n        var j = ((i + 1) >> 1) - 1,\n            parent = array[j];\n        if (compareArea(object, parent) >= 0) break;\n        array[parent._ = i] = parent;\n        array[object._ = i = j] = object;\n      }\n    }\n\n    function down(object, i) {\n      while (true) {\n        var r = (i + 1) << 1,\n            l = r - 1,\n            j = i,\n            child = array[j];\n        if (l < size && compareArea(array[l], child) < 0) child = array[j = l];\n        if (r < size && compareArea(array[r], child) < 0) child = array[j = r];\n        if (j === i) break;\n        array[child._ = i] = child;\n        array[object._ = i = j] = object;\n      }\n    }\n\n    return heap;\n  }\n\n  function presimplify(topology, triangleArea) {\n    var absolute$$ = absolute(topology.transform),\n        relative$$ = relative(topology.transform),\n        heap = minAreaHeap();\n\n    if (!triangleArea) triangleArea = triangle;\n\n    topology.arcs.forEach(function(arc) {\n      var triangles = [],\n          maxArea = 0,\n          triangle,\n          i,\n          n,\n          p;\n\n      // To store each points effective area, we create a new array rather than\n      // extending the passed-in point to workaround a Chrome/V8 bug (getting\n      // stuck in smi mode). For midpoints, the initial effective area of\n      // Infinity will be computed in the next step.\n      for (i = 0, n = arc.length; i < n; ++i) {\n        p = arc[i];\n        absolute$$(arc[i] = [p[0], p[1], Infinity], i);\n      }\n\n      for (i = 1, n = arc.length - 1; i < n; ++i) {\n        triangle = arc.slice(i - 1, i + 2);\n        triangle[1][2] = triangleArea(triangle);\n        triangles.push(triangle);\n        heap.push(triangle);\n      }\n\n      for (i = 0, n = triangles.length; i < n; ++i) {\n        triangle = triangles[i];\n        triangle.previous = triangles[i - 1];\n        triangle.next = triangles[i + 1];\n      }\n\n      while (triangle = heap.pop()) {\n        var previous = triangle.previous,\n            next = triangle.next;\n\n        // If the area of the current point is less than that of the previous point\n        // to be eliminated, use the latter's area instead. This ensures that the\n        // current point cannot be eliminated without eliminating previously-\n        // eliminated points.\n        if (triangle[1][2] < maxArea) triangle[1][2] = maxArea;\n        else maxArea = triangle[1][2];\n\n        if (previous) {\n          previous.next = next;\n          previous[2] = triangle[2];\n          update(previous);\n        }\n\n        if (next) {\n          next.previous = previous;\n          next[0] = triangle[0];\n          update(next);\n        }\n      }\n\n      arc.forEach(relative$$);\n    });\n\n    function update(triangle) {\n      heap.remove(triangle);\n      triangle[1][2] = triangleArea(triangle);\n      heap.push(triangle);\n    }\n\n    return topology;\n  }\n\n  var version = \"1.6.24\";\n\n  exports.version = version;\n  exports.mesh = mesh;\n  exports.meshArcs = meshArcs;\n  exports.merge = merge;\n  exports.mergeArcs = mergeArcs;\n  exports.feature = feature;\n  exports.neighbors = neighbors;\n  exports.presimplify = presimplify;\n\n}));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/topojson/build/topojson.js\n ** module id = 34\n ** module chunks = 0\n **/","var json = require('./json');\n\nmodule.exports = function(tree, format) {\n  return toTable(json(tree, format), format);\n};\n\nfunction toTable(root, fields) {\n  var childrenField = fields && fields.children || 'children',\n      parentField = fields && fields.parent || 'parent',\n      table = [];\n\n  function visit(node, parent) {\n    node[parentField] = parent;\n    table.push(node);\n    var children = node[childrenField];\n    if (children) {\n      for (var i=0; i<children.length; ++i) {\n        visit(children[i], node);\n      }\n    }\n  }\n\n  visit(root, null);\n  return (table.root = root, table);\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/datalib/src/import/formats/treejson.js\n ** module id = 35\n ** module chunks = 0\n **/","var util = require('./util'),\n    d3_time = require('d3-time'),\n    d3_timeF = require('d3-time-format'),\n    d3_numberF = require('d3-format'),\n    numberF = d3_numberF, // defaults to EN-US\n    timeF = d3_timeF,     // defaults to EN-US\n    tmpDate = new Date(2000, 0, 1),\n    monthFull, monthAbbr, dayFull, dayAbbr;\n\n\nmodule.exports = {\n  // Update number formatter to use provided locale configuration.\n  // For more see https://github.com/d3/d3-format\n  numberLocale: numberLocale,\n  number:       function(f) { return numberF.format(f); },\n  numberPrefix: function(f, v) { return numberF.formatPrefix(f, v); },\n\n  // Update time formatter to use provided locale configuration.\n  // For more see https://github.com/d3/d3-time-format\n  timeLocale:   timeLocale,\n  time:         function(f) { return timeF.format(f); },\n  utc:          function(f) { return timeF.utcFormat(f); },\n\n  // Set number and time locale simultaneously.\n  locale:       function(l) { numberLocale(l); timeLocale(l); },\n\n  // automatic formatting functions\n  auto: {\n    number:   autoNumberFormat,\n    linear:   linearNumberFormat,\n    time:     function() { return timeAutoFormat(); },\n    utc:      function() { return utcAutoFormat(); }\n  },\n\n  month: monthFormat, // format month name from integer code\n  day:   dayFormat    // format week day name from integer code\n};\n\n// -- Locales ----\n\n// transform 'en-US' style locale string to match d3-format v0.4+ convention\nfunction localeRef(l) {\n  return l.length > 4 && 'locale' + (\n    l[0].toUpperCase() + l[1].toLowerCase() +\n    l[3].toUpperCase() + l[4].toLowerCase()\n  );\n}\n\nfunction numberLocale(l) {\n  var f = util.isString(l) ? d3_numberF[localeRef(l)] : d3_numberF.locale(l);\n  if (f == null) throw Error('Unrecognized locale: ' + l);\n  numberF = f;\n}\n\nfunction timeLocale(l) {\n  var f = util.isString(l) ? d3_timeF[localeRef(l)] : d3_timeF.locale(l);\n  if (f == null) throw Error('Unrecognized locale: ' + l);\n  timeF = f;\n  monthFull = monthAbbr = dayFull = dayAbbr = null;\n}\n\n// -- Number Formatting ----\n\nvar e10 = Math.sqrt(50),\n    e5 = Math.sqrt(10),\n    e2 = Math.sqrt(2);\n\nfunction linearRange(domain, count) {\n  if (!domain.length) domain = [0];\n  if (count == null) count = 10;\n\n  var start = domain[0],\n      stop = domain[domain.length - 1];\n\n  if (stop < start) { error = stop; stop = start; start = error; }\n\n  var span = (stop - start) || (count = 1, start || stop || 1),\n      step = Math.pow(10, Math.floor(Math.log(span / count) / Math.LN10)),\n      error = span / count / step;\n\n  // Filter ticks to get closer to the desired count.\n  if (error >= e10) step *= 10;\n  else if (error >= e5) step *= 5;\n  else if (error >= e2) step *= 2;\n\n  // Round start and stop values to step interval.\n  return [\n    Math.ceil(start / step) * step,\n    Math.floor(stop / step) * step + step / 2, // inclusive\n    step\n  ];\n}\n\nfunction trimZero(f, decimal) {\n  return function(x) {\n    var s = f(x),\n        n = s.indexOf(decimal);\n    if (n < 0) return s;\n\n    var idx = rightmostDigit(s, n),\n        end = idx < s.length ? s.slice(idx) : '';\n\n    while (--idx > n) {\n      if (s[idx] !== '0') { ++idx; break; }\n    }\n    return s.slice(0, idx) + end;\n  };\n}\n\nfunction rightmostDigit(s, n) {\n  var i = s.lastIndexOf('e'), c;\n  if (i > 0) return i;\n  for (i=s.length; --i > n;) {\n    c = s.charCodeAt(i);\n    if (c >= 48 && c <= 57) return i+1; // is digit\n  }\n}\n\nfunction autoNumberFormat(f) {\n  var decimal = numberF.format('.1f')(1)[1]; // get decimal char\n  if (f == null) f = ',';\n  f = d3_numberF.formatSpecifier(f);\n  if (f.precision == null) f.precision = 12;\n  switch (f.type) {\n    case '%': f.precision -= 2; break;\n    case 'e': f.precision -= 1; break;\n  }\n  return trimZero(numberF.format(f), decimal);\n}\n\nfunction linearNumberFormat(domain, count, f) {\n  var range = linearRange(domain, count);\n\n  if (f == null) f = ',f';\n\n  switch (f = d3_numberF.formatSpecifier(f), f.type) {\n    case 's': {\n      var value = Math.max(Math.abs(range[0]), Math.abs(range[1]));\n      if (f.precision == null) f.precision = d3_numberF.precisionPrefix(range[2], value);\n      return numberF.formatPrefix(f, value);\n    }\n    case '':\n    case 'e':\n    case 'g':\n    case 'p':\n    case 'r': {\n      if (f.precision == null) f.precision = d3_numberF.precisionRound(range[2], Math.max(Math.abs(range[0]), Math.abs(range[1]))) - (f.type === 'e');\n      break;\n    }\n    case 'f':\n    case '%': {\n      if (f.precision == null) f.precision = d3_numberF.precisionFixed(range[2]) - 2 * (f.type === '%');\n      break;\n    }\n  }\n  return numberF.format(f);\n}\n\n// -- Datetime Formatting ----\n\nfunction timeAutoFormat() {\n  var f = timeF.format,\n      formatMillisecond = f('.%L'),\n      formatSecond = f(':%S'),\n      formatMinute = f('%I:%M'),\n      formatHour = f('%I %p'),\n      formatDay = f('%a %d'),\n      formatWeek = f('%b %d'),\n      formatMonth = f('%B'),\n      formatYear = f('%Y');\n\n  return function(date) {\n    var d = +date;\n    return (d3_time.second(date) < d ? formatMillisecond\n        : d3_time.minute(date) < d ? formatSecond\n        : d3_time.hour(date) < d ? formatMinute\n        : d3_time.day(date) < d ? formatHour\n        : d3_time.month(date) < d ?\n          (d3_time.week(date) < d ? formatDay : formatWeek)\n        : d3_time.year(date) < d ? formatMonth\n        : formatYear)(date);\n  };\n}\n\nfunction utcAutoFormat() {\n  var f = timeF.utcFormat,\n      formatMillisecond = f('.%L'),\n      formatSecond = f(':%S'),\n      formatMinute = f('%I:%M'),\n      formatHour = f('%I %p'),\n      formatDay = f('%a %d'),\n      formatWeek = f('%b %d'),\n      formatMonth = f('%B'),\n      formatYear = f('%Y');\n\n  return function(date) {\n    var d = +date;\n    return (d3_time.utcSecond(date) < d ? formatMillisecond\n        : d3_time.utcMinute(date) < d ? formatSecond\n        : d3_time.utcHour(date) < d ? formatMinute\n        : d3_time.utcDay(date) < d ? formatHour\n        : d3_time.utcMonth(date) < d ?\n          (d3_time.utcWeek(date) < d ? formatDay : formatWeek)\n        : d3_time.utcYear(date) < d ? formatMonth\n        : formatYear)(date);\n  };\n}\n\nfunction monthFormat(month, abbreviate) {\n  var f = abbreviate ?\n    (monthAbbr || (monthAbbr = timeF.format('%b'))) :\n    (monthFull || (monthFull = timeF.format('%B')));\n  return (tmpDate.setMonth(month), f(tmpDate));\n}\n\nfunction dayFormat(day, abbreviate) {\n  var f = abbreviate ?\n    (dayAbbr || (dayAbbr = timeF.format('%a'))) :\n    (dayFull || (dayFull = timeF.format('%A')));\n  return (tmpDate.setMonth(0), tmpDate.setDate(2 + day), f(tmpDate));\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/datalib/src/format.js\n ** module id = 36\n ** module chunks = 0\n **/","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define('d3-time', ['exports'], factory) :\n  factory((global.d3_time = {}));\n}(this, function (exports) { 'use strict';\n\n  var t0 = new Date;\n  var t1 = new Date;\n  function newInterval(floori, offseti, count, field) {\n\n    function interval(date) {\n      return floori(date = new Date(+date)), date;\n    }\n\n    interval.floor = interval;\n\n    interval.round = function(date) {\n      var d0 = new Date(+date),\n          d1 = new Date(date - 1);\n      floori(d0), floori(d1), offseti(d1, 1);\n      return date - d0 < d1 - date ? d0 : d1;\n    };\n\n    interval.ceil = function(date) {\n      return floori(date = new Date(date - 1)), offseti(date, 1), date;\n    };\n\n    interval.offset = function(date, step) {\n      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;\n    };\n\n    interval.range = function(start, stop, step) {\n      var range = [];\n      start = new Date(start - 1);\n      stop = new Date(+stop);\n      step = step == null ? 1 : Math.floor(step);\n      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date\n      offseti(start, 1), floori(start);\n      if (start < stop) range.push(new Date(+start));\n      while (offseti(start, step), floori(start), start < stop) range.push(new Date(+start));\n      return range;\n    };\n\n    interval.filter = function(test) {\n      return newInterval(function(date) {\n        while (floori(date), !test(date)) date.setTime(date - 1);\n      }, function(date, step) {\n        while (--step >= 0) while (offseti(date, 1), !test(date));\n      });\n    };\n\n    if (count) {\n      interval.count = function(start, end) {\n        t0.setTime(+start), t1.setTime(+end);\n        floori(t0), floori(t1);\n        return Math.floor(count(t0, t1));\n      };\n\n      interval.every = function(step) {\n        step = Math.floor(step);\n        return !isFinite(step) || !(step > 0) ? null\n            : !(step > 1) ? interval\n            : interval.filter(field\n                ? function(d) { return field(d) % step === 0; }\n                : function(d) { return interval.count(0, d) % step === 0; });\n      };\n    }\n\n    return interval;\n  };\n\n  var millisecond = newInterval(function() {\n    // noop\n  }, function(date, step) {\n    date.setTime(+date + step);\n  }, function(start, end) {\n    return end - start;\n  });\n\n  // An optimized implementation for this simple case.\n  millisecond.every = function(k) {\n    k = Math.floor(k);\n    if (!isFinite(k) || !(k > 0)) return null;\n    if (!(k > 1)) return millisecond;\n    return newInterval(function(date) {\n      date.setTime(Math.floor(date / k) * k);\n    }, function(date, step) {\n      date.setTime(+date + step * k);\n    }, function(start, end) {\n      return (end - start) / k;\n    });\n  };\n\n  var second = newInterval(function(date) {\n    date.setMilliseconds(0);\n  }, function(date, step) {\n    date.setTime(+date + step * 1e3);\n  }, function(start, end) {\n    return (end - start) / 1e3;\n  }, function(date) {\n    return date.getSeconds();\n  });\n\n  var minute = newInterval(function(date) {\n    date.setSeconds(0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 6e4);\n  }, function(start, end) {\n    return (end - start) / 6e4;\n  }, function(date) {\n    return date.getMinutes();\n  });\n\n  var hour = newInterval(function(date) {\n    date.setMinutes(0, 0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 36e5);\n  }, function(start, end) {\n    return (end - start) / 36e5;\n  }, function(date) {\n    return date.getHours();\n  });\n\n  var day = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setDate(date.getDate() + step);\n  }, function(start, end) {\n    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 864e5;\n  }, function(date) {\n    return date.getDate() - 1;\n  });\n\n  function weekday(i) {\n    return newInterval(function(date) {\n      date.setHours(0, 0, 0, 0);\n      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setDate(date.getDate() + step * 7);\n    }, function(start, end) {\n      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 6048e5;\n    });\n  }\n\n  var sunday = weekday(0);\n  var monday = weekday(1);\n  var tuesday = weekday(2);\n  var wednesday = weekday(3);\n  var thursday = weekday(4);\n  var friday = weekday(5);\n  var saturday = weekday(6);\n\n  var month = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setDate(1);\n  }, function(date, step) {\n    date.setMonth(date.getMonth() + step);\n  }, function(start, end) {\n    return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;\n  }, function(date) {\n    return date.getMonth();\n  });\n\n  var year = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setMonth(0, 1);\n  }, function(date, step) {\n    date.setFullYear(date.getFullYear() + step);\n  }, function(start, end) {\n    return end.getFullYear() - start.getFullYear();\n  }, function(date) {\n    return date.getFullYear();\n  });\n\n  var utcSecond = newInterval(function(date) {\n    date.setUTCMilliseconds(0);\n  }, function(date, step) {\n    date.setTime(+date + step * 1e3);\n  }, function(start, end) {\n    return (end - start) / 1e3;\n  }, function(date) {\n    return date.getUTCSeconds();\n  });\n\n  var utcMinute = newInterval(function(date) {\n    date.setUTCSeconds(0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 6e4);\n  }, function(start, end) {\n    return (end - start) / 6e4;\n  }, function(date) {\n    return date.getUTCMinutes();\n  });\n\n  var utcHour = newInterval(function(date) {\n    date.setUTCMinutes(0, 0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 36e5);\n  }, function(start, end) {\n    return (end - start) / 36e5;\n  }, function(date) {\n    return date.getUTCHours();\n  });\n\n  var utcDay = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setUTCDate(date.getUTCDate() + step);\n  }, function(start, end) {\n    return (end - start) / 864e5;\n  }, function(date) {\n    return date.getUTCDate() - 1;\n  });\n\n  function utcWeekday(i) {\n    return newInterval(function(date) {\n      date.setUTCHours(0, 0, 0, 0);\n      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setUTCDate(date.getUTCDate() + step * 7);\n    }, function(start, end) {\n      return (end - start) / 6048e5;\n    });\n  }\n\n  var utcSunday = utcWeekday(0);\n  var utcMonday = utcWeekday(1);\n  var utcTuesday = utcWeekday(2);\n  var utcWednesday = utcWeekday(3);\n  var utcThursday = utcWeekday(4);\n  var utcFriday = utcWeekday(5);\n  var utcSaturday = utcWeekday(6);\n\n  var utcMonth = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCDate(1);\n  }, function(date, step) {\n    date.setUTCMonth(date.getUTCMonth() + step);\n  }, function(start, end) {\n    return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;\n  }, function(date) {\n    return date.getUTCMonth();\n  });\n\n  var utcYear = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCMonth(0, 1);\n  }, function(date, step) {\n    date.setUTCFullYear(date.getUTCFullYear() + step);\n  }, function(start, end) {\n    return end.getUTCFullYear() - start.getUTCFullYear();\n  }, function(date) {\n    return date.getUTCFullYear();\n  });\n\n  var milliseconds = millisecond.range;\n  var seconds = second.range;\n  var minutes = minute.range;\n  var hours = hour.range;\n  var days = day.range;\n  var sundays = sunday.range;\n  var mondays = monday.range;\n  var tuesdays = tuesday.range;\n  var wednesdays = wednesday.range;\n  var thursdays = thursday.range;\n  var fridays = friday.range;\n  var saturdays = saturday.range;\n  var weeks = sunday.range;\n  var months = month.range;\n  var years = year.range;\n\n  var utcMillisecond = millisecond;\n  var utcMilliseconds = milliseconds;\n  var utcSeconds = utcSecond.range;\n  var utcMinutes = utcMinute.range;\n  var utcHours = utcHour.range;\n  var utcDays = utcDay.range;\n  var utcSundays = utcSunday.range;\n  var utcMondays = utcMonday.range;\n  var utcTuesdays = utcTuesday.range;\n  var utcWednesdays = utcWednesday.range;\n  var utcThursdays = utcThursday.range;\n  var utcFridays = utcFriday.range;\n  var utcSaturdays = utcSaturday.range;\n  var utcWeeks = utcSunday.range;\n  var utcMonths = utcMonth.range;\n  var utcYears = utcYear.range;\n\n  var version = \"0.1.1\";\n\n  exports.version = version;\n  exports.milliseconds = milliseconds;\n  exports.seconds = seconds;\n  exports.minutes = minutes;\n  exports.hours = hours;\n  exports.days = days;\n  exports.sundays = sundays;\n  exports.mondays = mondays;\n  exports.tuesdays = tuesdays;\n  exports.wednesdays = wednesdays;\n  exports.thursdays = thursdays;\n  exports.fridays = fridays;\n  exports.saturdays = saturdays;\n  exports.weeks = weeks;\n  exports.months = months;\n  exports.years = years;\n  exports.utcMillisecond = utcMillisecond;\n  exports.utcMilliseconds = utcMilliseconds;\n  exports.utcSeconds = utcSeconds;\n  exports.utcMinutes = utcMinutes;\n  exports.utcHours = utcHours;\n  exports.utcDays = utcDays;\n  exports.utcSundays = utcSundays;\n  exports.utcMondays = utcMondays;\n  exports.utcTuesdays = utcTuesdays;\n  exports.utcWednesdays = utcWednesdays;\n  exports.utcThursdays = utcThursdays;\n  exports.utcFridays = utcFridays;\n  exports.utcSaturdays = utcSaturdays;\n  exports.utcWeeks = utcWeeks;\n  exports.utcMonths = utcMonths;\n  exports.utcYears = utcYears;\n  exports.millisecond = millisecond;\n  exports.second = second;\n  exports.minute = minute;\n  exports.hour = hour;\n  exports.day = day;\n  exports.sunday = sunday;\n  exports.monday = monday;\n  exports.tuesday = tuesday;\n  exports.wednesday = wednesday;\n  exports.thursday = thursday;\n  exports.friday = friday;\n  exports.saturday = saturday;\n  exports.week = sunday;\n  exports.month = month;\n  exports.year = year;\n  exports.utcSecond = utcSecond;\n  exports.utcMinute = utcMinute;\n  exports.utcHour = utcHour;\n  exports.utcDay = utcDay;\n  exports.utcSunday = utcSunday;\n  exports.utcMonday = utcMonday;\n  exports.utcTuesday = utcTuesday;\n  exports.utcWednesday = utcWednesday;\n  exports.utcThursday = utcThursday;\n  exports.utcFriday = utcFriday;\n  exports.utcSaturday = utcSaturday;\n  exports.utcWeek = utcSunday;\n  exports.utcMonth = utcMonth;\n  exports.utcYear = utcYear;\n  exports.interval = newInterval;\n\n}));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/d3-time/build/d3-time.js\n ** module id = 37\n ** module chunks = 0\n **/","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-time')) :\n  typeof define === 'function' && define.amd ? define('d3-time-format', ['exports', 'd3-time'], factory) :\n  factory((global.d3_time_format = {}),global.d3_time);\n}(this, function (exports,d3Time) { 'use strict';\n\n  function localDate(d) {\n    if (0 <= d.y && d.y < 100) {\n      var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);\n      date.setFullYear(d.y);\n      return date;\n    }\n    return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);\n  }\n\n  function utcDate(d) {\n    if (0 <= d.y && d.y < 100) {\n      var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));\n      date.setUTCFullYear(d.y);\n      return date;\n    }\n    return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));\n  }\n\n  function newYear(y) {\n    return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};\n  }\n\n  function locale$1(locale) {\n    var locale_dateTime = locale.dateTime,\n        locale_date = locale.date,\n        locale_time = locale.time,\n        locale_periods = locale.periods,\n        locale_weekdays = locale.days,\n        locale_shortWeekdays = locale.shortDays,\n        locale_months = locale.months,\n        locale_shortMonths = locale.shortMonths;\n\n    var periodRe = formatRe(locale_periods),\n        periodLookup = formatLookup(locale_periods),\n        weekdayRe = formatRe(locale_weekdays),\n        weekdayLookup = formatLookup(locale_weekdays),\n        shortWeekdayRe = formatRe(locale_shortWeekdays),\n        shortWeekdayLookup = formatLookup(locale_shortWeekdays),\n        monthRe = formatRe(locale_months),\n        monthLookup = formatLookup(locale_months),\n        shortMonthRe = formatRe(locale_shortMonths),\n        shortMonthLookup = formatLookup(locale_shortMonths);\n\n    var formats = {\n      \"a\": formatShortWeekday,\n      \"A\": formatWeekday,\n      \"b\": formatShortMonth,\n      \"B\": formatMonth,\n      \"c\": null,\n      \"d\": formatDayOfMonth,\n      \"e\": formatDayOfMonth,\n      \"H\": formatHour24,\n      \"I\": formatHour12,\n      \"j\": formatDayOfYear,\n      \"L\": formatMilliseconds,\n      \"m\": formatMonthNumber,\n      \"M\": formatMinutes,\n      \"p\": formatPeriod,\n      \"S\": formatSeconds,\n      \"U\": formatWeekNumberSunday,\n      \"w\": formatWeekdayNumber,\n      \"W\": formatWeekNumberMonday,\n      \"x\": null,\n      \"X\": null,\n      \"y\": formatYear,\n      \"Y\": formatFullYear,\n      \"Z\": formatZone,\n      \"%\": formatLiteralPercent\n    };\n\n    var utcFormats = {\n      \"a\": formatUTCShortWeekday,\n      \"A\": formatUTCWeekday,\n      \"b\": formatUTCShortMonth,\n      \"B\": formatUTCMonth,\n      \"c\": null,\n      \"d\": formatUTCDayOfMonth,\n      \"e\": formatUTCDayOfMonth,\n      \"H\": formatUTCHour24,\n      \"I\": formatUTCHour12,\n      \"j\": formatUTCDayOfYear,\n      \"L\": formatUTCMilliseconds,\n      \"m\": formatUTCMonthNumber,\n      \"M\": formatUTCMinutes,\n      \"p\": formatUTCPeriod,\n      \"S\": formatUTCSeconds,\n      \"U\": formatUTCWeekNumberSunday,\n      \"w\": formatUTCWeekdayNumber,\n      \"W\": formatUTCWeekNumberMonday,\n      \"x\": null,\n      \"X\": null,\n      \"y\": formatUTCYear,\n      \"Y\": formatUTCFullYear,\n      \"Z\": formatUTCZone,\n      \"%\": formatLiteralPercent\n    };\n\n    var parses = {\n      \"a\": parseShortWeekday,\n      \"A\": parseWeekday,\n      \"b\": parseShortMonth,\n      \"B\": parseMonth,\n      \"c\": parseLocaleDateTime,\n      \"d\": parseDayOfMonth,\n      \"e\": parseDayOfMonth,\n      \"H\": parseHour24,\n      \"I\": parseHour24,\n      \"j\": parseDayOfYear,\n      \"L\": parseMilliseconds,\n      \"m\": parseMonthNumber,\n      \"M\": parseMinutes,\n      \"p\": parsePeriod,\n      \"S\": parseSeconds,\n      \"U\": parseWeekNumberSunday,\n      \"w\": parseWeekdayNumber,\n      \"W\": parseWeekNumberMonday,\n      \"x\": parseLocaleDate,\n      \"X\": parseLocaleTime,\n      \"y\": parseYear,\n      \"Y\": parseFullYear,\n      \"Z\": parseZone,\n      \"%\": parseLiteralPercent\n    };\n\n    // These recursive directive definitions must be deferred.\n    formats.x = newFormat(locale_date, formats);\n    formats.X = newFormat(locale_time, formats);\n    formats.c = newFormat(locale_dateTime, formats);\n    utcFormats.x = newFormat(locale_date, utcFormats);\n    utcFormats.X = newFormat(locale_time, utcFormats);\n    utcFormats.c = newFormat(locale_dateTime, utcFormats);\n\n    function newFormat(specifier, formats) {\n      return function(date) {\n        var string = [],\n            i = -1,\n            j = 0,\n            n = specifier.length,\n            c,\n            pad,\n            format;\n\n        if (!(date instanceof Date)) date = new Date(+date);\n\n        while (++i < n) {\n          if (specifier.charCodeAt(i) === 37) {\n            string.push(specifier.slice(j, i));\n            if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);\n            else pad = c === \"e\" ? \" \" : \"0\";\n            if (format = formats[c]) c = format(date, pad);\n            string.push(c);\n            j = i + 1;\n          }\n        }\n\n        string.push(specifier.slice(j, i));\n        return string.join(\"\");\n      };\n    }\n\n    function newParse(specifier, newDate) {\n      return function(string) {\n        var d = newYear(1900),\n            i = parseSpecifier(d, specifier, string += \"\", 0);\n        if (i != string.length) return null;\n\n        // The am-pm flag is 0 for AM, and 1 for PM.\n        if (\"p\" in d) d.H = d.H % 12 + d.p * 12;\n\n        // Convert day-of-week and week-of-year to day-of-year.\n        if (\"W\" in d || \"U\" in d) {\n          if (!(\"w\" in d)) d.w = \"W\" in d ? 1 : 0;\n          var day = \"Z\" in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();\n          d.m = 0;\n          d.d = \"W\" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;\n        }\n\n        // If a time zone is specified, all fields are interpreted as UTC and then\n        // offset according to the specified time zone.\n        if (\"Z\" in d) {\n          d.H += d.Z / 100 | 0;\n          d.M += d.Z % 100;\n          return utcDate(d);\n        }\n\n        // Otherwise, all fields are in local time.\n        return newDate(d);\n      };\n    }\n\n    function parseSpecifier(d, specifier, string, j) {\n      var i = 0,\n          n = specifier.length,\n          m = string.length,\n          c,\n          parse;\n\n      while (i < n) {\n        if (j >= m) return -1;\n        c = specifier.charCodeAt(i++);\n        if (c === 37) {\n          c = specifier.charAt(i++);\n          parse = parses[c in pads ? specifier.charAt(i++) : c];\n          if (!parse || ((j = parse(d, string, j)) < 0)) return -1;\n        } else if (c != string.charCodeAt(j++)) {\n          return -1;\n        }\n      }\n\n      return j;\n    }\n\n    function parsePeriod(d, string, i) {\n      var n = periodRe.exec(string.slice(i));\n      return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n    }\n\n    function parseShortWeekday(d, string, i) {\n      var n = shortWeekdayRe.exec(string.slice(i));\n      return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n    }\n\n    function parseWeekday(d, string, i) {\n      var n = weekdayRe.exec(string.slice(i));\n      return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n    }\n\n    function parseShortMonth(d, string, i) {\n      var n = shortMonthRe.exec(string.slice(i));\n      return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n    }\n\n    function parseMonth(d, string, i) {\n      var n = monthRe.exec(string.slice(i));\n      return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n    }\n\n    function parseLocaleDateTime(d, string, i) {\n      return parseSpecifier(d, locale_dateTime, string, i);\n    }\n\n    function parseLocaleDate(d, string, i) {\n      return parseSpecifier(d, locale_date, string, i);\n    }\n\n    function parseLocaleTime(d, string, i) {\n      return parseSpecifier(d, locale_time, string, i);\n    }\n\n    function formatShortWeekday(d) {\n      return locale_shortWeekdays[d.getDay()];\n    }\n\n    function formatWeekday(d) {\n      return locale_weekdays[d.getDay()];\n    }\n\n    function formatShortMonth(d) {\n      return locale_shortMonths[d.getMonth()];\n    }\n\n    function formatMonth(d) {\n      return locale_months[d.getMonth()];\n    }\n\n    function formatPeriod(d) {\n      return locale_periods[+(d.getHours() >= 12)];\n    }\n\n    function formatUTCShortWeekday(d) {\n      return locale_shortWeekdays[d.getUTCDay()];\n    }\n\n    function formatUTCWeekday(d) {\n      return locale_weekdays[d.getUTCDay()];\n    }\n\n    function formatUTCShortMonth(d) {\n      return locale_shortMonths[d.getUTCMonth()];\n    }\n\n    function formatUTCMonth(d) {\n      return locale_months[d.getUTCMonth()];\n    }\n\n    function formatUTCPeriod(d) {\n      return locale_periods[+(d.getUTCHours() >= 12)];\n    }\n\n    return {\n      format: function(specifier) {\n        var f = newFormat(specifier += \"\", formats);\n        f.parse = newParse(specifier, localDate);\n        f.toString = function() { return specifier; };\n        return f;\n      },\n      utcFormat: function(specifier) {\n        var f = newFormat(specifier += \"\", utcFormats);\n        f.parse = newParse(specifier, utcDate);\n        f.toString = function() { return specifier; };\n        return f;\n      }\n    };\n  };\n\n  var pads = {\"-\": \"\", \"_\": \" \", \"0\": \"0\"};\n  var numberRe = /^\\s*\\d+/;\n  var percentRe = /^%/;\n  var requoteRe = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\n  function pad(value, fill, width) {\n    var sign = value < 0 ? \"-\" : \"\",\n        string = (sign ? -value : value) + \"\",\n        length = string.length;\n    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);\n  }\n\n  function requote(s) {\n    return s.replace(requoteRe, \"\\\\$&\");\n  }\n\n  function formatRe(names) {\n    return new RegExp(\"^(?:\" + names.map(requote).join(\"|\") + \")\", \"i\");\n  }\n\n  function formatLookup(names) {\n    var map = {}, i = -1, n = names.length;\n    while (++i < n) map[names[i].toLowerCase()] = i;\n    return map;\n  }\n\n  function parseWeekdayNumber(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 1));\n    return n ? (d.w = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseWeekNumberSunday(d, string, i) {\n    var n = numberRe.exec(string.slice(i));\n    return n ? (d.U = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseWeekNumberMonday(d, string, i) {\n    var n = numberRe.exec(string.slice(i));\n    return n ? (d.W = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseFullYear(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 4));\n    return n ? (d.y = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseYear(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;\n  }\n\n  function parseZone(d, string, i) {\n    var n = /^(Z)|([+-]\\d\\d)(?:\\:?(\\d\\d))?/.exec(string.slice(i, i + 6));\n    return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || \"00\")), i + n[0].length) : -1;\n  }\n\n  function parseMonthNumber(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.m = n[0] - 1, i + n[0].length) : -1;\n  }\n\n  function parseDayOfMonth(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.d = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseDayOfYear(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 3));\n    return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseHour24(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.H = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseMinutes(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.M = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseSeconds(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 2));\n    return n ? (d.S = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseMilliseconds(d, string, i) {\n    var n = numberRe.exec(string.slice(i, i + 3));\n    return n ? (d.L = +n[0], i + n[0].length) : -1;\n  }\n\n  function parseLiteralPercent(d, string, i) {\n    var n = percentRe.exec(string.slice(i, i + 1));\n    return n ? i + n[0].length : -1;\n  }\n\n  function formatDayOfMonth(d, p) {\n    return pad(d.getDate(), p, 2);\n  }\n\n  function formatHour24(d, p) {\n    return pad(d.getHours(), p, 2);\n  }\n\n  function formatHour12(d, p) {\n    return pad(d.getHours() % 12 || 12, p, 2);\n  }\n\n  function formatDayOfYear(d, p) {\n    return pad(1 + d3Time.day.count(d3Time.year(d), d), p, 3);\n  }\n\n  function formatMilliseconds(d, p) {\n    return pad(d.getMilliseconds(), p, 3);\n  }\n\n  function formatMonthNumber(d, p) {\n    return pad(d.getMonth() + 1, p, 2);\n  }\n\n  function formatMinutes(d, p) {\n    return pad(d.getMinutes(), p, 2);\n  }\n\n  function formatSeconds(d, p) {\n    return pad(d.getSeconds(), p, 2);\n  }\n\n  function formatWeekNumberSunday(d, p) {\n    return pad(d3Time.sunday.count(d3Time.year(d), d), p, 2);\n  }\n\n  function formatWeekdayNumber(d) {\n    return d.getDay();\n  }\n\n  function formatWeekNumberMonday(d, p) {\n    return pad(d3Time.monday.count(d3Time.year(d), d), p, 2);\n  }\n\n  function formatYear(d, p) {\n    return pad(d.getFullYear() % 100, p, 2);\n  }\n\n  function formatFullYear(d, p) {\n    return pad(d.getFullYear() % 10000, p, 4);\n  }\n\n  function formatZone(d) {\n    var z = d.getTimezoneOffset();\n    return (z > 0 ? \"-\" : (z *= -1, \"+\"))\n        + pad(z / 60 | 0, \"0\", 2)\n        + pad(z % 60, \"0\", 2);\n  }\n\n  function formatUTCDayOfMonth(d, p) {\n    return pad(d.getUTCDate(), p, 2);\n  }\n\n  function formatUTCHour24(d, p) {\n    return pad(d.getUTCHours(), p, 2);\n  }\n\n  function formatUTCHour12(d, p) {\n    return pad(d.getUTCHours() % 12 || 12, p, 2);\n  }\n\n  function formatUTCDayOfYear(d, p) {\n    return pad(1 + d3Time.utcDay.count(d3Time.utcYear(d), d), p, 3);\n  }\n\n  function formatUTCMilliseconds(d, p) {\n    return pad(d.getUTCMilliseconds(), p, 3);\n  }\n\n  function formatUTCMonthNumber(d, p) {\n    return pad(d.getUTCMonth() + 1, p, 2);\n  }\n\n  function formatUTCMinutes(d, p) {\n    return pad(d.getUTCMinutes(), p, 2);\n  }\n\n  function formatUTCSeconds(d, p) {\n    return pad(d.getUTCSeconds(), p, 2);\n  }\n\n  function formatUTCWeekNumberSunday(d, p) {\n    return pad(d3Time.utcSunday.count(d3Time.utcYear(d), d), p, 2);\n  }\n\n  function formatUTCWeekdayNumber(d) {\n    return d.getUTCDay();\n  }\n\n  function formatUTCWeekNumberMonday(d, p) {\n    return pad(d3Time.utcMonday.count(d3Time.utcYear(d), d), p, 2);\n  }\n\n  function formatUTCYear(d, p) {\n    return pad(d.getUTCFullYear() % 100, p, 2);\n  }\n\n  function formatUTCFullYear(d, p) {\n    return pad(d.getUTCFullYear() % 10000, p, 4);\n  }\n\n  function formatUTCZone() {\n    return \"+0000\";\n  }\n\n  function formatLiteralPercent() {\n    return \"%\";\n  }\n\n  var locale = locale$1({\n    dateTime: \"%a %b %e %X %Y\",\n    date: \"%m/%d/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n    shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n    months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n  });\n\n  var caES = locale$1({\n    dateTime: \"%A, %e de %B de %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"diumenge\", \"dilluns\", \"dimarts\", \"dimecres\", \"dijous\", \"divendres\", \"dissabte\"],\n    shortDays: [\"dg.\", \"dl.\", \"dt.\", \"dc.\", \"dj.\", \"dv.\", \"ds.\"],\n    months: [\"gener\", \"febrer\", \"mar\", \"abril\", \"maig\", \"juny\", \"juliol\", \"agost\", \"setembre\", \"octubre\", \"novembre\", \"desembre\"],\n    shortMonths: [\"gen.\", \"febr.\", \"mar\", \"abr.\", \"maig\", \"juny\", \"jul.\", \"ag.\", \"set.\", \"oct.\", \"nov.\", \"des.\"]\n  });\n\n  var deCH = locale$1({\n    dateTime: \"%A, der %e. %B %Y, %X\",\n    date: \"%d.%m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"Sonntag\", \"Montag\", \"Dienstag\", \"Mittwoch\", \"Donnerstag\", \"Freitag\", \"Samstag\"],\n    shortDays: [\"So\", \"Mo\", \"Di\", \"Mi\", \"Do\", \"Fr\", \"Sa\"],\n    months: [\"Januar\", \"Februar\", \"Mrz\", \"April\", \"Mai\", \"Juni\", \"Juli\", \"August\", \"September\", \"Oktober\", \"November\", \"Dezember\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mrz\", \"Apr\", \"Mai\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Okt\", \"Nov\", \"Dez\"]\n  });\n\n  var deDE = locale$1({\n    dateTime: \"%A, der %e. %B %Y, %X\",\n    date: \"%d.%m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"Sonntag\", \"Montag\", \"Dienstag\", \"Mittwoch\", \"Donnerstag\", \"Freitag\", \"Samstag\"],\n    shortDays: [\"So\", \"Mo\", \"Di\", \"Mi\", \"Do\", \"Fr\", \"Sa\"],\n    months: [\"Januar\", \"Februar\", \"Mrz\", \"April\", \"Mai\", \"Juni\", \"Juli\", \"August\", \"September\", \"Oktober\", \"November\", \"Dezember\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mrz\", \"Apr\", \"Mai\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Okt\", \"Nov\", \"Dez\"]\n  });\n\n  var enCA = locale$1({\n    dateTime: \"%a %b %e %X %Y\",\n    date: \"%Y-%m-%d\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n    shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n    months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n  });\n\n  var enGB = locale$1({\n    dateTime: \"%a %e %b %X %Y\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n    shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n    months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n  });\n\n  var esES = locale$1({\n    dateTime: \"%A, %e de %B de %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"domingo\", \"lunes\", \"martes\", \"mircoles\", \"jueves\", \"viernes\", \"sbado\"],\n    shortDays: [\"dom\", \"lun\", \"mar\", \"mi\", \"jue\", \"vie\", \"sb\"],\n    months: [\"enero\", \"febrero\", \"marzo\", \"abril\", \"mayo\", \"junio\", \"julio\", \"agosto\", \"septiembre\", \"octubre\", \"noviembre\", \"diciembre\"],\n    shortMonths: [\"ene\", \"feb\", \"mar\", \"abr\", \"may\", \"jun\", \"jul\", \"ago\", \"sep\", \"oct\", \"nov\", \"dic\"]\n  });\n\n  var fiFI = locale$1({\n    dateTime: \"%A, %-d. %Bta %Y klo %X\",\n    date: \"%-d.%-m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"a.m.\", \"p.m.\"],\n    days: [\"sunnuntai\", \"maanantai\", \"tiistai\", \"keskiviikko\", \"torstai\", \"perjantai\", \"lauantai\"],\n    shortDays: [\"Su\", \"Ma\", \"Ti\", \"Ke\", \"To\", \"Pe\", \"La\"],\n    months: [\"tammikuu\", \"helmikuu\", \"maaliskuu\", \"huhtikuu\", \"toukokuu\", \"keskuu\", \"heinkuu\", \"elokuu\", \"syyskuu\", \"lokakuu\", \"marraskuu\", \"joulukuu\"],\n    shortMonths: [\"Tammi\", \"Helmi\", \"Maalis\", \"Huhti\", \"Touko\", \"Kes\", \"Hein\", \"Elo\", \"Syys\", \"Loka\", \"Marras\", \"Joulu\"]\n  });\n\n  var frCA = locale$1({\n    dateTime: \"%a %e %b %Y %X\",\n    date: \"%Y-%m-%d\",\n    time: \"%H:%M:%S\",\n    periods: [\"\", \"\"],\n    days: [\"dimanche\", \"lundi\", \"mardi\", \"mercredi\", \"jeudi\", \"vendredi\", \"samedi\"],\n    shortDays: [\"dim\", \"lun\", \"mar\", \"mer\", \"jeu\", \"ven\", \"sam\"],\n    months: [\"janvier\", \"fvrier\", \"mars\", \"avril\", \"mai\", \"juin\", \"juillet\", \"aot\", \"septembre\", \"octobre\", \"novembre\", \"dcembre\"],\n    shortMonths: [\"jan\", \"fv\", \"mar\", \"avr\", \"mai\", \"jui\", \"jul\", \"ao\", \"sep\", \"oct\", \"nov\", \"dc\"]\n  });\n\n  var frFR = locale$1({\n    dateTime: \"%A, le %e %B %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"dimanche\", \"lundi\", \"mardi\", \"mercredi\", \"jeudi\", \"vendredi\", \"samedi\"],\n    shortDays: [\"dim.\", \"lun.\", \"mar.\", \"mer.\", \"jeu.\", \"ven.\", \"sam.\"],\n    months: [\"janvier\", \"fvrier\", \"mars\", \"avril\", \"mai\", \"juin\", \"juillet\", \"aot\", \"septembre\", \"octobre\", \"novembre\", \"dcembre\"],\n    shortMonths: [\"janv.\", \"fvr.\", \"mars\", \"avr.\", \"mai\", \"juin\", \"juil.\", \"aot\", \"sept.\", \"oct.\", \"nov.\", \"dc.\"]\n  });\n\n  var heIL = locale$1({\n    dateTime: \"%A, %e %B %Y %X\",\n    date: \"%d.%m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortDays: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    months: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortMonths: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"]\n  });\n\n  var huHU = locale$1({\n    dateTime: \"%Y. %B %-e., %A %X\",\n    date: \"%Y. %m. %d.\",\n    time: \"%H:%M:%S\",\n    periods: [\"de.\", \"du.\"], // unused\n    days: [\"vasrnap\", \"htf\", \"kedd\", \"szerda\", \"cstrtk\", \"pntek\", \"szombat\"],\n    shortDays: [\"V\", \"H\", \"K\", \"Sze\", \"Cs\", \"P\", \"Szo\"],\n    months: [\"janur\", \"februr\", \"mrcius\", \"prilis\", \"mjus\", \"jnius\", \"jlius\", \"augusztus\", \"szeptember\", \"oktber\", \"november\", \"december\"],\n    shortMonths: [\"jan.\", \"feb.\", \"mr.\", \"pr.\", \"mj.\", \"jn.\", \"jl.\", \"aug.\", \"szept.\", \"okt.\", \"nov.\", \"dec.\"]\n  });\n\n  var itIT = locale$1({\n    dateTime: \"%A %e %B %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"Domenica\", \"Luned\", \"Marted\", \"Mercoled\", \"Gioved\", \"Venerd\", \"Sabato\"],\n    shortDays: [\"Dom\", \"Lun\", \"Mar\", \"Mer\", \"Gio\", \"Ven\", \"Sab\"],\n    months: [\"Gennaio\", \"Febbraio\", \"Marzo\", \"Aprile\", \"Maggio\", \"Giugno\", \"Luglio\", \"Agosto\", \"Settembre\", \"Ottobre\", \"Novembre\", \"Dicembre\"],\n    shortMonths: [\"Gen\", \"Feb\", \"Mar\", \"Apr\", \"Mag\", \"Giu\", \"Lug\", \"Ago\", \"Set\", \"Ott\", \"Nov\", \"Dic\"]\n  });\n\n  var jaJP = locale$1({\n    dateTime: \"%Y %b %e %a %X\",\n    date: \"%Y/%m/%d\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortDays: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    months: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortMonths: [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\"]\n  });\n\n  var koKR = locale$1({\n    dateTime: \"%Y/%m/%d %a %X\",\n    date: \"%Y/%m/%d\",\n    time: \"%H:%M:%S\",\n    periods: [\"\", \"\"],\n    days: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortDays: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    months: [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\"],\n    shortMonths: [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\"]\n  });\n\n  var mkMK = locale$1({\n    dateTime: \"%A, %e %B %Y . %X\",\n    date: \"%d.%m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortDays: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    months: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortMonths: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"]\n  });\n\n  var nlNL = locale$1({\n    dateTime: \"%a %e %B %Y %T\",\n    date: \"%d-%m-%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"zondag\", \"maandag\", \"dinsdag\", \"woensdag\", \"donderdag\", \"vrijdag\", \"zaterdag\"],\n    shortDays: [\"zo\", \"ma\", \"di\", \"wo\", \"do\", \"vr\", \"za\"],\n    months: [\"januari\", \"februari\", \"maart\", \"april\", \"mei\", \"juni\", \"juli\", \"augustus\", \"september\", \"oktober\", \"november\", \"december\"],\n    shortMonths: [\"jan\", \"feb\", \"mrt\", \"apr\", \"mei\", \"jun\", \"jul\", \"aug\", \"sep\", \"okt\", \"nov\", \"dec\"]\n  });\n\n  var plPL = locale$1({\n    dateTime: \"%A, %e %B %Y, %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"], // unused\n    days: [\"Niedziela\", \"Poniedziaek\", \"Wtorek\", \"roda\", \"Czwartek\", \"Pitek\", \"Sobota\"],\n    shortDays: [\"Niedz.\", \"Pon.\", \"Wt.\", \"r.\", \"Czw.\", \"Pt.\", \"Sob.\"],\n    months: [\"Stycze\", \"Luty\", \"Marzec\", \"Kwiecie\", \"Maj\", \"Czerwiec\", \"Lipiec\", \"Sierpie\", \"Wrzesie\", \"Padziernik\", \"Listopad\", \"Grudzie\"],\n    shortMonths: [\"Stycz.\", \"Luty\", \"Marz.\", \"Kwie.\", \"Maj\", \"Czerw.\", \"Lipc.\", \"Sierp.\", \"Wrz.\", \"Padz.\", \"Listop.\", \"Grudz.\"]/* In Polish language abbraviated months are not commonly used so there is a dispute about the proper abbraviations. */\n  });\n\n  var ptBR = locale$1({\n    dateTime: \"%A, %e de %B de %Y. %X\",\n    date: \"%d/%m/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"Domingo\", \"Segunda\", \"Tera\", \"Quarta\", \"Quinta\", \"Sexta\", \"Sbado\"],\n    shortDays: [\"Dom\", \"Seg\", \"Ter\", \"Qua\", \"Qui\", \"Sex\", \"Sb\"],\n    months: [\"Janeiro\", \"Fevereiro\", \"Maro\", \"Abril\", \"Maio\", \"Junho\", \"Julho\", \"Agosto\", \"Setembro\", \"Outubro\", \"Novembro\", \"Dezembro\"],\n    shortMonths: [\"Jan\", \"Fev\", \"Mar\", \"Abr\", \"Mai\", \"Jun\", \"Jul\", \"Ago\", \"Set\", \"Out\", \"Nov\", \"Dez\"]\n  });\n\n  var ruRU = locale$1({\n    dateTime: \"%A, %e %B %Y . %X\",\n    date: \"%d.%m.%Y\",\n    time: \"%H:%M:%S\",\n    periods: [\"AM\", \"PM\"],\n    days: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortDays: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    months: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortMonths: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"]\n  });\n\n  var svSE = locale$1({\n    dateTime: \"%A den %d %B %Y %X\",\n    date: \"%Y-%m-%d\",\n    time: \"%H:%M:%S\",\n    periods: [\"fm\", \"em\"],\n    days: [\"Sndag\", \"Mndag\", \"Tisdag\", \"Onsdag\", \"Torsdag\", \"Fredag\", \"Lrdag\"],\n    shortDays: [\"Sn\", \"Mn\", \"Tis\", \"Ons\", \"Tor\", \"Fre\", \"Lr\"],\n    months: [\"Januari\", \"Februari\", \"Mars\", \"April\", \"Maj\", \"Juni\", \"Juli\", \"Augusti\", \"September\", \"Oktober\", \"November\", \"December\"],\n    shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"Maj\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Okt\", \"Nov\", \"Dec\"]\n  });\n\n  var zhCN = locale$1({\n    dateTime: \"%a %b %e %X %Y\",\n    date: \"%Y/%-m/%-d\",\n    time: \"%H:%M:%S\",\n    periods: [\"\", \"\"],\n    days: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortDays: [\"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    months: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    shortMonths: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"]\n  });\n\n  var isoSpecifier = \"%Y-%m-%dT%H:%M:%S.%LZ\";\n\n  function formatIsoNative(date) {\n    return date.toISOString();\n  }\n\n  formatIsoNative.parse = function(string) {\n    var date = new Date(string);\n    return isNaN(date) ? null : date;\n  };\n\n  formatIsoNative.toString = function() {\n    return isoSpecifier;\n  };\n\n  var formatIso = Date.prototype.toISOString && +new Date(\"2000-01-01T00:00:00.000Z\")\n      ? formatIsoNative\n      : locale.utcFormat(isoSpecifier);\n\n  var format = locale.format;\n  var utcFormat = locale.utcFormat;\n\n  var version = \"0.2.1\";\n\n  exports.version = version;\n  exports.format = format;\n  exports.utcFormat = utcFormat;\n  exports.locale = locale$1;\n  exports.localeCaEs = caES;\n  exports.localeDeCh = deCH;\n  exports.localeDeDe = deDE;\n  exports.localeEnCa = enCA;\n  exports.localeEnGb = enGB;\n  exports.localeEnUs = locale;\n  exports.localeEsEs = esES;\n  exports.localeFiFi = fiFI;\n  exports.localeFrCa = frCA;\n  exports.localeFrFr = frFR;\n  exports.localeHeIl = heIL;\n  exports.localeHuHu = huHU;\n  exports.localeItIt = itIT;\n  exports.localeJaJp = jaJP;\n  exports.localeKoKr = koKR;\n  exports.localeMkMk = mkMK;\n  exports.localeNlNl = nlNL;\n  exports.localePlPl = plPL;\n  exports.localePtBr = ptBR;\n  exports.localeRuRu = ruRU;\n  exports.localeSvSe = svSE;\n  exports.localeZhCn = zhCN;\n  exports.isoFormat = formatIso;\n\n}));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/d3-time-format/build/d3-time-format.js\n ** module id = 38\n ** module chunks = 0\n **/","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define('d3-format', ['exports'], factory) :\n  factory((global.d3_format = {}));\n}(this, function (exports) { 'use strict';\n\n  // Computes the decimal coefficient and exponent of the specified number x with\n  // significant digits p, where x is positive and p is in [1, 21] or undefined.\n  // For example, formatDecimal(1.23) returns [\"123\", 0].\n  function formatDecimal(x, p) {\n    if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf(\"e\")) < 0) return null; // NaN, Infinity\n    var i, coefficient = x.slice(0, i);\n\n    // The string returned by toExponential either has the form \\d\\.\\d+e[-+]\\d+\n    // (e.g., 1.2e+3) or the form \\de[-+]\\d+ (e.g., 1e+3).\n    return [\n      coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,\n      +x.slice(i + 1)\n    ];\n  };\n\n  function exponent(x) {\n    return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;\n  };\n\n  function formatGroup(grouping, thousands) {\n    return function(value, width) {\n      var i = value.length,\n          t = [],\n          j = 0,\n          g = grouping[0],\n          length = 0;\n\n      while (i > 0 && g > 0) {\n        if (length + g + 1 > width) g = Math.max(1, width - length);\n        t.push(value.substring(i -= g, i + g));\n        if ((length += g + 1) > width) break;\n        g = grouping[j = (j + 1) % grouping.length];\n      }\n\n      return t.reverse().join(thousands);\n    };\n  };\n\n  var prefixExponent;\n\n  function formatPrefixAuto(x, p) {\n    var d = formatDecimal(x, p);\n    if (!d) return x + \"\";\n    var coefficient = d[0],\n        exponent = d[1],\n        i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,\n        n = coefficient.length;\n    return i === n ? coefficient\n        : i > n ? coefficient + new Array(i - n + 1).join(\"0\")\n        : i > 0 ? coefficient.slice(0, i) + \".\" + coefficient.slice(i)\n        : \"0.\" + new Array(1 - i).join(\"0\") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!\n  };\n\n  function formatRounded(x, p) {\n    var d = formatDecimal(x, p);\n    if (!d) return x + \"\";\n    var coefficient = d[0],\n        exponent = d[1];\n    return exponent < 0 ? \"0.\" + new Array(-exponent).join(\"0\") + coefficient\n        : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + \".\" + coefficient.slice(exponent + 1)\n        : coefficient + new Array(exponent - coefficient.length + 2).join(\"0\");\n  };\n\n  function formatDefault(x, p) {\n    x = x.toPrecision(p);\n\n    out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {\n      switch (x[i]) {\n        case \".\": i0 = i1 = i; break;\n        case \"0\": if (i0 === 0) i0 = i; i1 = i; break;\n        case \"e\": break out;\n        default: if (i0 > 0) i0 = 0; break;\n      }\n    }\n\n    return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;\n  };\n\n  var formatTypes = {\n    \"\": formatDefault,\n    \"%\": function(x, p) { return (x * 100).toFixed(p); },\n    \"b\": function(x) { return Math.round(x).toString(2); },\n    \"c\": function(x) { return x + \"\"; },\n    \"d\": function(x) { return Math.round(x).toString(10); },\n    \"e\": function(x, p) { return x.toExponential(p); },\n    \"f\": function(x, p) { return x.toFixed(p); },\n    \"g\": function(x, p) { return x.toPrecision(p); },\n    \"o\": function(x) { return Math.round(x).toString(8); },\n    \"p\": function(x, p) { return formatRounded(x * 100, p); },\n    \"r\": formatRounded,\n    \"s\": formatPrefixAuto,\n    \"X\": function(x) { return Math.round(x).toString(16).toUpperCase(); },\n    \"x\": function(x) { return Math.round(x).toString(16); }\n  };\n\n  // [[fill]align][sign][symbol][0][width][,][.precision][type]\n  var re = /^(?:(.)?([<>=^]))?([+\\-\\( ])?([$#])?(0)?(\\d+)?(,)?(\\.\\d+)?([a-z%])?$/i;\n\n  function formatSpecifier(specifier) {\n    return new FormatSpecifier(specifier);\n  };\n\n  function FormatSpecifier(specifier) {\n    if (!(match = re.exec(specifier))) throw new Error(\"invalid format: \" + specifier);\n\n    var match,\n        fill = match[1] || \" \",\n        align = match[2] || \">\",\n        sign = match[3] || \"-\",\n        symbol = match[4] || \"\",\n        zero = !!match[5],\n        width = match[6] && +match[6],\n        comma = !!match[7],\n        precision = match[8] && +match[8].slice(1),\n        type = match[9] || \"\";\n\n    // The \"n\" type is an alias for \",g\".\n    if (type === \"n\") comma = true, type = \"g\";\n\n    // Map invalid types to the default format.\n    else if (!formatTypes[type]) type = \"\";\n\n    // If zero fill is specified, padding goes after sign and before digits.\n    if (zero || (fill === \"0\" && align === \"=\")) zero = true, fill = \"0\", align = \"=\";\n\n    this.fill = fill;\n    this.align = align;\n    this.sign = sign;\n    this.symbol = symbol;\n    this.zero = zero;\n    this.width = width;\n    this.comma = comma;\n    this.precision = precision;\n    this.type = type;\n  }\n\n  FormatSpecifier.prototype.toString = function() {\n    return this.fill\n        + this.align\n        + this.sign\n        + this.symbol\n        + (this.zero ? \"0\" : \"\")\n        + (this.width == null ? \"\" : Math.max(1, this.width | 0))\n        + (this.comma ? \",\" : \"\")\n        + (this.precision == null ? \"\" : \".\" + Math.max(0, this.precision | 0))\n        + this.type;\n  };\n\n  var prefixes = [\"y\",\"z\",\"a\",\"f\",\"p\",\"n\",\"\",\"m\",\"\",\"k\",\"M\",\"G\",\"T\",\"P\",\"E\",\"Z\",\"Y\"];\n\n  function identity(x) {\n    return x;\n  }\n\n  function locale(locale) {\n    var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity,\n        currency = locale.currency,\n        decimal = locale.decimal;\n\n    function format(specifier) {\n      specifier = formatSpecifier(specifier);\n\n      var fill = specifier.fill,\n          align = specifier.align,\n          sign = specifier.sign,\n          symbol = specifier.symbol,\n          zero = specifier.zero,\n          width = specifier.width,\n          comma = specifier.comma,\n          precision = specifier.precision,\n          type = specifier.type;\n\n      // Compute the prefix and suffix.\n      // For SI-prefix, the suffix is lazily computed.\n      var prefix = symbol === \"$\" ? currency[0] : symbol === \"#\" && /[boxX]/.test(type) ? \"0\" + type.toLowerCase() : \"\",\n          suffix = symbol === \"$\" ? currency[1] : /[%p]/.test(type) ? \"%\" : \"\";\n\n      // What format function should we use?\n      // Is this an integer type?\n      // Can this type generate exponential notation?\n      var formatType = formatTypes[type],\n          maybeSuffix = !type || /[defgprs%]/.test(type);\n\n      // Set the default precision if not specified,\n      // or clamp the specified precision to the supported range.\n      // For significant precision, it must be in [1, 21].\n      // For fixed precision, it must be in [0, 20].\n      precision = precision == null ? (type ? 6 : 12)\n          : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))\n          : Math.max(0, Math.min(20, precision));\n\n      return function(value) {\n        var valuePrefix = prefix,\n            valueSuffix = suffix;\n\n        if (type === \"c\") {\n          valueSuffix = formatType(value) + valueSuffix;\n          value = \"\";\n        } else {\n          value = +value;\n\n          // Convert negative to positive, and compute the prefix.\n          // Note that -0 is not less than 0, but 1 / -0 is!\n          var valueNegative = (value < 0 || 1 / value < 0) && (value *= -1, true);\n\n          // Perform the initial formatting.\n          value = formatType(value, precision);\n\n          // If the original value was negative, it may be rounded to zero during\n          // formatting; treat this as (positive) zero.\n          if (valueNegative) {\n            var i = -1, n = value.length, c;\n            valueNegative = false;\n            while (++i < n) {\n              if (c = value.charCodeAt(i), (48 < c && c < 58)\n                  || (type === \"x\" && 96 < c && c < 103)\n                  || (type === \"X\" && 64 < c && c < 71)) {\n                valueNegative = true;\n                break;\n              }\n            }\n          }\n\n          // Compute the prefix and suffix.\n          valuePrefix = (valueNegative ? (sign === \"(\" ? sign : \"-\") : sign === \"-\" || sign === \"(\" ? \"\" : sign) + valuePrefix;\n          valueSuffix = valueSuffix + (type === \"s\" ? prefixes[8 + prefixExponent / 3] : \"\") + (valueNegative && sign === \"(\" ? \")\" : \"\");\n\n          // Break the formatted value into the integer value part that can be\n          // grouped, and fractional or exponential suffix part that is not.\n          if (maybeSuffix) {\n            var i = -1, n = value.length, c;\n            while (++i < n) {\n              if (c = value.charCodeAt(i), 48 > c || c > 57) {\n                valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;\n                value = value.slice(0, i);\n                break;\n              }\n            }\n          }\n        }\n\n        // If the fill character is not \"0\", grouping is applied before padding.\n        if (comma && !zero) value = group(value, Infinity);\n\n        // Compute the padding.\n        var length = valuePrefix.length + value.length + valueSuffix.length,\n            padding = length < width ? new Array(width - length + 1).join(fill) : \"\";\n\n        // If the fill character is \"0\", grouping is applied after padding.\n        if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = \"\";\n\n        // Reconstruct the final output based on the desired alignment.\n        switch (align) {\n          case \"<\": return valuePrefix + value + valueSuffix + padding;\n          case \"=\": return valuePrefix + padding + value + valueSuffix;\n          case \"^\": return padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);\n        }\n        return padding + valuePrefix + value + valueSuffix;\n      };\n    }\n\n    function formatPrefix(specifier, value) {\n      var f = format((specifier = formatSpecifier(specifier), specifier.type = \"f\", specifier)),\n          e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,\n          k = Math.pow(10, -e),\n          prefix = prefixes[8 + e / 3];\n      return function(value) {\n        return f(k * value) + prefix;\n      };\n    }\n\n    return {\n      format: format,\n      formatPrefix: formatPrefix\n    };\n  };\n\n  var defaultLocale = locale({\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"$\", \"\"]\n  });\n\n  var caES = locale({\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0\"]\n  });\n\n  var csCZ = locale({\n    decimal: \",\",\n    thousands: \"\\xa0\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0K\"],\n  });\n\n  var deCH = locale({\n    decimal: \",\",\n    thousands: \"'\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0CHF\"]\n  });\n\n  var deDE = locale({\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0\"]\n  });\n\n  var enCA = locale({\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"$\", \"\"]\n  });\n\n  var enGB = locale({\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"\", \"\"]\n  });\n\n  var esES = locale({\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0\"]\n  });\n\n  var fiFI = locale({\n    decimal: \",\",\n    thousands: \"\\xa0\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0\"]\n  });\n\n  var frCA = locale({\n    decimal: \",\",\n    thousands: \"\\xa0\",\n    grouping: [3],\n    currency: [\"\", \"$\"]\n  });\n\n  var frFR = locale({\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0\"]\n  });\n\n  var heIL = locale({\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"\", \"\"]\n  });\n\n  var huHU = locale({\n    decimal: \",\",\n    thousands: \"\\xa0\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0Ft\"]\n  });\n\n  var itIT = locale({\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"\"]\n  });\n\n  var jaJP = locale({\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"\", \"\"]\n  });\n\n  var koKR = locale({\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"\", \"\"]\n  });\n\n  var mkMK = locale({\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0.\"]\n  });\n\n  var nlNL = locale({\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\\xa0\", \"\"]\n  });\n\n  var plPL = locale({\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"\", \"z\"]\n  });\n\n  var ptBR = locale({\n    decimal: \",\",\n    thousands: \".\",\n    grouping: [3],\n    currency: [\"R$\", \"\"]\n  });\n\n  var ruRU = locale({\n    decimal: \",\",\n    thousands: \"\\xa0\",\n    grouping: [3],\n    currency: [\"\", \"\\xa0.\"]\n  });\n\n  var svSE = locale({\n    decimal: \",\",\n    thousands: \"\\xa0\",\n    grouping: [3],\n    currency: [\"\", \"SEK\"]\n  });\n\n  var zhCN = locale({\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [3],\n    currency: [\"\", \"\"]\n  });\n\n  function precisionFixed(step) {\n    return Math.max(0, -exponent(Math.abs(step)));\n  };\n\n  function precisionPrefix(step, value) {\n    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));\n  };\n\n  function precisionRound(step, max) {\n    step = Math.abs(step), max = Math.abs(max) - step;\n    return Math.max(0, exponent(max) - exponent(step)) + 1;\n  };\n\n  var format = defaultLocale.format;\n  var formatPrefix = defaultLocale.formatPrefix;\n\n  var version = \"0.4.2\";\n\n  exports.version = version;\n  exports.format = format;\n  exports.formatPrefix = formatPrefix;\n  exports.locale = locale;\n  exports.localeCaEs = caES;\n  exports.localeCsCz = csCZ;\n  exports.localeDeCh = deCH;\n  exports.localeDeDe = deDE;\n  exports.localeEnCa = enCA;\n  exports.localeEnGb = enGB;\n  exports.localeEnUs = defaultLocale;\n  exports.localeEsEs = esES;\n  exports.localeFiFi = fiFI;\n  exports.localeFrCa = frCA;\n  exports.localeFrFr = frFR;\n  exports.localeHeIl = heIL;\n  exports.localeHuHu = huHU;\n  exports.localeItIt = itIT;\n  exports.localeJaJp = jaJP;\n  exports.localeKoKr = koKR;\n  exports.localeMkMk = mkMK;\n  exports.localeNlNl = nlNL;\n  exports.localePlPl = plPL;\n  exports.localePtBr = ptBR;\n  exports.localeRuRu = ruRU;\n  exports.localeSvSe = svSE;\n  exports.localeZhCn = zhCN;\n  exports.formatSpecifier = formatSpecifier;\n  exports.precisionFixed = precisionFixed;\n  exports.precisionPrefix = precisionPrefix;\n  exports.precisionRound = precisionRound;\n\n}));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/d3-format/build/d3-format.js\n ** module id = 39\n ** module chunks = 0\n **/","var util = require('../util'),\n    Measures = require('./measures'),\n    Collector = require('./collector');\n\nfunction Aggregator() {\n  this._cells = {};\n  this._aggr = [];\n  this._stream = false;\n}\n\nvar Flags = Aggregator.Flags = {\n  ADD_CELL: 1,\n  MOD_CELL: 2\n};\n\nvar proto = Aggregator.prototype;\n\n// Parameters\n\nproto.stream = function(v) {\n  if (v == null) return this._stream;\n  this._stream = !!v;\n  this._aggr = [];\n  return this;\n};\n\n// key accessor to use for streaming removes\nproto.key = function(key) {\n  if (key == null) return this._key;\n  this._key = util.$(key);\n  return this;\n};\n\n// Input: array of objects of the form\n// {name: string, get: function}\nproto.groupby = function(dims) {\n  this._dims = util.array(dims).map(function(d, i) {\n    d = util.isString(d) ? {name: d, get: util.$(d)}\n      : util.isFunction(d) ? {name: util.name(d) || d.name || ('_' + i), get: d}\n      : (d.name && util.isFunction(d.get)) ? d : null;\n    if (d == null) throw 'Invalid groupby argument: ' + d;\n    return d;\n  });\n  return this.clear();\n};\n\n// Input: array of objects of the form\n// {name: string, ops: [string, ...]}\nproto.summarize = function(fields) {\n  fields = summarize_args(fields);\n  this._count = true;\n  var aggr = (this._aggr = []),\n      m, f, i, j, op, as, get;\n\n  for (i=0; i<fields.length; ++i) {\n    for (j=0, m=[], f=fields[i]; j<f.ops.length; ++j) {\n      op = f.ops[j];\n      if (op !== 'count') this._count = false;\n      as = (f.as && f.as[j]) || (op + (f.name==='*' ? '' : '_'+f.name));\n      m.push(Measures[op](as));\n    }\n    get = f.get && util.$(f.get) ||\n      (f.name === '*' ? util.identity : util.$(f.name));\n    aggr.push({\n      name: f.name,\n      measures: Measures.create(\n        m,\n        this._stream, // streaming remove flag\n        get,          // input tuple getter\n        this._assign) // output tuple setter\n    });\n  }\n  return this.clear();\n};\n\n// Convenience method to summarize by count\nproto.count = function() {\n  return this.summarize({'*':'count'});\n};\n\n// Override to perform custom tuple value assignment\nproto._assign = function(object, name, value) {\n  object[name] = value;\n};\n\nfunction summarize_args(fields) {\n  if (util.isArray(fields)) { return fields; }\n  if (fields == null) { return []; }\n  var a = [], name, ops;\n  for (name in fields) {\n    ops = util.array(fields[name]);\n    a.push({name: name, ops: ops});\n  }\n  return a;\n}\n\n// Cell Management\n\nproto.clear = function() {\n  return (this._cells = {}, this);\n};\n\nproto._cellkey = function(x) {\n  var d = this._dims,\n      n = d.length, i,\n      k = String(d[0].get(x));\n  for (i=1; i<n; ++i) {\n    k += '|' + d[i].get(x);\n  }\n  return k;\n};\n\nproto._cell = function(x) {\n  var key = this._dims.length ? this._cellkey(x) : '';\n  return this._cells[key] || (this._cells[key] = this._newcell(x, key));\n};\n\nproto._newcell = function(x, key) {\n  var cell = {\n    num:   0,\n    tuple: this._newtuple(x, key),\n    flag:  Flags.ADD_CELL,\n    aggs:  {}\n  };\n\n  var aggr = this._aggr, i;\n  for (i=0; i<aggr.length; ++i) {\n    cell.aggs[aggr[i].name] = new aggr[i].measures(cell, cell.tuple);\n  }\n  if (cell.collect) {\n    cell.data = new Collector(this._key);\n  }\n  return cell;\n};\n\nproto._newtuple = function(x) {\n  var dims = this._dims,\n      t = {}, i, n;\n  for (i=0, n=dims.length; i<n; ++i) {\n    t[dims[i].name] = dims[i].get(x);\n  }\n  return this._ingest(t);\n};\n\n// Override to perform custom tuple ingestion\nproto._ingest = util.identity;\n\n// Process Tuples\n\nproto._add = function(x) {\n  var cell = this._cell(x),\n      aggr = this._aggr, i;\n\n  cell.num += 1;\n  if (!this._count) { // skip if count-only\n    if (cell.collect) cell.data.add(x);\n    for (i=0; i<aggr.length; ++i) {\n      cell.aggs[aggr[i].name].add(x);\n    }\n  }\n  cell.flag |= Flags.MOD_CELL;\n  if (this._on_add) this._on_add(x, cell);\n};\n\nproto._rem = function(x) {\n  var cell = this._cell(x),\n      aggr = this._aggr, i;\n\n  cell.num -= 1;\n  if (!this._count) { // skip if count-only\n    if (cell.collect) cell.data.rem(x);\n    for (i=0; i<aggr.length; ++i) {\n      cell.aggs[aggr[i].name].rem(x);\n    }\n  }\n  cell.flag |= Flags.MOD_CELL;\n  if (this._on_rem) this._on_rem(x, cell);\n};\n\nproto._mod = function(curr, prev) {\n  var cell0 = this._cell(prev),\n      cell1 = this._cell(curr),\n      aggr = this._aggr, i;\n\n  if (cell0 !== cell1) {\n    cell0.num -= 1;\n    cell1.num += 1;\n    if (cell0.collect) cell0.data.rem(prev);\n    if (cell1.collect) cell1.data.add(curr);\n  } else if (cell0.collect && !util.isObject(curr)) {\n    cell0.data.rem(prev);\n    cell0.data.add(curr);\n  }\n\n  for (i=0; i<aggr.length; ++i) {\n    cell0.aggs[aggr[i].name].rem(prev);\n    cell1.aggs[aggr[i].name].add(curr);\n  }\n  cell0.flag |= Flags.MOD_CELL;\n  cell1.flag |= Flags.MOD_CELL;\n  if (this._on_mod) this._on_mod(curr, prev, cell0, cell1);\n};\n\nproto._markMod = function(x) {\n  var cell0 = this._cell(x);\n  cell0.flag |= Flags.MOD_CELL;\n};\n\nproto.result = function() {\n  var result = [],\n      aggr = this._aggr,\n      cell, i, k;\n\n  for (k in this._cells) {\n    cell = this._cells[k];\n    if (cell.num > 0) {\n      // consolidate collector values\n      if (cell.collect) {\n        cell.data.values();\n      }\n      // update tuple properties\n      for (i=0; i<aggr.length; ++i) {\n        cell.aggs[aggr[i].name].set();\n      }\n      // add output tuple\n      result.push(cell.tuple);\n    } else {\n      delete this._cells[k];\n    }\n    cell.flag = 0;\n  }\n\n  this._rems = false;\n  return result;\n};\n\nproto.changes = function(output) {\n  var changes = output || {add:[], rem:[], mod:[]},\n      aggr = this._aggr,\n      cell, flag, i, k;\n\n  for (k in this._cells) {\n    cell = this._cells[k];\n    flag = cell.flag;\n\n    // consolidate collector values\n    if (cell.collect) {\n      cell.data.values();\n    }\n\n    // update tuple properties\n    for (i=0; i<aggr.length; ++i) {\n      cell.aggs[aggr[i].name].set();\n    }\n\n    // organize output tuples\n    if (cell.num <= 0) {\n      changes.rem.push(cell.tuple); // if (flag === Flags.MOD_CELL) { ??\n      delete this._cells[k];\n      if (this._on_drop) this._on_drop(cell);\n    } else {\n      if (this._on_keep) this._on_keep(cell);\n      if (flag & Flags.ADD_CELL) {\n        changes.add.push(cell.tuple);\n      } else if (flag & Flags.MOD_CELL) {\n        changes.mod.push(cell.tuple);\n      }\n    }\n\n    cell.flag = 0;\n  }\n\n  this._rems = false;\n  return changes;\n};\n\nproto.execute = function(input) {\n  return this.clear().insert(input).result();\n};\n\nproto.insert = function(input) {\n  this._consolidate();\n  for (var i=0; i<input.length; ++i) {\n    this._add(input[i]);\n  }\n  return this;\n};\n\nproto.remove = function(input) {\n  if (!this._stream) {\n    throw 'Aggregator not configured for streaming removes.' +\n      ' Call stream(true) prior to calling summarize.';\n  }\n  for (var i=0; i<input.length; ++i) {\n    this._rem(input[i]);\n  }\n  this._rems = true;\n  return this;\n};\n\n// consolidate removals\nproto._consolidate = function() {\n  if (!this._rems) return;\n  for (var k in this._cells) {\n    if (this._cells[k].collect) {\n      this._cells[k].data.values();\n    }\n  }\n  this._rems = false;\n};\n\nmodule.exports = Aggregator;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/datalib/src/aggregate/aggregator.js\n ** module id = 40\n ** module chunks = 0\n **/","var util = require('../util');\n\nvar types = {\n  'values': measure({\n    name: 'values',\n    init: 'cell.collect = true;',\n    set:  'cell.data.values()', idx: -1\n  }),\n  'count': measure({\n    name: 'count',\n    set:  'cell.num'\n  }),\n  'missing': measure({\n    name: 'missing',\n    set:  'this.missing'\n  }),\n  'valid': measure({\n    name: 'valid',\n    set:  'this.valid'\n  }),\n  'sum': measure({\n    name: 'sum',\n    init: 'this.sum = 0;',\n    add:  'this.sum += v;',\n    rem:  'this.sum -= v;',\n    set:  'this.sum'\n  }),\n  'mean': measure({\n    name: 'mean',\n    init: 'this.mean = 0;',\n    add:  'var d = v - this.mean; this.mean += d / this.valid;',\n    rem:  'var d = v - this.mean; this.mean -= this.valid ? d / this.valid : this.mean;',\n    set:  'this.mean'\n  }),\n  'average': measure({\n    name: 'average',\n    set:  'this.mean',\n    req:  ['mean'], idx: 1\n  }),\n  'variance': measure({\n    name: 'variance',\n    init: 'this.dev = 0;',\n    add:  'this.dev += d * (v - this.mean);',\n    rem:  'this.dev -= d * (v - this.mean);',\n    set:  'this.valid > 1 ? this.dev / (this.valid-1) : 0',\n    req:  ['mean'], idx: 1\n  }),\n  'variancep': measure({\n    name: 'variancep',\n    set:  'this.valid > 1 ? this.dev / this.valid : 0',\n    req:  ['variance'], idx: 2\n  }),\n  'stdev': measure({\n    name: 'stdev',\n    set:  'this.valid > 1 ? Math.sqrt(this.dev / (this.valid-1)) : 0',\n    req:  ['variance'], idx: 2\n  }),\n  'stdevp': measure({\n    name: 'stdevp',\n    set:  'this.valid > 1 ? Math.sqrt(this.dev / this.valid) : 0',\n    req:  ['variance'], idx: 2\n  }),\n  'median': measure({\n    name: 'median',\n    set:  'cell.data.q2(this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'q1': measure({\n    name: 'q1',\n    set:  'cell.data.q1(this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'q3': measure({\n    name: 'q3',\n    set:  'cell.data.q3(this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'distinct': measure({\n    name: 'distinct',\n    set:  'this.distinct(cell.data.values(), this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'argmin': measure({\n    name: 'argmin',\n    add:  'if (v < this.min) this.argmin = t;',\n    rem:  'if (v <= this.min) this.argmin = null;',\n    set:  'this.argmin = this.argmin || cell.data.argmin(this.get)',\n    req:  ['min'], str: ['values'], idx: 3\n  }),\n  'argmax': measure({\n    name: 'argmax',\n    add:  'if (v > this.max) this.argmax = t;',\n    rem:  'if (v >= this.max) this.argmax = null;',\n    set:  'this.argmax = this.argmax || cell.data.argmax(this.get)',\n    req:  ['max'], str: ['values'], idx: 3\n  }),\n  'min': measure({\n    name: 'min',\n    init: 'this.min = +Infinity;',\n    add:  'if (v < this.min) this.min = v;',\n    rem:  'if (v <= this.min) this.min = NaN;',\n    set:  'this.min = (isNaN(this.min) ? cell.data.min(this.get) : this.min)',\n    str:  ['values'], idx: 4\n  }),\n  'max': measure({\n    name: 'max',\n    init: 'this.max = -Infinity;',\n    add:  'if (v > this.max) this.max = v;',\n    rem:  'if (v >= this.max) this.max = NaN;',\n    set:  'this.max = (isNaN(this.max) ? cell.data.max(this.get) : this.max)',\n    str:  ['values'], idx: 4\n  }),\n  'modeskew': measure({\n    name: 'modeskew',\n    set:  'this.dev===0 ? 0 : (this.mean - cell.data.q2(this.get)) / Math.sqrt(this.dev/(this.valid-1))',\n    req:  ['mean', 'stdev', 'median'], idx: 5\n  })\n};\n\nfunction measure(base) {\n  return function(out) {\n    var m = util.extend({init:'', add:'', rem:'', idx:0}, base);\n    m.out = out || base.name;\n    return m;\n  };\n}\n\nfunction resolve(agg, stream) {\n  function collect(m, a) {\n    function helper(r) { if (!m[r]) collect(m, m[r] = types[r]()); }\n    if (a.req) a.req.forEach(helper);\n    if (stream && a.str) a.str.forEach(helper);\n    return m;\n  }\n  var map = agg.reduce(\n    collect,\n    agg.reduce(function(m, a) { return (m[a.name] = a, m); }, {})\n  );\n  return util.vals(map).sort(function(a, b) { return a.idx - b.idx; });\n}\n\nfunction create(agg, stream, accessor, mutator) {\n  var all = resolve(agg, stream),\n      ctr = 'this.cell = cell; this.tuple = t; this.valid = 0; this.missing = 0;',\n      add = 'if (v==null) this.missing++; if (!this.isValid(v)) return; ++this.valid;',\n      rem = 'if (v==null) this.missing--; if (!this.isValid(v)) return; --this.valid;',\n      set = 'var t = this.tuple; var cell = this.cell;';\n\n  all.forEach(function(a) {\n    if (a.idx < 0) {\n      ctr = a.init + ctr;\n      add = a.add + add;\n      rem = a.rem + rem;\n    } else {\n      ctr += a.init;\n      add += a.add;\n      rem += a.rem;\n    }\n  });\n  agg.slice()\n    .sort(function(a, b) { return a.idx - b.idx; })\n    .forEach(function(a) {\n      set += 'this.assign(t,\\''+a.out+'\\','+a.set+');';\n    });\n  set += 'return t;';\n\n  /* jshint evil: true */\n  ctr = Function('cell', 't', ctr);\n  ctr.prototype.assign = mutator;\n  ctr.prototype.add = Function('t', 'var v = this.get(t);' + add);\n  ctr.prototype.rem = Function('t', 'var v = this.get(t);' + rem);\n  ctr.prototype.set = Function(set);\n  ctr.prototype.get = accessor;\n  ctr.prototype.distinct = require('../stats').count.distinct;\n  ctr.prototype.isValid = util.isValid;\n  ctr.fields = agg.map(util.$('out'));\n  return ctr;\n}\n\ntypes.create = create;\nmodule.exports = types;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/datalib/src/aggregate/measures.js\n ** module id = 41\n ** module chunks = 0\n **/","var util = require('./util');\nvar type = require('./import/type');\nvar gen = require('./generate');\n\nvar stats = module.exports;\n\n// Collect unique values.\n// Output: an array of unique values, in first-observed order\nstats.unique = function(values, f, results) {\n  f = util.$(f);\n  results = results || [];\n  var u = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    results.push(v);\n  }\n  return results;\n};\n\n// Return the length of the input array.\nstats.count = function(values) {\n  return values && values.length || 0;\n};\n\n// Count the number of non-null, non-undefined, non-NaN values.\nstats.count.valid = function(values, f) {\n  f = util.$(f);\n  var v, i, n, valid = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) valid += 1;\n  }\n  return valid;\n};\n\n// Count the number of null or undefined values.\nstats.count.missing = function(values, f) {\n  f = util.$(f);\n  var v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v == null) count += 1;\n  }\n  return count;\n};\n\n// Count the number of distinct values.\n// Null, undefined and NaN are each considered distinct values.\nstats.count.distinct = function(values, f) {\n  f = util.$(f);\n  var u = {}, v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    count += 1;\n  }\n  return count;\n};\n\n// Construct a map from distinct values to occurrence counts.\nstats.count.map = function(values, f) {\n  f = util.$(f);\n  var map = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    map[v] = (v in map) ? map[v] + 1 : 1;\n  }\n  return map;\n};\n\n// Compute the median of an array of numbers.\nstats.median = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  return stats.quantile(values, 0.5);\n};\n\n// Computes the quartile boundaries of an array of numbers.\nstats.quartile = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  var q = stats.quantile;\n  return [q(values, 0.25), q(values, 0.50), q(values, 0.75)];\n};\n\n// Compute the quantile of a sorted array of numbers.\n// Adapted from the D3.js implementation.\nstats.quantile = function(values, f, p) {\n  if (p === undefined) { p = f; f = util.identity; }\n  f = util.$(f);\n  var H = (values.length - 1) * p + 1,\n      h = Math.floor(H),\n      v = +f(values[h - 1]),\n      e = H - h;\n  return e ? v + e * (f(values[h]) - v) : v;\n};\n\n// Compute the sum of an array of numbers.\nstats.sum = function(values, f) {\n  f = util.$(f);\n  for (var sum=0, i=0, n=values.length, v; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) sum += v;\n  }\n  return sum;\n};\n\n// Compute the mean (average) of an array of numbers.\nstats.mean = function(values, f) {\n  f = util.$(f);\n  var mean = 0, delta, i, n, c, v;\n  for (i=0, c=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n    }\n  }\n  return mean;\n};\n\n// Compute the geometric mean of an array of numbers.\nstats.mean.geometric = function(values, f) {\n  f = util.$(f);\n  var mean = 1, c, n, v, i;\n  for (i=0, c=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v <= 0) {\n        throw Error(\"Geometric mean only defined for positive values.\");\n      }\n      mean *= v;\n      ++c;\n    }\n  }\n  mean = c > 0 ? Math.pow(mean, 1/c) : 0;\n  return mean;\n};\n\n// Compute the harmonic mean of an array of numbers.\nstats.mean.harmonic = function(values, f) {\n  f = util.$(f);\n  var mean = 0, c, n, v, i;\n  for (i=0, c=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      mean += 1/v;\n      ++c;\n    }\n  }\n  return c / mean;\n};\n\n// Compute the sample variance of an array of numbers.\nstats.variance = function(values, f) {\n  f = util.$(f);\n  if (!util.isArray(values) || values.length < 2) return 0;\n  var mean = 0, M2 = 0, delta, i, c, v;\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n      M2 = M2 + delta * (v - mean);\n    }\n  }\n  M2 = M2 / (c - 1);\n  return M2;\n};\n\n// Compute the sample standard deviation of an array of numbers.\nstats.stdev = function(values, f) {\n  return Math.sqrt(stats.variance(values, f));\n};\n\n// Compute the Pearson mode skewness ((median-mean)/stdev) of an array of numbers.\nstats.modeskew = function(values, f) {\n  var avg = stats.mean(values, f),\n      med = stats.median(values, f),\n      std = stats.stdev(values, f);\n  return std === 0 ? 0 : (avg - med) / std;\n};\n\n// Find the minimum value in an array.\nstats.min = function(values, f) {\n  return stats.extent(values, f)[0];\n};\n\n// Find the maximum value in an array.\nstats.max = function(values, f) {\n  return stats.extent(values, f)[1];\n};\n\n// Find the minimum and maximum of an array of values.\nstats.extent = function(values, f) {\n  f = util.$(f);\n  var a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) a = v;\n      if (v > b) b = v;\n    }\n  }\n  return [a, b];\n};\n\n// Find the integer indices of the minimum and maximum values.\nstats.extent.index = function(values, f) {\n  f = util.$(f);\n  var x = -1, y = -1, a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; x = y = i; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) { a = v; x = i; }\n      if (v > b) { b = v; y = i; }\n    }\n  }\n  return [x, y];\n};\n\n// Compute the dot product of two arrays of numbers.\nstats.dot = function(values, a, b) {\n  var sum = 0, i, v;\n  if (!b) {\n    if (values.length !== a.length) {\n      throw Error('Array lengths must match.');\n    }\n    for (i=0; i<values.length; ++i) {\n      v = values[i] * a[i];\n      if (v === v) sum += v;\n    }\n  } else {\n    a = util.$(a);\n    b = util.$(b);\n    for (i=0; i<values.length; ++i) {\n      v = a(values[i]) * b(values[i]);\n      if (v === v) sum += v;\n    }\n  }\n  return sum;\n};\n\n// Compute the vector distance between two arrays of numbers.\n// Default is Euclidean (exp=2) distance, configurable via exp argument.\nstats.dist = function(values, a, b, exp) {\n  var f = util.isFunction(b) || util.isString(b),\n      X = values,\n      Y = f ? values : a,\n      e = f ? exp : b,\n      L2 = e === 2 || e == null,\n      n = values.length, s = 0, d, i;\n  if (f) {\n    a = util.$(a);\n    b = util.$(b);\n  }\n  for (i=0; i<n; ++i) {\n    d = f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]);\n    s += L2 ? d*d : Math.pow(Math.abs(d), e);\n  }\n  return L2 ? Math.sqrt(s) : Math.pow(s, 1/e);\n};\n\n// Compute the Cohen's d effect size between two arrays of numbers.\nstats.cohensd = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a,\n      x1 = stats.mean(X),\n      x2 = stats.mean(Y),\n      n1 = stats.count.valid(X),\n      n2 = stats.count.valid(Y);\n\n  if ((n1+n2-2) <= 0) {\n    // if both arrays are size 1, or one is empty, there's no effect size\n    return 0;\n  }\n  // pool standard deviation\n  var s1 = stats.variance(X),\n      s2 = stats.variance(Y),\n      s = Math.sqrt((((n1-1)*s1) + ((n2-1)*s2)) / (n1+n2-2));\n  // if there is no variance, there's no effect size\n  return s===0 ? 0 : (x1 - x2) / s;\n};\n\n// Computes the covariance between two arrays of numbers\nstats.covariance = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a,\n      n = X.length,\n      xm = stats.mean(X),\n      ym = stats.mean(Y),\n      sum = 0, c = 0, i, x, y, vx, vy;\n\n  if (n !== Y.length) {\n    throw Error('Input lengths must match.');\n  }\n\n  for (i=0; i<n; ++i) {\n    x = X[i]; vx = util.isValid(x);\n    y = Y[i]; vy = util.isValid(y);\n    if (vx && vy) {\n      sum += (x-xm) * (y-ym);\n      ++c;\n    } else if (vx || vy) {\n      throw Error('Valid values must align.');\n    }\n  }\n  return sum / (c-1);\n};\n\n// Compute ascending rank scores for an array of values.\n// Ties are assigned their collective mean rank.\nstats.rank = function(values, f) {\n  f = util.$(f) || util.identity;\n  var a = values.map(function(v, i) {\n      return {idx: i, val: f(v)};\n    })\n    .sort(util.comparator('val'));\n\n  var n = values.length,\n      r = Array(n),\n      tie = -1, p = {}, i, v, mu;\n\n  for (i=0; i<n; ++i) {\n    v = a[i].val;\n    if (tie < 0 && p === v) {\n      tie = i - 1;\n    } else if (tie > -1 && p !== v) {\n      mu = 1 + (i-1 + tie) / 2;\n      for (; tie<i; ++tie) r[a[tie].idx] = mu;\n      tie = -1;\n    }\n    r[a[i].idx] = i + 1;\n    p = v;\n  }\n\n  if (tie > -1) {\n    mu = 1 + (n-1 + tie) / 2;\n    for (; tie<n; ++tie) r[a[tie].idx] = mu;\n  }\n\n  return r;\n};\n\n// Compute the sample Pearson product-moment correlation of two arrays of numbers.\nstats.cor = function(values, a, b) {\n  var fn = b;\n  b = fn ? values.map(util.$(b)) : a;\n  a = fn ? values.map(util.$(a)) : values;\n\n  var dot = stats.dot(a, b),\n      mua = stats.mean(a),\n      mub = stats.mean(b),\n      sda = stats.stdev(a),\n      sdb = stats.stdev(b),\n      n = values.length;\n\n  return (dot - n*mua*mub) / ((n-1) * sda * sdb);\n};\n\n// Compute the Spearman rank correlation of two arrays of values.\nstats.cor.rank = function(values, a, b) {\n  var ra = b ? stats.rank(values, a) : stats.rank(values),\n      rb = b ? stats.rank(values, b) : stats.rank(a),\n      n = values.length, i, s, d;\n\n  for (i=0, s=0; i<n; ++i) {\n    d = ra[i] - rb[i];\n    s += d * d;\n  }\n\n  return 1 - 6*s / (n * (n*n-1));\n};\n\n// Compute the distance correlation of two arrays of numbers.\n// http://en.wikipedia.org/wiki/Distance_correlation\nstats.cor.dist = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a;\n\n  var A = stats.dist.mat(X),\n      B = stats.dist.mat(Y),\n      n = A.length,\n      i, aa, bb, ab;\n\n  for (i=0, aa=0, bb=0, ab=0; i<n; ++i) {\n    aa += A[i]*A[i];\n    bb += B[i]*B[i];\n    ab += A[i]*B[i];\n  }\n\n  return Math.sqrt(ab / Math.sqrt(aa*bb));\n};\n\n// Simple linear regression.\n// Returns a \"fit\" object with slope (m), intercept (b),\n// r value (R), and sum-squared residual error (rss).\nstats.linearRegression = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a,\n      n = X.length,\n      xy = stats.covariance(X, Y), // will throw err if valid vals don't align\n      sx = stats.stdev(X),\n      sy = stats.stdev(Y),\n      slope = xy / (sx*sx),\n      icept = stats.mean(Y) - slope * stats.mean(X),\n      fit = {slope: slope, intercept: icept, R: xy / (sx*sy), rss: 0},\n      res, i;\n\n  for (i=0; i<n; ++i) {\n    if (util.isValid(X[i]) && util.isValid(Y[i])) {\n      res = (slope*X[i] + icept) - Y[i];\n      fit.rss += res * res;\n    }\n  }\n\n  return fit;\n};\n\n// Namespace for bootstrap\nstats.bootstrap = {};\n\n// Construct a bootstrapped confidence interval at a given percentile level\n// Arguments are an array, an optional n (defaults to 1000),\n//  an optional alpha (defaults to 0.05), and an optional smoothing parameter\nstats.bootstrap.ci = function(values, a, b, c, d) {\n  var X, N, alpha, smooth, bs, means, i;\n  if (util.isFunction(a) || util.isString(a)) {\n    X = values.map(util.$(a));\n    N = b;\n    alpha = c;\n    smooth = d;\n  } else {\n    X = values;\n    N = a;\n    alpha = b;\n    smooth = c;\n  }\n  N = N ? +N : 1000;\n  alpha = alpha || 0.05;\n\n  bs = gen.random.bootstrap(X, smooth);\n  for (i=0, means = Array(N); i<N; ++i) {\n    means[i] = stats.mean(bs.samples(X.length));\n  }\n  means.sort(util.numcmp);\n  return [\n    stats.quantile(means, alpha/2),\n    stats.quantile(means, 1-(alpha/2))\n  ];\n};\n\n// Namespace for z-tests\nstats.z = {};\n\n// Construct a z-confidence interval at a given significance level\n// Arguments are an array and an optional alpha (defaults to 0.05).\nstats.z.ci = function(values, a, b) {\n  var X = values, alpha = a;\n  if (util.isFunction(a) || util.isString(a)) {\n    X = values.map(util.$(a));\n    alpha = b;\n  }\n  alpha = alpha || 0.05;\n\n  var z = alpha===0.05 ? 1.96 : gen.random.normal(0, 1).icdf(1-(alpha/2)),\n      mu = stats.mean(X),\n      SE = stats.stdev(X) / Math.sqrt(stats.count.valid(X));\n  return [mu - (z*SE), mu + (z*SE)];\n};\n\n// Perform a z-test of means. Returns the p-value.\n// If a single array is provided, performs a one-sample location test.\n// If two arrays or a table and two accessors are provided, performs\n// a two-sample location test. A paired test is performed if specified\n// by the options hash.\n// The options hash format is: {paired: boolean, nullh: number}.\n// http://en.wikipedia.org/wiki/Z-test\n// http://en.wikipedia.org/wiki/Paired_difference_test\nstats.z.test = function(values, a, b, opt) {\n  if (util.isFunction(b) || util.isString(b)) { // table and accessors\n    return (opt && opt.paired ? ztestP : ztest2)(opt, values, a, b);\n  } else if (util.isArray(a)) { // two arrays\n    return (b && b.paired ? ztestP : ztest2)(b, values, a);\n  } else if (util.isFunction(a) || util.isString(a)) {\n    return ztest1(b, values, a); // table and accessor\n  } else {\n    return ztest1(a, values); // one array\n  }\n};\n\n// Perform a z-test of means. Returns the p-value.\n// Assuming we have a list of values, and a null hypothesis. If no null\n// hypothesis, assume our null hypothesis is mu=0.\nfunction ztest1(opt, X, f) {\n  var nullH = opt && opt.nullh || 0,\n      gaussian = gen.random.normal(0, 1),\n      mu = stats.mean(X,f),\n      SE = stats.stdev(X,f) / Math.sqrt(stats.count.valid(X,f));\n\n  if (SE===0) {\n    // Test not well defined when standard error is 0.\n    return (mu - nullH) === 0 ? 1 : 0;\n  }\n  // Two-sided, so twice the one-sided cdf.\n  var z = (mu - nullH) / SE;\n  return 2 * gaussian.cdf(-Math.abs(z));\n}\n\n// Perform a two sample paired z-test of means. Returns the p-value.\nfunction ztestP(opt, values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a,\n      n1 = stats.count(X),\n      n2 = stats.count(Y),\n      diffs = Array(), i;\n\n  if (n1 !== n2) {\n    throw Error('Array lengths must match.');\n  }\n  for (i=0; i<n1; ++i) {\n    // Only valid differences should contribute to the test statistic\n    if (util.isValid(X[i]) && util.isValid(Y[i])) {\n      diffs.push(X[i] - Y[i]);\n    }\n  }\n  return stats.z.test(diffs, opt && opt.nullh || 0);\n}\n\n// Perform a two sample z-test of means. Returns the p-value.\nfunction ztest2(opt, values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a,\n      n1 = stats.count.valid(X),\n      n2 = stats.count.valid(Y),\n      gaussian = gen.random.normal(0, 1),\n      meanDiff = stats.mean(X) - stats.mean(Y) - (opt && opt.nullh || 0),\n      SE = Math.sqrt(stats.variance(X)/n1 + stats.variance(Y)/n2);\n\n  if (SE===0) {\n    // Not well defined when pooled standard error is 0.\n    return meanDiff===0 ? 1 : 0;\n  }\n  // Two-tailed, so twice the one-sided cdf.\n  var z = meanDiff / SE;\n  return 2 * gaussian.cdf(-Math.abs(z));\n}\n\n// Construct a mean-centered distance matrix for an array of numbers.\nstats.dist.mat = function(X) {\n  var n = X.length,\n      m = n*n,\n      A = Array(m),\n      R = gen.zeros(n),\n      M = 0, v, i, j;\n\n  for (i=0; i<n; ++i) {\n    A[i*n+i] = 0;\n    for (j=i+1; j<n; ++j) {\n      A[i*n+j] = (v = Math.abs(X[i] - X[j]));\n      A[j*n+i] = v;\n      R[i] += v;\n      R[j] += v;\n    }\n  }\n\n  for (i=0; i<n; ++i) {\n    M += R[i];\n    R[i] /= n;\n  }\n  M /= m;\n\n  for (i=0; i<n; ++i) {\n    for (j=i; j<n; ++j) {\n      A[i*n+j] += M - R[i] - R[j];\n      A[j*n+i] = A[i*n+j];\n    }\n  }\n\n  return A;\n};\n\n// Compute the Shannon entropy (log base 2) of an array of counts.\nstats.entropy = function(counts, f) {\n  f = util.$(f);\n  var i, p, s = 0, H = 0, n = counts.length;\n  for (i=0; i<n; ++i) {\n    s += (f ? f(counts[i]) : counts[i]);\n  }\n  if (s === 0) return 0;\n  for (i=0; i<n; ++i) {\n    p = (f ? f(counts[i]) : counts[i]) / s;\n    if (p) H += p * Math.log(p);\n  }\n  return -H / Math.LN2;\n};\n\n// Compute the mutual information between two discrete variables.\n// Returns an array of the form [MI, MI_distance]\n// MI_distance is defined as 1 - I(a,b) / H(a,b).\n// http://en.wikipedia.org/wiki/Mutual_information\nstats.mutual = function(values, a, b, counts) {\n  var x = counts ? values.map(util.$(a)) : values,\n      y = counts ? values.map(util.$(b)) : a,\n      z = counts ? values.map(util.$(counts)) : b;\n\n  var px = {},\n      py = {},\n      n = z.length,\n      s = 0, I = 0, H = 0, p, t, i;\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] = 0;\n    py[y[i]] = 0;\n  }\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] += z[i];\n    py[y[i]] += z[i];\n    s += z[i];\n  }\n\n  t = 1 / (s * Math.LN2);\n  for (i=0; i<n; ++i) {\n    if (z[i] === 0) continue;\n    p = (s * z[i]) / (px[x[i]] * py[y[i]]);\n    I += z[i] * t * Math.log(p);\n    H += z[i] * t * Math.log(z[i]/s);\n  }\n\n  return [I, 1 + I/H];\n};\n\n// Compute the mutual information between two discrete variables.\nstats.mutual.info = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[0];\n};\n\n// Compute the mutual information distance between two discrete variables.\n// MI_distance is defined as 1 - I(a,b) / H(a,b).\nstats.mutual.dist = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[1];\n};\n\n// Compute a profile of summary statistics for a variable.\nstats.profile = function(values, f) {\n  var mean = 0,\n      valid = 0,\n      missing = 0,\n      distinct = 0,\n      min = null,\n      max = null,\n      M2 = 0,\n      vals = [],\n      u = {}, delta, sd, i, v, x;\n\n  // compute summary stats\n  for (i=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n\n    // update unique values\n    u[v] = (v in u) ? u[v] + 1 : (distinct += 1, 1);\n\n    if (v == null) {\n      ++missing;\n    } else if (util.isValid(v)) {\n      // update stats\n      x = (typeof v === 'string') ? v.length : v;\n      if (min===null || x < min) min = x;\n      if (max===null || x > max) max = x;\n      delta = x - mean;\n      mean = mean + delta / (++valid);\n      M2 = M2 + delta * (x - mean);\n      vals.push(x);\n    }\n  }\n  M2 = M2 / (valid - 1);\n  sd = Math.sqrt(M2);\n\n  // sort values for median and iqr\n  vals.sort(util.cmp);\n\n  return {\n    type:     type(values, f),\n    unique:   u,\n    count:    values.length,\n    valid:    valid,\n    missing:  missing,\n    distinct: distinct,\n    min:      min,\n    max:      max,\n    mean:     mean,\n    stdev:    sd,\n    median:   (v = stats.quantile(vals, 0.5)),\n    q1:       stats.quantile(vals, 0.25),\n    q3:       stats.quantile(vals, 0.75),\n    modeskew: sd === 0 ? 0 : (mean - v) / sd\n  };\n};\n\n// Compute profiles for all variables in a data set.\nstats.summary = function(data, fields) {\n  fields = fields || util.keys(data[0]);\n  var s = fields.map(function(f) {\n    var p = stats.profile(data, util.$(f));\n    return (p.field = f, p);\n  });\n  return (s.__summary__ = true, s);\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/datalib/src/stats.js\n ** module id = 42\n ** module chunks = 0\n **/","var util = require('./util'),\n    gen = module.exports;\n\ngen.repeat = function(val, n) {\n  var a = Array(n), i;\n  for (i=0; i<n; ++i) a[i] = val;\n  return a;\n};\n\ngen.zeros = function(n) {\n  return gen.repeat(0, n);\n};\n\ngen.range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error('Infinite range');\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n};\n\ngen.random = {};\n\ngen.random.uniform = function(min, max) {\n  if (max === undefined) {\n    max = min === undefined ? 1 : min;\n    min = 0;\n  }\n  var d = max - min;\n  var f = function() {\n    return min + d * Math.random();\n  };\n  f.samples = function(n) {\n    return gen.zeros(n).map(f);\n  };\n  f.pdf = function(x) {\n    return (x >= min && x <= max) ? 1/d : 0;\n  };\n  f.cdf = function(x) {\n    return x < min ? 0 : x > max ? 1 : (x - min) / d;\n  };\n  f.icdf = function(p) {\n    return (p >= 0 && p <= 1) ? min + p*d : NaN;\n  };\n  return f;\n};\n\ngen.random.integer = function(a, b) {\n  if (b === undefined) {\n    b = a;\n    a = 0;\n  }\n  var d = b - a;\n  var f = function() {\n    return a + Math.floor(d * Math.random());\n  };\n  f.samples = function(n) {\n    return gen.zeros(n).map(f);\n  };\n  f.pdf = function(x) {\n    return (x === Math.floor(x) && x >= a && x < b) ? 1/d : 0;\n  };\n  f.cdf = function(x) {\n    var v = Math.floor(x);\n    return v < a ? 0 : v >= b ? 1 : (v - a + 1) / d;\n  };\n  f.icdf = function(p) {\n    return (p >= 0 && p <= 1) ? a - 1 + Math.floor(p*d) : NaN;\n  };\n  return f;\n};\n\ngen.random.normal = function(mean, stdev) {\n  mean = mean || 0;\n  stdev = stdev || 1;\n  var next;\n  var f = function() {\n    var x = 0, y = 0, rds, c;\n    if (next !== undefined) {\n      x = next;\n      next = undefined;\n      return x;\n    }\n    do {\n      x = Math.random()*2-1;\n      y = Math.random()*2-1;\n      rds = x*x + y*y;\n    } while (rds === 0 || rds > 1);\n    c = Math.sqrt(-2*Math.log(rds)/rds); // Box-Muller transform\n    next = mean + y*c*stdev;\n    return mean + x*c*stdev;\n  };\n  f.samples = function(n) {\n    return gen.zeros(n).map(f);\n  };\n  f.pdf = function(x) {\n    var exp = Math.exp(Math.pow(x-mean, 2) / (-2 * Math.pow(stdev, 2)));\n    return (1 / (stdev * Math.sqrt(2*Math.PI))) * exp;\n  };\n  f.cdf = function(x) {\n    // Approximation from West (2009)\n    // Better Approximations to Cumulative Normal Functions\n    var cd,\n        z = (x - mean) / stdev,\n        Z = Math.abs(z);\n    if (Z > 37) {\n      cd = 0;\n    } else {\n      var sum, exp = Math.exp(-Z*Z/2);\n      if (Z < 7.07106781186547) {\n        sum = 3.52624965998911e-02 * Z + 0.700383064443688;\n        sum = sum * Z + 6.37396220353165;\n        sum = sum * Z + 33.912866078383;\n        sum = sum * Z + 112.079291497871;\n        sum = sum * Z + 221.213596169931;\n        sum = sum * Z + 220.206867912376;\n        cd = exp * sum;\n        sum = 8.83883476483184e-02 * Z + 1.75566716318264;\n        sum = sum * Z + 16.064177579207;\n        sum = sum * Z + 86.7807322029461;\n        sum = sum * Z + 296.564248779674;\n        sum = sum * Z + 637.333633378831;\n        sum = sum * Z + 793.826512519948;\n        sum = sum * Z + 440.413735824752;\n        cd = cd / sum;\n      } else {\n        sum = Z + 0.65;\n        sum = Z + 4 / sum;\n        sum = Z + 3 / sum;\n        sum = Z + 2 / sum;\n        sum = Z + 1 / sum;\n        cd = exp / sum / 2.506628274631;\n      }\n    }\n    return z > 0 ? 1 - cd : cd;\n  };\n  f.icdf = function(p) {\n    // Approximation of Probit function using inverse error function.\n    if (p <= 0 || p >= 1) return NaN;\n    var x = 2*p - 1,\n        v = (8 * (Math.PI - 3)) / (3 * Math.PI * (4-Math.PI)),\n        a = (2 / (Math.PI*v)) + (Math.log(1 - Math.pow(x,2)) / 2),\n        b = Math.log(1 - (x*x)) / v,\n        s = (x > 0 ? 1 : -1) * Math.sqrt(Math.sqrt((a*a) - b) - a);\n    return mean + stdev * Math.SQRT2 * s;\n  };\n  return f;\n};\n\ngen.random.bootstrap = function(domain, smooth) {\n  // Generates a bootstrap sample from a set of observations.\n  // Smooth bootstrapping adds random zero-centered noise to the samples.\n  var val = domain.filter(util.isValid),\n      len = val.length,\n      err = smooth ? gen.random.normal(0, smooth) : null;\n  var f = function() {\n    return val[~~(Math.random()*len)] + (err ? err() : 0);\n  };\n  f.samples = function(n) {\n    return gen.zeros(n).map(f);\n  };\n  return f;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/datalib/src/generate.js\n ** module id = 43\n ** module chunks = 0\n **/","var util = require('../util');\nvar stats = require('../stats');\n\nvar REM = '__dl_rem__';\n\nfunction Collector(key) {\n  this._add = [];\n  this._rem = [];\n  this._key = key || null;\n  this._last = null;\n}\n\nvar proto = Collector.prototype;\n\nproto.add = function(v) {\n  this._add.push(v);\n};\n\nproto.rem = function(v) {\n  this._rem.push(v);\n};\n\nproto.values = function() {\n  this._get = null;\n  if (this._rem.length === 0) return this._add;\n\n  var a = this._add,\n      r = this._rem,\n      k = this._key,\n      x = Array(a.length - r.length),\n      i, j, n, m;\n\n  if (!util.isObject(r[0])) {\n    // processing raw values\n    m = stats.count.map(r);\n    for (i=0, j=0, n=a.length; i<n; ++i) {\n      if (m[a[i]] > 0) {\n        m[a[i]] -= 1;\n      } else {\n        x[j++] = a[i];\n      }\n    }\n  } else if (k) {\n    // has unique key field, so use that\n    m = util.toMap(r, k);\n    for (i=0, j=0, n=a.length; i<n; ++i) {\n      if (!m.hasOwnProperty(k(a[i]))) { x[j++] = a[i]; }\n    }\n  } else {\n    // no unique key, mark tuples directly\n    for (i=0, n=r.length; i<n; ++i) {\n      r[i][REM] = 1;\n    }\n    for (i=0, j=0, n=a.length; i<n; ++i) {\n      if (!a[i][REM]) { x[j++] = a[i]; }\n    }\n    for (i=0, n=r.length; i<n; ++i) {\n      delete r[i][REM];\n    }\n  }\n\n  this._rem = [];\n  return (this._add = x);\n};\n\n// memoizing statistics methods\n\nproto.extent = function(get) {\n  if (this._get !== get || !this._ext) {\n    var v = this.values(),\n        i = stats.extent.index(v, get);\n    this._ext = [v[i[0]], v[i[1]]];\n    this._get = get;\n  }\n  return this._ext;\n};\n\nproto.argmin = function(get) {\n  return this.extent(get)[0];\n};\n\nproto.argmax = function(get) {\n  return this.extent(get)[1];\n};\n\nproto.min = function(get) {\n  var m = this.extent(get)[0];\n  return m != null ? get(m) : +Infinity;\n};\n\nproto.max = function(get) {\n  var m = this.extent(get)[1];\n  return m != null ? get(m) : -Infinity;\n};\n\nproto.quartile = function(get) {\n  if (this._get !== get || !this._q) {\n    this._q = stats.quartile(this.values(), get);\n    this._get = get;\n  }\n  return this._q;\n};\n\nproto.q1 = function(get) {\n  return this.quartile(get)[0];\n};\n\nproto.q2 = function(get) {\n  return this.quartile(get)[1];\n};\n\nproto.q3 = function(get) {\n  return this.quartile(get)[2];\n};\n\nmodule.exports = Collector;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/datalib/src/aggregate/collector.js\n ** module id = 44\n ** module chunks = 0\n **/","var util = require('../util');\nvar Aggregator = require('./aggregator');\n\nmodule.exports = function() {\n  // flatten arguments into a single array\n  var args = [].reduce.call(arguments, function(a, x) {\n    return a.concat(util.array(x));\n  }, []);\n  // create and return an aggregator\n  return new Aggregator()\n    .groupby(args)\n    .summarize({'*':'values'});\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/datalib/src/aggregate/groupby.js\n ** module id = 45\n ** module chunks = 0\n **/","var util = require('../util'),\n    time = require('../time'),\n    EPSILON = 1e-15;\n\nfunction bins(opt) {\n  if (!opt) { throw Error(\"Missing binning options.\"); }\n\n  // determine range\n  var maxb = opt.maxbins || 15,\n      base = opt.base || 10,\n      logb = Math.log(base),\n      div = opt.div || [5, 2],\n      min = opt.min,\n      max = opt.max,\n      span = max - min,\n      step, level, minstep, precision, v, i, eps;\n\n  if (opt.step) {\n    // if step size is explicitly given, use that\n    step = opt.step;\n  } else if (opt.steps) {\n    // if provided, limit choice to acceptable step sizes\n    step = opt.steps[Math.min(\n      opt.steps.length - 1,\n      bisect(opt.steps, span/maxb, 0, opt.steps.length)\n    )];\n  } else {\n    // else use span to determine step size\n    level = Math.ceil(Math.log(maxb) / logb);\n    minstep = opt.minstep || 0;\n    step = Math.max(\n      minstep,\n      Math.pow(base, Math.round(Math.log(span) / logb) - level)\n    );\n\n    // increase step size if too many bins\n    while (Math.ceil(span/step) > maxb) { step *= base; }\n\n    // decrease step size if allowed\n    for (i=0; i<div.length; ++i) {\n      v = step / div[i];\n      if (v >= minstep && span / v <= maxb) step = v;\n    }\n  }\n\n  // update precision, min and max\n  v = Math.log(step);\n  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;\n  eps = Math.pow(base, -precision - 1);\n  min = Math.min(min, Math.floor(min / step + eps) * step);\n  max = Math.ceil(max / step) * step;\n\n  return {\n    start: min,\n    stop:  max,\n    step:  step,\n    unit:  {precision: precision},\n    value: value,\n    index: index\n  };\n}\n\nfunction bisect(a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (util.cmp(a[mid], x) < 0) { lo = mid + 1; }\n    else { hi = mid; }\n  }\n  return lo;\n}\n\nfunction value(v) {\n  return this.step * Math.floor(v / this.step + EPSILON);\n}\n\nfunction index(v) {\n  return Math.floor((v - this.start) / this.step + EPSILON);\n}\n\nfunction date_value(v) {\n  return this.unit.date(value.call(this, v));\n}\n\nfunction date_index(v) {\n  return index.call(this, this.unit.unit(v));\n}\n\nbins.date = function(opt) {\n  if (!opt) { throw Error(\"Missing date binning options.\"); }\n\n  // find time step, then bin\n  var units = opt.utc ? time.utc : time,\n      dmin = opt.min,\n      dmax = opt.max,\n      maxb = opt.maxbins || 20,\n      minb = opt.minbins || 4,\n      span = (+dmax) - (+dmin),\n      unit = opt.unit ? units[opt.unit] : units.find(span, minb, maxb),\n      spec = bins({\n        min:     unit.min != null ? unit.min : unit.unit(dmin),\n        max:     unit.max != null ? unit.max : unit.unit(dmax),\n        maxbins: maxb,\n        minstep: unit.minstep,\n        steps:   unit.step\n      });\n\n  spec.unit = unit;\n  spec.index = date_index;\n  if (!opt.raw) spec.value = date_value;\n  return spec;\n};\n\nmodule.exports = bins;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/datalib/src/bins/bins.js\n ** module id = 46\n ** module chunks = 0\n **/","var d3_time = require('d3-time');\n\nvar tempDate = new Date(),\n    baseDate = new Date(0, 0, 1).setFullYear(0), // Jan 1, 0 AD\n    utcBaseDate = new Date(Date.UTC(0, 0, 1)).setUTCFullYear(0);\n\nfunction date(d) {\n  return (tempDate.setTime(+d), tempDate);\n}\n\n// create a time unit entry\nfunction entry(type, date, unit, step, min, max) {\n  var e = {\n    type: type,\n    date: date,\n    unit: unit\n  };\n  if (step) {\n    e.step = step;\n  } else {\n    e.minstep = 1;\n  }\n  if (min != null) e.min = min;\n  if (max != null) e.max = max;\n  return e;\n}\n\nfunction create(type, unit, base, step, min, max) {\n  return entry(type,\n    function(d) { return unit.offset(base, d); },\n    function(d) { return unit.count(base, d); },\n    step, min, max);\n}\n\nvar locale = [\n  create('second', d3_time.second, baseDate),\n  create('minute', d3_time.minute, baseDate),\n  create('hour',   d3_time.hour,   baseDate),\n  create('day',    d3_time.day,    baseDate, [1, 7]),\n  create('month',  d3_time.month,  baseDate, [1, 3, 6]),\n  create('year',   d3_time.year,   baseDate),\n\n  // periodic units\n  entry('seconds',\n    function(d) { return new Date(1970, 0, 1, 0, 0, d); },\n    function(d) { return date(d).getSeconds(); },\n    null, 0, 59\n  ),\n  entry('minutes',\n    function(d) { return new Date(1970, 0, 1, 0, d); },\n    function(d) { return date(d).getMinutes(); },\n    null, 0, 59\n  ),\n  entry('hours',\n    function(d) { return new Date(1970, 0, 1, d); },\n    function(d) { return date(d).getHours(); },\n    null, 0, 23\n  ),\n  entry('weekdays',\n    function(d) { return new Date(1970, 0, 4+d); },\n    function(d) { return date(d).getDay(); },\n    [1], 0, 6\n  ),\n  entry('dates',\n    function(d) { return new Date(1970, 0, d); },\n    function(d) { return date(d).getDate(); },\n    [1], 1, 31\n  ),\n  entry('months',\n    function(d) { return new Date(1970, d % 12, 1); },\n    function(d) { return date(d).getMonth(); },\n    [1], 0, 11\n  )\n];\n\nvar utc = [\n  create('second', d3_time.utcSecond, utcBaseDate),\n  create('minute', d3_time.utcMinute, utcBaseDate),\n  create('hour',   d3_time.utcHour,   utcBaseDate),\n  create('day',    d3_time.utcDay,    utcBaseDate, [1, 7]),\n  create('month',  d3_time.utcMonth,  utcBaseDate, [1, 3, 6]),\n  create('year',   d3_time.utcYear,   utcBaseDate),\n\n  // periodic units\n  entry('seconds',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, 0, d)); },\n    function(d) { return date(d).getUTCSeconds(); },\n    null, 0, 59\n  ),\n  entry('minutes',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, d)); },\n    function(d) { return date(d).getUTCMinutes(); },\n    null, 0, 59\n  ),\n  entry('hours',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, d)); },\n    function(d) { return date(d).getUTCHours(); },\n    null, 0, 23\n  ),\n  entry('weekdays',\n    function(d) { return new Date(Date.UTC(1970, 0, 4+d)); },\n    function(d) { return date(d).getUTCDay(); },\n    [1], 0, 6\n  ),\n  entry('dates',\n    function(d) { return new Date(Date.UTC(1970, 0, d)); },\n    function(d) { return date(d).getUTCDate(); },\n    [1], 1, 31\n  ),\n  entry('months',\n    function(d) { return new Date(Date.UTC(1970, d % 12, 1)); },\n    function(d) { return date(d).getUTCMonth(); },\n    [1], 0, 11\n  )\n];\n\nvar STEPS = [\n  [31536e6, 5],  // 1-year\n  [7776e6, 4],   // 3-month\n  [2592e6, 4],   // 1-month\n  [12096e5, 3],  // 2-week\n  [6048e5, 3],   // 1-week\n  [1728e5, 3],   // 2-day\n  [864e5, 3],    // 1-day\n  [432e5, 2],    // 12-hour\n  [216e5, 2],    // 6-hour\n  [108e5, 2],    // 3-hour\n  [36e5, 2],     // 1-hour\n  [18e5, 1],     // 30-minute\n  [9e5, 1],      // 15-minute\n  [3e5, 1],      // 5-minute\n  [6e4, 1],      // 1-minute\n  [3e4, 0],      // 30-second\n  [15e3, 0],     // 15-second\n  [5e3, 0],      // 5-second\n  [1e3, 0]       // 1-second\n];\n\nfunction find(units, span, minb, maxb) {\n  var step = STEPS[0], i, n, bins;\n\n  for (i=1, n=STEPS.length; i<n; ++i) {\n    step = STEPS[i];\n    if (span > step[0]) {\n      bins = span / step[0];\n      if (bins > maxb) {\n        return units[STEPS[i-1][1]];\n      }\n      if (bins >= minb) {\n        return units[step[1]];\n      }\n    }\n  }\n  return units[STEPS[n-1][1]];\n}\n\nfunction toUnitMap(units) {\n  var map = {}, i, n;\n  for (i=0, n=units.length; i<n; ++i) {\n    map[units[i].type] = units[i];\n  }\n  map.find = function(span, minb, maxb) {\n    return find(units, span, minb, maxb);\n  };\n  return map;\n}\n\nmodule.exports = toUnitMap(locale);\nmodule.exports.utc = toUnitMap(utc);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/datalib/src/time.js\n ** module id = 47\n ** module chunks = 0\n **/","var bins = require('./bins'),\n    gen  = require('../generate'),\n    type = require('../import/type'),\n    util = require('../util'),\n    stats = require('../stats');\n\nvar qtype = {\n  'integer': 1,\n  'number': 1,\n  'date': 1\n};\n\nfunction $bin(values, f, opt) {\n  opt = options(values, f, opt);\n  var b = spec(opt);\n  return !b ? (opt.accessor || util.identity) :\n    util.$func('bin', b.unit.unit ?\n      function(x) { return b.value(b.unit.unit(x)); } :\n      function(x) { return b.value(x); }\n    )(opt.accessor);\n}\n\nfunction histogram(values, f, opt) {\n  opt = options(values, f, opt);\n  var b = spec(opt);\n  return b ?\n    numerical(values, opt.accessor, b) :\n    categorical(values, opt.accessor, opt && opt.sort);\n}\n\nfunction spec(opt) {\n  var t = opt.type, b = null;\n  if (t == null || qtype[t]) {\n    if (t === 'integer' && opt.minstep == null) opt.minstep = 1;\n    b = (t === 'date') ? bins.date(opt) : bins(opt);\n  }\n  return b;\n}\n\nfunction options() {\n  var a = arguments,\n      i = 0,\n      values = util.isArray(a[i]) ? a[i++] : null,\n      f = util.isFunction(a[i]) || util.isString(a[i]) ? util.$(a[i++]) : null,\n      opt = util.extend({}, a[i]);\n\n  if (values) {\n    opt.type = opt.type || type(values, f);\n    if (qtype[opt.type]) {\n      var ext = stats.extent(values, f);\n      opt = util.extend({min: ext[0], max: ext[1]}, opt);\n    }\n  }\n  if (f) { opt.accessor = f; }\n  return opt;\n}\n\nfunction numerical(values, f, b) {\n  var h = gen.range(b.start, b.stop + b.step/2, b.step)\n    .map(function(v) { return {value: b.value(v), count: 0}; });\n\n  for (var i=0, v, j; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      j = b.index(v);\n      if (j < 0 || j >= h.length || !isFinite(j)) continue;\n      h[j].count += 1;\n    }\n  }\n  h.bins = b;\n  return h;\n}\n\nfunction categorical(values, f, sort) {\n  var u = stats.unique(values, f),\n      c = stats.count.map(values, f);\n  return u.map(function(k) { return {value: k, count: c[k]}; })\n    .sort(util.comparator(sort ? '-count' : '+value'));\n}\n\nmodule.exports = {\n  $bin: $bin,\n  histogram: histogram\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/datalib/src/bins/histogram.js\n ** module id = 48\n ** module chunks = 0\n **/","var util = require('./util'),\n    format = require('./format');\n\nvar context = {\n  formats:    [],\n  format_map: {},\n  truncate:   util.truncate,\n  pad:        util.pad,\n  day:        format.day,\n  month:      format.month\n};\n\nfunction template(text) {\n  var src = source(text, 'd');\n  src = 'var __t; return ' + src + ';';\n\n  /* jshint evil: true */\n  return (new Function('d', src)).bind(context);\n}\n\ntemplate.source = source;\ntemplate.context = context;\ntemplate.format = get_format;\nmodule.exports = template;\n\n// Clear cache of format objects.\n// This can *break* prior template functions, so invoke with care!\ntemplate.clearFormatCache = function() {\n  context.formats = [];\n  context.format_map = {};\n};\n\n// Generate property access code for use within template source.\n// object: the name of the object (variable) containing template data\n// property: the property access string, verbatim from template tag\ntemplate.property = function(object, property) {\n  var src = util.field(property).map(util.str).join('][');\n  return object + '[' + src + ']';\n};\n\n// Generate source code for a template function.\n// text: the template text\n// variable: the name of the data object variable ('obj' by default)\n// properties: optional hash for collecting all accessed properties\nfunction source(text, variable, properties) {\n  variable = variable || 'obj';\n  var index = 0;\n  var src = '\\'';\n  var regex = template_re;\n\n  // Compile the template source, escaping string literals appropriately.\n  text.replace(regex, function(match, interpolate, offset) {\n    src += text\n      .slice(index, offset)\n      .replace(template_escaper, template_escapeChar);\n    index = offset + match.length;\n\n    if (interpolate) {\n      src += '\\'\\n+((__t=(' +\n        template_var(interpolate, variable, properties) +\n        '))==null?\\'\\':__t)+\\n\\'';\n    }\n\n    // Adobe VMs need the match returned to produce the correct offest.\n    return match;\n  });\n  return src + '\\'';\n}\n\nfunction template_var(text, variable, properties) {\n  var filters = text.match(filter_re);\n  var prop = filters.shift().trim();\n  var stringCast = true;\n\n  function strcall(fn) {\n    fn = fn || '';\n    if (stringCast) {\n      stringCast = false;\n      src = 'String(' + src + ')' + fn;\n    } else {\n      src += fn;\n    }\n    return src;\n  }\n\n  function date() {\n    return '(typeof ' + src + '===\"number\"?new Date('+src+'):'+src+')';\n  }\n\n  function formatter(type) {\n    var pattern = args[0];\n    if ((pattern[0] === '\\'' && pattern[pattern.length-1] === '\\'') ||\n        (pattern[0] === '\"'  && pattern[pattern.length-1] === '\"')) {\n      pattern = pattern.slice(1, -1);\n    } else {\n      throw Error('Format pattern must be quoted: ' + pattern);\n    }\n    a = template_format(pattern, type);\n    stringCast = false;\n    var arg = type === 'number' ? src : date();\n    src = 'this.formats['+a+']('+arg+')';\n  }\n\n  if (properties) properties[prop] = 1;\n  var src = template.property(variable, prop);\n\n  for (var i=0; i<filters.length; ++i) {\n    var f = filters[i], args = null, pidx, a, b;\n\n    if ((pidx=f.indexOf(':')) > 0) {\n      f = f.slice(0, pidx);\n      args = filters[i].slice(pidx+1)\n        .match(args_re)\n        .map(function(s) { return s.trim(); });\n    }\n    f = f.trim();\n\n    switch (f) {\n      case 'length':\n        strcall('.length');\n        break;\n      case 'lower':\n        strcall('.toLowerCase()');\n        break;\n      case 'upper':\n        strcall('.toUpperCase()');\n        break;\n      case 'lower-locale':\n        strcall('.toLocaleLowerCase()');\n        break;\n      case 'upper-locale':\n        strcall('.toLocaleUpperCase()');\n        break;\n      case 'trim':\n        strcall('.trim()');\n        break;\n      case 'left':\n        a = util.number(args[0]);\n        strcall('.slice(0,' + a + ')');\n        break;\n      case 'right':\n        a = util.number(args[0]);\n        strcall('.slice(-' + a +')');\n        break;\n      case 'mid':\n        a = util.number(args[0]);\n        b = a + util.number(args[1]);\n        strcall('.slice(+'+a+','+b+')');\n        break;\n      case 'slice':\n        a = util.number(args[0]);\n        strcall('.slice('+ a +\n          (args.length > 1 ? ',' + util.number(args[1]) : '') +\n          ')');\n        break;\n      case 'truncate':\n        a = util.number(args[0]);\n        b = args[1];\n        b = (b!=='left' && b!=='middle' && b!=='center') ? 'right' : b;\n        src = 'this.truncate(' + strcall() + ',' + a + ',\\'' + b + '\\')';\n        break;\n      case 'pad':\n        a = util.number(args[0]);\n        b = args[1];\n        b = (b!=='left' && b!=='middle' && b!=='center') ? 'right' : b;\n        src = 'this.pad(' + strcall() + ',' + a + ',\\'' + b + '\\')';\n        break;\n      case 'number':\n        formatter('number');\n        break;\n      case 'time':\n        formatter('time');\n        break;\n      case 'time-utc':\n        formatter('utc');\n        break;\n      case 'month':\n        src = 'this.month(' + src + ')';\n        break;\n      case 'month-abbrev':\n        src = 'this.month(' + src + ',true)';\n        break;\n      case 'day':\n        src = 'this.day(' + src + ')';\n        break;\n      case 'day-abbrev':\n        src = 'this.day(' + src + ',true)';\n        break;\n      default:\n        throw Error('Unrecognized template filter: ' + f);\n    }\n  }\n\n  return src;\n}\n\nvar template_re = /\\{\\{(.+?)\\}\\}|$/g,\n    filter_re = /(?:\"[^\"]*\"|\\'[^\\']*\\'|[^\\|\"]+|[^\\|\\']+)+/g,\n    args_re = /(?:\"[^\"]*\"|\\'[^\\']*\\'|[^,\"]+|[^,\\']+)+/g;\n\n// Certain characters need to be escaped so that they can be put into a\n// string literal.\nvar template_escapes = {\n  '\\'':     '\\'',\n  '\\\\':     '\\\\',\n  '\\r':     'r',\n  '\\n':     'n',\n  '\\u2028': 'u2028',\n  '\\u2029': 'u2029'\n};\n\nvar template_escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\nfunction template_escapeChar(match) {\n  return '\\\\' + template_escapes[match];\n}\n\nfunction template_format(pattern, type) {\n  var key = type + ':' + pattern;\n  if (context.format_map[key] == null) {\n    var f = format[type](pattern);\n    var i = context.formats.length;\n    context.formats.push(f);\n    context.format_map[key] = i;\n    return i;\n  }\n  return context.format_map[key];\n}\n\nfunction get_format(pattern, type) {\n  return context.formats[template_format(pattern, type)];\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/datalib/src/template.js\n ** module id = 49\n ** module chunks = 0\n **/","var util = require('./util'),\n    time = require('./time'),\n    utc = time.utc;\n\nvar u = module.exports;\n\nu.$year   = util.$func('year', time.year.unit);\nu.$month  = util.$func('month', time.months.unit);\nu.$date   = util.$func('date', time.dates.unit);\nu.$day    = util.$func('day', time.weekdays.unit);\nu.$hour   = util.$func('hour', time.hours.unit);\nu.$minute = util.$func('minute', time.minutes.unit);\nu.$second = util.$func('second', time.seconds.unit);\n\nu.$utcYear   = util.$func('utcYear', utc.year.unit);\nu.$utcMonth  = util.$func('utcMonth', utc.months.unit);\nu.$utcDate   = util.$func('utcDate', utc.dates.unit);\nu.$utcDay    = util.$func('utcDay', utc.weekdays.unit);\nu.$utcHour   = util.$func('utcHour', utc.hours.unit);\nu.$utcMinute = util.$func('utcMinute', utc.minutes.unit);\nu.$utcSecond = util.$func('utcSecond', utc.seconds.unit);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/datalib/src/accessor.js\n ** module id = 50\n ** module chunks = 0\n **/","var util = require('../util');\nvar load = require('./load');\nvar read = require('./read');\n\nmodule.exports = util\n  .keys(read.formats)\n  .reduce(function(out, type) {\n    out[type] = function(opt, format, callback) {\n      // process arguments\n      if (util.isString(opt)) { opt = {url: opt}; }\n      if (arguments.length === 2 && util.isFunction(format)) {\n        callback = format;\n        format = undefined;\n      }\n\n      // set up read format\n      format = util.extend({parse: 'auto'}, format);\n      format.type = type;\n\n      // load data\n      var data = load(opt, callback ? function(error, data) {\n        if (error) { callback(error, null); return; }\n        try {\n          // data loaded, now parse it (async)\n          data = read(data, format);\n          callback(null, data);\n        } catch (e) {\n          callback(e, null);\n        }\n      } : undefined);\n\n      // data loaded, now parse it (sync)\n      if (!callback) return read(data, format);\n    };\n    return out;\n  }, {});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/datalib/src/import/readers.js\n ** module id = 51\n ** module chunks = 0\n **/","var util = require('./util'),\n    type = require('./import/type'),\n    stats = require('./stats'),\n    template = require('./template');\n\nmodule.exports = {\n  table:   formatTable,  // format a data table\n  summary: formatSummary // format a data table summary\n};\n\nvar FMT = {\n  'date':    '|time:\"%m/%d/%Y %H:%M:%S\"',\n  'number':  '|number:\".4f\"',\n  'integer': '|number:\"d\"'\n};\n\nvar POS = {\n  'number':  'left',\n  'integer': 'left'\n};\n\nfunction formatTable(data, opt) {\n  opt = util.extend({separator:' ', minwidth: 8, maxwidth: 15}, opt);\n  var fields = opt.fields || util.keys(data[0]),\n      types = type.all(data);\n\n  if (opt.start || opt.limit) {\n    var a = opt.start || 0,\n        b = opt.limit ? a + opt.limit : data.length;\n    data = data.slice(a, b);\n  }\n\n  // determine char width of fields\n  var lens = fields.map(function(name) {\n    var format = FMT[types[name]] || '',\n        t = template('{{' + name + format + '}}'),\n        l = stats.max(data, function(x) { return t(x).length; });\n    l = Math.max(Math.min(name.length, opt.minwidth), l);\n    return opt.maxwidth > 0 ? Math.min(l, opt.maxwidth) : l;\n  });\n\n  // print header row\n  var head = fields.map(function(name, i) {\n    return util.truncate(util.pad(name, lens[i], 'center'), lens[i]);\n  }).join(opt.separator);\n\n  // build template function for each row\n  var tmpl = template(fields.map(function(name, i) {\n    return '{{' +\n      name +\n      (FMT[types[name]] || '') +\n      ('|pad:' + lens[i] + ',' + (POS[types[name]] || 'right')) +\n      ('|truncate:' + lens[i]) +\n    '}}';\n  }).join(opt.separator));\n\n  // print table\n  return head + \"\\n\" + data.map(tmpl).join('\\n');\n}\n\nfunction formatSummary(s) {\n  s = s ? s.__summary__ ? s : stats.summary(s) : this;\n  var str = [], i, n;\n  for (i=0, n=s.length; i<n; ++i) {\n    str.push('-- ' + s[i].field + ' --');\n    if (s[i].type === 'string' || s[i].distinct < 10) {\n      str.push(printCategoricalProfile(s[i]));\n    } else {\n      str.push(printQuantitativeProfile(s[i]));\n    }\n    str.push('');\n  }\n  return str.join('\\n');\n}\n\nfunction printQuantitativeProfile(p) {\n  return [\n    'valid:    ' + p.valid,\n    'missing:  ' + p.missing,\n    'distinct: ' + p.distinct,\n    'min:      ' + p.min,\n    'max:      ' + p.max,\n    'median:   ' + p.median,\n    'mean:     ' + p.mean,\n    'stdev:    ' + p.stdev,\n    'modeskew: ' + p.modeskew\n  ].join('\\n');\n}\n\nfunction printCategoricalProfile(p) {\n  var list = [\n    'valid:    ' + p.valid,\n    'missing:  ' + p.missing,\n    'distinct: ' + p.distinct,\n    'top values: '\n  ];\n  var u = p.unique;\n  var top = util.keys(u)\n    .sort(function(a,b) { return u[b] - u[a]; })\n    .slice(0, 6)\n    .map(function(v) { return ' \\'' + v + '\\' (' + u[v] + ')'; });\n  return list.concat(top).join('\\n');\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/datalib/src/format-tables.js\n ** module id = 52\n ** module chunks = 0\n **/","var dl = require('datalib'),\n    log = require('vega-logging'),\n    Heap = require('./Heap'),\n    ChangeSet = require('./ChangeSet'),\n    DataSource = require('./DataSource'),\n    Collector = require('./Collector'),\n    Tuple = require('./Tuple'),\n    Signal = require('./Signal'),\n    Deps = require('./Dependencies');\n\nfunction Graph() {\n}\n\nvar prototype = Graph.prototype;\n\nprototype.init = function() {\n  this._stamp = 0;\n  this._rank  = 0;\n\n  this._data = {};\n  this._signals = {};\n  this._requestedIndexes = {};\n\n  this.doNotPropagate = {};\n};\n\nprototype.rank = function() {\n  return ++this._rank;\n};\n\nprototype.values = function(type, names, hash) {\n  var data = (type === Deps.SIGNALS ? this._signals : this._data),\n      n = (names !== undefined ? names : dl.keys(data)),\n      vals, i;\n\n  if (Array.isArray(n)) {\n    vals = hash || {};\n    for (i=0; i<n.length; ++i) {\n      vals[n[i]] = data[n[i]].values();\n    }\n    return vals;\n  } else {\n    return data[n].values();\n  }\n};\n\n// Retain for backwards-compatibility\nprototype.dataValues = function(names) {\n  return this.values(Deps.DATA, names);\n};\n\n// Retain for backwards-compatibility\nprototype.signalValues = function(names) {\n  return this.values(Deps.SIGNALS, names);\n};\n\nprototype.data = function(name, pipeline, facet) {\n  var db = this._data;\n  if (!arguments.length) {\n    var all = [], key;\n    for (key in db) { all.push(db[key]); }\n    return all;\n  } else if (arguments.length === 1) {\n    return db[name];\n  } else {\n    return (db[name] = new DataSource(this, name, facet).pipeline(pipeline));\n  }\n};\n\nprototype.signal = function(name, init) {\n  if (arguments.length === 1) {\n    var m = this;\n    return Array.isArray(name) ?\n      name.map(function(n) { return m._signals[n]; }) :\n      this._signals[name];\n  } else {\n    return (this._signals[name] = new Signal(this, name, init));\n  }\n};\n\nprototype.signalRef = function(ref) {\n  if (!Array.isArray(ref)) {\n    ref = dl.field(ref);\n  }\n\n  var value = this.signal(ref[0]).value();\n  if (ref.length > 1) {\n    for (var i=1, n=ref.length; i<n; ++i) {\n      value = value[ref[i]];\n    }\n  }\n  return value;\n};\n\nprototype.requestIndex = function(data, field) {\n  var ri  = this._requestedIndexes,\n      reg = ri[data] || (ri[data] = {}); \n  return (reg[field] = true, this);\n};\n\nprototype.buildIndexes = function() {\n  var ri = this._requestedIndexes,\n      data = dl.keys(ri),\n      i, len, j, jlen, d, src, fields, f;\n\n  for (i=0, len=data.length; i<len; ++i) {\n    src = this.data(d=data[i]);\n    if (!src) throw Error('Data source '+dl.str(d)+' does not exist.');\n\n    fields = dl.keys(ri[d]);\n    for (j=0, jlen=fields.length; j<jlen; ++j) {\n      if ((f=fields[j]) === null) continue;\n      src.getIndex(f);\n      ri[d][f] = null;\n    }\n  }\n\n  return this;\n};\n\n// Stamp should be specified with caution. It is necessary for inline datasources,\n// which need to be populated during the same cycle even though propagation has\n// passed that part of the dataflow graph. \n// If skipSignals is true, Signal nodes do not get reevaluated but their listeners\n// are queued for propagation. This is useful when setting signal values in batch\n// (e.g., time travel to the initial state).\nprototype.propagate = function(pulse, node, stamp, skipSignals) {\n  var pulses = {},\n      listeners, next, nplse, tpls, ntpls, i, len, isSg;\n\n  // new PQ with each propagation cycle so that we can pulse branches\n  // of the dataflow graph during a propagation (e.g., when creating\n  // a new inline datasource).\n  var pq = new Heap(function(a, b) {\n    // Sort on qrank (queue-rank).\n    // Rank can change during propagation due to rewiring.\n    return a._qrank - b._qrank;\n  });\n\n  if (pulse.stamp) throw Error('Pulse already has a non-zero stamp.');\n\n  pulse.stamp = stamp || ++this._stamp;\n  pulses[node._id] = pulse;\n  pq.push(node.qrank(true));\n\n  while (pq.size() > 0) {\n    node  = pq.peek();\n    isSg  = node instanceof Signal;\n    pulse = pulses[node._id];\n\n    if (node.rank() !== node.qrank()) {\n      // A node's rank might change during a propagation. Re-queue if so.\n      pq.replace(node.qrank(true));\n    } else {\n      // Evaluate node and propagate pulse.\n      pq.pop();\n      pulses[node._id] = null;\n      listeners = node._listeners;\n\n      if (!isSg || (isSg && !skipSignals)) {\n        pulse = this.evaluate(pulse, node);\n      }\n\n      // Propagate the pulse.\n      if (pulse !== this.doNotPropagate) {\n        // Ensure reflow pulses always send reflow pulses even if skipped.\n        if (!pulse.reflow && node.reflows()) {\n          pulse = ChangeSet.create(pulse, true);\n        }\n\n        for (i=0, len=listeners.length; i<len; ++i) {\n          next = listeners[i];\n\n          if ((nplse = pulses[next._id]) !== undefined) {\n            if (nplse === null) throw Error('Already propagated to node.');\n            if (nplse === pulse) continue;  // Re-queueing the same pulse.\n\n            // We've already queued this node. Ensure there should be at most one\n            // pulse with tuples (add/mod/rem), and the remainder will be reflows.\n            tpls  = pulse.add.length || pulse.mod.length || pulse.rem.length;\n            ntpls = nplse.add.length || nplse.mod.length || nplse.rem.length;\n\n            if (tpls && ntpls) throw Error('Multiple changeset pulses to same node');\n\n            // Combine reflow and tuples into a single pulse.\n            pulses[next._id] = tpls ? pulse : nplse;\n            pulses[next._id].reflow = pulse.reflow || nplse.reflow;\n          } else {\n            // First time we're seeing this node, queue it for propagation.\n            pq.push(next.qrank(true));\n            pulses[next._id] = pulse;\n          }\n        }\n      }\n    }\n  }\n\n  return this.done(pulse);\n};\n\n// Perform final bookkeeping on the graph, after propagation is complete.\n//  - For all updated datasources, synchronize their previous values.\nprototype.done = function(pulse) {\n  log.debug(pulse, ['bookkeeping']);\n  for (var d in pulse.data) { this.data(d).synchronize(); }\n  return this;\n};\n\n// Process a new branch of the dataflow graph prior to connection:\n// (1) Insert new Collector nodes as needed.\n// (2) Track + return mutation/routing status of the branch.\nprototype.preprocess = function(branch) {\n  var graph = this,\n      mutates = 0,\n      node, router, collector, collects;\n\n  for (var i=0; i<branch.length; ++i) {\n    node = branch[i];\n\n    // Batch nodes need access to a materialized dataset.\n    if (node.batch() && !node._collector) {\n      if (router || !collector) {\n        node = new Collector(graph);\n        branch.splice(i, 0, node);\n        router = false;\n      } else {\n        node._collector = collector;\n      }\n    }\n\n    if ((collects = node.collector())) collector = node;\n    router  = router  || node.router() && !collects;\n    mutates = mutates || node.mutates();\n\n    // A collector needs to be inserted after tuple-producing\n    // nodes for correct previous value tracking.\n    if (node.produces()) {\n      branch.splice(i+1, 0, new Collector(graph));\n      router = false;\n    }\n  }\n\n  return {router: router, collector: collector, mutates: mutates};\n};\n\nprototype.connect = function(branch) {\n  var collector, node, data, signals, i, n, j, m, x, y;\n\n  // connect the pipeline\n  for (i=0, n=branch.length; i<n; ++i) {\n    node = branch[i];\n    if (node.collector()) collector = node;\n\n    data = node.dependency(Deps.DATA);\n    for (j=0, m=data.length; j<m; ++j) {\n      if (!(x=this.data(y=data[j]))) {\n        throw new Error('Unknown data source ' + dl.str(y));\n      }\n\n      x.addListener(collector);\n    }\n\n    signals = node.dependency(Deps.SIGNALS);\n    for (j=0, m=signals.length; j<m; ++j) {\n      if (!(x=this.signal(y=signals[j]))) {\n        throw new Error('Unknown signal ' + dl.str(y));\n      }\n\n      x.addListener(collector);\n    }\n\n    if (i > 0) branch[i-1].addListener(node);\n  }\n\n  return branch;\n};\n\nprototype.disconnect = function(branch) {\n  var collector, node, data, signals, i, n, j, m;\n\n  for (i=0, n=branch.length; i<n; ++i) {\n    node = branch[i];\n    if (node.collector()) collector = node;\n\n    data = node.dependency(Deps.DATA);\n    for (j=0, m=data.length; j<m; ++j) {\n      this.data(data[j]).removeListener(collector);\n    }\n\n    signals = node.dependency(Deps.SIGNALS);\n    for (j=0, m=signals.length; j<m; ++j) {\n      this.signal(signals[j]).removeListener(collector);\n    }\n\n    node.disconnect();\n  }\n\n  return branch;\n};\n\nprototype.synchronize = function(branch) {\n  var ids = {},\n      node, data, i, n, j, m, d, id;\n\n  for (i=0, n=branch.length; i<n; ++i) {\n    node = branch[i];\n    if (!node.collector()) continue;\n\n    for (j=0, data=node.data(), m=data.length; j<m; ++j) {\n      id = (d = data[j])._id;\n      if (ids[id]) continue;\n      Tuple.prev_update(d);\n      ids[id] = 1;\n    }\n  }\n\n  return this;\n};\n\nprototype.reevaluate = function(pulse, node) {\n  var reflowed = pulse.reflow && node.last() >= pulse.stamp,\n      run = node.router() || pulse.add.length || pulse.rem.length;\n\n  return run || !reflowed || node.reevaluate(pulse);\n};\n\nprototype.evaluate = function(pulse, node) {\n  if (!this.reevaluate(pulse, node)) return pulse;\n  pulse = node.evaluate(pulse);\n  node.last(pulse.stamp);\n  return pulse;\n};\n\nmodule.exports = Graph;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-dataflow/src/Graph.js\n ** module id = 53\n ** module chunks = 0\n **/","function Heap(comparator) {\n  this.cmp = comparator;\n  this.nodes = [];\n}\n\nvar prototype = Heap.prototype;\n\nprototype.size = function() {\n  return this.nodes.length;\n};\n\nprototype.clear = function() {\n  return (this.nodes = [], this);\n};\n\nprototype.peek = function() {\n  return this.nodes[0];\n};\n\nprototype.push = function(x) {\n  var array = this.nodes;\n  array.push(x);\n  return _siftdown(array, 0, array.length-1, this.cmp);\n};\n\nprototype.pop = function() {\n  var array = this.nodes,\n      last = array.pop(),\n      item;\n\n  if (array.length) {\n    item = array[0];\n    array[0] = last;\n    _siftup(array, 0, this.cmp);\n  } else {\n    item = last;\n  }\n  return item;\n};\n\nprototype.replace = function(item) {\n  var array = this.nodes,\n      retval = array[0];\n  array[0] = item;\n  _siftup(array, 0, this.cmp);\n  return retval;\n};\n\nprototype.pushpop = function(item) {\n  var array = this.nodes, ref = array[0];\n  if (array.length && this.cmp(ref, item) < 0) {\n    array[0] = item;\n    item = ref;\n    _siftup(array, 0, this.cmp);\n  }\n  return item;\n};\n\nfunction _siftdown(array, start, idx, cmp) {\n  var item, parent, pidx;\n\n  item = array[idx];\n  while (idx > start) {\n    pidx = (idx - 1) >> 1;\n    parent = array[pidx];\n    if (cmp(item, parent) < 0) {\n      array[idx] = parent;\n      idx = pidx;\n      continue;\n    }\n    break;\n  }\n  return (array[idx] = item);\n}\n\nfunction _siftup(array, idx, cmp) {\n  var start = idx,\n      end = array.length,\n      item = array[idx],\n      cidx = 2 * idx + 1, ridx;\n\n  while (cidx < end) {\n    ridx = cidx + 1;\n    if (ridx < end && cmp(array[cidx], array[ridx]) >= 0) {\n      cidx = ridx;\n    }\n    array[idx] = array[cidx];\n    idx = cidx;\n    cidx = 2 * idx + 1;\n  }\n  array[idx] = item;\n  return _siftdown(array, start, idx, cmp);\n}\n\nmodule.exports = Heap;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-dataflow/src/Heap.js\n ** module id = 54\n ** module chunks = 0\n **/","var ChangeSet = require('./ChangeSet'),\n    Node = require('./Node'), // jshint ignore:line\n    Base = Node.prototype;\n\nfunction Signal(graph, name, initialValue) {\n  Base.init.call(this, graph);\n  this._name  = name;\n  this._value = initialValue;\n  this._verbose = false; // Verbose signals re-pulse the graph even if prev === val.\n  this._handlers = [];\n  return this;\n}\n\nvar prototype = (Signal.prototype = Object.create(Base));\nprototype.constructor = Signal;\n\nprototype.name = function() {\n  return this._name;\n};\n\nprototype.value = function(val) {\n  if (!arguments.length) return this._value;\n  return (this._value = val, this);\n};\n\n// Alias to value, for shared API with DataSource\nprototype.values = prototype.value;\n\nprototype.verbose = function(v) {\n  if (!arguments.length) return this._verbose;\n  return (this._verbose = !!v, this);\n};\n\nprototype.evaluate = function(input) {\n  return input.signals[this._name] ? input : this._graph.doNotPropagate;\n};\n\nprototype.fire = function(cs) {\n  if (!cs) cs = ChangeSet.create(null, true);\n  cs.signals[this._name] = 1;\n  this._graph.propagate(cs, this);\n};\n\nprototype.on = function(handler) {\n  var signal = this,\n      node = new Node(this._graph);\n\n  node.evaluate = function(input) {\n    handler(signal.name(), signal.value());\n    return input;\n  };\n\n  this._handlers.push({\n    handler: handler,\n    node: node\n  });\n\n  return this.addListener(node);\n};\n\nprototype.off = function(handler) {\n  var h = this._handlers, i, x;\n\n  for (i=h.length; --i>=0;) {\n    if (!handler || h[i].handler === handler) {\n      x = h.splice(i, 1)[0];\n      this.removeListener(x.node);\n    }\n  }\n\n  return this;\n};\n\nmodule.exports = Signal;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-dataflow/src/Signal.js\n ** module id = 55\n ** module chunks = 0\n **/","module.exports = {\n  axes:       require('./axes'),\n  background: require('./background'),\n  data:       require('./data'),\n  events:     require('vega-event-selector'),\n  expr:       require('./expr'),\n  legends:    require('./legends'),\n  mark:       require('./mark'),\n  marks:      require('./marks'),\n  modify:     require('./modify'),\n  padding:    require('./padding'),\n  predicates: require('./predicates'),\n  properties: require('./properties'),\n  signals:    require('./signals'),\n  spec:       require('./spec'),\n  streams:    require('./streams'),\n  transforms: require('./transforms')\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/parse/index.js\n ** module id = 56\n ** module chunks = 0\n **/","var dl = require('datalib'),\n    axs = require('../scene/axis');\n\nvar ORIENT = {\n  \"x\":      \"bottom\",\n  \"y\":      \"left\",\n  \"top\":    \"top\",\n  \"bottom\": \"bottom\",\n  \"left\":   \"left\",\n  \"right\":  \"right\"\n};\n\nfunction parseAxes(model, spec, axes, group) {\n  var config = model.config();\n  (spec || []).forEach(function(def, index) {\n    axes[index] = axes[index] || axs(model);\n    parseAxis(config, def, index, axes[index], group);\n  });\n}\n\nfunction parseAxis(config, def, index, axis, group) {\n  // axis scale\n  if (def.scale !== undefined) {\n    axis.scale(group.scale(def.scale));\n  }\n\n  // axis orientation\n  axis.orient(def.orient || ORIENT[def.type]);\n  // axis offset\n  axis.offset(def.offset || 0);\n  // axis layer\n  axis.layer(def.layer || \"front\");\n  // axis grid lines\n  axis.grid(def.grid || false);\n  // axis title\n  axis.title(def.title || null);\n  // axis title offset\n  axis.titleOffset(def.titleOffset != null ?\n    def.titleOffset : config.axis.titleOffset);\n  // axis values\n  axis.tickValues(def.values || null);\n  // axis label formatting\n  axis.tickFormat(def.format || null);\n  axis.tickFormatType(def.formatType || null);\n  // axis tick subdivision\n  axis.tickSubdivide(def.subdivide || 0);\n  // axis tick padding\n  axis.tickPadding(def.tickPadding || config.axis.padding);\n\n  // axis tick size(s)\n  var size = [];\n  if (def.tickSize !== undefined) {\n    for (var i=0; i<3; ++i) size.push(def.tickSize);\n  } else {\n    var ts = config.axis.tickSize;\n    size = [ts, ts, ts];\n  }\n  if (def.tickSizeMajor != null) size[0] = def.tickSizeMajor;\n  if (def.tickSizeMinor != null) size[1] = def.tickSizeMinor;\n  if (def.tickSizeEnd   != null) size[2] = def.tickSizeEnd;\n  if (size.length) {\n    axis.tickSize.apply(axis, size);\n  }\n\n  // axis tick count\n  axis.tickCount(def.ticks || config.axis.ticks);\n\n  // style properties\n  var p = def.properties;\n  if (p && p.ticks) {\n    axis.majorTickProperties(p.majorTicks ?\n      dl.extend({}, p.ticks, p.majorTicks) : p.ticks);\n    axis.minorTickProperties(p.minorTicks ?\n      dl.extend({}, p.ticks, p.minorTicks) : p.ticks);\n  } else {\n    axis.majorTickProperties(p && p.majorTicks || {});\n    axis.minorTickProperties(p && p.minorTicks || {});\n  }\n  axis.tickLabelProperties(p && p.labels || {});\n  axis.titleProperties(p && p.title || {});\n  axis.gridLineProperties(p && p.grid || {});\n  axis.domainProperties(p && p.axis || {});\n}\n\nmodule.exports = parseAxes;\n\nparseAxes.schema = {\n  \"defs\": {\n    \"axis\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"type\": {\"enum\": [\"x\", \"y\"]},\n        \"scale\": {\"type\": \"string\"},\n        \"orient\": {\"enum\": [\"top\", \"bottom\", \"left\", \"right\"]},\n        \"title\": {\"type\": \"string\"},\n        \"titleOffset\": {\"type\": \"number\"},\n        \"format\": {\"type\": \"string\"},\n        \"formatType\": {\"enum\": [\"time\", \"utc\", \"string\", \"number\"]},\n        \"ticks\": {\"type\": \"number\"},\n        \"values\": {\n          \"type\": \"array\",\n          \"items\": {\"type\": [\"string\", \"number\"]}\n        },\n        \"subdivide\": {\"type\": \"number\"},\n        \"tickPadding\": {\"type\": \"number\"},\n        \"tickSize\": {\"type\": \"number\"},\n        \"tickSizeMajor\": {\"type\": \"number\"},\n        \"tickSizeMinor\": {\"type\": \"number\"},\n        \"tickSizeEnd\": {\"type\": \"number\"},\n        \"offset\": {\n          \"oneOf\": [{\"type\": \"number\"}, {\n            \"type\": \"object\",\n            \"properties\": {\n              \"scale\": {\"type\": \"string\"},\n              \"value\": {\"type\": [\"string\", \"number\"]}\n            },\n            \"required\": [\"scale\", \"value\"],\n            \"additionalProperties\": false\n          }]\n        },\n        \"layer\": {\"enum\": [\"front\", \"back\"], \"default\": \"front\"},\n        \"grid\": {\"type\": \"boolean\"},\n        \"properties\": {\n          \"type\": \"object\",\n          \"properties\": {\n            \"ticks\": {\"$ref\": \"#/defs/propset\"},\n            \"majorTicks\": {\"$ref\": \"#/defs/propset\"},\n            \"minorTicks\": {\"$ref\": \"#/defs/propset\"},\n            \"labels\": {\"$ref\": \"#/defs/propset\"},\n            \"title\": {\"$ref\": \"#/defs/propset\"},\n            \"grid\": {\"$ref\": \"#/defs/propset\"},\n            \"axis\": {\"$ref\": \"#/defs/propset\"}\n          },\n          \"additionalProperties\": false\n        }\n      },\n      \"additionalProperties\": false,\n      \"required\": [\"type\", \"scale\"]\n    }\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/parse/axes.js\n ** module id = 57\n ** module chunks = 0\n **/","var dl = require('datalib'),\n    Tuple = require('vega-dataflow').Tuple,\n    parseMark = require('../parse/mark'),\n    util = require('../util');\n\nvar axisBounds = new (require('vega-scenegraph').Bounds)();\nvar ORDINAL = 'ordinal';\n\nfunction axs(model) {\n  var scale,\n      config = model.config().axis,\n      orient = config.orient,\n      offset = 0,\n      titleOffset = config.titleOffset,\n      axisDef = {},\n      layer = 'front',\n      grid = false,\n      title = null,\n      tickMajorSize = config.tickSize,\n      tickMinorSize = config.tickSize,\n      tickEndSize = config.tickSize,\n      tickPadding = config.padding,\n      tickValues = null,\n      tickFormatString = null,\n      tickFormatType = null,\n      tickSubdivide = 0,\n      tickCount = config.ticks,\n      gridLineStyle = {},\n      tickLabelStyle = {},\n      majorTickStyle = {},\n      minorTickStyle = {},\n      titleStyle = {},\n      domainStyle = {},\n      m = { // Axis marks as references for updates\n        gridLines:  {},\n        majorTicks: {},\n        minorTicks: {},\n        tickLabels: {},\n        domain: {},\n        title:  {}\n      };\n\n  var axis = {};\n\n  function reset() {\n    axisDef.type = null;\n  }\n\n  function ingest(d) {\n    return {data: d};\n  }\n\n  function getTicks(format) {\n    var major = tickValues || (scale.ticks ? scale.ticks(tickCount) : scale.domain()),\n        minor = axisSubdivide(scale, major, tickSubdivide).map(ingest);\n    major = major.map(function(d) { return (d = ingest(d), d.label = format(d.data), d); });\n    return [major, minor];\n  }\n\n  axis.def = function() {\n    if (!axisDef.type) axis_def(scale);\n\n    var format = util.getTickFormat(scale, tickCount, tickFormatType, tickFormatString),\n        ticks  = getTicks(format),\n        tdata  = title ? [title].map(ingest) : [];\n\n    axisDef.marks[0].from = function() { return grid ? ticks[0] : []; };\n    axisDef.marks[1].from = function() { return ticks[0]; };\n    axisDef.marks[2].from = function() { return ticks[1]; };\n    axisDef.marks[3].from = axisDef.marks[1].from;\n    axisDef.marks[4].from = function() { return [1]; };\n    axisDef.marks[5].from = function() { return tdata; };\n    axisDef.offset = offset;\n    axisDef.orient = orient;\n    axisDef.layer = layer;\n    if (titleOffset === 'auto') titleAutoOffset(axisDef);\n\n    return axisDef;\n  };\n\n  function titleAutoOffset(axisDef) {\n    var orient = axisDef.orient,\n        update = axisDef.marks[5].properties.update,\n        fn = update.encode,\n        min = config.titleOffsetAutoMin,\n        max = config.titleOffsetAutoMax,\n        pad = config.titleOffsetAutoMargin;\n\n    // Offset axis title using bounding box of axis domain and labels\n    // Assumes other components are **encoded and bounded** beforehand\n    update.encode = function(item, group, trans, db, signals, preds) {\n      var dirty = fn.call(fn, item, group, trans, db, signals, preds),\n          field = (orient==='bottom' || orient==='top') ? 'y' : 'x';\n      if (titleStyle[field] != null) return dirty;\n\n      axisBounds.clear()\n        .union(group.items[3].bounds)\n        .union(group.items[4].bounds);\n\n      var o = trans ? {} : item,\n          method = (orient==='left' || orient==='right') ? 'width' : 'height',\n          sign = (orient==='top' || orient==='left') ? -1 : 1,\n          off = ~~(axisBounds[method]() + item.fontSize/2 + pad);\n\n      Tuple.set(o, field, sign * Math.min(Math.max(min, off), max));\n      if (trans) trans.interpolate(item, o);\n      return true;\n    };\n  }\n\n  function axis_def(scale) {\n    // setup scale mapping\n    var newScale, oldScale, range;\n    if (scale.type === ORDINAL) {\n      newScale = {scale: scale.scaleName, offset: 0.5 + scale.rangeBand()/2};\n      oldScale = newScale;\n    } else {\n      newScale = {scale: scale.scaleName, offset: 0.5};\n      oldScale = {scale: scale.scaleName+':prev', offset: 0.5};\n    }\n    range = axisScaleRange(scale);\n\n    // setup axis marks\n    dl.extend(m.gridLines, axisTicks(config));\n    dl.extend(m.majorTicks, axisTicks(config));\n    dl.extend(m.minorTicks, axisTicks(config));\n    dl.extend(m.tickLabels, axisTickLabels(config));\n    dl.extend(m.domain, axisDomain(config));\n    dl.extend(m.title, axisTitle(config));\n    m.gridLines.properties.enter.stroke = {value: config.gridColor};\n    m.gridLines.properties.enter.strokeOpacity = {value: config.gridOpacity};\n\n    // extend axis marks based on axis orientation\n    axisTicksExtend(orient, m.gridLines, oldScale, newScale, Infinity, offset);\n    axisTicksExtend(orient, m.majorTicks, oldScale, newScale, tickMajorSize);\n    axisTicksExtend(orient, m.minorTicks, oldScale, newScale, tickMinorSize);\n    axisLabelExtend(orient, m.tickLabels, oldScale, newScale, tickMajorSize, tickPadding);\n\n    axisDomainExtend(orient, m.domain, range, tickEndSize);\n    axisTitleExtend(orient, m.title, range, +titleOffset || -1);\n\n    // add / override custom style properties\n    dl.extend(m.gridLines.properties.update, gridLineStyle);\n    dl.extend(m.majorTicks.properties.update, majorTickStyle);\n    dl.extend(m.minorTicks.properties.update, minorTickStyle);\n    dl.extend(m.tickLabels.properties.update, tickLabelStyle);\n    dl.extend(m.domain.properties.update, domainStyle);\n    dl.extend(m.title.properties.update, titleStyle);\n\n    var marks = [m.gridLines, m.majorTicks, m.minorTicks, m.tickLabels, m.domain, m.title];\n    dl.extend(axisDef, {\n      type: 'group',\n      interactive: false,\n      properties: {\n        enter: {\n          encode: axisUpdate,\n          scales: [scale.scaleName],\n          signals: [], data: []\n        },\n        update: {\n          encode: axisUpdate,\n          scales: [scale.scaleName],\n          signals: [], data: []\n        }\n      }\n    });\n\n    axisDef.marks = marks.map(function(m) { return parseMark(model, m); });\n  }\n\n  axis.scale = function(x) {\n    if (!arguments.length) return scale;\n    if (scale !== x) { scale = x; reset(); }\n    return axis;\n  };\n\n  axis.orient = function(x) {\n    if (!arguments.length) return orient;\n    if (orient !== x) {\n      orient = x in axisOrients ? x + '' : config.orient;\n      reset();\n    }\n    return axis;\n  };\n\n  axis.title = function(x) {\n    if (!arguments.length) return title;\n    if (title !== x) { title = x; reset(); }\n    return axis;\n  };\n\n  axis.tickCount = function(x) {\n    if (!arguments.length) return tickCount;\n    tickCount = x;\n    return axis;\n  };\n\n  axis.tickValues = function(x) {\n    if (!arguments.length) return tickValues;\n    tickValues = x;\n    return axis;\n  };\n\n  axis.tickFormat = function(x) {\n    if (!arguments.length) return tickFormatString;\n    if (tickFormatString !== x) {\n      tickFormatString = x;\n      reset();\n    }\n    return axis;\n  };\n\n  axis.tickFormatType = function(x) {\n    if (!arguments.length) return tickFormatType;\n    if (tickFormatType !== x) {\n      tickFormatType = x;\n      reset();\n    }\n    return axis;\n  };\n\n  axis.tickSize = function(x, y) {\n    if (!arguments.length) return tickMajorSize;\n    var n = arguments.length - 1,\n        major = +x,\n        minor = n > 1 ? +y : tickMajorSize,\n        end   = n > 0 ? +arguments[n] : tickMajorSize;\n\n    if (tickMajorSize !== major ||\n        tickMinorSize !== minor ||\n        tickEndSize !== end) {\n      reset();\n    }\n\n    tickMajorSize = major;\n    tickMinorSize = minor;\n    tickEndSize = end;\n    return axis;\n  };\n\n  axis.tickSubdivide = function(x) {\n    if (!arguments.length) return tickSubdivide;\n    tickSubdivide = +x;\n    return axis;\n  };\n\n  axis.offset = function(x) {\n    if (!arguments.length) return offset;\n    offset = dl.isObject(x) ? x : +x;\n    return axis;\n  };\n\n  axis.tickPadding = function(x) {\n    if (!arguments.length) return tickPadding;\n    if (tickPadding !== +x) { tickPadding = +x; reset(); }\n    return axis;\n  };\n\n  axis.titleOffset = function(x) {\n    if (!arguments.length) return titleOffset;\n    if (titleOffset !== x) { titleOffset = x; reset(); }\n    return axis;\n  };\n\n  axis.layer = function(x) {\n    if (!arguments.length) return layer;\n    if (layer !== x) { layer = x; reset(); }\n    return axis;\n  };\n\n  axis.grid = function(x) {\n    if (!arguments.length) return grid;\n    if (grid !== x) { grid = x; reset(); }\n    return axis;\n  };\n\n  axis.gridLineProperties = function(x) {\n    if (!arguments.length) return gridLineStyle;\n    if (gridLineStyle !== x) { gridLineStyle = x; }\n    return axis;\n  };\n\n  axis.majorTickProperties = function(x) {\n    if (!arguments.length) return majorTickStyle;\n    if (majorTickStyle !== x) { majorTickStyle = x; }\n    return axis;\n  };\n\n  axis.minorTickProperties = function(x) {\n    if (!arguments.length) return minorTickStyle;\n    if (minorTickStyle !== x) { minorTickStyle = x; }\n    return axis;\n  };\n\n  axis.tickLabelProperties = function(x) {\n    if (!arguments.length) return tickLabelStyle;\n    if (tickLabelStyle !== x) { tickLabelStyle = x; }\n    return axis;\n  };\n\n  axis.titleProperties = function(x) {\n    if (!arguments.length) return titleStyle;\n    if (titleStyle !== x) { titleStyle = x; }\n    return axis;\n  };\n\n  axis.domainProperties = function(x) {\n    if (!arguments.length) return domainStyle;\n    if (domainStyle !== x) { domainStyle = x; }\n    return axis;\n  };\n\n  axis.reset = function() {\n    reset();\n    return axis;\n  };\n\n  return axis;\n}\n\nvar axisOrients = {top: 1, right: 1, bottom: 1, left: 1};\n\nfunction axisSubdivide(scale, ticks, m) {\n  var subticks = [];\n  if (m && ticks.length > 1) {\n    var extent = axisScaleExtent(scale.domain()),\n        i = -1,\n        n = ticks.length,\n        d = (ticks[1] - ticks[0]) / ++m,\n        j,\n        v;\n    while (++i < n) {\n      for (j = m; --j > 0;) {\n        if ((v = +ticks[i] - j * d) >= extent[0]) {\n          subticks.push(v);\n        }\n      }\n    }\n    for (--i, j = 0; ++j < m && (v = +ticks[i] + j * d) < extent[1];) {\n      subticks.push(v);\n    }\n  }\n  return subticks;\n}\n\nfunction axisScaleExtent(domain) {\n  var start = domain[0], stop = domain[domain.length - 1];\n  return start < stop ? [start, stop] : [stop, start];\n}\n\nfunction axisScaleRange(scale) {\n  return scale.rangeExtent ?\n    scale.rangeExtent() :\n    axisScaleExtent(scale.range());\n}\n\nvar axisAlign = {\n  bottom: 'center',\n  top: 'center',\n  left: 'right',\n  right: 'left'\n};\n\nvar axisBaseline = {\n  bottom: 'top',\n  top: 'bottom',\n  left: 'middle',\n  right: 'middle'\n};\n\nfunction axisLabelExtend(orient, labels, oldScale, newScale, size, pad) {\n  size = Math.max(size, 0) + pad;\n  if (orient === 'left' || orient === 'top') {\n    size *= -1;\n  }\n  if (orient === 'top' || orient === 'bottom') {\n    dl.extend(labels.properties.enter, {\n      x: oldScale,\n      y: {value: size},\n    });\n    dl.extend(labels.properties.update, {\n      x: newScale,\n      y: {value: size},\n      align: {value: 'center'},\n      baseline: {value: axisBaseline[orient]}\n    });\n  } else {\n    dl.extend(labels.properties.enter, {\n      x: {value: size},\n      y: oldScale,\n    });\n    dl.extend(labels.properties.update, {\n      x: {value: size},\n      y: newScale,\n      align: {value: axisAlign[orient]},\n      baseline: {value: 'middle'}\n    });\n  }\n}\n\nfunction axisTicksExtend(orient, ticks, oldScale, newScale, size, offset) {\n  var sign = (orient === 'left' || orient === 'top') ? -1 : 1;\n  if (size === Infinity) {\n    size = (orient === 'top' || orient === 'bottom') ?\n      {field: {group: 'height', level: 2}, mult: -sign, offset: offset*-sign} :\n      {field: {group: 'width',  level: 2}, mult: -sign, offset: offset*-sign};\n  } else {\n    size = {value: sign * size, offset: offset};\n  }\n  if (orient === 'top' || orient === 'bottom') {\n    dl.extend(ticks.properties.enter, {\n      x:  oldScale,\n      y:  {value: 0},\n      y2: size\n    });\n    dl.extend(ticks.properties.update, {\n      x:  newScale,\n      y:  {value: 0},\n      y2: size\n    });\n    dl.extend(ticks.properties.exit, {\n      x:  newScale,\n    });\n  } else {\n    dl.extend(ticks.properties.enter, {\n      x:  {value: 0},\n      x2: size,\n      y:  oldScale\n    });\n    dl.extend(ticks.properties.update, {\n      x:  {value: 0},\n      x2: size,\n      y:  newScale\n    });\n    dl.extend(ticks.properties.exit, {\n      y:  newScale,\n    });\n  }\n}\n\nfunction axisTitleExtend(orient, title, range, offset) {\n  var update = title.properties.update,\n      mid = ~~((range[0] + range[1]) / 2),\n      sign = (orient === 'top' || orient === 'left') ? -1 : 1;\n\n  if (orient === 'bottom' || orient === 'top') {\n    update.x = {value: mid};\n    update.angle = {value: 0};\n    if (offset >= 0) update.y = {value: sign * offset};\n  } else {\n    update.y = {value: mid};\n    update.angle = {value: orient === 'left' ? -90 : 90};\n    if (offset >= 0) update.x = {value: sign * offset};\n  }\n}\n\nfunction axisDomainExtend(orient, domain, range, size) {\n  var path;\n  if (orient === 'top' || orient === 'left') {\n    size = -1 * size;\n  }\n  if (orient === 'bottom' || orient === 'top') {\n    path = 'M' + range[0] + ',' + size + 'V0H' + range[1] + 'V' + size;\n  } else {\n    path = 'M' + size + ',' + range[0] + 'H0V' + range[1] + 'H' + size;\n  }\n  domain.properties.update.path = {value: path};\n}\n\nfunction axisUpdate(item, group, trans) {\n  var o = trans ? {} : item,\n      offset = item.mark.def.offset,\n      orient = item.mark.def.orient,\n      width  = group.width,\n      height = group.height; // TODO fallback to global w,h?\n\n  if (dl.isArray(offset)) {\n    var ofx = offset[0],\n        ofy = offset[1];\n\n    switch (orient) {\n      case 'left':   { Tuple.set(o, 'x', -ofx); Tuple.set(o, 'y', ofy); break; }\n      case 'right':  { Tuple.set(o, 'x', width + ofx); Tuple.set(o, 'y', ofy); break; }\n      case 'bottom': { Tuple.set(o, 'x', ofx); Tuple.set(o, 'y', height + ofy); break; }\n      case 'top':    { Tuple.set(o, 'x', ofx); Tuple.set(o, 'y', -ofy); break; }\n      default:       { Tuple.set(o, 'x', ofx); Tuple.set(o, 'y', ofy); }\n    }\n  } else {\n    if (dl.isObject(offset)) {\n      offset = -group.scale(offset.scale)(offset.value);\n    }\n\n    switch (orient) {\n      case 'left':   { Tuple.set(o, 'x', -offset); Tuple.set(o, 'y', 0); break; }\n      case 'right':  { Tuple.set(o, 'x', width + offset); Tuple.set(o, 'y', 0); break; }\n      case 'bottom': { Tuple.set(o, 'x', 0); Tuple.set(o, 'y', height + offset); break; }\n      case 'top':    { Tuple.set(o, 'x', 0); Tuple.set(o, 'y', -offset); break; }\n      default:       { Tuple.set(o, 'x', 0); Tuple.set(o, 'y', 0); }\n    }\n  }\n\n  if (trans) trans.interpolate(item, o);\n  return true;\n}\n\nfunction axisTicks(config) {\n  return {\n    type: 'rule',\n    interactive: false,\n    key: 'data',\n    properties: {\n      enter: {\n        stroke: {value: config.tickColor},\n        strokeWidth: {value: config.tickWidth},\n        opacity: {value: 1e-6}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: { opacity: {value: 1} }\n    }\n  };\n}\n\nfunction axisTickLabels(config) {\n  return {\n    type: 'text',\n    interactive: true,\n    key: 'data',\n    properties: {\n      enter: {\n        fill: {value: config.tickLabelColor},\n        font: {value: config.tickLabelFont},\n        fontSize: {value: config.tickLabelFontSize},\n        opacity: {value: 1e-6},\n        text: {field: 'label'}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: { opacity: {value: 1} }\n    }\n  };\n}\n\nfunction axisTitle(config) {\n  return {\n    type: 'text',\n    interactive: true,\n    properties: {\n      enter: {\n        font: {value: config.titleFont},\n        fontSize: {value: config.titleFontSize},\n        fontWeight: {value: config.titleFontWeight},\n        fill: {value: config.titleColor},\n        align: {value: 'center'},\n        baseline: {value: 'middle'},\n        text: {field: 'data'}\n      },\n      update: {}\n    }\n  };\n}\n\nfunction axisDomain(config) {\n  return {\n    type: 'path',\n    interactive: false,\n    properties: {\n      enter: {\n        x: {value: 0.5},\n        y: {value: 0.5},\n        stroke: {value: config.axisColor},\n        strokeWidth: {value: config.axisWidth}\n      },\n      update: {}\n    }\n  };\n}\n\nmodule.exports = axs;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/scene/axis.js\n ** module id = 58\n ** module chunks = 0\n **/","var dl = require('datalib'),\n    parseProperties = require('./properties');\n\nfunction parseMark(model, mark) {\n  var props = mark.properties,\n      group = mark.marks;\n\n  // parse mark property definitions\n  dl.keys(props).forEach(function(k) {\n    props[k] = parseProperties(model, mark.type, props[k]);\n  });\n\n  // parse delay function\n  if (mark.delay) {\n    mark.delay = parseProperties(model, mark.type, {delay: mark.delay});\n  }\n\n  // recurse if group type\n  if (group) {\n    mark.marks = group.map(function(g) { return parseMark(model, g); });\n  }\n\n  return mark;\n}\n\nmodule.exports = parseMark;\n\nparseMark.schema = {\n  \"defs\": {\n    \"mark\": {\n      \"type\": \"object\",\n\n      \"properties\": {\n        \"name\": {\"type\": \"string\"},\n        \"key\": {\"type\": \"string\"},\n        \"type\": {\"enum\": [\"rect\", \"symbol\", \"path\", \"arc\",\n          \"area\", \"line\", \"rule\", \"image\", \"text\", \"group\"]},\n\n        \"from\": {\n          \"type\": \"object\",\n          \"properties\": {\n            \"data\": {\"type\": \"string\"},\n            \"mark\": {\"type\": \"string\"},\n            \"transform\": {\"$ref\": \"#/defs/transform\"}\n          },\n          \"additionalProperties\": false\n        },\n\n        \"delay\": {\"$ref\": \"#/refs/numberValue\"},\n        \"ease\": {\n          \"enum\": [\"linear\", \"quad\", \"cubic\", \"sin\",\n            \"exp\", \"circle\", \"bounce\"].reduce(function(acc, e) {\n              [\"in\", \"out\", \"in-out\", \"out-in\"].forEach(function(m) {\n                acc.push(e+\"-\"+m);\n              });\n              return acc;\n          }, [])\n        },\n\n        \"interactive\": {\"type\": \"boolean\"},\n\n        \"properties\": {\n          \"type\": \"object\",\n          \"properties\": {\n            \"enter\":  {\"$ref\": \"#/defs/propset\"},\n            \"update\": {\"$ref\": \"#/defs/propset\"},\n            \"exit\":   {\"$ref\": \"#/defs/propset\"},\n            \"hover\":  {\"$ref\": \"#/defs/propset\"}\n          },\n          \"additionalProperties\": false,\n          \"anyOf\": [{\"required\": [\"enter\"]}, {\"required\": [\"update\"]}]\n        }\n      },\n\n      // \"additionalProperties\": false,\n      \"required\": [\"type\"]\n    }\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/parse/mark.js\n ** module id = 59\n ** module chunks = 0\n **/","var d3 = require('d3'),\n    dl = require('datalib'),\n    log = require('vega-logging'),\n    Tuple = require('vega-dataflow').Tuple;\n\nvar DEPS = [\"signals\", \"scales\", \"data\", \"fields\"];\n\nfunction properties(model, mark, spec) {\n  var config = model.config(),\n      code = \"\",\n      names = dl.keys(spec),\n      exprs = [], // parsed expressions injected in the generated code\n      i, len, name, ref, vars = {},\n      deps = {\n        signals: {},\n        scales:  {},\n        data:    {},\n        fields:  {},\n        nested:  [],\n        _nRefs:  {},  // Temp stash to de-dupe nested refs.\n        reflow:  false\n      };\n\n  code += \"var o = trans ? {} : item, d=0, exprs=this.exprs, set=this.tpl.set, tmpl=signals||{}, t;\\n\" +\n          // Stash for dl.template\n          \"tmpl.datum  = item.datum;\\n\" +\n          \"tmpl.group  = group;\\n\" +\n          \"tmpl.parent = group.datum;\\n\";\n\n  function handleDep(p) {\n    if (ref[p] == null) return;\n    var k = dl.array(ref[p]), i, n;\n    for (i=0, n=k.length; i<n; ++i) {\n      deps[p][k[i]] = 1;\n    }\n  }\n\n  function handleNestedRefs(r) {\n    var k = (r.parent ? \"parent_\" : \"group_\")+r.level;\n    deps._nRefs[k] = r;\n  }\n\n  for (i=0, len=names.length; i<len; ++i) {\n    ref = spec[name = names[i]];\n    code += (i > 0) ? \"\\n  \" : \"  \";\n    if (ref.rule) {\n      // a production rule valueref\n      ref = rule(model, name, ref.rule, exprs);\n      code += \"\\n  \" + ref.code;\n    } else if (dl.isArray(ref)) {\n      // a production rule valueref as an array\n      ref = rule(model, name, ref, exprs);\n      code += \"\\n  \" + ref.code;\n    } else {\n      // a simple valueref\n      ref = valueRef(config, name, ref);\n      code += \"d += set(o, \"+dl.str(name)+\", \"+ref.val+\");\";\n    }\n\n    vars[name] = true;\n    DEPS.forEach(handleDep);\n    deps.reflow = deps.reflow || ref.reflow;\n    if (ref.nested.length) ref.nested.forEach(handleNestedRefs);\n  }\n\n  // If nested references are present, sort them based on their level\n  // to speed up determination of whether encoders should be reeval'd.\n  dl.keys(deps._nRefs).forEach(function(k) { deps.nested.push(deps._nRefs[k]); });\n  deps.nested.sort(function(a, b) {\n    a = a.level;\n    b = b.level;\n    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n  });\n\n  if (vars.x2) {\n    if (vars.x) {\n      code += \"\\n  if (o.x > o.x2) { \" +\n              \"\\n    t = o.x;\" +\n              \"\\n    d += set(o, 'x', o.x2);\" +\n              \"\\n    d += set(o, 'x2', t); \" +\n              \"\\n  };\";\n      code += \"\\n  d += set(o, 'width', (o.x2 - o.x));\";\n    } else if (vars.width) {\n      code += \"\\n  d += set(o, 'x', (o.x2 - o.width));\";\n    } else {\n      code += \"\\n  d += set(o, 'x', o.x2);\";\n    }\n  }\n\n  if (vars.xc) {\n    if (vars.width) {\n      code += \"\\n  d += set(o, 'x', (o.xc - o.width/2));\" ;\n    } else {\n      code += \"\\n  d += set(o, 'x', o.xc);\" ;\n    }\n  }\n\n  if (vars.y2) {\n    if (vars.y) {\n      code += \"\\n  if (o.y > o.y2) { \" +\n              \"\\n    t = o.y;\" +\n              \"\\n    d += set(o, 'y', o.y2);\" +\n              \"\\n    d += set(o, 'y2', t);\" +\n              \"\\n  };\";\n      code += \"\\n  d += set(o, 'height', (o.y2 - o.y));\";\n    } else if (vars.height) {\n      code += \"\\n  d += set(o, 'y', (o.y2 - o.height));\";\n    } else {\n      code += \"\\n  d += set(o, 'y', o.y2);\";\n    }\n  }\n\n  if (vars.yc) {\n    if (vars.height) {\n      code += \"\\n  d += set(o, 'y', (o.yc - o.height/2));\" ;\n    } else {\n      code += \"\\n  d += set(o, 'y', o.yc);\" ;\n    }\n  }\n\n  if (hasPath(mark, vars)) code += \"\\n  d += (item.touch(), 1);\";\n  code += \"\\n  if (trans) trans.interpolate(item, o);\";\n  code += \"\\n  return d > 0;\";\n\n  try {\n    /* jshint evil:true */\n    var encoder = Function('item', 'group', 'trans', 'db',\n      'signals', 'predicates', code);\n\n    encoder.tpl  = Tuple;\n    encoder.exprs = exprs;\n    encoder.util = dl;\n    encoder.d3   = d3; // For color spaces\n    dl.extend(encoder, dl.template.context);\n    return {\n      encode:  encoder,\n      signals: dl.keys(deps.signals),\n      scales:  dl.keys(deps.scales),\n      data:    dl.keys(deps.data),\n      fields:  dl.keys(deps.fields),\n      nested:  deps.nested,\n      reflow:  deps.reflow\n    };\n  } catch (e) {\n    log.error(e);\n    log.log(code);\n  }\n}\n\nfunction dependencies(a, b) {\n  if (!dl.isObject(a)) {\n    a = {reflow: false, nested: []};\n    DEPS.forEach(function(d) { a[d] = []; });\n  }\n\n  if (dl.isObject(b)) {\n    a.reflow = a.reflow || b.reflow;\n    a.nested.push.apply(a.nested, b.nested);\n    DEPS.forEach(function(d) { a[d].push.apply(a[d], b[d]); });\n  }\n\n  return a;\n}\n\nfunction hasPath(mark, vars) {\n  return vars.path ||\n    ((mark==='area' || mark==='line') &&\n      (vars.x || vars.x2 || vars.width ||\n       vars.y || vars.y2 || vars.height ||\n       vars.tension || vars.interpolate));\n}\n\nfunction rule(model, name, rules, exprs) {\n  var config  = model.config(),\n      deps = dependencies(),\n      inputs  = [],\n      code = '';\n\n  (rules||[]).forEach(function(r, i) {\n    var ref = valueRef(config, name, r);\n    dependencies(deps, ref);\n\n    if (r.test) {\n      // rule uses an expression instead of a predicate.\n      var exprFn = model.expr(r.test);\n      deps.signals.push.apply(deps.signals, exprFn.globals);\n      deps.data.push.apply(deps.data, exprFn.dataSources);\n\n      code += \"if (exprs[\" + exprs.length + \"](item.datum, null)) {\" +\n          \"\\n    d += set(o, \"+dl.str(name)+\", \" +ref.val+\");\";\n      code += rules[i+1] ? \"\\n  } else \" : \"  }\";\n\n      exprs.push(exprFn.fn);\n    } else {\n      var def = r.predicate,\n          predName = def && (def.name || def),\n          pred = model.predicate(predName),\n          p = 'predicates['+dl.str(predName)+']',\n          input = [], args = name+'_arg'+i;\n\n      if (dl.isObject(def)) {\n        dl.keys(def).forEach(function(k) {\n          if (k === 'name') return;\n          var ref = valueRef(config, i, def[k], true);\n          input.push(dl.str(k)+': '+ref.val);\n          dependencies(deps, ref);\n        });\n      }\n\n      if (predName) {\n        // append the predicates dependencies to our dependencies\n        deps.signals.push.apply(deps.signals, pred.signals);\n        deps.data.push.apply(deps.data, pred.data);\n        inputs.push(args+\" = {\\n    \"+input.join(\",\\n    \")+\"\\n  }\");\n        code += \"if (\"+p+\".call(\"+p+\",\"+args+\", db, signals, predicates)) {\" +\n          \"\\n    d += set(o, \"+dl.str(name)+\", \"+ref.val+\");\";\n        code += rules[i+1] ? \"\\n  } else \" : \"  }\";\n      } else {\n        code += \"{\" +\n          \"\\n    d += set(o, \"+dl.str(name)+\", \"+ref.val+\");\"+\n          \"\\n  }\\n\";\n      }\n    }\n  });\n\n  if (inputs.length) code = \"var \" + inputs.join(\",\\n      \") + \";\\n  \" + code;\n  return (deps.code = code, deps);\n}\n\nfunction valueRef(config, name, ref, predicateArg) {\n  if (ref == null) return null;\n\n  if (name==='fill' || name==='stroke') {\n    if (ref.c) {\n      return colorRef(config, 'hcl', ref.h, ref.c, ref.l);\n    } else if (ref.h || ref.s) {\n      return colorRef(config, 'hsl', ref.h, ref.s, ref.l);\n    } else if (ref.l || ref.a) {\n      return colorRef(config, 'lab', ref.l, ref.a, ref.b);\n    } else if (ref.r || ref.g || ref.b) {\n      return colorRef(config, 'rgb', ref.r, ref.g, ref.b);\n    }\n  }\n\n  // initialize value\n  var val = null, scale = null,\n      deps = dependencies(),\n      sgRef = null, fRef = null, sRef = null, tmpl = {};\n\n  if (ref.template !== undefined) {\n    val = dl.template.source(ref.template, 'tmpl', tmpl);\n    dl.keys(tmpl).forEach(function(k) {\n      var f = dl.field(k),\n          a = f.shift();\n      if (a === 'parent' || a === 'group') {\n        deps.nested.push({\n          parent: a === 'parent',\n          group:  a === 'group',\n          level:  1\n        });\n      } else if (a === 'datum') {\n        deps.fields.push(f[0]);\n      } else {\n        deps.signals.push(a);\n      }\n    });\n  }\n\n  if (ref.value !== undefined) {\n    val = dl.str(ref.value);\n  }\n\n  if (ref.signal !== undefined) {\n    sgRef = dl.field(ref.signal);\n    val = 'signals['+sgRef.map(dl.str).join('][')+']';\n    deps.signals.push(sgRef.shift());\n  }\n\n  if (ref.field !== undefined) {\n    ref.field = dl.isString(ref.field) ? {datum: ref.field} : ref.field;\n    fRef = fieldRef(ref.field);\n    val  = fRef.val;\n    dependencies(deps, fRef);\n  }\n\n  if (ref.scale !== undefined) {\n    sRef  = scaleRef(ref.scale);\n    scale = sRef.val;\n    dependencies(deps, sRef);\n    deps.scales.push(ref.scale.name || ref.scale);\n\n    // run through scale function if val specified.\n    // if no val, scale function is predicate arg.\n    if (val !== null || ref.band || ref.mult || ref.offset || !predicateArg) {\n      val = scale + (ref.band ? '.rangeBand()' :\n        '('+(val !== null ? val : 'item.datum.data')+')');\n    } else if (predicateArg) {\n      val = scale;\n    }\n  }\n\n  // multiply, offset, return value\n  val = '(' + (ref.mult?(dl.number(ref.mult)+' * '):'') + val + ')' +\n        (ref.offset ? ' + ' + dl.number(ref.offset) : '');\n\n  // Collate dependencies\n  return (deps.val = val, deps);\n}\n\nfunction colorRef(config, type, x, y, z) {\n  var xx = x ? valueRef(config, '', x) : config.color[type][0],\n      yy = y ? valueRef(config, '', y) : config.color[type][1],\n      zz = z ? valueRef(config, '', z) : config.color[type][2],\n      deps = dependencies();\n\n  [xx, yy, zz].forEach(function(v) {\n    if (dl.isArray) return;\n    dependencies(deps, v);\n  });\n\n  var val = '(this.d3.' + type + '(' + [xx.val, yy.val, zz.val].join(',') + ') + \"\")';\n  return (deps.val = val, deps);\n}\n\n// {field: {datum: \"foo\"} }  -> item.datum.foo\n// {field: {group: \"foo\"} }  -> group.foo\n// {field: {parent: \"foo\"} } -> group.datum.foo\nfunction fieldRef(ref) {\n  if (dl.isString(ref)) {\n    return {val: dl.field(ref).map(dl.str).join('][')};\n  }\n\n  // Resolve nesting/parent lookups\n  var l = ref.level || 1,\n      nested = (ref.group || ref.parent) && l,\n      scope = nested ? Array(l).join('group.mark.') : '',\n      r = fieldRef(ref.datum || ref.group || ref.parent || ref.signal),\n      val = r.val,\n      deps = dependencies(null, r);\n\n  if (ref.datum) {\n    val = 'item.datum['+val+']';\n    deps.fields.push(ref.datum);\n  } else if (ref.group) {\n    val = scope+'group['+val+']';\n    deps.nested.push({ level: l, group: true });\n  } else if (ref.parent) {\n    val = scope+'group.datum['+val+']';\n    deps.nested.push({ level: l, parent: true });\n  } else if (ref.signal) {\n    val = 'signals['+val+']';\n    deps.signals.push(dl.field(ref.signal)[0]);\n    deps.reflow = true;\n  }\n\n  return (deps.val = val, deps);\n}\n\n// {scale: \"x\"}\n// {scale: {name: \"x\"}},\n// {scale: fieldRef}\nfunction scaleRef(ref) {\n  var scale = null,\n      fr = null,\n      deps = dependencies();\n\n  if (dl.isString(ref)) {\n    scale = dl.str(ref);\n  } else if (ref.name) {\n    scale = dl.isString(ref.name) ? dl.str(ref.name) : (fr = fieldRef(ref.name)).val;\n  } else {\n    scale = (fr = fieldRef(ref)).val;\n  }\n\n  scale = '(item.mark._scaleRefs['+scale+'] = 1, group.scale('+scale+'))';\n  if (ref.invert) scale += '.invert';\n\n  // Mark scale refs as they're dealt with separately in mark._scaleRefs.\n  if (fr) fr.nested.forEach(function(g) { g.scale = true; });\n  return fr ? (fr.val = scale, fr) : (deps.val = scale, deps);\n}\n\nmodule.exports = properties;\n\nfunction valueSchema(type) {\n  type = dl.isArray(type) ? {\"enum\": type} : {\"type\": type};\n  var modType = type.type === \"number\" && type.type || \"string\";\n  var valRef  = {\n    \"type\": \"object\",\n    \"allOf\": [{\"$ref\": \"#/refs/\" + modType + \"Modifiers\"}, {\n      \"oneOf\": [{\n        \"$ref\": \"#/refs/signal\",\n        \"required\": [\"signal\"]\n      }, {\n        \"properties\": {\"value\": type},\n        \"required\": [\"value\"]\n      }, {\n        \"properties\": {\"field\": {\"$ref\": \"#/refs/field\"}},\n        \"required\": [\"field\"]\n      }, {\n        \"properties\": {\"band\": {\"type\": \"boolean\"}},\n        \"required\": [\"band\"]\n      }]\n    }]\n  };\n\n  if (type.type === \"string\") {\n    valRef.allOf[1].oneOf.push({\n      \"properties\": {\"template\": {\"type\": \"string\"}},\n      \"required\": [\"template\"]\n    });\n  }\n\n  return {\n    \"oneOf\": [{\n      \"type\": \"object\",\n      \"properties\": {\n        \"rule\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"allOf\": [{\"$ref\": \"#/defs/rule\"}, valRef]\n          }\n        }\n      },\n      \"additionalProperties\": false,\n      \"required\": [\"rule\"]\n    },\n    {\n      \"type\": \"array\",\n      \"items\": {\n        \"allOf\": [{\"$ref\": \"#/defs/rule\"}, valRef]\n      }\n    },\n    valRef]\n  };\n}\n\nproperties.schema = {\n  \"refs\": {\n    \"field\": {\n      \"title\": \"FieldRef\",\n      \"oneOf\": [\n        {\"type\": \"string\"},\n        {\n          \"oneOf\": [\n            {\"$ref\": \"#/refs/signal\"},\n            {\n              \"type\": \"object\",\n              \"properties\": {\"datum\": {\"$ref\": \"#/refs/field\"}},\n              \"required\": [\"datum\"],\n              \"additionalProperties\": false\n            },\n            {\n              \"type\": \"object\",\n              \"properties\": {\n                \"group\": {\"$ref\": \"#/refs/field\"},\n                \"level\": {\"type\": \"number\"}\n              },\n              \"required\": [\"group\"],\n              \"additionalProperties\": false\n            },\n            {\n              \"type\": \"object\",\n              \"properties\": {\n                \"parent\": {\"$ref\": \"#/refs/field\"},\n                \"level\": {\"type\": \"number\"}\n              },\n              \"required\": [\"parent\"],\n              \"additionalProperties\": false\n            }\n          ]\n        }\n      ]\n    },\n\n    \"scale\": {\n      \"title\": \"ScaleRef\",\n      \"oneOf\": [\n        {\"$ref\": \"#/refs/field\"},\n        {\n          \"type\": \"object\",\n          \"properties\": {\n            \"name\": {\"$ref\": \"#/refs/field\"},\n            \"invert\": {\"type\": \"boolean\", \"default\": false}\n          },\n          \"required\": [\"name\"]\n        }\n      ]\n    },\n\n    \"stringModifiers\": {\n      \"properties\": {\n        \"scale\": {\"$ref\": \"#/refs/scale\"}\n      }\n    },\n\n    \"numberModifiers\": {\n      \"properties\": {\n        \"mult\": {\"type\": \"number\"},\n        \"offset\": {\"type\": \"number\"},\n        \"scale\": {\"$ref\": \"#/refs/scale\"}\n      }\n    },\n\n    \"value\": valueSchema({}, \"value\"),\n    \"numberValue\": valueSchema(\"number\", \"numberValue\"),\n    \"stringValue\": valueSchema(\"string\", \"stringValue\"),\n    \"booleanValue\": valueSchema(\"boolean\", \"booleanValue\"),\n    \"arrayValue\": valueSchema(\"array\", \"arrayValue\"),\n\n    \"colorValue\": {\n      \"title\": \"ColorRef\",\n      \"oneOf\": [{\"$ref\": \"#/refs/stringValue\"}, {\n        \"type\": \"object\",\n        \"properties\": {\n          \"r\": {\"$ref\": \"#/refs/numberValue\"},\n          \"g\": {\"$ref\": \"#/refs/numberValue\"},\n          \"b\": {\"$ref\": \"#/refs/numberValue\"}\n        },\n        \"required\": [\"r\", \"g\", \"b\"]\n      }, {\n        \"type\": \"object\",\n        \"properties\": {\n          \"h\": {\"$ref\": \"#/refs/numberValue\"},\n          \"s\": {\"$ref\": \"#/refs/numberValue\"},\n          \"l\": {\"$ref\": \"#/refs/numberValue\"}\n        },\n        \"required\": [\"h\", \"s\", \"l\"]\n      }, {\n        \"type\": \"object\",\n        \"properties\": {\n          \"l\": {\"$ref\": \"#/refs/numberValue\"},\n          \"a\": {\"$ref\": \"#/refs/numberValue\"},\n          \"b\": {\"$ref\": \"#/refs/numberValue\"}\n        },\n        \"required\": [\"l\", \"a\", \"b\"]\n      }, {\n        \"type\": \"object\",\n        \"properties\": {\n          \"h\": {\"$ref\": \"#/refs/numberValue\"},\n          \"c\": {\"$ref\": \"#/refs/numberValue\"},\n          \"l\": {\"$ref\": \"#/refs/numberValue\"}\n        },\n        \"required\": [\"h\", \"c\", \"l\"]\n      }]\n    }\n  },\n\n  \"defs\": {\n    \"rule\": {\n      \"anyOf\": [\n        {\n          \"type\": \"object\",\n          \"properties\": {\n            \"predicate\": {\n              \"oneOf\": [\n                {\"type\": \"string\"},\n                {\n                  \"type\": \"object\",\n                  \"properties\": {\"name\": { \"type\": \"string\" }},\n                  \"required\": [\"name\"]\n                }\n              ]\n            }\n          }\n        },\n        {\n          \"type\": \"object\",\n          \"properties\": {\"test\": {\"type\": \"string\"}}\n        }\n      ]\n    },\n    \"propset\": {\n      \"title\": \"Mark property set\",\n      \"type\": \"object\",\n      \"properties\": {\n        // Common Properties\n        \"x\": {\"$ref\": \"#/refs/numberValue\"},\n        \"x2\": {\"$ref\": \"#/refs/numberValue\"},\n        \"xc\": {\"$ref\": \"#/refs/numberValue\"},\n        \"width\": {\"$ref\": \"#/refs/numberValue\"},\n        \"y\": {\"$ref\": \"#/refs/numberValue\"},\n        \"y2\": {\"$ref\": \"#/refs/numberValue\"},\n        \"yc\": {\"$ref\": \"#/refs/numberValue\"},\n        \"height\": {\"$ref\": \"#/refs/numberValue\"},\n        \"opacity\": {\"$ref\": \"#/refs/numberValue\"},\n        \"fill\": {\"$ref\": \"#/refs/colorValue\"},\n        \"fillOpacity\": {\"$ref\": \"#/refs/numberValue\"},\n        \"stroke\": {\"$ref\": \"#/refs/colorValue\"},\n        \"strokeWidth\": {\"$ref\": \"#/refs/numberValue\"},\n        \"strokeOpacity\": {\"$ref\": \"#/refs/numberValue\"},\n        \"strokeDash\": {\"$ref\": \"#/refs/arrayValue\"},\n        \"strokeDashOffset\": {\"$ref\": \"#/refs/numberValue\"},\n        \"cursor\": {\"$ref\": \"#/refs/stringValue\"},\n\n        // Group-mark properties\n        \"clip\": {\"$ref\": \"#/refs/booleanValue\"},\n\n        // Symbol-mark properties\n        \"size\": {\"$ref\": \"#/refs/numberValue\"},\n        \"shape\": valueSchema([\"circle\", \"square\",\n          \"cross\", \"diamond\", \"triangle-up\", \"triangle-down\"]),\n\n        // Path-mark properties\n        \"path\": {\"$ref\": \"#/refs/stringValue\"},\n\n        // Arc-mark properties\n        \"innerRadius\": {\"$ref\": \"#/refs/numberValue\"},\n        \"outerRadius\": {\"$ref\": \"#/refs/numberValue\"},\n        \"startAngle\": {\"$ref\": \"#/refs/numberValue\"},\n        \"endAngle\": {\"$ref\": \"#/refs/numberValue\"},\n\n        // Area- and line-mark properties\n        \"interpolate\": valueSchema([\"linear\", \"step-before\", \"step-after\",\n          \"basis\", \"basis-open\", \"cardinal\", \"cardinal-open\", \"monotone\"]),\n        \"tension\": {\"$ref\": \"#/refs/numberValue\"},\n        \"orient\": valueSchema([\"horizontal\", \"vertical\"]),\n\n        // Image-mark properties\n        \"url\": {\"$ref\": \"#/refs/stringValue\"},\n        \"align\": valueSchema([\"left\", \"right\", \"center\"]),\n        \"baseline\": valueSchema([\"top\", \"middle\", \"bottom\", \"alphabetic\"]),\n\n        // Text-mark properties\n        \"text\": {\"$ref\": \"#/refs/stringValue\"},\n        \"dx\": {\"$ref\": \"#/refs/numberValue\"},\n        \"dy\": {\"$ref\": \"#/refs/numberValue\"},\n        \"radius\":{\"$ref\": \"#/refs/numberValue\"},\n        \"theta\": {\"$ref\": \"#/refs/numberValue\"},\n        \"angle\": {\"$ref\": \"#/refs/numberValue\"},\n        \"font\": {\"$ref\": \"#/refs/stringValue\"},\n        \"fontSize\": {\"$ref\": \"#/refs/numberValue\"},\n        \"fontWeight\": {\"$ref\": \"#/refs/stringValue\"},\n        \"fontStyle\": {\"$ref\": \"#/refs/stringValue\"}\n      },\n\n      \"additionalProperties\": false\n    }\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/parse/properties.js\n ** module id = 60\n ** module chunks = 0\n **/","var dl = require('datalib'),\n    u  = {};\n\ndl.extend(u, require('./format'));\nmodule.exports = dl.extend(u, dl);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/util/index.js\n ** module id = 61\n ** module chunks = 0\n **/","var dl = require('datalib');\n\nvar TIME    = 'time',\n    UTC     = 'utc',\n    STRING  = 'string',\n    ORDINAL = 'ordinal',\n    NUMBER  = 'number';\n\nfunction getTickFormat(scale, tickCount, tickFormatType, tickFormatString) {\n  var formatType = tickFormatType || inferFormatType(scale);\n  return getFormatter(scale, tickCount, formatType, tickFormatString);\n}\n\nfunction inferFormatType(scale) {\n  switch (scale.type) {\n    case TIME:    return TIME;\n    case UTC:     return UTC;\n    case ORDINAL: return STRING;\n    default:      return NUMBER;\n  }\n}\n\n// Adapted from d3 log scale\n// TODO customize? replace with range-size-aware filtering?\nfunction logFilter(scale, domain, count, f) {\n  if (count == null) return f;\n  var base = scale.base(),\n      k = Math.min(base, scale.ticks().length / count),\n      v = domain[0] > 0 ? (e = 1e-12, Math.ceil) : (e = -1e-12, Math.floor),\n      e;\n  function log(x) {\n    return (domain[0] < 0 ?\n      -Math.log(x > 0 ? 0 : -x) :\n      Math.log(x < 0 ? 0 : x)) / Math.log(base);\n  }\n  function pow(x) {\n    return domain[0] < 0 ? -Math.pow(base, -x) : Math.pow(base, x);\n  }\n  return function(d) {\n    return pow(v(log(d) + e)) / d >= k ? f(d) : '';\n  };\n}\n\nfunction getFormatter(scale, tickCount, formatType, str) {\n  var fmt = dl.format,\n      log = scale.type === 'log',\n      domain;\n\n  switch (formatType) {\n    case NUMBER:\n      domain = scale.domain();\n      return log ?\n        logFilter(scale, domain, tickCount, fmt.auto.number(str || null)) :\n        fmt.auto.linear(domain, tickCount, str || null);\n    case TIME: return (str ? fmt : fmt.auto).time(str);\n    case UTC:  return (str ? fmt : fmt.auto).utc(str);\n    default:   return String;\n  }\n}\n\nmodule.exports = {\n  getTickFormat: getTickFormat\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/util/format.js\n ** module id = 62\n ** module chunks = 0\n **/","module.exports = {\n  path:       require('./path'),\n  render:     require('./render'),\n  Item:       require('./util/Item'),\n  bound:      require('./util/bound'),\n  Bounds:     require('./util/Bounds'),\n  canvas:     require('./util/canvas'),\n  Gradient:   require('./util/Gradient'),\n  toJSON:     require('./util/scene').toJSON,\n  fromJSON:   require('./util/scene').fromJSON\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-scenegraph/src/index.js\n ** module id = 63\n ** module chunks = 0\n **/","module.exports = {\n  parse:  require('./parse'),\n  render: require('./render')\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-scenegraph/src/path/index.js\n ** module id = 64\n ** module chunks = 0\n **/","// Path parsing and rendering code adapted from fabric.js -- Thanks!\nvar cmdlen = { m:2, l:2, h:1, v:1, c:6, s:4, q:4, t:2, a:7 },\n    regexp = [/([MLHVCSQTAZmlhvcsqtaz])/g, /###/, /(\\d)([-+])/g, /\\s|,|###/];\n\nmodule.exports = function(pathstr) {\n  var result = [],\n      path,\n      curr,\n      chunks,\n      parsed, param,\n      cmd, len, i, j, n, m;\n\n  // First, break path into command sequence\n  path = pathstr\n    .slice()\n    .replace(regexp[0], '###$1')\n    .split(regexp[1])\n    .slice(1);\n\n  // Next, parse each command in turn\n  for (i=0, n=path.length; i<n; ++i) {\n    curr = path[i];\n    chunks = curr\n      .slice(1)\n      .trim()\n      .replace(regexp[2],'$1###$2')\n      .split(regexp[3]);\n    cmd = curr.charAt(0);\n\n    parsed = [cmd];\n    for (j=0, m=chunks.length; j<m; ++j) {\n      if ((param = +chunks[j]) === param) { // not NaN\n        parsed.push(param);\n      }\n    }\n\n    len = cmdlen[cmd.toLowerCase()];\n    if (parsed.length-1 > len) {\n      for (j=1, m=parsed.length; j<m; j+=len) {\n        result.push([cmd].concat(parsed.slice(j, j+len)));\n      }\n    }\n    else {\n      result.push(parsed);\n    }\n  }\n\n  return result;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-scenegraph/src/path/parse.js\n ** module id = 65\n ** module chunks = 0\n **/","var arc = require('./arc');\n\nmodule.exports = function(g, path, l, t) {\n  var current, // current instruction\n      previous = null,\n      x = 0, // current x\n      y = 0, // current y\n      controlX = 0, // current control point x\n      controlY = 0, // current control point y\n      tempX,\n      tempY,\n      tempControlX,\n      tempControlY;\n\n  if (l == null) l = 0;\n  if (t == null) t = 0;\n\n  g.beginPath();\n\n  for (var i=0, len=path.length; i<len; ++i) {\n    current = path[i];\n\n    switch (current[0]) { // first letter\n\n      case 'l': // lineto, relative\n        x += current[1];\n        y += current[2];\n        g.lineTo(x + l, y + t);\n        break;\n\n      case 'L': // lineto, absolute\n        x = current[1];\n        y = current[2];\n        g.lineTo(x + l, y + t);\n        break;\n\n      case 'h': // horizontal lineto, relative\n        x += current[1];\n        g.lineTo(x + l, y + t);\n        break;\n\n      case 'H': // horizontal lineto, absolute\n        x = current[1];\n        g.lineTo(x + l, y + t);\n        break;\n\n      case 'v': // vertical lineto, relative\n        y += current[1];\n        g.lineTo(x + l, y + t);\n        break;\n\n      case 'V': // verical lineto, absolute\n        y = current[1];\n        g.lineTo(x + l, y + t);\n        break;\n\n      case 'm': // moveTo, relative\n        x += current[1];\n        y += current[2];\n        g.moveTo(x + l, y + t);\n        break;\n\n      case 'M': // moveTo, absolute\n        x = current[1];\n        y = current[2];\n        g.moveTo(x + l, y + t);\n        break;\n\n      case 'c': // bezierCurveTo, relative\n        tempX = x + current[5];\n        tempY = y + current[6];\n        controlX = x + current[3];\n        controlY = y + current[4];\n        g.bezierCurveTo(\n          x + current[1] + l, // x1\n          y + current[2] + t, // y1\n          controlX + l, // x2\n          controlY + t, // y2\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'C': // bezierCurveTo, absolute\n        x = current[5];\n        y = current[6];\n        controlX = current[3];\n        controlY = current[4];\n        g.bezierCurveTo(\n          current[1] + l,\n          current[2] + t,\n          controlX + l,\n          controlY + t,\n          x + l,\n          y + t\n        );\n        break;\n\n      case 's': // shorthand cubic bezierCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        g.bezierCurveTo(\n          controlX + l,\n          controlY + t,\n          x + current[1] + l,\n          y + current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n\n        // set control point to 2nd one of this command\n        // the first control point is assumed to be the reflection of\n        // the second control point on the previous command relative\n        // to the current point.\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'S': // shorthand cubic bezierCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n        // calculate reflection of previous control points\n        controlX = 2*x - controlX;\n        controlY = 2*y - controlY;\n        g.bezierCurveTo(\n          controlX + l,\n          controlY + t,\n          current[1] + l,\n          current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        // set control point to 2nd one of this command\n        // the first control point is assumed to be the reflection of\n        // the second control point on the previous command relative\n        // to the current point.\n        controlX = current[1];\n        controlY = current[2];\n\n        break;\n\n      case 'q': // quadraticCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        g.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'Q': // quadraticCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n\n        g.quadraticCurveTo(\n          current[1] + l,\n          current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        controlX = current[1];\n        controlY = current[2];\n        break;\n\n      case 't': // shorthand quadraticCurveTo, relative\n\n        // transform to absolute x,y\n        tempX = x + current[1];\n        tempY = y + current[2];\n\n        if (previous[0].match(/[QqTt]/) === null) {\n          // If there is no previous command or if the previous command was not a Q, q, T or t,\n          // assume the control point is coincident with the current point\n          controlX = x;\n          controlY = y;\n        }\n        else if (previous[0] === 't') {\n          // calculate reflection of previous control points for t\n          controlX = 2 * x - tempControlX;\n          controlY = 2 * y - tempControlY;\n        }\n        else if (previous[0] === 'q') {\n          // calculate reflection of previous control points for q\n          controlX = 2 * x - controlX;\n          controlY = 2 * y - controlY;\n        }\n\n        tempControlX = controlX;\n        tempControlY = controlY;\n\n        g.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        controlX = x + current[1];\n        controlY = y + current[2];\n        break;\n\n      case 'T':\n        tempX = current[1];\n        tempY = current[2];\n\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        g.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'a':\n        drawArc(g, x + l, y + t, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6] + x + l,\n          current[7] + y + t\n        ]);\n        x += current[6];\n        y += current[7];\n        break;\n\n      case 'A':\n        drawArc(g, x + l, y + t, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6] + l,\n          current[7] + t\n        ]);\n        x = current[6];\n        y = current[7];\n        break;\n\n      case 'z':\n      case 'Z':\n        g.closePath();\n        break;\n    }\n    previous = current;\n  }\n};\n\nfunction drawArc(g, x, y, coords) {\n  var seg = arc.segments(\n    coords[5], // end x\n    coords[6], // end y\n    coords[0], // radius x\n    coords[1], // radius y\n    coords[3], // large flag\n    coords[4], // sweep flag\n    coords[2], // rotation\n    x, y\n  );\n  for (var i=0; i<seg.length; ++i) {\n    var bez = arc.bezier(seg[i]);\n    g.bezierCurveTo.apply(g, bez);\n  }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-scenegraph/src/path/render.js\n ** module id = 66\n ** module chunks = 0\n **/","var segmentCache = {},\n    bezierCache = {},\n    join = [].join;\n\n// Copied from Inkscape svgtopdf, thanks!\nfunction segments(x, y, rx, ry, large, sweep, rotateX, ox, oy) {\n  var key = join.call(arguments);\n  if (segmentCache[key]) {\n    return segmentCache[key];\n  }\n\n  var th = rotateX * (Math.PI/180);\n  var sin_th = Math.sin(th);\n  var cos_th = Math.cos(th);\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  var px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;\n  var py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;\n  var pl = (px*px) / (rx*rx) + (py*py) / (ry*ry);\n  if (pl > 1) {\n    pl = Math.sqrt(pl);\n    rx *= pl;\n    ry *= pl;\n  }\n\n  var a00 = cos_th / rx;\n  var a01 = sin_th / rx;\n  var a10 = (-sin_th) / ry;\n  var a11 = (cos_th) / ry;\n  var x0 = a00 * ox + a01 * oy;\n  var y0 = a10 * ox + a11 * oy;\n  var x1 = a00 * x + a01 * y;\n  var y1 = a10 * x + a11 * y;\n\n  var d = (x1-x0) * (x1-x0) + (y1-y0) * (y1-y0);\n  var sfactor_sq = 1 / d - 0.25;\n  if (sfactor_sq < 0) sfactor_sq = 0;\n  var sfactor = Math.sqrt(sfactor_sq);\n  if (sweep == large) sfactor = -sfactor;\n  var xc = 0.5 * (x0 + x1) - sfactor * (y1-y0);\n  var yc = 0.5 * (y0 + y1) + sfactor * (x1-x0);\n\n  var th0 = Math.atan2(y0-yc, x0-xc);\n  var th1 = Math.atan2(y1-yc, x1-xc);\n\n  var th_arc = th1-th0;\n  if (th_arc < 0 && sweep === 1){\n    th_arc += 2 * Math.PI;\n  } else if (th_arc > 0 && sweep === 0) {\n    th_arc -= 2 * Math.PI;\n  }\n\n  var segs = Math.ceil(Math.abs(th_arc / (Math.PI * 0.5 + 0.001)));\n  var result = [];\n  for (var i=0; i<segs; ++i) {\n    var th2 = th0 + i * th_arc / segs;\n    var th3 = th0 + (i+1) * th_arc / segs;\n    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];\n  }\n\n  return (segmentCache[key] = result);\n}\n\nfunction bezier(params) {\n  var key = join.call(params);\n  if (bezierCache[key]) {\n    return bezierCache[key];\n  }\n  \n  var cx = params[0],\n      cy = params[1],\n      th0 = params[2],\n      th1 = params[3],\n      rx = params[4],\n      ry = params[5],\n      sin_th = params[6],\n      cos_th = params[7];\n\n  var a00 = cos_th * rx;\n  var a01 = -sin_th * ry;\n  var a10 = sin_th * rx;\n  var a11 = cos_th * ry;\n\n  var cos_th0 = Math.cos(th0);\n  var sin_th0 = Math.sin(th0);\n  var cos_th1 = Math.cos(th1);\n  var sin_th1 = Math.sin(th1);\n\n  var th_half = 0.5 * (th1 - th0);\n  var sin_th_h2 = Math.sin(th_half * 0.5);\n  var t = (8/3) * sin_th_h2 * sin_th_h2 / Math.sin(th_half);\n  var x1 = cx + cos_th0 - t * sin_th0;\n  var y1 = cy + sin_th0 + t * cos_th0;\n  var x3 = cx + cos_th1;\n  var y3 = cy + sin_th1;\n  var x2 = x3 + t * sin_th1;\n  var y2 = y3 - t * cos_th1;\n\n  return (bezierCache[key] = [\n    a00 * x1 + a01 * y1,  a10 * x1 + a11 * y1,\n    a00 * x2 + a01 * y2,  a10 * x2 + a11 * y2,\n    a00 * x3 + a01 * y3,  a10 * x3 + a11 * y3\n  ]);\n}\n\nmodule.exports = {\n  segments: segments,\n  bezier: bezier,\n  cache: {\n    segments: segmentCache,\n    bezier: bezierCache\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-scenegraph/src/path/arc.js\n ** module id = 67\n ** module chunks = 0\n **/","module.exports = {\n  'canvas': require('./canvas'),\n  'svg':    require('./svg')\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-scenegraph/src/render/index.js\n ** module id = 68\n ** module chunks = 0\n **/","module.exports = {\n  Handler:  require('./CanvasHandler'),\n  Renderer: require('./CanvasRenderer')\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-scenegraph/src/render/canvas/index.js\n ** module id = 69\n ** module chunks = 0\n **/","var DOM = require('../../util/dom'),\n    Handler = require('../Handler'),\n    marks = require('./marks');\n\nfunction CanvasHandler() {\n  Handler.call(this);\n  this._down = null;\n  this._touch = null;\n  this._first = true;\n}\n\nvar base = Handler.prototype;\nvar prototype = (CanvasHandler.prototype = Object.create(base));\nprototype.constructor = CanvasHandler;\n\nprototype.initialize = function(el, pad, obj) {\n  // add event listeners\n  var canvas = this._canvas = DOM.find(el, 'canvas');\n  if (canvas) {\n    var that = this;\n    this.events.forEach(function(type) {\n      canvas.addEventListener(type, function(evt) {\n        if (prototype[type]) {\n          prototype[type].call(that, evt);\n        } else {\n          that.fire(type, evt);\n        }\n      });\n    });\n  }\n\n  return base.initialize.call(this, el, pad, obj);\n};\n\nprototype.canvas = function() {\n  return this._canvas;\n};\n\n// retrieve the current canvas context\nprototype.context = function() {\n  return this._canvas.getContext('2d');\n};\n\n// supported events\nprototype.events = [\n  'keydown',\n  'keypress',\n  'keyup',\n  'dragenter',\n  'dragleave',\n  'dragover',\n  'mousedown',\n  'mouseup',\n  'mousemove',\n  'mouseout',\n  'mouseover',\n  'click',\n  'dblclick',\n  'wheel',\n  'mousewheel',\n  'touchstart',\n  'touchmove',\n  'touchend'\n];\n\n// to keep firefox happy\nprototype.DOMMouseScroll = function(evt) {\n  this.fire('mousewheel', evt);\n};\n\nfunction move(moveEvent, overEvent, outEvent) {\n  return function(evt) {\n    var a = this._active,\n        p = this.pickEvent(evt);\n\n    if (p === a) {\n      // active item and picked item are the same\n      this.fire(moveEvent, evt); // fire move\n    } else {\n      // active item and picked item are different\n      this.fire(outEvent, evt);  // fire out for prior active item\n      this._active = p;            // set new active item\n      this.fire(overEvent, evt); // fire over for new active item\n      this.fire(moveEvent, evt); // fire move for new active item\n    }\n  };\n}\n\nfunction inactive(type) {\n  return function(evt) {\n    this.fire(type, evt);\n    this._active = null;\n  };\n}\n\nprototype.mousemove = move('mousemove', 'mouseover', 'mouseout');\nprototype.dragover  = move('dragover', 'dragenter', 'dragleave');\n\nprototype.mouseout  = inactive('mouseout');\nprototype.dragleave = inactive('dragleave');\n\nprototype.mousedown = function(evt) {\n  this._down = this._active;\n  this.fire('mousedown', evt);\n};\n\nprototype.click = function(evt) {\n  if (this._down === this._active) {\n    this.fire('click', evt);\n    this._down = null;\n  }\n};\n\nprototype.touchstart = function(evt) {\n  this._touch = this.pickEvent(evt.changedTouches[0]);\n\n  if (this._first) {\n    this._active = this._touch;\n    this._first = false;\n  }\n\n  this.fire('touchstart', evt, true);\n};\n\nprototype.touchmove = function(evt) {\n  this.fire('touchmove', evt, true);\n};\n\nprototype.touchend = function(evt) {\n  this.fire('touchend', evt, true);\n  this._touch = null;\n};\n\n// fire an event\nprototype.fire = function(type, evt, touch) {\n  var a = touch ? this._touch : this._active,\n      h = this._handlers[type], i, len;\n  if (h) {\n    evt.vegaType = type;\n    for (i=0, len=h.length; i<len; ++i) {\n      h[i].handler.call(this._obj, evt, a);\n    }\n  }\n};\n\n// add an event handler\nprototype.on = function(type, handler) {\n  var name = this.eventName(type),\n      h = this._handlers;\n  (h[name] || (h[name] = [])).push({\n    type: type,\n    handler: handler\n  });\n  return this;\n};\n\n// remove an event handler\nprototype.off = function(type, handler) {\n  var name = this.eventName(type),\n      h = this._handlers[name], i;\n  if (!h) return;\n  for (i=h.length; --i>=0;) {\n    if (h[i].type !== type) continue;\n    if (!handler || h[i].handler === handler) h.splice(i, 1);\n  }\n  return this;\n};\n\nprototype.pickEvent = function(evt) {\n  var rect = this._canvas.getBoundingClientRect(),\n      pad = this._padding, x, y;\n  return this.pick(this._scene,\n    x = (evt.clientX - rect.left),\n    y = (evt.clientY - rect.top),\n    x - pad.left, y - pad.top);\n};\n\n// find the scenegraph item at the current mouse position\n// x, y -- the absolute x, y mouse coordinates on the canvas element\n// gx, gy -- the relative coordinates within the current group\nprototype.pick = function(scene, x, y, gx, gy) {\n  var g = this.context(),\n      mark = marks[scene.marktype];\n  return mark.pick.call(this, g, scene, x, y, gx, gy);\n};\n\nmodule.exports = CanvasHandler;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-scenegraph/src/render/canvas/CanvasHandler.js\n ** module id = 70\n ** module chunks = 0\n **/","// create a new DOM element\nfunction create(doc, tag, ns) {\n  return ns ? doc.createElementNS(ns, tag) : doc.createElement(tag);\n}\n\n// remove element from DOM\n// recursively remove parent elements if empty\nfunction remove(el) {\n  if (!el) return;\n  var p = el.parentNode;\n  if (p) {\n    p.removeChild(el);\n    if (!p.childNodes || !p.childNodes.length) remove(p);\n  }\n}\n\nmodule.exports = {\n  // find first child element with matching tag\n  find: function(el, tag) {\n    tag = tag.toLowerCase();\n    for (var i=0, n=el.childNodes.length; i<n; ++i) {\n      if (el.childNodes[i].tagName.toLowerCase() === tag) {\n        return el.childNodes[i];\n      }\n    }\n  },\n  // retrieve child element at given index\n  // create & insert if doesn't exist or if tag/className do not match\n  child: function(el, index, tag, ns, className, insert) {\n    var a, b;\n    a = b = el.childNodes[index];\n    if (!a || insert ||\n        a.tagName.toLowerCase() !== tag.toLowerCase() ||\n        className && a.getAttribute('class') != className) {\n      a = create(el.ownerDocument, tag, ns);\n      el.insertBefore(a, b);\n      if (className) a.setAttribute('class', className);\n    }\n    return a;\n  },\n  // remove all child elements at or above the given index\n  clear: function(el, index) {\n    var curr = el.childNodes.length;\n    while (curr > index) {\n      el.removeChild(el.childNodes[--curr]);\n    }\n    return el;\n  },\n  remove: remove,\n  // generate css class name for mark\n  cssClass: function(mark) {\n    return 'mark-' + mark.marktype + (mark.name ? ' '+mark.name : '');\n  },\n  // generate string for an opening xml tag\n  // tag: the name of the xml tag\n  // attr: hash of attribute name-value pairs to include\n  // raw: additional raw string to include in tag markup\n  openTag: function(tag, attr, raw) {\n    var s = '<' + tag, key, val;\n    if (attr) {\n      for (key in attr) {\n        val = attr[key];\n        if (val != null) {\n          s += ' ' + key + '=\"' + val + '\"';\n        }\n      }\n    }\n    if (raw) s += ' ' + raw;\n    return s + '>';\n  },\n  // generate string for closing xml tag\n  // tag: the name of the xml tag\n  closeTag: function(tag) {\n    return '</' + tag + '>';\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-scenegraph/src/util/dom.js\n ** module id = 71\n ** module chunks = 0\n **/","function Handler() {\n  this._active = null;\n  this._handlers = {};\n}\n\nvar prototype = Handler.prototype;\n\nprototype.initialize = function(el, pad, obj) {\n  this._el = el;\n  this._obj = obj || null;\n  return this.padding(pad);\n};\n\nprototype.element = function() {\n  return this._el;\n};\n\nprototype.padding = function(pad) {\n  this._padding = pad || {top:0, left:0, bottom:0, right:0};\n  return this;\n};\n\nprototype.scene = function(scene) {\n  if (!arguments.length) return this._scene;\n  this._scene = scene;\n  return this;\n};\n\n// add an event handler\n// subclasses should override\nprototype.on = function(/*type, handler*/) {};\n\n// remove an event handler\n// subclasses should override\nprototype.off = function(/*type, handler*/) {};\n\n// return an array with all registered event handlers\nprototype.handlers = function() {\n  var h = this._handlers, a = [], k;\n  for (k in h) { a.push.apply(a, h[k]); }\n  return a;\n};\n\nprototype.eventName = function(name) {\n  var i = name.indexOf('.');\n  return i < 0 ? name : name.slice(0,i);\n};\n\nmodule.exports = Handler;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-scenegraph/src/render/Handler.js\n ** module id = 72\n ** module chunks = 0\n **/","module.exports = {\n  arc:    require('./arc'),\n  area:   require('./area'),\n  group:  require('./group'),\n  image:  require('./image'),\n  line:   require('./line'),\n  path:   require('./path'),\n  rect:   require('./rect'),\n  rule:   require('./rule'),\n  symbol: require('./symbol'),\n  text:   require('./text')\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-scenegraph/src/render/canvas/marks/index.js\n ** module id = 73\n ** module chunks = 0\n **/","var util = require('./util');\nvar halfpi = Math.PI / 2;\n\nfunction path(g, o) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      ir = o.innerRadius || 0,\n      or = o.outerRadius || 0,\n      sa = (o.startAngle || 0) - halfpi,\n      ea = (o.endAngle || 0) - halfpi;\n  g.beginPath();\n  if (ir === 0) g.moveTo(x, y);\n  else g.arc(x, y, ir, sa, ea, 0);\n  g.arc(x, y, or, ea, sa, 1);\n  g.closePath();\n}\n\nmodule.exports = {\n  draw: util.drawAll(path),\n  pick: util.pickPath(path)\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-scenegraph/src/render/canvas/marks/arc.js\n ** module id = 74\n ** module chunks = 0\n **/","function drawPathOne(path, g, o, items) {\n  if (path(g, items)) return;\n\n  var opac = o.opacity == null ? 1 : o.opacity;\n  if (opac===0) return;\n\n  if (o.fill && fill(g, o, opac)) { g.fill(); }\n  if (o.stroke && stroke(g, o, opac)) { g.stroke(); }\n}\n\nfunction drawPathAll(path, g, scene, bounds) {\n  var i, len, item;\n  for (i=0, len=scene.items.length; i<len; ++i) {\n    item = scene.items[i];\n    if (!bounds || bounds.intersects(item.bounds)) {\n      drawPathOne(path, g, item, item);\n    }\n  }\n}\n\nfunction drawAll(pathFunc) {\n  return function(g, scene, bounds) {\n    drawPathAll(pathFunc, g, scene, bounds);\n  };\n}\n\nfunction drawOne(pathFunc) {\n  return function(g, scene, bounds) {\n    if (!scene.items.length) return;\n    if (!bounds || bounds.intersects(scene.bounds)) {\n      drawPathOne(pathFunc, g, scene.items[0], scene.items);\n    }\n  };\n}\n\nvar trueFunc = function() { return true; };\n\nfunction pick(test) {\n  if (!test) test = trueFunc;\n\n  return function(g, scene, x, y, gx, gy) {\n    if (!scene.items.length) return null;\n\n    var o, b, i;\n\n    if (g.pixelratio != null && g.pixelratio !== 1) {\n      x *= g.pixelratio;\n      y *= g.pixelratio;\n    }\n\n    for (i=scene.items.length; --i >= 0;) {\n      o = scene.items[i]; b = o.bounds;\n      // first hit test against bounding box\n      if ((b && !b.contains(gx, gy)) || !b) continue;\n      // if in bounding box, perform more careful test\n      if (test(g, o, x, y, gx, gy)) return o;\n    }\n    return null;\n  };\n}\n\nfunction testPath(path, filled) {\n  return function(g, o, x, y) {\n    var item = Array.isArray(o) ? o[0] : o,\n        fill = (filled == null) ? item.fill : filled,\n        stroke = item.stroke && g.isPointInStroke, lw, lc;\n\n    if (stroke) {\n      lw = item.strokeWidth;\n      lc = item.strokeCap;\n      g.lineWidth = lw != null ? lw : 1;\n      g.lineCap   = lc != null ? lc : 'butt';\n    }\n\n    return path(g, o) ? false :\n      (fill && g.isPointInPath(x, y)) ||\n      (stroke && g.isPointInStroke(x, y));\n  };\n}\n\nfunction pickPath(path) {\n  return pick(testPath(path));\n}\n\nfunction fill(g, o, opacity) {\n  opacity *= (o.fillOpacity==null ? 1 : o.fillOpacity);\n  if (opacity > 0) {\n    g.globalAlpha = opacity;\n    g.fillStyle = color(g, o, o.fill);\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction stroke(g, o, opacity) {\n  var lw = (lw = o.strokeWidth) != null ? lw : 1, lc;\n  if (lw <= 0) return false;\n\n  opacity *= (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n  if (opacity > 0) {\n    g.globalAlpha = opacity;\n    g.strokeStyle = color(g, o, o.stroke);\n    g.lineWidth = lw;\n    g.lineCap = (lc = o.strokeCap) != null ? lc : 'butt';\n    g.vgLineDash(o.strokeDash || null);\n    g.vgLineDashOffset(o.strokeDashOffset || 0);\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction color(g, o, value) {\n  return (value.id) ?\n    gradient(g, value, o.bounds) :\n    value;\n}\n\nfunction gradient(g, p, b) {\n  var w = b.width(),\n      h = b.height(),\n      x1 = b.x1 + p.x1 * w,\n      y1 = b.y1 + p.y1 * h,\n      x2 = b.x1 + p.x2 * w,\n      y2 = b.y1 + p.y2 * h,\n      grad = g.createLinearGradient(x1, y1, x2, y2),\n      stop = p.stops,\n      i, n;\n\n  for (i=0, n=stop.length; i<n; ++i) {\n    grad.addColorStop(stop[i].offset, stop[i].color);\n  }\n  return grad;\n}\n\nmodule.exports = {\n  drawOne:  drawOne,\n  drawAll:  drawAll,\n  pick:     pick,\n  pickPath: pickPath,\n  testPath: testPath,\n  stroke:   stroke,\n  fill:     fill,\n  color:    color,\n  gradient: gradient\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-scenegraph/src/render/canvas/marks/util.js\n ** module id = 75\n ** module chunks = 0\n **/","var util = require('./util'),\n    parse = require('../../../path/parse'),\n    render = require('../../../path/render'),\n    areaPath = require('../../../util/svg').path.area;\n\nfunction path(g, items) {\n  var o = items[0],\n      p = o.pathCache || (o.pathCache = parse(areaPath(items)));\n  render(g, p);\n}\n\nfunction pick(g, scene, x, y, gx, gy) {\n  var items = scene.items,\n      b = scene.bounds;\n\n  if (!items || !items.length || b && !b.contains(gx, gy)) {\n    return null;\n  }\n\n  if (g.pixelratio != null && g.pixelratio !== 1) {\n    x *= g.pixelratio;\n    y *= g.pixelratio;\n  }\n  return hit(g, items, x, y) ? items[0] : null;\n}\n\nvar hit = util.testPath(path);\n\nmodule.exports = {\n  draw: util.drawOne(path),\n  pick: pick,\n  nested: true\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-scenegraph/src/render/canvas/marks/area.js\n ** module id = 76\n ** module chunks = 0\n **/","var d3_svg = require('d3').svg;\n\nfunction x(o)     { return o.x || 0; }\nfunction y(o)     { return o.y || 0; }\nfunction xw(o)    { return (o.x || 0) + (o.width || 0); }\nfunction yh(o)    { return (o.y || 0) + (o.height || 0); }\nfunction size(o)  { return o.size == null ? 100 : o.size; }\nfunction shape(o) { return o.shape || 'circle'; }\n\nvar areav = d3_svg.area().x(x).y1(y).y0(yh),\n    areah = d3_svg.area().y(y).x1(x).x0(xw),\n    line  = d3_svg.line().x(x).y(y);\n\nmodule.exports = {\n  metadata: {\n    'version': '1.1',\n    'xmlns': 'http://www.w3.org/2000/svg',\n    'xmlns:xlink': 'http://www.w3.org/1999/xlink'\n  },\n  path: {\n    arc: d3_svg.arc(),\n    symbol: d3_svg.symbol().type(shape).size(size),\n    area: function(items) {\n      var o = items[0];\n      return (o.orient === 'horizontal' ? areah : areav)\n        .interpolate(o.interpolate || 'linear')\n        .tension(o.tension || 0.7)\n        (items);\n    },\n    line: function(items) {\n      var o = items[0];\n      return line\n        .interpolate(o.interpolate || 'linear')\n        .tension(o.tension || 0.7)\n        (items);\n    }\n  },\n  textAlign: {\n    'left':   'start',\n    'center': 'middle',\n    'right':  'end'\n  },\n  textBaseline: {\n    'top':    'before-edge',\n    'bottom': 'after-edge',\n    'middle': 'central'\n  },\n  styles: {\n    'fill':             'fill',\n    'fillOpacity':      'fill-opacity',\n    'stroke':           'stroke',\n    'strokeWidth':      'stroke-width',\n    'strokeOpacity':    'stroke-opacity',\n    'strokeCap':        'stroke-linecap',\n    'strokeDash':       'stroke-dasharray',\n    'strokeDashOffset': 'stroke-dashoffset',\n    'opacity':          'opacity'\n  },\n  styleProperties: [\n    'fill',\n    'fillOpacity',\n    'stroke',\n    'strokeWidth',\n    'strokeOpacity',\n    'strokeCap',\n    'strokeDash',\n    'strokeDashOffset',\n    'opacity'\n  ]\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-scenegraph/src/util/svg.js\n ** module id = 77\n ** module chunks = 0\n **/","var util = require('./util'),\n    EMPTY = [];\n\nfunction draw(g, scene, bounds) {\n  if (!scene.items || !scene.items.length) return;\n\n  var groups = scene.items,\n      renderer = this,\n      group, items, axes, legends, gx, gy, w, h, opac, i, n, j, m;\n\n  for (i=0, n=groups.length; i<n; ++i) {\n    group = groups[i];\n    axes = group.axisItems || EMPTY;\n    items = group.items || EMPTY;\n    legends = group.legendItems || EMPTY;\n    gx = group.x || 0;\n    gy = group.y || 0;\n    w = group.width || 0;\n    h = group.height || 0;\n\n    // draw group background\n    if (group.stroke || group.fill) {\n      opac = group.opacity == null ? 1 : group.opacity;\n      if (opac > 0) {\n        if (group.fill && util.fill(g, group, opac)) {\n          g.fillRect(gx, gy, w, h);\n        }\n        if (group.stroke && util.stroke(g, group, opac)) {\n          g.strokeRect(gx, gy, w, h);\n        }\n      }\n    }\n\n    // setup graphics context\n    g.save();\n    g.translate(gx, gy);\n    if (group.clip) {\n      g.beginPath();\n      g.rect(0, 0, w, h);\n      g.clip();\n    }\n    if (bounds) bounds.translate(-gx, -gy);\n\n    // draw group contents\n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].layer === 'back') {\n        renderer.draw(g, axes[j], bounds);\n      }\n    }\n    for (j=0, m=items.length; j<m; ++j) {\n      renderer.draw(g, items[j], bounds);\n    }\n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].layer !== 'back') {\n        renderer.draw(g, axes[j], bounds);\n      }\n    }\n    for (j=0, m=legends.length; j<m; ++j) {\n      renderer.draw(g, legends[j], bounds);\n    }\n\n    // restore graphics context\n    if (bounds) bounds.translate(gx, gy);\n    g.restore();\n  }    \n}\n\nfunction pick(g, scene, x, y, gx, gy) {\n  if (scene.bounds && !scene.bounds.contains(gx, gy)) {\n    return null;\n  }\n\n  var groups = scene.items || EMPTY, subscene,\n      group, axes, items, legends, hits, dx, dy, i, j, b;\n\n  for (i=groups.length; --i>=0;) {\n    group = groups[i];\n\n    // first hit test against bounding box\n    // if a group is clipped, that should be handled by the bounds check.\n    b = group.bounds;\n    if (b && !b.contains(gx, gy)) continue;\n\n    // passed bounds check, so test sub-groups\n    axes = group.axisItems || EMPTY;\n    items = group.items || EMPTY;\n    legends = group.legendItems || EMPTY;\n    dx = (group.x || 0);\n    dy = (group.y || 0);\n\n    g.save();\n    g.translate(dx, dy);\n    dx = gx - dx;\n    dy = gy - dy;\n    for (j=legends.length; --j>=0;) {\n      subscene = legends[j];\n      if (subscene.interactive !== false) {\n        hits = this.pick(subscene, x, y, dx, dy);\n        if (hits) { g.restore(); return hits; }\n      }\n    }\n    for (j=axes.length; --j>=0;) {\n      subscene = axes[j];\n      if (subscene.interactive !== false && subscene.layer !== 'back') {\n        hits = this.pick(subscene, x, y, dx, dy);\n        if (hits) { g.restore(); return hits; }\n      }\n    }\n    for (j=items.length; --j>=0;) {\n      subscene = items[j];\n      if (subscene.interactive !== false) {\n        hits = this.pick(subscene, x, y, dx, dy);\n        if (hits) { g.restore(); return hits; }\n      }\n    }\n    for (j=axes.length; --j>=0;) {\n      subscene = axes[j];\n      if (subscene.interative !== false && subscene.layer === 'back') {\n        hits = this.pick(subscene, x, y, dx, dy);\n        if (hits) { g.restore(); return hits; }\n      }\n    }\n    g.restore();\n\n    if (scene.interactive !== false && (group.fill || group.stroke) &&\n        dx >= 0 && dx <= group.width && dy >= 0 && dy <= group.height) {\n      return group;\n    }\n  }\n\n  return null;\n}\n\nmodule.exports = {\n  draw: draw,\n  pick: pick\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-scenegraph/src/render/canvas/marks/group.js\n ** module id = 78\n ** module chunks = 0\n **/","var util = require('./util');\n\nfunction draw(g, scene, bounds) {\n  if (!scene.items || !scene.items.length) return;\n\n  var renderer = this,\n      items = scene.items, o;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    if (!(o.image && o.image.url === o.url)) {\n      o.image = renderer.loadImage(o.url);\n      o.image.url = o.url;\n    }\n\n    var x = o.x || 0,\n        y = o.y || 0,\n        w = o.width || (o.image && o.image.width) || 0,\n        h = o.height || (o.image && o.image.height) || 0,\n        opac;\n    x = x - (o.align==='center' ? w/2 : o.align==='right' ? w : 0);\n    y = y - (o.baseline==='middle' ? h/2 : o.baseline==='bottom' ? h : 0);\n\n    if (o.image.loaded) {\n      g.globalAlpha = (opac = o.opacity) != null ? opac : 1;\n      g.drawImage(o.image, x, y, w, h);\n    }\n  }\n}\n\nmodule.exports = {\n  draw: draw,\n  pick: util.pick()\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-scenegraph/src/render/canvas/marks/image.js\n ** module id = 79\n ** module chunks = 0\n **/","var util = require('./util'),\n    parse = require('../../../path/parse'),\n    render = require('../../../path/render'),\n    linePath = require('../../../util/svg').path.line;\n    \nfunction path(g, items) {\n  var o = items[0],\n      p = o.pathCache || (o.pathCache = parse(linePath(items)));\n  render(g, p);\n}\n\nfunction pick(g, scene, x, y, gx, gy) {\n  var items = scene.items,\n      b = scene.bounds;\n\n  if (!items || !items.length || b && !b.contains(gx, gy)) {\n    return null;\n  }\n\n  if (g.pixelratio != null && g.pixelratio !== 1) {\n    x *= g.pixelratio;\n    y *= g.pixelratio;\n  }\n  return hit(g, items, x, y) ? items[0] : null;\n}\n\nvar hit = util.testPath(path, false);\n\nmodule.exports = {\n  draw: util.drawOne(path),\n  pick: pick,\n  nested: true\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-scenegraph/src/render/canvas/marks/line.js\n ** module id = 80\n ** module chunks = 0\n **/","var util = require('./util'),\n    parse = require('../../../path/parse'),\n    render = require('../../../path/render');\n\nfunction path(g, o) {\n  if (o.path == null) return true;\n  var p = o.pathCache || (o.pathCache = parse(o.path));\n  render(g, p, o.x, o.y);\n}\n\nmodule.exports = {\n  draw: util.drawAll(path),\n  pick: util.pickPath(path)\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-scenegraph/src/render/canvas/marks/path.js\n ** module id = 81\n ** module chunks = 0\n **/","var util = require('./util');\n\nfunction draw(g, scene, bounds) {\n  if (!scene.items || !scene.items.length) return;\n\n  var items = scene.items,\n      o, opac, x, y, w, h;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    opac = o.opacity == null ? 1 : o.opacity;\n    if (opac === 0) continue;\n\n    x = o.x || 0;\n    y = o.y || 0;\n    w = o.width || 0;\n    h = o.height || 0;\n\n    if (o.fill && util.fill(g, o, opac)) {\n      g.fillRect(x, y, w, h);\n    }\n    if (o.stroke && util.stroke(g, o, opac)) {\n      g.strokeRect(x, y, w, h);\n    }\n  }\n}\n\nmodule.exports = {\n  draw: draw,\n  pick: util.pick()\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-scenegraph/src/render/canvas/marks/rect.js\n ** module id = 82\n ** module chunks = 0\n **/","var util = require('./util');\n\nfunction draw(g, scene, bounds) {\n  if (!scene.items || !scene.items.length) return;\n\n  var items = scene.items,\n      o, opac, x1, y1, x2, y2;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    opac = o.opacity == null ? 1 : o.opacity;\n    if (opac === 0) continue;\n      \n    x1 = o.x || 0;\n    y1 = o.y || 0;\n    x2 = o.x2 != null ? o.x2 : x1;\n    y2 = o.y2 != null ? o.y2 : y1;\n\n    if (o.stroke && util.stroke(g, o, opac)) {\n      g.beginPath();\n      g.moveTo(x1, y1);\n      g.lineTo(x2, y2);\n      g.stroke();\n    }\n  }\n}\n\nfunction stroke(g, o) {\n  var x1 = o.x || 0,\n      y1 = o.y || 0,\n      x2 = o.x2 != null ? o.x2 : x1,\n      y2 = o.y2 != null ? o.y2 : y1,\n      lw = o.strokeWidth,\n      lc = o.strokeCap;\n\n  g.lineWidth = lw != null ? lw : 1;\n  g.lineCap   = lc != null ? lc : 'butt';\n  g.beginPath();\n  g.moveTo(x1, y1);\n  g.lineTo(x2, y2);\n}\n\nfunction hit(g, o, x, y) {\n  if (!g.isPointInStroke) return false;\n  stroke(g, o);\n  return g.isPointInStroke(x, y);\n}\n\nmodule.exports = {\n  draw: draw,\n  pick: util.pick(hit)\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-scenegraph/src/render/canvas/marks/rule.js\n ** module id = 83\n ** module chunks = 0\n **/","var util = require('./util');\n\nvar sqrt3 = Math.sqrt(3),\n    tan30 = Math.tan(30 * Math.PI / 180);\n\nfunction path(g, o) {\n  var size = o.size != null ? o.size : 100,\n      x = o.x, y = o.y, r, t, rx, ry;\n\n  g.beginPath();\n\n  if (o.shape == null || o.shape === 'circle') {\n    r = Math.sqrt(size / Math.PI);\n    g.arc(x, y, r, 0, 2*Math.PI, 0);\n    g.closePath();\n    return;\n  }\n\n  switch (o.shape) {\n    case 'cross':\n      r = Math.sqrt(size / 5) / 2;\n      t = 3*r;\n      g.moveTo(x-t, y-r);\n      g.lineTo(x-r, y-r);\n      g.lineTo(x-r, y-t);\n      g.lineTo(x+r, y-t);\n      g.lineTo(x+r, y-r);\n      g.lineTo(x+t, y-r);\n      g.lineTo(x+t, y+r);\n      g.lineTo(x+r, y+r);\n      g.lineTo(x+r, y+t);\n      g.lineTo(x-r, y+t);\n      g.lineTo(x-r, y+r);\n      g.lineTo(x-t, y+r);\n      break;\n\n    case 'diamond':\n      ry = Math.sqrt(size / (2 * tan30));\n      rx = ry * tan30;\n      g.moveTo(x, y-ry);\n      g.lineTo(x+rx, y);\n      g.lineTo(x, y+ry);\n      g.lineTo(x-rx, y);\n      break;\n\n    case 'square':\n      t = Math.sqrt(size);\n      r = t / 2;\n      g.rect(x-r, y-r, t, t);\n      break;\n\n    case 'triangle-down':\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      g.moveTo(x, y+ry);\n      g.lineTo(x+rx, y-ry);\n      g.lineTo(x-rx, y-ry);\n      break;\n\n    case 'triangle-up':\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      g.moveTo(x, y-ry);\n      g.lineTo(x+rx, y+ry);\n      g.lineTo(x-rx, y+ry);\n  }\n  g.closePath();\n}\n\nmodule.exports = {\n  draw: util.drawAll(path),\n  pick: util.pickPath(path)\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-scenegraph/src/render/canvas/marks/symbol.js\n ** module id = 84\n ** module chunks = 0\n **/","var Bounds = require('../../../util/Bounds'),\n    textBounds = require('../../../util/bound').text,\n    text = require('../../../util/text'),\n    util = require('./util'),\n    tempBounds = new Bounds();\n\nfunction draw(g, scene, bounds) {\n  if (!scene.items || !scene.items.length) return;\n\n  var items = scene.items,\n      o, opac, x, y, r, t, str;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    str = text.value(o.text);\n    if (!str) continue;\n    opac = o.opacity == null ? 1 : o.opacity;\n    if (opac === 0) continue;\n\n    g.font = text.font(o);\n    g.textAlign = o.align || 'left';\n\n    x = (o.x || 0);\n    y = (o.y || 0);\n    if ((r = o.radius)) {\n      t = (o.theta || 0) - Math.PI/2;\n      x += r * Math.cos(t);\n      y += r * Math.sin(t);\n    }\n\n    if (o.angle) {\n      g.save();\n      g.translate(x, y);\n      g.rotate(o.angle * Math.PI/180);\n      x = y = 0; // reset x, y\n    }\n    x += (o.dx || 0);\n    y += (o.dy || 0) + text.offset(o);\n\n    if (o.fill && util.fill(g, o, opac)) {\n      g.fillText(str, x, y);\n    }\n    if (o.stroke && util.stroke(g, o, opac)) {\n      g.strokeText(str, x, y);\n    }\n    if (o.angle) g.restore();\n  }\n}\n\nfunction hit(g, o, x, y, gx, gy) {\n  if (o.fontSize <= 0) return false;\n  if (!o.angle) return true; // bounds sufficient if no rotation\n\n  // project point into space of unrotated bounds\n  var b = textBounds(o, tempBounds, true),\n      a = -o.angle * Math.PI / 180,\n      cos = Math.cos(a),\n      sin = Math.sin(a),\n      ox = o.x,\n      oy = o.y,\n      px = cos*gx - sin*gy + (ox - ox*cos + oy*sin),\n      py = sin*gx + cos*gy + (oy - ox*sin - oy*cos);\n\n  return b.contains(px, py);\n}\n\nmodule.exports = {\n  draw: draw,\n  pick: util.pick(hit)\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-scenegraph/src/render/canvas/marks/text.js\n ** module id = 85\n ** module chunks = 0\n **/","function Bounds(b) {\n  this.clear();\n  if (b) this.union(b);\n}\n\nvar prototype = Bounds.prototype;\n\nprototype.clone = function() {\n  return new Bounds(this);\n};\n\nprototype.clear = function() {\n  this.x1 = +Number.MAX_VALUE;\n  this.y1 = +Number.MAX_VALUE;\n  this.x2 = -Number.MAX_VALUE;\n  this.y2 = -Number.MAX_VALUE;\n  return this;\n};\n\nprototype.set = function(x1, y1, x2, y2) {\n  this.x1 = x1;\n  this.y1 = y1;\n  this.x2 = x2;\n  this.y2 = y2;\n  return this;\n};\n\nprototype.add = function(x, y) {\n  if (x < this.x1) this.x1 = x;\n  if (y < this.y1) this.y1 = y;\n  if (x > this.x2) this.x2 = x;\n  if (y > this.y2) this.y2 = y;\n  return this;\n};\n\nprototype.expand = function(d) {\n  this.x1 -= d;\n  this.y1 -= d;\n  this.x2 += d;\n  this.y2 += d;\n  return this;\n};\n\nprototype.round = function() {\n  this.x1 = Math.floor(this.x1);\n  this.y1 = Math.floor(this.y1);\n  this.x2 = Math.ceil(this.x2);\n  this.y2 = Math.ceil(this.y2);\n  return this;\n};\n\nprototype.translate = function(dx, dy) {\n  this.x1 += dx;\n  this.x2 += dx;\n  this.y1 += dy;\n  this.y2 += dy;\n  return this;\n};\n\nprototype.rotate = function(angle, x, y) {\n  var cos = Math.cos(angle),\n      sin = Math.sin(angle),\n      cx = x - x*cos + y*sin,\n      cy = y - x*sin - y*cos,\n      x1 = this.x1, x2 = this.x2,\n      y1 = this.y1, y2 = this.y2;\n\n  return this.clear()\n    .add(cos*x1 - sin*y1 + cx,  sin*x1 + cos*y1 + cy)\n    .add(cos*x1 - sin*y2 + cx,  sin*x1 + cos*y2 + cy)\n    .add(cos*x2 - sin*y1 + cx,  sin*x2 + cos*y1 + cy)\n    .add(cos*x2 - sin*y2 + cx,  sin*x2 + cos*y2 + cy);\n};\n\nprototype.union = function(b) {\n  if (b.x1 < this.x1) this.x1 = b.x1;\n  if (b.y1 < this.y1) this.y1 = b.y1;\n  if (b.x2 > this.x2) this.x2 = b.x2;\n  if (b.y2 > this.y2) this.y2 = b.y2;\n  return this;\n};\n\nprototype.encloses = function(b) {\n  return b && (\n    this.x1 <= b.x1 &&\n    this.x2 >= b.x2 &&\n    this.y1 <= b.y1 &&\n    this.y2 >= b.y2\n  );\n};\n\nprototype.alignsWith = function(b) {\n  return b && (\n    this.x1 == b.x1 ||\n    this.x2 == b.x2 ||\n    this.y1 == b.y1 ||\n    this.y2 == b.y2\n  );\n};\n\nprototype.intersects = function(b) {\n  return b && !(\n    this.x2 < b.x1 ||\n    this.x1 > b.x2 ||\n    this.y2 < b.y1 ||\n    this.y1 > b.y2\n  );\n};\n\nprototype.contains = function(x, y) {\n  return !(\n    x < this.x1 ||\n    x > this.x2 ||\n    y < this.y1 ||\n    y > this.y2\n  );\n};\n\nprototype.width = function() {\n  return this.x2 - this.x1;\n};\n\nprototype.height = function() {\n  return this.y2 - this.y1;\n};\n\nmodule.exports = Bounds;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-scenegraph/src/util/Bounds.js\n ** module id = 86\n ** module chunks = 0\n **/","var BoundsContext = require('./BoundsContext'),\n    Bounds = require('./Bounds'),\n    canvas = require('./canvas'),\n    svg = require('./svg'),\n    text = require('./text'),\n    paths = require('../path'),\n    parse = paths.parse,\n    drawPath = paths.render,\n    areaPath = svg.path.area,\n    linePath = svg.path.line,\n    halfpi = Math.PI / 2,\n    sqrt3 = Math.sqrt(3),\n    tan30 = Math.tan(30 * Math.PI / 180),\n    g2D = null,\n    bc = BoundsContext();\n\nfunction context() {\n  return g2D || (g2D = canvas.instance(1,1).getContext('2d'));\n}\n\nfunction strokeBounds(o, bounds) {\n  if (o.stroke && o.opacity !== 0 && o.stokeOpacity !== 0) {\n    bounds.expand(o.strokeWidth != null ? o.strokeWidth : 1);\n  }\n  return bounds;\n}\n\nfunction pathBounds(o, path, bounds, x, y) {\n  if (path == null) {\n    bounds.set(0, 0, 0, 0);\n  } else {\n    drawPath(bc.bounds(bounds), path, x, y);\n    strokeBounds(o, bounds);\n  }\n  return bounds;\n}\n\nfunction path(o, bounds) {\n  var p = o.path ? o.pathCache || (o.pathCache = parse(o.path)) : null;\n  return pathBounds(o, p, bounds, o.x, o.y);\n}\n\nfunction area(mark, bounds) {\n  if (mark.items.length === 0) return bounds;\n  var items = mark.items,\n      item = items[0],\n      p = item.pathCache || (item.pathCache = parse(areaPath(items)));\n  return pathBounds(item, p, bounds);\n}\n\nfunction line(mark, bounds) {\n  if (mark.items.length === 0) return bounds;\n  var items = mark.items,\n      item = items[0],\n      p = item.pathCache || (item.pathCache = parse(linePath(items)));\n  return pathBounds(item, p, bounds);\n}\n\nfunction rect(o, bounds) {\n  var x, y;\n  return strokeBounds(o, bounds.set(\n    x = o.x || 0,\n    y = o.y || 0,\n    (x + o.width) || 0,\n    (y + o.height) || 0\n  ));\n}\n\nfunction image(o, bounds) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      w = o.width || 0,\n      h = o.height || 0;\n  x = x - (o.align === 'center' ? w/2 : (o.align === 'right' ? w : 0));\n  y = y - (o.baseline === 'middle' ? h/2 : (o.baseline === 'bottom' ? h : 0));\n  return bounds.set(x, y, x+w, y+h);\n}\n\nfunction rule(o, bounds) {\n  var x1, y1;\n  return strokeBounds(o, bounds.set(\n    x1 = o.x || 0,\n    y1 = o.y || 0,\n    o.x2 != null ? o.x2 : x1,\n    o.y2 != null ? o.y2 : y1\n  ));\n}\n\nfunction arc(o, bounds) {\n  var cx = o.x || 0,\n      cy = o.y || 0,\n      ir = o.innerRadius || 0,\n      or = o.outerRadius || 0,\n      sa = (o.startAngle || 0) - halfpi,\n      ea = (o.endAngle || 0) - halfpi,\n      xmin = Infinity, xmax = -Infinity,\n      ymin = Infinity, ymax = -Infinity,\n      a, i, n, x, y, ix, iy, ox, oy;\n\n  var angles = [sa, ea],\n      s = sa - (sa % halfpi);\n  for (i=0; i<4 && s<ea; ++i, s+=halfpi) {\n    angles.push(s);\n  }\n\n  for (i=0, n=angles.length; i<n; ++i) {\n    a = angles[i];\n    x = Math.cos(a); ix = ir*x; ox = or*x;\n    y = Math.sin(a); iy = ir*y; oy = or*y;\n    xmin = Math.min(xmin, ix, ox);\n    xmax = Math.max(xmax, ix, ox);\n    ymin = Math.min(ymin, iy, oy);\n    ymax = Math.max(ymax, iy, oy);\n  }\n\n  return strokeBounds(o, bounds.set(\n    cx + xmin,\n    cy + ymin,\n    cx + xmax,\n    cy + ymax\n  ));\n}\n\nfunction symbol(o, bounds) {\n  var size = o.size != null ? o.size : 100,\n      x = o.x || 0,\n      y = o.y || 0,\n      r, t, rx, ry;\n\n  switch (o.shape) {\n    case 'cross':\n      t = 3 * Math.sqrt(size / 5) / 2;\n      bounds.set(x-t, y-t, x+t, y+t);\n      break;\n\n    case 'diamond':\n      ry = Math.sqrt(size / (2 * tan30));\n      rx = ry * tan30;\n      bounds.set(x-rx, y-ry, x+rx, y+ry);\n      break;\n\n    case 'square':\n      t = Math.sqrt(size);\n      r = t / 2;\n      bounds.set(x-r, y-r, x+r, y+r);\n      break;\n\n    case 'triangle-down':\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      bounds.set(x-rx, y-ry, x+rx, y+ry);\n      break;\n\n    case 'triangle-up':\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      bounds.set(x-rx, y-ry, x+rx, y+ry);\n      break;\n\n    default:\n      r = Math.sqrt(size/Math.PI);\n      bounds.set(x-r, y-r, x+r, y+r);\n  }\n\n  return strokeBounds(o, bounds);\n}\n\nfunction textMark(o, bounds, noRotate) {\n  var g = context(),\n      h = text.size(o),\n      a = o.align,\n      r = o.radius || 0,\n      x = (o.x || 0),\n      y = (o.y || 0),\n      dx = (o.dx || 0),\n      dy = (o.dy || 0) + text.offset(o) - Math.round(0.8*h), // use 4/5 offset\n      w, t;\n\n  if (r) {\n    t = (o.theta || 0) - Math.PI/2;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n\n  // horizontal alignment\n  g.font = text.font(o);\n  w = g.measureText(text.value(o.text)).width;\n  if (a === 'center') {\n    dx -= (w / 2);\n  } else if (a === 'right') {\n    dx -= w;\n  } else {\n    // left by default, do nothing\n  }\n\n  bounds.set(dx+=x, dy+=y, dx+w, dy+h);\n  if (o.angle && !noRotate) {\n    bounds.rotate(o.angle*Math.PI/180, x, y);\n  }\n  return bounds.expand(noRotate ? 0 : 1);\n}\n\nfunction group(g, bounds, includeLegends) {\n  var axes = g.axisItems || [],\n      items = g.items || [],\n      legends = g.legendItems || [],\n      j, m;\n\n  if (!g.clip) {\n    for (j=0, m=axes.length; j<m; ++j) {\n      bounds.union(axes[j].bounds);\n    }\n    for (j=0, m=items.length; j<m; ++j) {\n      bounds.union(items[j].bounds);\n    }\n    if (includeLegends) {\n      for (j=0, m=legends.length; j<m; ++j) {\n        bounds.union(legends[j].bounds);\n      }\n    }\n  }\n  if (g.clip || g.width || g.height) {\n    strokeBounds(g, bounds\n      .add(0, 0)\n      .add(g.width || 0, g.height || 0));\n  }\n  return bounds.translate(g.x || 0, g.y || 0);\n}\n\nvar methods = {\n  group:  group,\n  symbol: symbol,\n  image:  image,\n  rect:   rect,\n  rule:   rule,\n  arc:    arc,\n  text:   textMark,\n  path:   path,\n  area:   area,\n  line:   line\n};\nmethods.area.nest = true;\nmethods.line.nest = true;\n\nfunction itemBounds(item, func, opt) {\n  var type = item.mark.marktype;\n  func = func || methods[type];\n  if (func.nest) item = item.mark;\n\n  var curr = item.bounds,\n      prev = item['bounds:prev'] || (item['bounds:prev'] = new Bounds());\n\n  if (curr) {\n    prev.clear().union(curr);\n    curr.clear();\n  } else {\n    item.bounds = new Bounds();\n  }\n  func(item, item.bounds, opt);\n  if (!curr) prev.clear().union(item.bounds);\n  return item.bounds;\n}\n\nvar DUMMY_ITEM = {mark: null};\n\nfunction markBounds(mark, bounds, opt) {\n  var type  = mark.marktype,\n      func  = methods[type],\n      items = mark.items,\n      hasi  = items && items.length,\n      i, n, o, b;\n\n  if (func.nest) {\n    o = hasi ? items[0]\n      : (DUMMY_ITEM.mark = mark, DUMMY_ITEM); // no items, so fake it\n    b = itemBounds(o, func, opt);\n    bounds = bounds && bounds.union(b) || b;\n    return bounds;\n  }\n\n  bounds = bounds || mark.bounds && mark.bounds.clear() || new Bounds();\n  if (hasi) {  \n    for (i=0, n=items.length; i<n; ++i) {\n      bounds.union(itemBounds(items[i], func, opt));\n    }\n  }\n  return (mark.bounds = bounds);\n}\n\nmodule.exports = {\n  mark:  markBounds,\n  item:  itemBounds,\n  text:  textMark,\n  group: group\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-scenegraph/src/util/bound.js\n ** module id = 87\n ** module chunks = 0\n **/","module.exports = function(b) {\n  function noop() { }\n  function add(x,y) { b.add(x, y); }\n\n  return {\n    bounds: function(_) {\n      if (!arguments.length) return b;\n      return (b = _, this);\n    },\n    beginPath: noop,\n    closePath: noop,\n    moveTo: add,\n    lineTo: add,\n    quadraticCurveTo: function(x1, y1, x2, y2) {\n      b.add(x1, y1);\n      b.add(x2, y2);\n    },\n    bezierCurveTo: function(x1, y1, x2, y2, x3, y3) {\n      b.add(x1, y1);\n      b.add(x2, y2);\n      b.add(x3, y3);\n    }\n  };\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-scenegraph/src/util/BoundsContext.js\n ** module id = 88\n ** module chunks = 0\n **/","function instance(w, h) {\n  w = w || 1;\n  h = h || 1;\n  var canvas;\n\n  if (typeof document !== 'undefined' && document.createElement) {\n    canvas = document.createElement('canvas');\n    canvas.width = w;\n    canvas.height = h;\n  } else {\n    var Canvas = require('canvas');\n    if (!Canvas.prototype) return null;\n    canvas = new Canvas(w, h);\n  }\n  return lineDash(canvas);\n}\n\nfunction resize(canvas, w, h, p, retina) {\n  var g = this._ctx = canvas.getContext('2d'), \n      s = 1;\n\n  canvas.width = w + p.left + p.right;\n  canvas.height = h + p.top + p.bottom;\n\n  // if browser canvas, attempt to modify for retina display\n  if (retina && typeof HTMLElement !== 'undefined' &&\n      canvas instanceof HTMLElement)\n  {\n    g.pixelratio = (s = pixelRatio(canvas) || 1);\n  }\n\n  g.setTransform(s, 0, 0, s, s*p.left, s*p.top);\n  return canvas;\n}\n\nfunction pixelRatio(canvas) {\n  var g = canvas.getContext('2d');\n\n  // get canvas pixel data\n  var devicePixelRatio = window && window.devicePixelRatio || 1,\n      backingStoreRatio = (\n        g.webkitBackingStorePixelRatio ||\n        g.mozBackingStorePixelRatio ||\n        g.msBackingStorePixelRatio ||\n        g.oBackingStorePixelRatio ||\n        g.backingStorePixelRatio) || 1,\n      ratio = devicePixelRatio / backingStoreRatio;\n\n  if (devicePixelRatio !== backingStoreRatio) {\n    // set actual and visible canvas size\n    var w = canvas.width,\n        h = canvas.height;\n    canvas.width = w * ratio;\n    canvas.height = h * ratio;\n    canvas.style.width = w + 'px';\n    canvas.style.height = h + 'px';\n  }\n\n  return ratio;\n}\n\nfunction lineDash(canvas) {\n  var g = canvas.getContext('2d');\n  if (g.vgLineDash) return; // already initialized!\n\n  var NOOP = function() {},\n      NODASH = [];\n  \n  if (g.setLineDash) {\n    g.vgLineDash = function(dash) { this.setLineDash(dash || NODASH); };\n    g.vgLineDashOffset = function(off) { this.lineDashOffset = off; };\n  } else if (g.webkitLineDash !== undefined) {\n  \tg.vgLineDash = function(dash) { this.webkitLineDash = dash || NODASH; };\n    g.vgLineDashOffset = function(off) { this.webkitLineDashOffset = off; };\n  } else if (g.mozDash !== undefined) {\n    g.vgLineDash = function(dash) { this.mozDash = dash; };\n    g.vgLineDashOffset = NOOP;\n  } else {\n    g.vgLineDash = NOOP;\n    g.vgLineDashOffset = NOOP;\n  }\n  return canvas;\n}\n\nmodule.exports = {\n  instance:   instance,\n  resize:     resize,\n  lineDash:   lineDash\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-scenegraph/src/util/canvas.js\n ** module id = 89\n ** module chunks = 0\n **/","/* (ignored) */\n\n\n/*****************\n ** WEBPACK FOOTER\n ** canvas (ignored)\n ** module id = 90\n ** module chunks = 0\n **/","function size(item) {\n  return item.fontSize != null ? item.fontSize : 11;\n}\n\nmodule.exports = {\n  size: size,\n  value: function(s) {\n    return s != null ? String(s) : '';\n  },\n  font: function(item, quote) {\n    var font = item.font;\n    if (quote && font) {\n      font = String(font).replace(/\\\"/g, '\\'');\n    }\n    return '' +\n      (item.fontStyle ? item.fontStyle + ' ' : '') +\n      (item.fontVariant ? item.fontVariant + ' ' : '') +\n      (item.fontWeight ? item.fontWeight + ' ' : '') +\n      size(item) + 'px ' +\n      (font || 'sans-serif');\n  },\n  offset: function(item) {\n    // perform our own font baseline calculation\n    // why? not all browsers support SVG 1.1 'alignment-baseline' :(\n    var baseline = item.baseline,\n        h = size(item);\n    return Math.round(\n      baseline === 'top'    ?  0.93*h :\n      baseline === 'middle' ?  0.30*h :\n      baseline === 'bottom' ? -0.21*h : 0\n    );\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-scenegraph/src/util/text.js\n ** module id = 91\n ** module chunks = 0\n **/","var DOM = require('../../util/dom'),\n    Bounds = require('../../util/Bounds'),\n    ImageLoader = require('../../util/ImageLoader'),\n    Canvas = require('../../util/canvas'),\n    Renderer = require('../Renderer'),\n    marks = require('./marks');\n\nfunction CanvasRenderer(loadConfig) {\n  Renderer.call(this);\n  this._loader = new ImageLoader(loadConfig);\n}\n\nCanvasRenderer.RETINA = true;\n\nvar base = Renderer.prototype;\nvar prototype = (CanvasRenderer.prototype = Object.create(base));\nprototype.constructor = CanvasRenderer;\n\nprototype.initialize = function(el, width, height, padding) {\n  this._canvas = Canvas.instance(width, height);\n  if (el) {\n    DOM.clear(el, 0).appendChild(this._canvas);\n    this._canvas.setAttribute('class', 'marks');\n  }\n  return base.initialize.call(this, el, width, height, padding);\n};\n\nprototype.resize = function(width, height, padding) {\n  base.resize.call(this, width, height, padding);\n  Canvas.resize(this._canvas, this._width, this._height,\n    this._padding, CanvasRenderer.RETINA);\n  return this;\n};\n\nprototype.canvas = function() {\n  return this._canvas;\n};\n\nprototype.context = function() {\n  return this._canvas ? this._canvas.getContext('2d') : null;\n};\n\nprototype.pendingImages = function() {\n  return this._loader.pending();\n};\n\nfunction clipToBounds(g, items) {\n  if (!items) return null;\n\n  var b = new Bounds(), i, n, item, mark, group;\n  for (i=0, n=items.length; i<n; ++i) {\n    item = items[i];\n    mark = item.mark;\n    group = mark.group;\n    item = marks[mark.marktype].nested ? mark : item;\n    b.union(translate(item.bounds, group));\n    if (item['bounds:prev']) {\n      b.union(translate(item['bounds:prev'], group));\n    }\n  }\n  b.round();\n\n  g.beginPath();\n  g.rect(b.x1, b.y1, b.width(), b.height());\n  g.clip();\n\n  return b;\n}\n\nfunction translate(bounds, group) {\n  if (group == null) return bounds;\n  var b = bounds.clone();\n  for (; group != null; group = group.mark.group) {\n    b.translate(group.x || 0, group.y || 0);\n  }\n  return b;\n}\n\nprototype.render = function(scene, items) {\n  var g = this.context(),\n      p = this._padding,\n      w = this._width + p.left + p.right,\n      h = this._height + p.top + p.bottom,\n      b;\n\n  // setup\n  this._scene = scene; // cache scene for async redraw\n  g.save();\n  b = clipToBounds(g, items);\n  this.clear(-p.left, -p.top, w, h);\n\n  // render\n  this.draw(g, scene, b);\n  \n  // takedown\n  g.restore();\n  this._scene = null; // clear scene cache\n\n  return this;\n};\n\nprototype.draw = function(ctx, scene, bounds) {\n  var mark = marks[scene.marktype];\n  mark.draw.call(this, ctx, scene, bounds);\n};\n\nprototype.clear = function(x, y, w, h) {\n  var g = this.context();\n  g.clearRect(x, y, w, h);\n  if (this._bgcolor != null) {\n    g.fillStyle = this._bgcolor;\n    g.fillRect(x, y, w, h); \n  }\n};\n\nprototype.loadImage = function(uri) {\n  var renderer = this,\n      scene = this._scene;\n  return this._loader.loadImage(uri, function() {\n    renderer.renderAsync(scene);\n  });\n};\n\nprototype.renderAsync = function(scene) {\n  // TODO make safe for multiple scene rendering?\n  var renderer = this;\n  if (renderer._async_id) {\n    clearTimeout(renderer._async_id);\n  }\n  renderer._async_id = setTimeout(function() {\n    renderer.render(scene);\n    delete renderer._async_id;\n  }, 10);\n};\n\nmodule.exports = CanvasRenderer;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-scenegraph/src/render/canvas/CanvasRenderer.js\n ** module id = 92\n ** module chunks = 0\n **/","var load = require('datalib/src/import/load');\n\nfunction ImageLoader(loadConfig) {\n  this._pending = 0;\n  this._config = loadConfig || ImageLoader.Config; \n}\n\n// Overridable global default load configuration\nImageLoader.Config = null;\n\nvar prototype = ImageLoader.prototype;\n\nprototype.pending = function() {\n  return this._pending;\n};\n\nprototype.params = function(uri) {\n  var p = {url: uri}, k;\n  for (k in this._config) { p[k] = this._config[k]; }\n  return p;\n};\n\nprototype.imageURL = function(uri) {\n  return load.sanitizeUrl(this.params(uri));\n};\n\nfunction browser(uri, callback) {\n  var url = load.sanitizeUrl(this.params(uri));\n  if (!url) { // error\n    if (callback) callback(uri, null);\n    return null;\n  }\n\n  var loader = this,\n      image = new Image();\n\n  loader._pending += 1;\n\n  image.onload = function() {\n    loader._pending -= 1;\n    image.loaded = true;\n    if (callback) callback(null, image);\n  };\n  image.src = url;\n\n  return image;\n}\n\nfunction server(uri, callback) {\n  var loader = this,\n      image = new (require('canvas').Image)();\n\n  loader._pending += 1;\n\n  load(this.params(uri), function(err, data) {\n    loader._pending -= 1;\n    if (err) {\n      if (callback) callback(err, null);\n      return null;\n    }\n    image.src = data;\n    image.loaded = true;\n    if (callback) callback(null, image);\n  });\n\n  return image;\n}\n\nprototype.loadImage = function(uri, callback) {\n  return load.useXHR ?\n    browser.call(this, uri, callback) :\n    server.call(this, uri, callback);\n};\n\nmodule.exports = ImageLoader;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-scenegraph/src/util/ImageLoader.js\n ** module id = 93\n ** module chunks = 0\n **/","function Renderer() {\n  this._el = null;\n  this._bgcolor = null;\n}\n\nvar prototype = Renderer.prototype;\n\nprototype.initialize = function(el, width, height, padding) {\n  this._el = el;\n  return this.resize(width, height, padding);\n};\n\n// Returns the parent container element for a visualization\nprototype.element = function() {\n  return this._el;\n};\n\n// Returns the scene element (e.g., canvas or SVG) of the visualization\n// Subclasses must override if the first child is not the scene element\nprototype.scene = function() {\n  return this._el && this._el.firstChild;\n};\n\nprototype.background = function(bgcolor) {\n  if (arguments.length === 0) return this._bgcolor;\n  this._bgcolor = bgcolor;\n  return this;\n};\n\nprototype.resize = function(width, height, padding) {\n  this._width = width;\n  this._height = height;\n  this._padding = padding || {top:0, left:0, bottom:0, right:0};\n  return this;\n};\n\nprototype.render = function(/*scene, items*/) {\n  return this;\n};\n\nmodule.exports = Renderer;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-scenegraph/src/render/Renderer.js\n ** module id = 94\n ** module chunks = 0\n **/","module.exports = {\n  Handler:  require('./SVGHandler'),\n  Renderer: require('./SVGRenderer'),\n  string: {\n    Renderer : require('./SVGStringRenderer')\n  }\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-scenegraph/src/render/svg/index.js\n ** module id = 95\n ** module chunks = 0\n **/","var DOM = require('../../util/dom'),\n    Handler = require('../Handler');\n\nfunction SVGHandler() {\n  Handler.call(this);\n}\n\nvar base = Handler.prototype;\nvar prototype = (SVGHandler.prototype = Object.create(base));\nprototype.constructor = SVGHandler;\n\nprototype.initialize = function(el, pad, obj) {\n  this._svg = DOM.find(el, 'svg');\n  return base.initialize.call(this, el, pad, obj);\n};\n\nprototype.svg = function() {\n  return this._svg;\n};\n\n// wrap an event listener for the SVG DOM\nprototype.listener = function(handler) {\n  var that = this;\n  return function(evt) {\n    var target = evt.target,\n        item = target.__data__;\n    evt.vegaType = evt.type;\n    item = Array.isArray(item) ? item[0] : item;\n    handler.call(that._obj, evt, item);\n  };\n};\n\n// add an event handler\nprototype.on = function(type, handler) {\n  var name = this.eventName(type),\n      svg = this._svg,\n      h = this._handlers,\n      x = {\n        type:     type,\n        handler:  handler,\n        listener: this.listener(handler)\n      };\n\n  (h[name] || (h[name] = [])).push(x);\n  svg.addEventListener(name, x.listener);\n  return this;\n};\n\n// remove an event handler\nprototype.off = function(type, handler) {\n  var name = this.eventName(type),\n      svg = this._svg,\n      h = this._handlers[name], i;\n  if (!h) return;\n  for (i=h.length; --i>=0;) {\n    if (h[i].type === type && !handler || h[i].handler === handler) {\n      svg.removeEventListener(name, h[i].listener);\n      h.splice(i, 1);\n    }\n  }\n  return this;\n};\n\nmodule.exports = SVGHandler;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-scenegraph/src/render/svg/SVGHandler.js\n ** module id = 96\n ** module chunks = 0\n **/","var ImageLoader = require('../../util/ImageLoader'),\n    Renderer = require('../Renderer'),\n    text = require('../../util/text'),\n    DOM = require('../../util/dom'),\n    SVG = require('../../util/svg'),\n    ns = SVG.metadata.xmlns,\n    marks = require('./marks');\n\nfunction SVGRenderer(loadConfig) {\n  Renderer.call(this);\n  this._loader = new ImageLoader(loadConfig);\n  this._dirtyID = 0;\n}\n\nvar base = Renderer.prototype;\nvar prototype = (SVGRenderer.prototype = Object.create(base));\nprototype.constructor = SVGRenderer;\n\nprototype.initialize = function(el, width, height, padding) {\n  if (el) {\n    this._svg = DOM.child(el, 0, 'svg', ns, 'marks');\n    DOM.clear(el, 1);\n    // set the svg root group\n    this._root = DOM.child(this._svg, 0, 'g', ns);\n    DOM.clear(this._svg, 1);\n  }\n\n  // create the svg definitions cache\n  this._defs = {\n    clip_id:  1,\n    gradient: {},\n    clipping: {}\n  };\n\n  // set background color if defined\n  this.background(this._bgcolor);\n\n  return base.initialize.call(this, el, width, height, padding);\n};\n\nprototype.background = function(bgcolor) {\n  if (arguments.length && this._svg) {\n    this._svg.style.setProperty('background-color', bgcolor);\n  }\n  return base.background.apply(this, arguments);\n};\n\nprototype.resize = function(width, height, padding) {\n  base.resize.call(this, width, height, padding);\n  \n  if (this._svg) {\n    var w = this._width,\n        h = this._height,\n        p = this._padding;\n  \n    this._svg.setAttribute('width', w + p.left + p.right);\n    this._svg.setAttribute('height', h + p.top + p.bottom);\n    \n    this._root.setAttribute('transform', 'translate('+p.left+','+p.top+')');\n  }\n\n  return this;\n};\n\nprototype.svg = function() {\n  if (!this._svg) return null;\n\n  var attr = {\n    'class':  'marks',\n    'width':  this._width + this._padding.left + this._padding.right,\n    'height': this._height + this._padding.top + this._padding.bottom,\n  };\n  for (var key in SVG.metadata) {\n    attr[key] = SVG.metadata[key];\n  }\n\n  return DOM.openTag('svg', attr) + this._svg.innerHTML + DOM.closeTag('svg');\n};\n\nprototype.imageURL = function(url) {\n  return this._loader.imageURL(url);\n};\n\n\n// -- Render entry point --\n\nprototype.render = function(scene, items) {\n  if (this._dirtyCheck(items)) {\n    if (this._dirtyAll) this._resetDefs();\n    this.draw(this._root, scene, -1);\n    DOM.clear(this._root, 1);\n  }\n  this.updateDefs();\n  return this;\n};\n\nprototype.draw = function(el, scene, index) {\n  this.drawMark(el, scene, index, marks[scene.marktype]);\n};\n\n\n// -- Manage SVG definitions ('defs') block --\n\nprototype.updateDefs = function() {\n  var svg = this._svg,\n      defs = this._defs,\n      el = defs.el,\n      index = 0, id;\n\n  for (id in defs.gradient) {\n    if (!el) el = (defs.el = DOM.child(svg, 0, 'defs', ns));\n    updateGradient(el, defs.gradient[id], index++);\n  }\n\n  for (id in defs.clipping) {\n    if (!el) el = (defs.el = DOM.child(svg, 0, 'defs', ns));\n    updateClipping(el, defs.clipping[id], index++);\n  }\n\n  // clean-up\n  if (el) {\n    if (index === 0) {\n      svg.removeChild(el);\n      defs.el = null;\n    } else {\n      DOM.clear(el, index);      \n    }\n  }\n};\n\nfunction updateGradient(el, grad, index) {\n  var i, n, stop;\n\n  el = DOM.child(el, index, 'linearGradient', ns);\n  el.setAttribute('id', grad.id);\n  el.setAttribute('x1', grad.x1);\n  el.setAttribute('x2', grad.x2);\n  el.setAttribute('y1', grad.y1);\n  el.setAttribute('y2', grad.y2);\n  \n  for (i=0, n=grad.stops.length; i<n; ++i) {\n    stop = DOM.child(el, i, 'stop', ns);\n    stop.setAttribute('offset', grad.stops[i].offset);\n    stop.setAttribute('stop-color', grad.stops[i].color);\n  }\n  DOM.clear(el, i);\n}\n\nfunction updateClipping(el, clip, index) {\n  var rect;\n\n  el = DOM.child(el, index, 'clipPath', ns);\n  el.setAttribute('id', clip.id);\n  rect = DOM.child(el, 0, 'rect', ns);\n  rect.setAttribute('x', 0);\n  rect.setAttribute('y', 0);\n  rect.setAttribute('width', clip.width);\n  rect.setAttribute('height', clip.height);\n}\n\nprototype._resetDefs = function() {\n  var def = this._defs;\n  def.clip_id = 1;\n  def.gradient = {};\n  def.clipping = {};\n};\n\n\n// -- Manage rendering of items marked as dirty --\n\nprototype.isDirty = function(item) {\n  return this._dirtyAll || item.dirty === this._dirtyID;\n};\n\nprototype._dirtyCheck = function(items) {\n  this._dirtyAll = true;\n  if (!items) return true;\n\n  var id = ++this._dirtyID,\n      item, mark, type, mdef, i, n, o;\n\n  for (i=0, n=items.length; i<n; ++i) {\n    item = items[i];\n    mark = item.mark;\n    if (mark.marktype !== type) {\n      // memoize mark instance lookup\n      type = mark.marktype;\n      mdef = marks[type];\n    }\n\n    if (item.status === 'exit') { // EXIT\n      if (item._svg) {\n        if (mdef.nest && item.mark.items.length) {\n          // if nested mark with remaining points, update instead\n          this._update(mdef, item._svg, item.mark.items[0]);\n          o = item.mark.items[0];\n          o._svg = item._svg;\n          o._update = id;\n        } else {\n          // otherwise remove from DOM\n          DOM.remove(item._svg);\n        }\n        item._svg = null;\n      }\n      continue;\n    }\n\n    item = (mdef.nest ? mark.items[0] : item);\n    if (item._update === id) { // Already processed\n      continue;\n    } else if (item._svg) { // UPDATE\n      this._update(mdef, item._svg, item);\n    } else { // ENTER\n      this._dirtyAll = false;\n      dirtyParents(item, id);\n    }\n    item._update = id;\n  }\n  return !this._dirtyAll;\n};\n\nfunction dirtyParents(item, id) {\n  for (; item && item.dirty !== id; item=item.mark.group) {\n    item.dirty = id;\n    if (item.mark && item.mark.dirty !== id) {\n      item.mark.dirty = id;\n    } else return;\n  }\n}\n\n\n// -- Construct & maintain scenegraph to SVG mapping ---\n\n// Draw a mark container.\nprototype.drawMark = function(el, scene, index, mdef) {\n  if (!this.isDirty(scene)) return;\n\n  var items = mdef.nest ?\n        (scene.items && scene.items.length ? [scene.items[0]] : []) :\n        scene.items || [],\n      events = scene.interactive === false ? 'none' : null,\n      isGroup = (mdef.tag === 'g'),\n      className = DOM.cssClass(scene),\n      p, i, n, c, d, insert;\n\n  p = DOM.child(el, index+1, 'g', ns, className);\n  p.setAttribute('class', className);\n  scene._svg = p;\n  if (!isGroup && events) {\n    p.style.setProperty('pointer-events', events);\n  }\n\n  for (i=0, n=items.length; i<n; ++i) {\n    if (this.isDirty(d = items[i])) {\n      insert = !(this._dirtyAll || d._svg);\n      c = bind(p, mdef, d, i, insert);\n      this._update(mdef, c, d);\n      if (isGroup) {\n        if (insert) this._dirtyAll = true;\n        this._recurse(c, d);\n        if (insert) this._dirtyAll = false;\n      }\n    }\n  }\n  DOM.clear(p, i);\n  return p;\n};\n\n// Recursively process group contents.\nprototype._recurse = function(el, group) {\n  var items = group.items || [],\n      legends = group.legendItems || [],\n      axes = group.axisItems || [],\n      idx = 0, j, m;\n\n  for (j=0, m=axes.length; j<m; ++j) {\n    if (axes[j].layer === 'back') {\n      this.drawMark(el, axes[j], idx++, marks.group);\n    }\n  }\n  for (j=0, m=items.length; j<m; ++j) {\n    this.draw(el, items[j], idx++);\n  }\n  for (j=0, m=axes.length; j<m; ++j) {\n    if (axes[j].layer !== 'back') {\n      this.drawMark(el, axes[j], idx++, marks.group);\n    }\n  }\n  for (j=0, m=legends.length; j<m; ++j) {\n    this.drawMark(el, legends[j], idx++, marks.group);\n  }\n\n  // remove any extraneous DOM elements\n  DOM.clear(el, 1 + idx);\n};\n\n// Bind a scenegraph item to an SVG DOM element.\n// Create new SVG elements as needed.\nfunction bind(el, mdef, item, index, insert) {\n  // create svg element, bind item data for D3 compatibility\n  var node = DOM.child(el, index, mdef.tag, ns, null, insert);\n  node.__data__ = item;\n  node.__values__ = {fill: 'default'};\n\n  // create background rect\n  if (mdef.tag === 'g') {\n    var bg = DOM.child(node, 0, 'rect', ns, 'background');\n    bg.__data__ = item;\n  }\n\n  // add pointer from scenegraph item to svg element\n  return (item._svg = node);\n}\n\n\n// -- Set attributes & styles on SVG elements ---\n\nvar element = null, // temp var for current SVG element\n    values = null;  // temp var for current values hash\n\n// Extra configuration for certain mark types\nvar mark_extras = {\n  group: function(mdef, el, item) {\n    element = el.childNodes[0];\n    values = el.__values__; // use parent's values hash\n    mdef.background(emit, item, this);\n\n    var value = item.mark.interactive === false ? 'none' : null;\n    if (value !== values.events) {\n      element.style.setProperty('pointer-events', value);\n      values.events = value;\n    }\n  },\n  text: function(mdef, el, item) {\n    var str = text.value(item.text);\n    if (str !== values.text) {\n      el.textContent = str;\n      values.text = str;\n    }\n    str = text.font(item);\n    if (str !== values.font) {\n      el.style.setProperty('font', str);\n      values.font = str;\n    }\n  }\n};\n\nprototype._update = function(mdef, el, item) {\n  // set dom element and values cache\n  // provides access to emit method\n  element = el;\n  values = el.__values__;\n\n  // apply svg attributes\n  mdef.attr(emit, item, this);\n\n  // some marks need special treatment\n  var extra = mark_extras[mdef.type];\n  if (extra) extra(mdef, el, item);\n\n  // apply svg css styles\n  // note: element may be modified by 'extra' method\n  this.style(element, item);\n};\n\nfunction emit(name, value, ns) {\n  // early exit if value is unchanged\n  if (value === values[name]) return;\n\n  if (value != null) {\n    // if value is provided, update DOM attribute\n    if (ns) {\n      element.setAttributeNS(ns, name, value);\n    } else {\n      element.setAttribute(name, value);\n    }\n  } else {\n    // else remove DOM attribute\n    if (ns) {\n      element.removeAttributeNS(ns, name);\n    } else {\n      element.removeAttribute(name);\n    }\n  }\n\n  // note current value for future comparison\n  values[name] = value;\n}\n\nprototype.style = function(el, o) {\n  if (o == null) return;\n  var i, n, prop, name, value;\n\n  for (i=0, n=SVG.styleProperties.length; i<n; ++i) {\n    prop = SVG.styleProperties[i];\n    value = o[prop];\n    if (value === values[prop]) continue;\n\n    name = SVG.styles[prop];\n    if (value == null) {\n      if (name === 'fill') {\n        el.style.setProperty(name, 'none');\n      } else {\n        el.style.removeProperty(name);\n      }\n    } else {\n      if (value.id) {\n        // ensure definition is included\n        this._defs.gradient[value.id] = value;\n        value = 'url(' + href() + '#' + value.id + ')';\n      }\n      el.style.setProperty(name, value+'');\n    }\n\n    values[prop] = value;\n  }\n};\n\nfunction href() {\n  return typeof window !== 'undefined' ? window.location.href : '';\n}\n\nmodule.exports = SVGRenderer;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-scenegraph/src/render/svg/SVGRenderer.js\n ** module id = 97\n ** module chunks = 0\n **/","var text = require('../../util/text'),\n    SVG = require('../../util/svg'),\n    textAlign = SVG.textAlign,\n    path = SVG.path;\n\nfunction translateItem(o) {\n  return translate(o.x || 0, o.y || 0);\n}\n\nfunction translate(x, y) {\n  return 'translate(' + x + ',' + y + ')';\n}\n\nmodule.exports = {\n  arc: {\n    tag:  'path',\n    type: 'arc',\n    attr: function(emit, o) {\n      emit('transform', translateItem(o));\n      emit('d', path.arc(o));\n    }\n  },\n  area: {\n    tag:  'path',\n    type: 'area',\n    nest: true,\n    attr: function(emit, o) {\n      var items = o.mark.items;\n      if (items.length) emit('d', path.area(items));\n    }\n  },\n  group: {\n    tag:  'g',\n    type: 'group',\n    attr: function(emit, o, renderer) {\n      var id = null, defs, c;\n      emit('transform', translateItem(o));\n      if (o.clip) {\n        defs = renderer._defs;\n        id = o.clip_id || (o.clip_id = 'clip' + defs.clip_id++);\n        c = defs.clipping[id] || (defs.clipping[id] = {id: id});\n        c.width = o.width || 0;\n        c.height = o.height || 0;\n      }\n      emit('clip-path', id ? ('url(#' + id + ')') : null);\n    },\n    background: function(emit, o) {\n      emit('class', 'background');\n      emit('width', o.width || 0);\n      emit('height', o.height || 0);\n    }\n  },\n  image: {\n    tag:  'image',\n    type: 'image',\n    attr: function(emit, o, renderer) {\n      var x = o.x || 0,\n          y = o.y || 0,\n          w = o.width || 0,\n          h = o.height || 0,\n          url = renderer.imageURL(o.url);\n\n      x = x - (o.align === 'center' ? w/2 : o.align === 'right' ? w : 0);\n      y = y - (o.baseline === 'middle' ? h/2 : o.baseline === 'bottom' ? h : 0);\n\n      emit('href', url, 'http://www.w3.org/1999/xlink', 'xlink:href');\n      emit('transform', translate(x, y));\n      emit('width', w);\n      emit('height', h);\n    }\n  },\n  line: {\n    tag:  'path',\n    type: 'line',\n    nest: true,\n    attr: function(emit, o) {\n      var items = o.mark.items;\n      if (items.length) emit('d', path.line(items));\n    }\n  },\n  path: {\n    tag:  'path',\n    type: 'path',\n    attr: function(emit, o) {\n      emit('transform', translateItem(o));\n      emit('d', o.path);\n    }\n  },\n  rect: {\n    tag:  'rect',\n    type: 'rect',\n    nest: false,\n    attr: function(emit, o) {\n      emit('transform', translateItem(o));\n      emit('width', o.width || 0);\n      emit('height', o.height || 0);\n    }\n  },\n  rule: {\n    tag:  'line',\n    type: 'rule',\n    attr: function(emit, o) {\n      emit('transform', translateItem(o));\n      emit('x2', o.x2 != null ? o.x2 - (o.x||0) : 0);\n      emit('y2', o.y2 != null ? o.y2 - (o.y||0) : 0);\n    }\n  },\n  symbol: {\n    tag:  'path',\n    type: 'symbol',\n    attr: function(emit, o) {\n      emit('transform', translateItem(o));\n      emit('d', path.symbol(o));\n    }\n  },\n  text: {\n    tag:  'text',\n    type: 'text',\n    nest: false,\n    attr: function(emit, o) {\n      var dx = (o.dx || 0),\n          dy = (o.dy || 0) + text.offset(o),\n          x = (o.x || 0),\n          y = (o.y || 0),\n          a = o.angle || 0,\n          r = o.radius || 0, t;\n\n      if (r) {\n        t = (o.theta || 0) - Math.PI/2;\n        x += r * Math.cos(t);\n        y += r * Math.sin(t);\n      }\n\n      emit('text-anchor', textAlign[o.align] || 'start');\n      \n      if (a) {\n        t = translate(x, y) + ' rotate('+a+')';\n        if (dx || dy) t += ' ' + translate(dx, dy);\n      } else {\n        t = translate(x+dx, y+dy);\n      }\n      emit('transform', t);\n    }\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-scenegraph/src/render/svg/marks.js\n ** module id = 98\n ** module chunks = 0\n **/","var Renderer = require('../Renderer'),\n    ImageLoader = require('../../util/ImageLoader'),\n    SVG = require('../../util/svg'),\n    text = require('../../util/text'),\n    DOM = require('../../util/dom'),\n    openTag = DOM.openTag,\n    closeTag = DOM.closeTag,\n    MARKS = require('./marks');\n\nfunction SVGStringRenderer(loadConfig) {\n  Renderer.call(this);\n\n  this._loader = new ImageLoader(loadConfig);\n\n  this._text = {\n    head: '',\n    root: '',\n    foot: '',\n    defs: '',\n    body: ''\n  };\n\n  this._defs = {\n    clip_id:  1,\n    gradient: {},\n    clipping: {}\n  };\n}\n\nvar base = Renderer.prototype;\nvar prototype = (SVGStringRenderer.prototype = Object.create(base));\nprototype.constructor = SVGStringRenderer;\n\nprototype.resize = function(width, height, padding) {\n  base.resize.call(this, width, height, padding);\n  var p = this._padding,\n      t = this._text;\n\n  var attr = {\n    'class':  'marks',\n    'width':  this._width + p.left + p.right,\n    'height': this._height + p.top + p.bottom,\n  };\n  for (var key in SVG.metadata) {\n    attr[key] = SVG.metadata[key];\n  }\n\n  t.head = openTag('svg', attr);\n  t.root = openTag('g', {\n    transform: 'translate(' + p.left + ',' + p.top + ')'\n  });\n  t.foot = closeTag('g') + closeTag('svg');\n\n  return this;\n};\n\nprototype.svg = function() {\n  var t = this._text;\n  return t.head + t.defs + t.root + t.body + t.foot;\n};\n\nprototype.render = function(scene) {\n  this._text.body = this.mark(scene);\n  this._text.defs = this.buildDefs();\n  return this;\n};\n\nprototype.reset = function() {\n  this._defs.clip_id = 0;\n  return this;\n};\n\nprototype.buildDefs = function() {\n  var all = this._defs,\n      defs = '',\n      i, id, def, stops;\n\n  for (id in all.gradient) {\n    def = all.gradient[id];\n    stops = def.stops;\n\n    defs += openTag('linearGradient', {\n      id: id,\n      x1: def.x1,\n      x2: def.x2,\n      y1: def.y1,\n      y2: def.y2\n    });\n    \n    for (i=0; i<stops.length; ++i) {\n      defs += openTag('stop', {\n        offset: stops[i].offset,\n        'stop-color': stops[i].color\n      }) + closeTag('stop');\n    }\n    \n    defs += closeTag('linearGradient');\n  }\n  \n  for (id in all.clipping) {\n    def = all.clipping[id];\n\n    defs += openTag('clipPath', {id: id});\n\n    defs += openTag('rect', {\n      x: 0,\n      y: 0,\n      width: def.width,\n      height: def.height\n    }) + closeTag('rect');\n\n    defs += closeTag('clipPath');\n  }\n  \n  return (defs.length > 0) ? openTag('defs') + defs + closeTag('defs') : '';\n};\n\nprototype.imageURL = function(url) {\n  return this._loader.imageURL(url);\n};\n\nvar object;\n\nfunction emit(name, value, ns, prefixed) {\n  object[prefixed || name] = value;\n}\n\nprototype.attributes = function(attr, item) {\n  object = {};\n  attr(emit, item, this);\n  return object;\n};\n\nprototype.mark = function(scene) {\n  var mdef = MARKS[scene.marktype],\n      tag  = mdef.tag,\n      attr = mdef.attr,\n      nest = mdef.nest || false,\n      data = nest ?\n          (scene.items && scene.items.length ? [scene.items[0]] : []) :\n          (scene.items || []),\n      defs = this._defs,\n      str = '',\n      style, i, item;\n\n  if (tag !== 'g' && scene.interactive === false) {\n    style = 'style=\"pointer-events: none;\"';\n  }\n\n  // render opening group tag\n  str += openTag('g', {\n    'class': DOM.cssClass(scene)\n  }, style);\n\n  // render contained elements\n  for (i=0; i<data.length; ++i) {\n    item = data[i];\n    style = (tag !== 'g') ? styles(item, scene, tag, defs) : null;\n    str += openTag(tag, this.attributes(attr, item), style);\n    if (tag === 'text') {\n      str += escape_text(text.value(item.text));\n    } else if (tag === 'g') {\n      str += openTag('rect',\n        this.attributes(mdef.background, item),\n        styles(item, scene, 'bgrect', defs)) + closeTag('rect');\n      str += this.markGroup(item);\n    }\n    str += closeTag(tag);\n  }\n\n  // render closing group tag\n  return str + closeTag('g');\n};\n\nprototype.markGroup = function(scene) {\n  var str = '',\n      axes = scene.axisItems || [],\n      items = scene.items || [],\n      legends = scene.legendItems || [],\n      j, m;\n\n  for (j=0, m=axes.length; j<m; ++j) {\n    if (axes[j].layer === 'back') {\n      str += this.mark(axes[j]);\n    }\n  }\n  for (j=0, m=items.length; j<m; ++j) {\n    str += this.mark(items[j]);\n  }\n  for (j=0, m=axes.length; j<m; ++j) {\n    if (axes[j].layer !== 'back') {\n      str += this.mark(axes[j]);\n    }\n  }\n  for (j=0, m=legends.length; j<m; ++j) {\n    str += this.mark(legends[j]);\n  }\n\n  return str;\n};\n\nfunction styles(o, mark, tag, defs) {\n  if (o == null) return '';\n  var i, n, prop, name, value, s = '';\n\n  if (tag === 'bgrect' && mark.interactive === false) {\n    s += 'pointer-events: none;';\n  }\n\n  if (tag === 'text') {\n    s += 'font: ' + text.font(o) + ';';\n  }\n\n  for (i=0, n=SVG.styleProperties.length; i<n; ++i) {\n    prop = SVG.styleProperties[i];\n    name = SVG.styles[prop];\n    value = o[prop];\n\n    if (value == null) {\n      if (name === 'fill') {\n        s += (s.length ? ' ' : '') + 'fill: none;';\n      }\n    } else {\n      if (value.id) {\n        // ensure definition is included\n        defs.gradient[value.id] = value;\n        value = 'url(#' + value.id + ')';\n      }\n      s += (s.length ? ' ' : '') + name + ': ' + value + ';';\n    }\n  }\n\n  return s ? 'style=\"' + s + '\"' : null;\n}\n\nfunction escape_text(s) {\n  return s.replace(/&/g, '&amp;')\n          .replace(/</g, '&lt;')\n          .replace(/>/g, '&gt;');\n}\n\nmodule.exports = SVGStringRenderer;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-scenegraph/src/render/svg/SVGStringRenderer.js\n ** module id = 99\n ** module chunks = 0\n **/","function Item(mark) {\n  this.mark = mark;\n}\n\nvar prototype = Item.prototype;\n\nprototype.hasPropertySet = function(name) {\n  var props = this.mark.def.properties;\n  return props && props[name] != null;\n};\n\nprototype.cousin = function(offset, index) {\n  if (offset === 0) return this;\n  offset = offset || -1;\n  var mark = this.mark,\n      group = mark.group,\n      iidx = index==null ? mark.items.indexOf(this) : index,\n      midx = group.items.indexOf(mark) + offset;\n  return group.items[midx].items[iidx];\n};\n\nprototype.sibling = function(offset) {\n  if (offset === 0) return this;\n  offset = offset || -1;\n  var mark = this.mark,\n      iidx = mark.items.indexOf(this) + offset;\n  return mark.items[iidx];\n};\n\nprototype.remove = function() {\n  var item = this,\n      list = item.mark.items,\n      i = list.indexOf(item);\n  if (i >= 0) {\n    if (i===list.length-1) {\n      list.pop();\n    } else {\n      list.splice(i, 1);\n    }\n  }\n  return item;\n};\n\nprototype.touch = function() {\n  if (this.pathCache) this.pathCache = null;\n};\n\nmodule.exports = Item;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-scenegraph/src/util/Item.js\n ** module id = 100\n ** module chunks = 0\n **/","var gradient_id = 0;\n\nfunction Gradient(type) {\n  this.id = 'gradient_' + (gradient_id++);\n  this.type = type || 'linear';\n  this.stops = [];\n  this.x1 = 0;\n  this.x2 = 1;\n  this.y1 = 0;\n  this.y2 = 0;\n}\n\nvar prototype = Gradient.prototype;\n\nprototype.stop = function(offset, color) {\n  this.stops.push({\n    offset: offset,\n    color: color\n  });\n  return this;\n};\n\nmodule.exports = Gradient;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-scenegraph/src/util/Gradient.js\n ** module id = 101\n ** module chunks = 0\n **/","var bound = require('../util/bound');\n\nvar sets = [\n  'items',\n  'axisItems',\n  'legendItems'\n];\n\nvar keys = [\n  'marktype', 'name', 'interactive', 'clip',\n  'items', 'axisItems', 'legendItems', 'layer',\n  'x', 'y', 'width', 'height', 'align', 'baseline',             // layout\n  'fill', 'fillOpacity', 'opacity',                             // fill\n  'stroke', 'strokeOpacity', 'strokeWidth', 'strokeCap',        // stroke\n  'strokeDash', 'strokeDashOffset',                             // stroke dash\n  'startAngle', 'endAngle', 'innerRadius', 'outerRadius',       // arc\n  'interpolate', 'tension', 'orient',                           // area, line\n  'url',                                                        // image\n  'path',                                                       // path\n  'x2', 'y2',                                                   // rule\n  'size', 'shape',                                              // symbol\n  'text', 'angle', 'theta', 'radius', 'dx', 'dy',               // text\n  'font', 'fontSize', 'fontWeight', 'fontStyle', 'fontVariant'  // font\n];\n\nfunction toJSON(scene, indent) {\n  return JSON.stringify(scene, keys, indent);\n}\n\nfunction fromJSON(json) {\n  var scene = (typeof json === 'string' ? JSON.parse(json) : json);\n  return initialize(scene);\n}\n\nfunction initialize(scene) {\n  var type = scene.marktype,\n      i, n, s, m, items;\n\n  for (s=0, m=sets.length; s<m; ++s) {\n    if ((items = scene[sets[s]])) {\n      for (i=0, n=items.length; i<n; ++i) {\n        items[i][type ? 'mark' : 'group'] = scene;\n        if (!type || type === 'group') {\n          initialize(items[i]);\n        }\n      }\n    }\n  }\n\n  if (type) bound.mark(scene);\n  return scene;\n}\n\nmodule.exports = {\n  toJSON:   toJSON,\n  fromJSON: fromJSON\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-scenegraph/src/util/scene.js\n ** module id = 102\n ** module chunks = 0\n **/","var d3 = require('d3');\n\nfunction parseBg(bg) {\n  // return null if input is null or undefined\n  if (bg == null) return null;\n  // run through d3 rgb to sanity check\n  return d3.rgb(bg) + '';\n}\n\nmodule.exports = parseBg;\n\nparseBg.schema = {\"defs\": {\"background\": {\"type\": \"string\"}}};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/parse/background.js\n ** module id = 103\n ** module chunks = 0\n **/","var dl = require('datalib'),\n    log = require('vega-logging'),\n    parseTransforms = require('./transforms'),\n    parseModify = require('./modify');\n\nfunction parseData(model, spec, callback) {\n  var config = model.config(),\n      count = 0;\n\n  function onError(error, d) {\n    log.error('PARSE DATA FAILED: ' + d.name + ' ' + error);\n    count = -1;\n    callback(error);\n  }\n\n  function onLoad(d) {\n    return function(error, data) {\n      if (error) {\n        onError(error, d);\n      } else if (count > 0) {\n        try {\n          model.data(d.name).values(dl.read(data, d.format));\n          if (--count === 0) callback();\n        } catch (err) {\n          onError(err, d);\n        }\n      }\n    };\n  }\n\n  // process each data set definition\n  (spec || []).forEach(function(d) {\n    if (d.url) {\n      count += 1;\n      dl.load(dl.extend({url: d.url}, config.load), onLoad(d));\n    }\n    try {\n      parseData.datasource(model, d);\n    } catch (err) {\n      onError(err, d);\n    }\n  });\n\n  if (count === 0) setTimeout(callback, 1);\n  return spec;\n}\n\nparseData.datasource = function(model, d) {\n  var transform = (d.transform || []).map(function(t) {\n        return parseTransforms(model, t);\n      }),\n      mod = (d.modify || []).map(function(m) {\n        return parseModify(model, m, d);\n      }),\n      ds = model.data(d.name, mod.concat(transform));\n\n  if (d.values) {\n    ds.values(dl.read(d.values, d.format));\n  } else if (d.source) {\n    // Derived ds will be pulsed by its src rather than the model.\n    ds.source(d.source).addListener(ds);\n    model.removeListener(ds.pipeline()[0]);\n  }\n\n  return ds;\n};\n\nmodule.exports = parseData;\n\nvar parseDef = {\n  \"oneOf\": [\n    {\"enum\": [\"auto\"]},\n    {\n      \"type\": \"object\",\n      \"additionalProperties\": {\n        \"enum\": [\"number\", \"boolean\", \"date\", \"string\"]\n      }\n    }\n  ]\n};\n\nparseData.schema = {\n  \"defs\": {\n    \"data\": {\n      \"title\": \"Input data set definition\",\n      \"type\": \"object\",\n\n      \"allOf\": [{\n        \"properties\": {\n          \"name\": {\"type\": \"string\"},\n          \"transform\": {\"$ref\": \"#/defs/transform\"},\n          \"modify\": {\"$ref\": \"#/defs/modify\"},\n          \"format\": {\n            \"type\": \"object\",\n            \"oneOf\": [{\n              \"properties\": {\n                \"type\": {\"enum\": [\"json\"]},\n                \"parse\": parseDef,\n                \"property\": {\"type\": \"string\"}\n              },\n              \"additionalProperties\": false\n            }, {\n              \"properties\": {\n                \"type\": {\"enum\": [\"csv\", \"tsv\"]},\n                \"parse\": parseDef\n              },\n              \"additionalProperties\": false\n            }, {\n              \"oneOf\": [{\n                \"properties\": {\n                  \"type\": {\"enum\": [\"topojson\"]},\n                  \"feature\": {\"type\": \"string\"}\n                },\n                \"additionalProperties\": false\n              }, {\n                \"properties\": {\n                  \"type\": {\"enum\": [\"topojson\"]},\n                  \"mesh\": {\"type\": \"string\"}\n                },\n                \"additionalProperties\": false\n              }]\n            }, {\n              \"properties\": {\n                \"type\": {\"enum\": [\"treejson\"]},\n                \"children\": {\"type\": \"string\"},\n                \"parse\": parseDef\n              },\n              \"additionalProperties\": false\n            }]\n          }\n        },\n        \"required\": [\"name\"]\n      }, {\n        \"anyOf\": [{\n          \"required\": [\"name\", \"modify\"]\n        }, {\n          \"oneOf\": [{\n            \"properties\": {\"source\": {\"type\": \"string\"}},\n            \"required\": [\"source\"]\n          }, {\n            \"properties\": {\"values\": {\"type\": \"array\"}},\n            \"required\": [\"values\"]\n          }, {\n            \"properties\": {\"url\": {\"type\": \"string\"}},\n            \"required\": [\"url\"]\n          }]\n        }]\n      }]\n    }\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/parse/data.js\n ** module id = 104\n ** module chunks = 0\n **/","var dl = require('datalib'),\n    transforms = require('../transforms/index');\n\nfunction parseTransforms(model, def) {\n  var transform = transforms[def.type],\n      tx;\n\n  if (!transform) throw new Error('\"' + def.type + '\" is not a valid transformation');\n\n  tx = new transform(model);\n  // We want to rename output fields before setting any other properties,\n  // as subsequent properties may require output to be set (e.g. group by).\n  if(def.output) tx.output(def.output);\n\n  dl.keys(def).forEach(function(k) {\n    if(k === 'type' || k === 'output') return;\n    tx.param(k, def[k]);\n  });\n\n  return tx;\n}\n\nmodule.exports = parseTransforms;\n\nvar keys = dl.keys(transforms)\n  .filter(function(k) { return transforms[k].schema; });\n\nvar defs = keys.reduce(function(acc, k) {\n  return (acc[k+'Transform'] = transforms[k].schema, acc);\n}, {});\n\nparseTransforms.schema = {\n  \"defs\": dl.extend(defs, {\n    \"transform\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"oneOf\": keys.map(function(k) {\n          return {\"$ref\": \"#/defs/\"+k+\"Transform\"};\n        })\n      }\n    }\n  })\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/parse/transforms.js\n ** module id = 105\n ** module chunks = 0\n **/","module.exports = {\n  aggregate:    require('./Aggregate'),\n  bin:          require('./Bin'),\n  cross:        require('./Cross'),\n  countpattern: require('./CountPattern'),\n  linkpath:     require('./LinkPath'),\n  facet:        require('./Facet'),\n  filter:       require('./Filter'),\n  fold:         require('./Fold'),\n  force:        require('./Force'),\n  formula:      require('./Formula'),\n  geo:          require('./Geo'),\n  geopath:      require('./GeoPath'),\n  hierarchy:    require('./Hierarchy'),\n  impute:       require('./Impute'),\n  lookup:       require('./Lookup'),\n  pie:          require('./Pie'),\n  rank:         require('./Rank'),\n  sort:         require('./Sort'),\n  stack:        require('./Stack'),\n  treeify:      require('./Treeify'),\n  treemap:      require('./Treemap'),\n  voronoi:      require('./Voronoi'),\n  wordcloud:    require('./Wordcloud')\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/transforms/index.js\n ** module id = 106\n ** module chunks = 0\n **/","var dl = require('datalib'),\n    df = require('vega-dataflow'),\n    log = require('vega-logging'),\n    ChangeSet = df.ChangeSet,\n    Tuple = df.Tuple,\n    Deps = df.Dependencies,\n    Transform = require('./Transform'),\n    Facetor = require('./Facetor');\n\nfunction Aggregate(graph) {\n  Transform.prototype.init.call(this, graph);\n\n  Transform.addParameters(this, {\n    groupby: {type: 'array<field>'},\n    summarize: {\n      type: 'custom',\n      set: function(summarize) {\n        var signalDeps = {},\n            tx = this._transform,\n            i, len, f, fields, name, ops;\n\n        if (!dl.isArray(fields = summarize)) { // Object syntax from dl\n          fields = [];\n          for (name in summarize) {\n            ops = dl.array(summarize[name]);\n            fields.push({field: name, ops: ops});\n          }\n        }\n\n        function sg(x) { if (x.signal) signalDeps[x.signal] = 1; }\n\n        for (i=0, len=fields.length; i<len; ++i) {\n          f = fields[i];\n          if (f.field.signal) { signalDeps[f.field.signal] = 1; }\n          dl.array(f.ops).forEach(sg);\n          dl.array(f.as).forEach(sg);\n        }\n\n        tx._fields = fields;\n        tx._aggr = null;\n        tx.dependency(Deps.SIGNALS, dl.keys(signalDeps));\n        return tx;\n      }\n    }\n  });\n\n  this._aggr  = null; // dl.Aggregator\n  this._input = null; // Used by Facetor._on_keep.\n  this._args  = null; // To cull re-computation.\n  this._fields = [];\n  this._out = [];\n\n  this._type = TYPES.TUPLE;\n  this._acc = {groupby: dl.true, value: dl.true};\n\n  return this.router(true).produces(true);\n}\n\nvar prototype = (Aggregate.prototype = Object.create(Transform.prototype));\nprototype.constructor = Aggregate;\n\nvar TYPES = Aggregate.TYPES = {\n  VALUE: 1,\n  TUPLE: 2,\n  MULTI: 3\n};\n\nAggregate.VALID_OPS = [\n  'values', 'count', 'valid', 'missing', 'distinct',\n  'sum', 'mean', 'average', 'variance', 'variancep', 'stdev',\n  'stdevp', 'median', 'q1', 'q3', 'modeskew', 'min', 'max',\n  'argmin', 'argmax'\n];\n\nprototype.type = function(type) {\n  return (this._type = type, this);\n};\n\nprototype.accessors = function(groupby, value) {\n  var acc = this._acc;\n  acc.groupby = dl.$(groupby) || dl.true;\n  acc.value = dl.$(value) || dl.true;\n};\n\nprototype.aggr = function() {\n  if (this._aggr) return this._aggr;\n\n  var g = this._graph,\n      hasGetter = false,\n      args = [],\n      groupby = this.param('groupby').field,\n      value = function(x) { return x.signal ? g.signalRef(x.signal) : x; };\n\n  // Prepare summarize fields.\n  var fields = this._fields.map(function(f) {\n    var field = {\n      name: value(f.field),\n      as:   dl.array(f.as),\n      ops:  dl.array(value(f.ops)).map(value),\n      get:  f.get\n    };\n    hasGetter = hasGetter || field.get != null;\n    args.push(field.name);\n    return field;\n  });\n\n  // If there is an arbitrary getter, all bets are off.\n  // Otherwise, we can check argument fields to cull re-computation.\n  groupby.forEach(function(g) {\n    if (g.get) hasGetter = true;\n    args.push(g.name || g);\n  });\n  this._args = hasGetter || !fields.length ? null : args;\n\n  if (!fields.length) fields = {'*': 'values'};\n\n  // Instantiate our aggregator instance.\n  // Facetor is a special subclass that can facet into data pipelines.\n  var aggr = this._aggr = new Facetor()\n    .groupby(groupby)\n    .stream(true)\n    .summarize(fields);\n\n  // Collect output fields sets by this aggregate.\n  this._out = getFields(aggr);\n\n  // If we are processing tuples, key them by '_id'.\n  if (this._type !== TYPES.VALUE) { aggr.key('_id'); }\n\n  return aggr;\n};\n\nfunction getFields(aggr) {\n  // Collect the output fields set by this aggregate.\n  var f = [], i, n, j, m, dims, vals, meas;\n\n  dims = aggr._dims;\n  for (i=0, n=dims.length; i<n; ++i) {\n    f.push(dims[i].name);\n  }\n\n  vals = aggr._aggr;\n  for (i=0, n=vals.length; i<n; ++i) {\n    meas = vals[i].measures.fields;\n    for (j=0, m=meas.length; j<m; ++j) {\n      f.push(meas[j]);\n    }\n  }\n\n  return f;\n}\n\nprototype.transform = function(input, reset) {\n  log.debug(input, ['aggregate']);\n\n  var output = ChangeSet.create(input),\n      aggr = this.aggr(),\n      out = this._out,\n      args = this._args,\n      reeval = true,\n      p = Tuple.prev,\n      add, rem, mod, mark, i;\n\n  // Upon reset, retract prior tuples and re-initialize.\n  if (reset) {\n    output.rem.push.apply(output.rem, aggr.result());\n    aggr.clear();\n    this._aggr = null;\n    aggr = this.aggr();\n  }\n\n  // Get update methods according to input type.\n  if (this._type === TYPES.TUPLE) {\n    add  = function(x) { aggr._add(x); Tuple.prev_init(x); };\n    rem  = function(x) { aggr._rem(p(x)); };\n    mod  = function(x) { aggr._mod(x, p(x)); };\n    mark = function(x) { aggr._markMod(x, p(x)); };\n  } else {\n    var gby = this._acc.groupby,\n        val = this._acc.value,\n        get = this._type === TYPES.VALUE ? val : function(x) {\n          return { _id: x._id, groupby: gby(x), value: val(x) };\n        };\n    add  = function(x) { aggr._add(get(x)); Tuple.prev_init(x); };\n    rem  = function(x) { aggr._rem(get(p(x))); };\n    mod  = function(x) { aggr._mod(get(x), get(p(x))); };\n    mark = function(x) { aggr._mark(get(x), get(p(x))); };\n  }\n\n  input.add.forEach(add);\n  if (reset) {\n    // A signal change triggered reflow. Add everything.\n    // No need for rem, we cleared the aggregator.\n    input.mod.forEach(add);\n  } else {\n    input.rem.forEach(rem);\n\n    // If possible, check argument fields to see if we need to re-process mods.\n    if (args) for (i=0, reeval=false; i<args.length; ++i) {\n      if (input.fields[args[i]]) { reeval = true; break; }\n    }\n    input.mod.forEach(reeval ? mod : mark);\n  }\n\n  // Indicate output fields and return aggregate tuples.\n  for (i=0; i<out.length; ++i) {\n    output.fields[out[i]] = 1;\n  }\n  return (aggr._input = input, aggr.changes(output));\n};\n\nmodule.exports = Aggregate;\n\nvar VALID_OPS = Aggregate.VALID_OPS;\n\nAggregate.schema = {\n  \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n  \"title\": \"Aggregate transform\",\n  \"description\": \"Compute summary aggregate statistics\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"type\": {\"enum\": [\"aggregate\"]},\n    \"groupby\": {\n      \"type\": \"array\",\n      \"items\": {\"oneOf\": [{\"type\": \"string\"}, {\"$ref\": \"#/refs/signal\"}]},\n      \"description\": \"A list of fields to split the data into groups.\"\n    },\n    \"summarize\": {\n      \"oneOf\": [\n        {\n          \"type\": \"object\",\n          \"additionalProperties\": {\n            \"type\": \"array\",\n            \"description\": \"An array of aggregate functions.\",\n            \"items\": {\"oneOf\": [{\"enum\": VALID_OPS}, {\"$ref\": \"#/refs/signal\"}]}\n          }\n        },\n        {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"object\",\n            \"properties\": {\n              \"field\": {\n                \"description\": \"The name of the field to aggregate.\",\n                \"oneOf\": [{\"type\": \"string\"}, {\"$ref\": \"#/refs/signal\"}]\n              },\n              \"ops\": {\n                \"type\": \"array\",\n                \"description\": \"An array of aggregate functions.\",\n                \"items\": {\"oneOf\": [{\"enum\": VALID_OPS}, {\"$ref\": \"#/refs/signal\"}]}\n              },\n              \"as\": {\n                \"type\": \"array\",\n                \"description\": \"An optional array of names to use for the output fields.\",\n                \"items\": {\"oneOf\": [{\"type\": \"string\"}, {\"$ref\": \"#/refs/signal\"}]}\n              }\n            },\n            \"additionalProperties\": false,\n            \"required\": [\"field\", \"ops\"]\n          }\n        }\n      ]\n    }\n  },\n  \"additionalProperties\": false,\n  \"required\": [\"type\"]\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/transforms/Aggregate.js\n ** module id = 107\n ** module chunks = 0\n **/","var df = require('vega-dataflow'),\n    Base = df.Node.prototype, // jshint ignore:line\n    Deps = df.Dependencies,\n    Parameter = require('./Parameter');\n\nfunction Transform(graph) {\n  if (graph) Base.init.call(this, graph);\n}\n\nTransform.addParameters = function(proto, params) {\n  proto._parameters = proto._parameters || {};\n  for (var name in params) {\n    var p = params[name],\n        param = new Parameter(name, p.type, proto);\n\n    proto._parameters[name] = param;\n\n    if (p.type === 'custom') {\n      if (p.set) param.set = p.set.bind(param);\n      if (p.get) param.get = p.get.bind(param);\n    }\n\n    if (p.hasOwnProperty('default')) param.set(p.default);\n  }\n};\n\nvar prototype = (Transform.prototype = Object.create(Base));\nprototype.constructor = Transform;\n\nprototype.param = function(name, value) {\n  var param = this._parameters[name];\n  return (param === undefined) ? this :\n    (arguments.length === 1) ? param.get() : param.set(value);\n};\n\n// Perform transformation. Subclasses should override.\nprototype.transform = function(input/*, reset */) {\n  return input;\n};\n\nprototype.evaluate = function(input) {\n  // Many transforms store caches that must be invalidated if\n  // a signal value has changed.\n  var reset = this._stamp < input.stamp &&\n    this.dependency(Deps.SIGNALS).reduce(function(c, s) {\n      return c += input.signals[s] ? 1 : 0;\n    }, 0);\n  return this.transform(input, reset);\n};\n\nprototype.output = function(map) {\n  for (var key in this._output) {\n    if (map[key] !== undefined) {\n      this._output[key] = map[key];\n    }\n  }\n  return this;\n};\n\nmodule.exports = Transform;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/transforms/Transform.js\n ** module id = 108\n ** module chunks = 0\n **/","var dl = require('datalib'),\n    Deps = require('vega-dataflow').Dependencies;\n\nvar arrayType = /array/i,\n    dataType  = /data/i,\n    fieldType = /field/i,\n    exprType  = /expr/i,\n    valType   = /value/i;\n\nfunction Parameter(name, type, transform) {\n  this._name = name;\n  this._type = type;\n  this._transform = transform;\n\n  // If parameter is defined w/signals, it must be resolved\n  // on every pulse.\n  this._value = [];\n  this._accessors = [];\n  this._resolution = false;\n  this._signals = [];\n}\n\nvar prototype = Parameter.prototype;\n\nfunction get() {\n  var isArray = arrayType.test(this._type),\n      isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type);\n\n  var val = isArray ? this._value : this._value[0],\n      acc = isArray ? this._accessors : this._accessors[0];\n\n  if (!dl.isValid(acc) && valType.test(this._type)) {\n    return val;\n  } else {\n    return isData ? { name: val, source: acc } :\n    isField ? { field: val, accessor: acc } : val;\n  }\n}\n\nprototype.get = function() {\n  var graph = this._transform._graph,\n      isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type),\n      i, n, sig, idx, val;\n\n  // If we don't require resolution, return the value immediately.\n  if (!this._resolution) return get.call(this);\n\n  if (isData) {\n    this._accessors = this._value.map(function(v) { return graph.data(v); });\n    return get.call(this); // TODO: support signal as dataTypes\n  }\n\n  for (i=0, n=this._signals.length; i<n; ++i) {\n    sig = this._signals[i];\n    idx = sig.index;\n    val = sig.value(graph);\n\n    if (isField) {\n      this._accessors[idx] = this._value[idx] != val ?\n        dl.accessor(val) : this._accessors[idx];\n    }\n\n    this._value[idx] = val;\n  }\n\n  return get.call(this);\n};\n\nprototype.set = function(value) {\n  var p = this,\n      graph = p._transform._graph,\n      isExpr = exprType.test(this._type),\n      isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type);\n\n  p._signals = [];\n  this._value = dl.array(value).map(function(v, i) {\n    var e;\n    if (dl.isString(v)) {\n      if (isExpr) {\n        e = graph.expr(v);\n        p._transform.dependency(Deps.FIELDS,  e.fields);\n        p._transform.dependency(Deps.SIGNALS, e.globals);\n        p._transform.dependency(Deps.DATA,    e.dataSources);\n        return e.fn;\n      } else if (isField) {  // Backwards compatibility\n        p._accessors[i] = dl.accessor(v);\n        p._transform.dependency(Deps.FIELDS, dl.field(v));\n      } else if (isData) {\n        p._resolution = true;\n        p._transform.dependency(Deps.DATA, v);\n      }\n      return v;\n    } else if (v.value !== undefined) {\n      return v.value;\n    } else if (v.field !== undefined) {\n      p._accessors[i] = dl.accessor(v.field);\n      p._transform.dependency(Deps.FIELDS, dl.field(v.field));\n      return v.field;\n    } else if (v.signal !== undefined) {\n      p._resolution = true;\n      p._transform.dependency(Deps.SIGNALS, v.signal);\n      p._signals.push({\n        index: i,\n        value: function(graph) { return graph.signalRef(v.signal); }\n      });\n      return v.signal;\n    } else if (v.expr !== undefined) {\n      p._resolution = true;\n      e = graph.expr(v.expr);\n      p._transform.dependency(Deps.SIGNALS, e.globals);\n      p._signals.push({\n        index: i,\n        value: function() { return e.fn(); }\n      });\n      return v.expr;\n    }\n\n    return v;\n  });\n\n  return p._transform;\n};\n\nmodule.exports = Parameter;\n\n// Schema for field|value-type parameters.\nParameter.schema = {\n  \"type\": \"object\",\n  \"oneOf\": [{\n    \"properties\": {\"field\": {\"type\": \"string\"}},\n    \"required\": [\"field\"]\n  }, {\n    \"properties\": {\"value\": {\"type\": \"string\"}},\n    \"required\": [\"value\"]\n  }]\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/transforms/Parameter.js\n ** module id = 109\n ** module chunks = 0\n **/","var dl = require('datalib'),\n    Aggregator = dl.Aggregator,\n    Base = Aggregator.prototype,\n    df = require('vega-dataflow'),\n    Tuple = df.Tuple,\n    log = require('vega-logging'),\n    facetID = 0;\n\nfunction Facetor() {\n  Aggregator.call(this);\n  this._facet = null;\n  this._facetID = ++facetID;\n}\n\nvar prototype = (Facetor.prototype = Object.create(Base));\nprototype.constructor = Facetor;\n\nprototype.facet = function(f) {\n  return arguments.length ? (this._facet = f, this) : this._facet;\n};\n\nprototype._ingest = function(t) {\n  return Tuple.ingest(t, null);\n};\n\nprototype._assign = Tuple.set;\n\nfunction disconnect_cell(facet) {\n  log.debug({}, ['disconnecting cell', this.tuple._id]);\n  var pipeline = this.ds.pipeline();\n  facet.removeListener(pipeline[0]);\n  facet._graph.removeListener(pipeline[0]);\n  facet._graph.disconnect(pipeline);\n}\n\nprototype._newcell = function(x, key) {\n  var cell  = Base._newcell.call(this, x, key),\n      facet = this._facet;\n\n  if (facet) {\n    var graph = facet._graph,\n        tuple = cell.tuple,\n        pipeline = facet.param('transform');\n    cell.ds = graph.data(tuple._facetID, pipeline, tuple);\n    cell.disconnect = disconnect_cell;\n    facet.addListener(pipeline[0]);\n  }\n\n  return cell;\n};\n\nprototype._newtuple = function(x, key) {\n  var t = Base._newtuple.call(this, x);\n  if (this._facet) {\n    Tuple.set(t, 'key', key);\n    Tuple.set(t, '_facetID', this._facetID + '_' + key);\n  }\n  return t;\n};\n\nprototype.clear = function() {\n  if (this._facet) {\n    for (var k in this._cells) {\n      this._cells[k].disconnect(this._facet);\n    }\n  }\n  return Base.clear.call(this);\n};\n\nprototype._on_add = function(x, cell) {\n  if (this._facet) cell.ds._input.add.push(x);\n};\n\nprototype._on_rem = function(x, cell) {\n  if (this._facet) cell.ds._input.rem.push(x);\n};\n\nprototype._on_mod = function(x, prev, cell0, cell1) {\n  if (this._facet) { // Propagate tuples\n    if (cell0 === cell1) {\n      cell0.ds._input.mod.push(x);\n    } else {\n      cell0.ds._input.rem.push(x);\n      cell1.ds._input.add.push(x);\n    }\n  }\n};\n\nprototype._on_drop = function(cell) {\n  if (this._facet) cell.disconnect(this._facet);\n};\n\nprototype._on_keep = function(cell) {\n  // propagate sort, signals, fields, etc.\n  if (this._facet) df.ChangeSet.copy(this._input, cell.ds._input);\n};\n\nmodule.exports = Facetor;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/transforms/Facetor.js\n ** module id = 110\n ** module chunks = 0\n **/","var dl = require('datalib'),\n    Tuple = require('vega-dataflow').Tuple,\n    log = require('vega-logging'),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform');\n\nfunction Bin(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    field: {type: 'field'},\n    min: {type: 'value'},\n    max: {type: 'value'},\n    base: {type: 'value', default: 10},\n    maxbins: {type: 'value', default: 20},\n    step: {type: 'value'},\n    steps: {type: 'value'},\n    minstep: {type: 'value'},\n    div: {type: 'array<value>', default: [5, 2]}\n  });\n\n  this._output = {\n    start: 'bin_start',\n    end:   'bin_end',\n    mid:   'bin_mid'\n  };\n  return this.mutates(true);\n}\n\nvar prototype = (Bin.prototype = Object.create(BatchTransform.prototype));\nprototype.constructor = Bin;\n\nprototype.extent = function(data) {\n  // TODO only recompute extent upon data or field change?\n  var e = [this.param('min'), this.param('max')], d;\n  if (e[0] == null || e[1] == null) {\n    d = dl.extent(data, this.param('field').accessor);\n    if (e[0] == null) e[0] = d[0];\n    if (e[1] == null) e[1] = d[1];\n  }\n  return e;\n};\n\nprototype.batchTransform = function(input, data) {\n  log.debug(input, ['binning']);\n\n  var extent  = this.extent(data),\n      output  = this._output,\n      step    = this.param('step'),\n      steps   = this.param('steps'),\n      minstep = this.param('minstep'),\n      get     = this.param('field').accessor,\n      opt = {\n        min: extent[0],\n        max: extent[1],\n        base: this.param('base'),\n        maxbins: this.param('maxbins'),\n        div: this.param('div')\n      };\n\n  if (step) opt.step = step;\n  if (steps) opt.steps = steps;\n  if (minstep) opt.minstep = minstep;\n  var b = dl.bins(opt),\n      s = b.step;\n\n  function update(d) {\n    var v = get(d);\n    v = v == null ? null\n      : b.start + s * ~~((v - b.start) / s);\n    Tuple.set(d, output.start, v);\n    Tuple.set(d, output.end, v + s);\n    Tuple.set(d, output.mid, v + s/2);\n  }\n  input.add.forEach(update);\n  input.mod.forEach(update);\n  input.rem.forEach(update);\n\n  input.fields[output.start] = 1;\n  input.fields[output.end] = 1;\n  input.fields[output.mid] = 1;\n  return input;\n};\n\nmodule.exports = Bin;\n\nBin.schema = {\n  \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n  \"title\": \"Bin transform\",\n  \"description\": \"Bins values into quantitative bins (e.g., for a histogram).\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"type\": {\"enum\": [\"bin\"]},\n    \"field\": {\n      \"oneOf\": [{\"type\": \"string\"}, {\"$ref\": \"#/refs/signal\"}],\n      \"description\": \"The name of the field to bin values from.\"\n    },\n    \"min\": {\n      \"oneOf\": [{\"type\": \"number\"}, {\"$ref\": \"#/refs/signal\"}],\n      \"description\": \"The minimum bin value to consider.\"\n    },\n    \"max\": {\n      \"oneOf\": [{\"type\": \"number\"}, {\"$ref\": \"#/refs/signal\"}],\n      \"description\": \"The maximum bin value to consider.\"\n    },\n    \"base\": {\n      \"oneOf\": [{\"type\": \"number\"}, {\"$ref\": \"#/refs/signal\"}],\n      \"description\": \"The number base to use for automatic bin determination.\",\n      \"default\": 10\n    },\n    \"maxbins\": {\n      \"oneOf\": [{\"type\": \"number\"}, {\"$ref\": \"#/refs/signal\"}],\n      \"description\": \"The maximum number of allowable bins.\",\n      \"default\": 20\n    },\n    \"step\": {\n      \"oneOf\": [{\"type\": \"number\"}, {\"$ref\": \"#/refs/signal\"}],\n      \"description\": \"An exact step size to use between bins. If provided, options such as maxbins will be ignored.\"\n    },\n    \"steps\": {\n      \"description\": \"An array of allowable step sizes to choose from.\",\n      \"oneOf\": [\n        {\n          \"type\": \"array\",\n          \"items\": {\"type\": \"number\"}\n        },\n        {\"$ref\": \"#/refs/signal\"}\n      ]\n    },\n    \"minstep\": {\n      \"oneOf\": [{\"type\": \"number\"}, {\"$ref\": \"#/refs/signal\"}],\n      \"description\": \"A minimum allowable step size (particularly useful for integer values).\"\n    },\n    \"div\": {\n      \"description\": \"An array of scale factors indicating allowable subdivisions.\",\n      \"oneOf\": [\n        {\n          \"type\": \"array\",\n          \"items\": {\"type\": \"number\"},\n          \"default\": [5, 2]\n        },\n        {\"$ref\": \"#/refs/signal\"}\n      ]\n    },\n    \"output\": {\n      \"type\": \"object\",\n      \"description\": \"Rename the output data fields\",\n      \"properties\": {\n        \"start\": {\"type\": \"string\", \"default\": \"bin_start\"},\n        \"end\": {\"type\": \"string\", \"default\": \"bin_end\"},\n        \"mid\": {\"type\": \"string\", \"default\": \"bin_mid\"}\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false,\n  \"required\": [\"type\", \"field\"]\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/transforms/Bin.js\n ** module id = 111\n ** module chunks = 0\n **/","var Base = require('./Transform').prototype;\n\nfunction BatchTransform() {\n  // Nearest appropriate collector.\n  // Set by the dataflow Graph during connection.\n  this._collector = null;\n}\n\nvar prototype = (BatchTransform.prototype = Object.create(Base));\nprototype.constructor = BatchTransform;\n\nprototype.init = function(graph) {\n  Base.init.call(this, graph);\n  return this.batch(true);\n};\n\nprototype.transform = function(input, reset) {\n  return this.batchTransform(input, this._collector.data(), reset);\n};\n\nprototype.batchTransform = function(/* input, data, reset */) {\n};\n\nmodule.exports = BatchTransform;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/transforms/BatchTransform.js\n ** module id = 112\n ** module chunks = 0\n **/","var dl = require('datalib'),\n    df = require('vega-dataflow'),\n    ChangeSet = df.ChangeSet,\n    Tuple = df.Tuple,\n    log = require('vega-logging'),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform');\n\nfunction Cross(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    with: {type: 'data'},\n    diagonal: {type: 'value', default: 'true'},\n    filter: {type: 'expr'}\n  });\n\n  this._output = {'left': 'a', 'right': 'b'};\n  this._lastWith = null; // Last time we crossed w/with-ds.\n  this._cids  = {};\n  this._cache = {};\n\n  return this.router(true).produces(true);\n}\n\nvar prototype = (Cross.prototype = Object.create(BatchTransform.prototype));\nprototype.constructor = Cross;\n\n// Each cached incoming tuple also has a flag to determine whether\n// any tuples were filtered.\nfunction _cache(x, t) {\n  var c = this._cache,\n      cross = c[x._id] || (c[x._id] = {c: [], f: false});\n  cross.c.push(t);\n}\n\nfunction _cid(left, x, y) {\n  return left ? x._id+'_'+y._id : y._id+'_'+x._id;\n}\n\nfunction add(output, left, data, diag, test, mids, x) {\n  var as = this._output,\n      cache = this._cache,\n      cids  = this._cids,\n      oadd  = output.add,\n      fltrd = false,\n      i = 0, len = data.length,\n      t = {}, y, cid;\n\n  for (; i<len; ++i) {\n    y = data[i];\n    cid = _cid(left, x, y);\n    if (cids[cid]) continue;\n    if (x._id === y._id && !diag) continue;\n\n    Tuple.set(t, as.left, left ? x : y);\n    Tuple.set(t, as.right, left ? y : x);\n\n    // Only ingest a tuple if we keep it around. Otherwise, flag the\n    // caches as filtered.\n    if (!test || test(t)) {\n      oadd.push(t=Tuple.ingest(t));\n      _cache.call(this, x, t);\n      if (x._id !== y._id) _cache.call(this, y, t);\n      mids[t._id] = 1;\n      cids[cid] = true;\n      t = {};\n    } else {\n      if (cache[y._id]) cache[y._id].f = true;\n      fltrd = true;\n    }\n  }\n\n  if (cache[x._id]) cache[x._id].f = fltrd;\n}\n\nfunction mod(output, left, data, diag, test, mids, rids, x) {\n  var as = this._output,\n      cache = this._cache,\n      cids  = this._cids,\n      cross = cache[x._id],\n      tpls  = cross && cross.c,\n      fltrd = !cross || cross.f,\n      omod  = output.mod,\n      orem  = output.rem,\n      i, t, y, l, cid;\n\n  // If we have cached values, iterate through them for lazy\n  // removal, and to re-run the filter.\n  if (tpls) {\n    for (i=tpls.length-1; i>=0; --i) {\n      t = tpls[i];\n      l = x === t[as.left]; // Cache has tpls w/x both on left & right.\n      y = l ? t[as.right] : t[as.left];\n      cid = _cid(l, x, y);\n\n      // Lazy removal: y was previously rem'd, so clean up the cache.\n      if (!cache[y._id]) {\n        cids[cid] = false;\n        tpls.splice(i, 1);\n        continue;\n      }\n\n      if (!test || test(t)) {\n        if (mids[t._id]) continue;\n        omod.push(t);\n        mids[t._id] = 1;\n      } else {\n        if (!rids[t._id]) orem.push.apply(orem, tpls.splice(i, 1));\n        rids[t._id] = 1;\n        cids[cid] = false;\n        cross.f = true;\n      }\n    }\n  }\n\n  // If we have a filter param, call add to catch any tuples that may\n  // have previously been filtered.\n  if (test && fltrd) add.call(this, output, left, data, diag, test, mids, x);\n}\n\nfunction rem(output, left, rids, x) {\n  var as = this._output,\n      cross = this._cache[x._id],\n      cids  = this._cids,\n      orem  = output.rem,\n      i, len, t, y, l;\n  if (!cross) return;\n\n  for (i=0, len=cross.c.length; i<len; ++i) {\n    t = cross.c[i];\n    l = x === t[as.left];\n    y = l ? t[as.right] : t[as.left];\n    cids[_cid(l, x, y)] = false;\n    if (!rids[t._id]) {\n      orem.push(t);\n      rids[t._id] = 1;\n    }\n  }\n\n  this._cache[x._id] = null;\n}\n\nfunction purge(output, rids) {\n  var cache = this._cache,\n      keys  = dl.keys(cache),\n      rem = output.rem,\n      i, len, j, jlen, cross, t;\n\n  for (i=0, len=keys.length; i<len; ++i) {\n    cross = cache[keys[i]];\n    for (j=0, jlen=cross.c.length; j<jlen; ++j) {\n      t = cross.c[j];\n      if (rids[t._id]) continue;\n      rem.push(t);\n      rids[t._id] = 1;\n    }\n  }\n\n  this._cache = {};\n  this._cids = {};\n  this._lastWith = null;\n}\n\nprototype.batchTransform = function(input, data, reset) {\n  log.debug(input, ['crossing']);\n\n  var w = this.param('with'),\n      diag = this.param('diagonal'),\n      as = this._output,\n      test = this.param('filter') || null,\n      selfCross = (!w.name),\n      woutput = selfCross ? input : w.source.last(),\n      wdata   = selfCross ? data : w.source.values(),\n      output  = ChangeSet.create(input),\n      mids = {}, rids = {}; // Track IDs to prevent dupe mod/rem tuples.\n\n  // If signal values (for diag or test) have changed, purge the cache\n  // and re-run cross in batch mode. Otherwise stream cross values.\n  if (reset) {\n    purge.call(this, output, rids);\n    data.forEach(add.bind(this, output, true, wdata, diag, test, mids));\n    this._lastWith = woutput.stamp;\n  } else {\n    input.rem.forEach(rem.bind(this, output, true, rids));\n    input.add.forEach(add.bind(this, output, true, wdata, diag, test, mids));\n\n    if (woutput.stamp > this._lastWith) {\n      woutput.rem.forEach(rem.bind(this, output, false, rids));\n      woutput.add.forEach(add.bind(this, output, false, data, diag, test, mids));\n      woutput.mod.forEach(mod.bind(this, output, false, data, diag, test, mids, rids));\n      this._lastWith = woutput.stamp;\n    }\n\n    // Mods need to come after all removals have been run.\n    input.mod.forEach(mod.bind(this, output, true, wdata, diag, test, mids, rids));\n  }\n\n  output.fields[as.left]  = 1;\n  output.fields[as.right] = 1;\n  return output;\n};\n\nmodule.exports = Cross;\n\nCross.schema = {\n  \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n  \"title\": \"Cross transform\",\n  \"description\": \"Compute the cross-product of two data sets.\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"type\": {\"enum\": [\"cross\"]},\n    \"with\": {\n      \"type\": \"string\",\n      \"description\": \"The name of the secondary data set to cross with the primary data. \" +\n        \"If unspecified, the primary data is crossed with itself.\"\n    },\n    \"diagonal\": {\n      \"oneOf\": [{\"type\": \"boolean\"}, {\"$ref\": \"#/refs/signal\"}],\n      \"description\": \"If false, items along the \\\"diagonal\\\" of the cross-product \" +\n        \"(those elements with the same index in their respective array) \" +\n        \"will not be included in the output.\",\n      \"default\": true\n    },\n    \"filter\": {\n      \"type\": \"string\",\n      \"description\": \"A string containing an expression (in JavaScript syntax) \" +\n        \"to filter the resulting data elements.\"\n    },\n    \"output\": {\n      \"type\": \"object\",\n      \"description\": \"Rename the output data fields\",\n      \"properties\": {\n        \"left\": {\"type\": \"string\", \"default\": \"a\"},\n        \"right\": {\"type\": \"string\", \"default\": \"b\"}\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false,\n  \"required\": [\"type\"]\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/transforms/Cross.js\n ** module id = 113\n ** module chunks = 0\n **/","var df = require('vega-dataflow'),\n    Tuple = df.Tuple,\n    log = require('vega-logging'),\n    Transform = require('./Transform');\n\nfunction CountPattern(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    field:     {type: 'field', default: 'data'},\n    pattern:   {type: 'value', default: '[\\\\w\\']+'},\n    case:      {type: 'value', default: 'lower'},\n    stopwords: {type: 'value', default: ''}\n  });\n\n  this._output = {text: 'text', count: 'count'};\n\n  return this.router(true).produces(true);\n}\n\nvar prototype = (CountPattern.prototype = Object.create(Transform.prototype));\nprototype.constructor = CountPattern;\n\nprototype.transform = function(input, reset) {\n  log.debug(input, ['countpattern']);\n\n  var get = this.param('field').accessor,\n      pattern = this.param('pattern'),\n      stop = this.param('stopwords'),\n      rem = false;\n\n  // update parameters\n  if (this._stop !== stop) {\n    this._stop = stop;\n    this._stop_re = new RegExp('^' + stop + '$', 'i');\n    reset = true;\n  }\n\n  if (this._pattern !== pattern) {\n    this._pattern = pattern;\n    this._match = new RegExp(this._pattern, 'g');\n    reset = true;\n  }\n\n  if (reset) this._counts = {};\n\n  function curr(t) { return (Tuple.prev_init(t), get(t)); }\n  function prev(t) { return get(Tuple.prev(t)); }\n\n  this._add(input.add, curr);\n  if (!reset) this._rem(input.rem, prev);\n  if (reset || (rem = input.fields[get.field])) {\n    if (rem) this._rem(input.mod, prev);\n    this._add(input.mod, curr);\n  }\n\n  // generate output tuples\n  return this._changeset(input);\n};\n\nprototype._changeset = function(input) {\n  var counts = this._counts,\n      tuples = this._tuples || (this._tuples = {}),\n      change = df.ChangeSet.create(input),\n      out = this._output, w, t, c;\n\n  for (w in counts) {\n    t = tuples[w];\n    c = counts[w] || 0;\n    if (!t && c) {\n      tuples[w] = (t = Tuple.ingest({}));\n      t[out.text] = w;\n      t[out.count] = c;\n      change.add.push(t);\n    } else if (c === 0) {\n      if (t) change.rem.push(t);\n      delete counts[w];\n      delete tuples[w];\n    } else if (t[out.count] !== c) {\n      Tuple.set(t, out.count, c);\n      change.mod.push(t);\n    }\n  }\n  return change;\n};\n\nprototype._tokenize = function(text) {\n  switch (this.param('case')) {\n    case 'upper': text = text.toUpperCase(); break;\n    case 'lower': text = text.toLowerCase(); break;\n  }\n  return text.match(this._match);\n};\n\nprototype._add = function(tuples, get) {\n  var counts = this._counts,\n      stop = this._stop_re,\n      tok, i, j, t;\n\n  for (j=0; j<tuples.length; ++j) {\n    tok = this._tokenize(get(tuples[j]));\n    for (i=0; i<tok.length; ++i) {\n      if (!stop.test(t=tok[i])) {\n        counts[t] = 1 + (counts[t] || 0);\n      }\n    }\n  }\n};\n\nprototype._rem = function(tuples, get) {\n  var counts = this._counts,\n      stop = this._stop_re,\n      tok, i, j, t;\n\n  for (j=0; j<tuples.length; ++j) {\n    tok = this._tokenize(get(tuples[j]));\n    for (i=0; i<tok.length; ++i) {\n      if (!stop.test(t=tok[i])) {\n        counts[t] -= 1;\n      }\n    }\n  }\n};\n\nmodule.exports = CountPattern;\n\nCountPattern.schema = {\n  \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n  \"title\": \"CountPattern transform\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"type\": {\"enum\": [\"countpattern\"]},\n    \"field\": {\n      \"description\": \"The field containing the text to analyze.\",\n      \"oneOf\": [{\"type\": \"string\"}, {\"$ref\": \"#/refs/signal\"}],\n      \"default\": 'data'\n    },\n    \"pattern\": {\n      \"description\": \"A regexp pattern for matching words in text.\",\n      \"oneOf\": [{\"type\": \"string\"}, {\"$ref\": \"#/refs/signal\"}],\n      \"default\": \"[\\\\w\\']+\"\n    },\n    \"case\": {\n      \"description\": \"Text case transformation to apply.\",\n      \"oneOf\": [{\"enum\": [\"lower\", \"upper\", \"none\"]}, {\"$ref\": \"#/refs/signal\"}],\n      \"default\": \"lower\"\n    },\n    \"stopwords\": {\n      \"description\": \"A regexp pattern for matching stopwords to omit.\",\n      \"oneOf\": [{\"type\": \"string\"}, {\"$ref\": \"#/refs/signal\"}],\n      \"default\": \"\"\n    },\n    \"output\": {\n      \"type\": \"object\",\n      \"description\": \"Rename the output data fields\",\n      \"properties\": {\n        \"text\": {\"type\": \"string\", \"default\": \"text\"},\n        \"count\": {\"type\": \"string\", \"default\": \"count\"}\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false,\n  \"required\": [\"type\"]\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/transforms/CountPattern.js\n ** module id = 114\n ** module chunks = 0\n **/","var Tuple = require('vega-dataflow').Tuple,\n    log = require('vega-logging'),\n    Transform = require('./Transform');\n\nfunction LinkPath(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    sourceX:  {type: 'field', default: '_source.layout_x'},\n    sourceY:  {type: 'field', default: '_source.layout_y'},\n    targetX:  {type: 'field', default: '_target.layout_x'},\n    targetY:  {type: 'field', default: '_target.layout_y'},\n    tension:  {type: 'value', default: 0.2},\n    shape:    {type: 'value', default: 'line'}\n  });\n\n  this._output = {'path': 'layout_path'};\n  return this.mutates(true);\n}\n\nvar prototype = (LinkPath.prototype = Object.create(Transform.prototype));\nprototype.constructor = LinkPath;\n\nfunction line(sx, sy, tx, ty) {\n  return 'M' + sx + ',' + sy +\n         'L' + tx + ',' + ty;\n}\n\nfunction curve(sx, sy, tx, ty, tension) {\n  var dx = tx - sx,\n      dy = ty - sy,\n      ix = tension * (dx + dy),\n      iy = tension * (dy - dx);\n  return 'M' + sx + ',' + sy +\n         'C' + (sx+ix) + ',' + (sy+iy) +\n         ' ' + (tx+iy) + ',' + (ty-ix) +\n         ' ' + tx + ',' + ty;\n}\n\nfunction cornerX(sx, sy, tx, ty) {\n  return 'M' + sx + ',' + sy +\n         'V' + ty + 'H' + tx;\n}\n\nfunction cornerY(sx, sy, tx, ty) {\n  return 'M' + sx + ',' + sy +\n         'H' + tx + 'V' + ty;\n}\n\nfunction cornerR(sa, sr, ta, tr) {\n  var sc = Math.cos(sa),\n      ss = Math.sin(sa),\n      tc = Math.cos(ta),\n      ts = Math.sin(ta),\n      sf = Math.abs(ta - sa) > Math.PI ? ta <= sa : ta > sa;\n  return 'M' + (sr*sc) + ',' + (sr*ss) +\n         'A' + sr + ',' + sr + ' 0 0,' + (sf?1:0) +\n         ' ' + (sr*tc) + ',' + (sr*ts) +\n         'L' + (tr*tc) + ',' + (tr*ts);\n}\n\nfunction diagonalX(sx, sy, tx, ty) {\n  var m = (sx + tx) / 2;\n  return 'M' + sx + ',' + sy +\n         'C' + m  + ',' + sy +\n         ' ' + m  + ',' + ty +\n         ' ' + tx + ',' + ty;\n}\n\nfunction diagonalY(sx, sy, tx, ty) {\n  var m = (sy + ty) / 2;\n  return 'M' + sx + ',' + sy +\n         'C' + sx + ',' + m +\n         ' ' + tx + ',' + m +\n         ' ' + tx + ',' + ty;\n}\n\nfunction diagonalR(sa, sr, ta, tr) {\n  var sc = Math.cos(sa),\n      ss = Math.sin(sa),\n      tc = Math.cos(ta),\n      ts = Math.sin(ta),\n      mr = (sr + tr) / 2;\n  return 'M' + (sr*sc) + ',' + (sr*ss) +\n         'C' + (mr*sc) + ',' + (mr*ss) +\n         ' ' + (mr*tc) + ',' + (mr*ts) +\n         ' ' + (tr*tc) + ',' + (tr*ts);\n}\n\nvar shapes = {\n  line:      line,\n  curve:     curve,\n  cornerX:   cornerX,\n  cornerY:   cornerY,\n  cornerR:   cornerR,\n  diagonalX: diagonalX,\n  diagonalY: diagonalY,\n  diagonalR: diagonalR\n};\n\nprototype.transform = function(input) {\n  log.debug(input, ['linkpath']);\n\n  var output = this._output,\n      shape = shapes[this.param('shape')] || shapes.line,\n      sourceX = this.param('sourceX').accessor,\n      sourceY = this.param('sourceY').accessor,\n      targetX = this.param('targetX').accessor,\n      targetY = this.param('targetY').accessor,\n      tension = this.param('tension');\n\n  function set(t) {\n    var path = shape(sourceX(t), sourceY(t), targetX(t), targetY(t), tension);\n    Tuple.set(t, output.path, path);\n  }\n\n  input.add.forEach(set);\n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n    input.rem.forEach(set);\n  }\n\n  input.fields[output.path] = 1;\n  return input;\n};\n\nmodule.exports = LinkPath;\n\nLinkPath.schema = {\n  \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n  \"title\": \"LinkPath transform\",\n  \"description\": \"Computes a path definition for connecting nodes within a node-link network or tree diagram.\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"type\": {\"enum\": [\"linkpath\"]},\n    \"sourceX\": {\n      \"description\": \"The data field that references the source x-coordinate for this link.\",\n      \"oneOf\": [{\"type\": \"string\"}, {\"$ref\": \"#/refs/signal\"}],\n      \"default\": \"_source\"\n    },\n    \"sourceY\": {\n      \"description\": \"The data field that references the source y-coordinate for this link.\",\n      \"oneOf\": [{\"type\": \"string\"}, {\"$ref\": \"#/refs/signal\"}],\n      \"default\": \"_source\"\n    },\n    \"targetX\": {\n      \"description\": \"The data field that references the target x-coordinate for this link.\",\n      \"oneOf\": [{\"type\": \"string\"}, {\"$ref\": \"#/refs/signal\"}],\n      \"default\": \"_target\"\n    },\n    \"targetY\": {\n      \"description\": \"The data field that references the target y-coordinate for this link.\",\n      \"oneOf\": [{\"type\": \"string\"}, {\"$ref\": \"#/refs/signal\"}],\n      \"default\": \"_target\"\n    },\n    \"tension\": {\n      \"description\": \"A tension parameter for the \\\"tightness\\\" of \\\"curve\\\"-shaped links.\",\n      \"oneOf\": [\n        {\n          \"type\": \"number\",\n          \"minimum\": 0,\n          \"maximum\": 1\n        },\n        {\"$ref\": \"#/refs/signal\"}\n      ],\n      \"default\": 0.2\n    },\n    \"shape\": {\n      \"description\": \"The path shape to use\",\n      \"oneOf\": [\n        {\"enum\": [\"line\", \"curve\", \"cornerX\", \"cornerY\", \"cornerR\", \"diagonalX\", \"diagonalY\", \"diagonalR\"]},\n        {\"$ref\": \"#/refs/signal\"}\n      ],\n      \"default\": \"line\"\n    },\n    \"output\": {\n      \"type\": \"object\",\n      \"description\": \"Rename the output data fields\",\n      \"properties\": {\n        \"path\": {\"type\": \"string\", \"default\": \"layout_path\"}\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false,\n  \"required\": [\"type\"]\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/transforms/LinkPath.js\n ** module id = 115\n ** module chunks = 0\n **/","var Transform = require('./Transform'),\n    Aggregate = require('./Aggregate');\n\nfunction Facet(graph) {\n  Transform.addParameters(this, {\n    transform: {\n      type: \"custom\",\n      set: function(pipeline) {\n        return (this._transform._pipeline = pipeline, this._transform);\n      },\n      get: function() {\n        var parse = require('../parse/transforms'),\n            facet = this._transform;\n        return facet._pipeline.map(function(t) {\n          return parse(facet._graph, t);\n        });\n      }\n    }\n  });\n\n  this._pipeline = [];\n  return Aggregate.call(this, graph);\n}\n\nvar prototype = (Facet.prototype = Object.create(Aggregate.prototype));\nprototype.constructor = Facet;\n\nprototype.aggr = function() {\n  return Aggregate.prototype.aggr.call(this).facet(this);\n};\n\nprototype.transform = function(input, reset) {\n  var output  = Aggregate.prototype.transform.call(this, input, reset);\n\n  // New facet cells should trigger a re-ranking of the dataflow graph.\n  // This ensures facet datasources are computed before scenegraph nodes.\n  // We rerank the Facet's first listener, which is the next node in the\n  // datasource's pipeline.\n  if (input.add.length) {\n    this.listeners()[0].rerank();\n  }\n\n  return output;\n};\n\nmodule.exports = Facet;\n\nvar dl = require('datalib');\n\nFacet.schema = {\n  \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n  \"title\": \"Facet transform\",\n  \"description\": \"A special aggregate transform that organizes a data set into groups or \\\"facets\\\".\",\n  \"type\": \"object\",\n  \"properties\": dl.extend({}, Aggregate.schema.properties, {\n    \"type\": {\"enum\": [\"facet\"]},\n    \"transform\": {\"$ref\": \"#/defs/transform\"}\n  }),\n  \"additionalProperties\": false,\n  \"required\": [\"type\"]\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/transforms/Facet.js\n ** module id = 116\n ** module chunks = 0\n **/","var df = require('vega-dataflow'),\n    log = require('vega-logging'),\n    Transform = require('./Transform');\n\nfunction Filter(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {test: {type: 'expr'}});\n\n  this._skip = {};\n  return this.router(true);\n}\n\nvar prototype = (Filter.prototype = Object.create(Transform.prototype));\nprototype.constructor = Filter;\n\nprototype.transform = function(input) {\n  log.debug(input, ['filtering']);\n\n  var output = df.ChangeSet.create(input),\n      skip = this._skip,\n      test = this.param('test');\n\n  input.rem.forEach(function(x) {\n    if (skip[x._id] !== 1) output.rem.push(x);\n    else skip[x._id] = 0;\n  });\n\n  input.add.forEach(function(x) {\n    if (test(x)) output.add.push(x);\n    else skip[x._id] = 1;\n  });\n\n  input.mod.forEach(function(x) {\n    var b = test(x),\n        s = (skip[x._id] === 1);\n    if (b && s) {\n      skip[x._id] = 0;\n      output.add.push(x);\n    } else if (b && !s) {\n      output.mod.push(x);\n    } else if (!b && s) {\n      // do nothing, keep skip true\n    } else { // !b && !s\n      output.rem.push(x);\n      skip[x._id] = 1;\n    }\n  });\n\n  return output;\n};\n\nmodule.exports = Filter;\n\nFilter.schema = {\n  \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n  \"title\": \"Filter transform\",\n  \"description\": \"Filters elements from a data set to remove unwanted items.\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"type\": {\"enum\": [\"filter\"]},\n    \"test\": {\n      \"type\": \"string\",\n      \"description\": \"A string containing an expression (in JavaScript syntax) for the filter predicate.\"\n    }\n  },\n  \"additionalProperties\": false,\n  \"required\": [\"type\", \"test\"]\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/transforms/Filter.js\n ** module id = 117\n ** module chunks = 0\n **/","var df = require('vega-dataflow'),\n    Tuple = df.Tuple,\n    log = require('vega-logging'),\n    Transform = require('./Transform');\n\nfunction Fold(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    fields: {type: 'array<field>'}\n  });\n\n  this._output = {key: 'key', value: 'value'};\n  this._cache = {};\n\n  return this.router(true).produces(true);\n}\n\nvar prototype = (Fold.prototype = Object.create(Transform.prototype));\nprototype.constructor = Fold;\n\nprototype._reset = function(input, output) {\n  for (var id in this._cache) {\n    output.rem.push.apply(output.rem, this._cache[id]);\n  }\n  this._cache = {};\n};\n\nprototype._tuple = function(x, i, len) {\n  var list = this._cache[x._id] || (this._cache[x._id] = Array(len));\n  return list[i] ? Tuple.rederive(x, list[i]) : (list[i] = Tuple.derive(x));\n};\n\nprototype._fn = function(data, on, out) {\n  var i, j, n, m, d, t;\n  for (i=0, n=data.length; i<n; ++i) {\n    d = data[i];\n    for (j=0, m=on.field.length; j<m; ++j) {\n      t = this._tuple(d, j, m);\n      Tuple.set(t, this._output.key, on.field[j]);\n      Tuple.set(t, this._output.value, on.accessor[j](d));\n      out.push(t);\n    }\n  }\n};\n\nprototype.transform = function(input, reset) {\n  log.debug(input, ['folding']);\n\n  var fold = this,\n      on = this.param('fields'),\n      output = df.ChangeSet.create(input);\n\n  if (reset) this._reset(input, output);\n\n  this._fn(input.add, on, output.add);\n  this._fn(input.mod, on, reset ? output.add : output.mod);\n  input.rem.forEach(function(x) {\n    output.rem.push.apply(output.rem, fold._cache[x._id]);\n    fold._cache[x._id] = null;\n  });\n\n  // If we're only propagating values, don't mark key/value as updated.\n  if (input.add.length || input.rem.length ||\n      on.field.some(function(f) { return !!input.fields[f]; })) {\n    output.fields[this._output.key] = 1;\n    output.fields[this._output.value] = 1;\n  }\n  return output;\n};\n\nmodule.exports = Fold;\n\nFold.schema = {\n  \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n  \"title\": \"Fold transform\",\n  \"description\": \"Collapse (\\\"fold\\\") one or more data properties into two properties.\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"type\": {\"enum\": [\"fold\"]},\n    \"fields\": {\n      \"oneOf\": [\n        {\n          \"type\": \"array\",\n          \"description\": \"An array of field references indicating the data properties to fold.\",\n          \"items\": {\"oneOf\": [{\"type\": \"string\"}, {\"$ref\": \"#/refs/signal\"}]},\n          \"minItems\": 1,\n          \"uniqueItems\": true\n        },\n        {\"$ref\": \"#/refs/signal\"}\n      ]\n    },\n    \"output\": {\n      \"type\": \"object\",\n      \"description\": \"Rename the output data fields\",\n      \"properties\": {\n        \"key\": {\"type\": \"string\", \"default\": \"key\"},\n        \"value\": {\"type\": \"string\", \"default\": \"value\"}\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false,\n  \"required\": [\"type\", \"fields\"]\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/transforms/Fold.js\n ** module id = 118\n ** module chunks = 0\n **/","var d3 = require('d3'),\n    df = require('vega-dataflow'),\n    Tuple = df.Tuple,\n    ChangeSet = df.ChangeSet,\n    log = require('vega-logging'),\n    Transform = require('./Transform');\n\nfunction Force(graph) {\n  Transform.prototype.init.call(this, graph);\n\n  this._prev = null;\n  this._interactive = false;\n  this._setup = true;\n  this._nodes  = [];\n  this._links = [];\n  this._layout = d3.layout.force();\n\n  Transform.addParameters(this, {\n    size: {type: 'array<value>', default: require('./screen').size},\n    bound: {type: 'value', default: true},\n    links: {type: 'data'},\n\n    // TODO: for now force these to be value params only (pun-intended)\n    // Can update to include fields after Parameter refactoring.\n    linkStrength: {type: 'value', default: 1},\n    linkDistance: {type: 'value', default: 20},\n    charge: {type: 'value', default: -30},\n\n    chargeDistance: {type: 'value', default: Infinity},\n    friction: {type: 'value', default: 0.9},\n    theta: {type: 'value', default: 0.8},\n    gravity: {type: 'value', default: 0.1},\n    alpha: {type: 'value', default: 0.1},\n    iterations: {type: 'value', default: 500},\n\n    interactive: {type: 'value', default: this._interactive},\n    active: {type: 'value', default: this._prev},\n    fixed: {type: 'data'}\n  });\n\n  this._output = {\n    'x': 'layout_x',\n    'y': 'layout_y'\n  };\n\n  return this.mutates(true);\n}\n\nvar prototype = (Force.prototype = Object.create(Transform.prototype));\nprototype.constructor = Force;\n\nprototype.transform = function(nodeInput, reset) {\n  log.debug(nodeInput, ['force']);\n  reset = reset - (nodeInput.signals.active ? 1 : 0);\n\n  // get variables\n  var interactive = this.param('interactive'),\n      linkSource = this.param('links').source,\n      linkInput = linkSource.last(),\n      active = this.param('active'),\n      output = this._output,\n      layout = this._layout,\n      nodes = this._nodes,\n      links = this._links;\n\n  // configure nodes, links and layout\n  if (linkInput.stamp < nodeInput.stamp) linkInput = null;\n  this.configure(nodeInput, linkInput, interactive, reset);\n\n  // run batch layout\n  if (!interactive) {\n    var iterations = this.param('iterations');\n    for (var i=0; i<iterations; ++i) layout.tick();\n    layout.stop();\n  }\n\n  // update node positions\n  this.update(active);\n\n  // re-up alpha on parameter change\n  if (reset || active !== this._prev && active && active.update) {\n    layout.alpha(this.param('alpha')); // re-start layout\n  }\n\n  // update active node status,\n  if (active !== this._prev) {\n    this._prev = active;\n  }\n\n  // process removed nodes or edges\n  if (nodeInput.rem.length) {\n    layout.nodes(this._nodes = Tuple.idFilter(nodes, nodeInput.rem));\n  }\n  if (linkInput && linkInput.rem.length) {\n    layout.links(this._links = Tuple.idFilter(links, linkInput.rem));\n  }\n\n  // return changeset\n  nodeInput.fields[output.x] = 1;\n  nodeInput.fields[output.y] = 1;\n  return nodeInput;\n};\n\nprototype.configure = function(nodeInput, linkInput, interactive, reset) {\n  // check if we need to run configuration\n  var layout = this._layout,\n      update = this._setup || nodeInput.add.length ||\n            linkInput && linkInput.add.length ||\n            interactive !== this._interactive ||\n            this.param('charge') !== layout.charge() ||\n            this.param('linkStrength') !== layout.linkStrength() ||\n            this.param('linkDistance') !== layout.linkDistance();\n\n  if (update || reset) {\n    // a parameter changed, so update tick-only parameters\n    layout\n      .size(this.param('size'))\n      .chargeDistance(this.param('chargeDistance'))\n      .theta(this.param('theta'))\n      .gravity(this.param('gravity'))\n      .friction(this.param('friction'));\n  }\n\n  if (!update) return; // if no more updates needed, return now\n\n  this._setup = false;\n  this._interactive = interactive;\n\n  var force = this,\n      graph = this._graph,\n      nodes = this._nodes,\n      links = this._links, a, i;\n\n  // process added nodes\n  for (a=nodeInput.add, i=0; i<a.length; ++i) {\n    nodes.push({tuple: a[i]});\n  }\n\n  // process added edges\n  if (linkInput) for (a=linkInput.add, i=0; i<a.length; ++i) {\n    // TODO add configurable source/target accessors\n    // TODO support lookup by node id\n    // TODO process 'mod' of edge source or target?\n    links.push({\n      tuple:  a[i],\n      source: nodes[a[i].source],\n      target: nodes[a[i].target]\n    });\n  }\n\n  // setup handler for force layout tick events\n  var tickHandler = !interactive ? null : function() {\n    // re-schedule the transform, force reflow\n    graph.propagate(ChangeSet.create(null, true), force);\n  };\n\n  // configure the rest of the layout\n  layout\n    .linkStrength(this.param('linkStrength'))\n    .linkDistance(this.param('linkDistance'))\n    .charge(this.param('charge'))\n    .nodes(nodes)\n    .links(links)\n    .on('tick', tickHandler)\n    .start().alpha(this.param('alpha'));\n};\n\nprototype.update = function(active) {\n  var output = this._output,\n      bound = this.param('bound'),\n      fixed = this.param('fixed'),\n      size = this.param('size'),\n      nodes = this._nodes,\n      lut = {}, id, i, n, t, x, y;\n\n  if (fixed && fixed.source) {\n    // TODO: could cache and update as needed?\n    fixed = fixed.source.values();\n    for (i=0, n=fixed.length; i<n; ++i) {\n      lut[fixed[i].id] = 1;\n    }\n  }\n\n  for (i=0; i<nodes.length; ++i) {\n    n = nodes[i];\n    t = n.tuple;\n    id = t._id;\n\n    if (active && active.id === id) {\n      n.fixed = 1;\n      if (active.update) {\n        n.x = n.px = active.x;\n        n.y = n.py = active.y;\n      }\n    } else {\n      n.fixed = lut[id] || 0;\n    }\n\n    x = bound ? Math.max(0, Math.min(n.x, size[0])) : n.x;\n    y = bound ? Math.max(0, Math.min(n.y, size[1])) : n.y;\n    Tuple.set(t, output.x, x);\n    Tuple.set(t, output.y, y);\n  }\n};\n\nmodule.exports = Force;\n\nForce.schema = {\n  \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n  \"title\": \"Force transform\",\n  \"description\": \"Performs force-directed layout for network data.\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"type\": {\"enum\": [\"force\"]},\n    \"size\": {\n      \"description\": \"The dimensions [width, height] of this force layout.\",\n      \"oneOf\": [\n        {\n          \"type\": \"array\",\n          \"minItems\": 2,\n          \"maxItems\": 2,\n          \"items\": {\"oneOf\": [{\"type\": \"number\"}, {\"$ref\": \"#/refs/signal\"}]}\n        },\n        {\"$ref\": \"#/refs/signal\"}\n      ],\n\n      \"default\": [500, 500]\n    },\n    \"links\": {\n      \"type\": \"string\",\n      \"description\": \"The name of the link (edge) data set.\"\n    },\n    \"linkDistance\": {\n      \"description\": \"Determines the length of edges, in pixels.\",\n      \"oneOf\": [{\"type\": \"number\"}, {\"type\": \"string\"}, {\"$ref\": \"#/refs/signal\"}],\n      \"default\": 20\n    },\n    \"linkStrength\": {\n      \"oneOf\": [{\"type\": \"number\"}, {\"type\": \"string\"}, {\"$ref\": \"#/refs/signal\"}],\n      \"description\": \"Determines the tension of edges (the spring constant).\",\n      \"default\": 1\n    },\n    \"charge\": {\n      \"oneOf\": [{\"type\": \"number\"}, {\"type\": \"string\"}, {\"$ref\": \"#/refs/signal\"}],\n      \"description\": \"The strength of the charge each node exerts.\",\n      \"default\": -30\n    },\n    \"chargeDistance\": {\n      \"oneOf\": [{\"type\": \"number\"}, {\"$ref\": \"#/refs/signal\"}],\n      \"description\": \"The maximum distance over which charge forces are applied.\",\n      \"default\": Infinity\n    },\n    \"iterations\": {\n      \"description\": \"The number of iterations to run the force directed layout.\",\n      \"oneOf\": [{\"type\": \"number\"}, {\"$ref\": \"#/refs/signal\"}],\n      \"default\": 500\n    },\n    \"friction\": {\n      \"description\": \"The strength of the friction force used to stabilize the layout.\",\n      \"oneOf\": [{\"type\": \"number\"}, {\"$ref\": \"#/refs/signal\"}],\n      \"default\": 0.9\n    },\n    \"theta\": {\n      \"description\": \"The theta parameter for the Barnes-Hut algorithm, which is used to compute charge forces between nodes.\",\n      \"oneOf\": [{\"type\": \"number\"}, {\"$ref\": \"#/refs/signal\"}],\n      \"default\": 0.8\n    },\n    \"gravity\": {\n      \"description\": \"The strength of the pseudo-gravity force that pulls nodes towards the center of the layout area.\",\n      \"oneOf\": [{\"type\": \"number\"}, {\"$ref\": \"#/refs/signal\"}],\n      \"default\": 0.1\n    },\n    \"alpha\": {\n      \"description\": \"A \\\"temperature\\\" parameter that determines how much node positions are adjusted at each step.\",\n      \"oneOf\": [{\"type\": \"number\"}, {\"$ref\": \"#/refs/signal\"}],\n      \"default\": 0.1\n    },\n    \"interactive\": {\n      \"description\": \"Enables an interactive force-directed layout.\",\n      \"oneOf\": [{\"type\": \"boolean\"}, {\"$ref\": \"#/refs/signal\"}],\n      \"default\": false\n    },\n    \"active\": {\n      \"description\": \"A signal representing the active node.\",\n      \"$ref\": \"#/refs/signal\"\n    },\n    \"fixed\": {\n      \"description\": \"The name of a datasource containing the IDs of nodes with fixed positions.\",\n      \"type\": \"string\"\n    },\n    \"output\": {\n      \"type\": \"object\",\n      \"description\": \"Rename the output data fields\",\n      \"properties\": {\n        \"x\": {\"type\": \"string\", \"default\": \"layout_x\"},\n        \"y\": {\"type\": \"string\", \"default\": \"layout_y\"}\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false,\n  \"required\": [\"type\", \"links\"]\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/transforms/Force.js\n ** module id = 119\n ** module chunks = 0\n **/","module.exports = {\n  size:   [{signal: 'width'}, {signal: 'height'}],\n  mid:    [{expr: 'width/2'}, {expr: 'height/2'}],\n  extent: [\n    {expr: '[-padding.left, -padding.top]'},\n    {expr: '[width+padding.right, height+padding.bottom]'}\n  ]\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/transforms/screen.js\n ** module id = 120\n ** module chunks = 0\n **/","var df = require('vega-dataflow'),\n    Tuple = df.Tuple,\n    log = require('vega-logging'),\n    Transform = require('./Transform');\n\nfunction Formula(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    field: {type: 'value'},\n    expr:  {type: 'expr'}\n  });\n\n  return this.mutates(true);\n}\n\nvar prototype = (Formula.prototype = Object.create(Transform.prototype));\nprototype.constructor = Formula;\n\nprototype.transform = function(input) {\n  log.debug(input, ['formulating']);\n\n  var field = this.param('field'),\n      expr = this.param('expr');\n\n  function set(x) {\n    Tuple.set(x, field, expr(x));\n  }\n\n  input.add.forEach(set);\n\n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n  }\n\n  input.fields[field] = 1;\n  return input;\n};\n\nmodule.exports = Formula;\n\nFormula.schema = {\n  \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n  \"title\": \"Formula transform\",\n  \"description\": \"Extends data elements with new values according to a calculation formula.\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"type\": {\"enum\": [\"formula\"]},\n    \"field\": {\n      \"type\": \"string\",\n      \"description\": \"The property name in which to store the computed formula value.\"\n    },\n    \"expr\": {\n      \"type\": \"string\",\n      \"description\": \"A string containing an expression (in JavaScript syntax) for the formula.\"\n    }\n  },\n  \"required\": [\"type\", \"field\", \"expr\"]\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/transforms/Formula.js\n ** module id = 121\n ** module chunks = 0\n **/","var d3 = require('d3'),\n    dl = require('datalib'),\n    Tuple = require('vega-dataflow').Tuple,\n    log = require('vega-logging'),\n    Transform = require('./Transform');\n\nfunction Geo(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, Geo.Parameters);\n  Transform.addParameters(this, {\n    lon: {type: 'field'},\n    lat: {type: 'field'}\n  });\n\n  this._output = {\n    'x': 'layout_x',\n    'y': 'layout_y'\n  };\n  return this.mutates(true);\n}\n\nGeo.Parameters = {\n  projection: {type: 'value', default: 'mercator'},\n  center:     {type: 'array<value>'},\n  translate:  {type: 'array<value>', default: require('./screen').center},\n  rotate:     {type: 'array<value>'},\n  scale:      {type: 'value'},\n  precision:  {type: 'value'},\n  clipAngle:  {type: 'value'},\n  clipExtent: {type: 'value'}\n};\n\nGeo.d3Projection = function() {\n  var p = this.param('projection'),\n      param = Geo.Parameters,\n      proj, name, value;\n\n  if (p !== this._mode) {\n    this._mode = p;\n    this._projection = d3.geo[p]();\n  }\n  proj = this._projection;\n\n  for (name in param) {\n    if (name === 'projection' || !proj[name]) continue;\n    value = this.param(name);\n    if (value === undefined || (dl.isArray(value) && value.length === 0)) {\n      continue;\n    }\n    if (value !== proj[name]()) {\n      proj[name](value);\n    }\n  }\n\n  return proj;\n};\n\nvar prototype = (Geo.prototype = Object.create(Transform.prototype));\nprototype.constructor = Geo;\n\nprototype.transform = function(input) {\n  log.debug(input, ['geo']);\n\n  var output = this._output,\n      lon = this.param('lon').accessor,\n      lat = this.param('lat').accessor,\n      proj = Geo.d3Projection.call(this);\n\n  function set(t) {\n    var ll = [lon(t), lat(t)];\n    var xy = proj(ll) || [null, null];\n    Tuple.set(t, output.x, xy[0]);\n    Tuple.set(t, output.y, xy[1]);\n  }\n\n  input.add.forEach(set);\n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n    input.rem.forEach(set);\n  }\n\n  input.fields[output.x] = 1;\n  input.fields[output.y] = 1;\n  return input;\n};\n\nmodule.exports = Geo;\n\nGeo.baseSchema = {\n  \"projection\": {\n    \"description\": \"The type of cartographic projection to use.\",\n    \"oneOf\": [{\"type\": \"string\"}, {\"$ref\": \"#/refs/signal\"}],\n    \"default\": \"mercator\"\n  },\n  \"center\": {\n    \"description\": \"The center of the projection.\",\n    \"oneOf\": [\n      {\n        \"type\": \"array\",\n        \"items\": {\"oneOf\": [{\"type\": \"number\"}, {\"$ref\": \"#/refs/signal\"}]},\n        \"minItems\": 2,\n        \"maxItems\": 2\n      },\n      {\"$ref\": \"#/refs/signal\"}\n    ]\n  },\n  \"translate\": {\n    \"description\": \"The translation of the projection.\",\n    \"oneOf\": [\n      {\n        \"type\": \"array\",\n        \"items\": {\"oneOf\": [{\"type\": \"number\"}, {\"$ref\": \"#/refs/signal\"}]},\n        \"minItems\": 2,\n        \"maxItems\": 2\n      },\n      {\"$ref\": \"#/refs/signal\"}\n    ]\n  },\n  \"rotate\": {\n    \"description\": \"The rotation of the projection.\",\n    \"oneOf\": [{\"type\": \"number\"}, {\"$ref\": \"#/refs/signal\"}]\n  },\n  \"scale\": {\n    \"description\": \"The scale of the projection.\",\n    \"oneOf\": [{\"type\": \"number\"}, {\"$ref\": \"#/refs/signal\"}]\n  },\n  \"precision\": {\n    \"description\": \"The desired precision of the projection.\",\n    \"oneOf\": [{\"type\": \"number\"}, {\"$ref\": \"#/refs/signal\"}]\n  },\n  \"clipAngle\": {\n    \"description\": \"The clip angle of the projection.\",\n    \"oneOf\": [{\"type\": \"number\"}, {\"$ref\": \"#/refs/signal\"}]\n  },\n  \"clipExtent\": {\n    \"description\": \"The clip extent of the projection.\",\n    \"oneOf\": [{\"type\": \"number\"}, {\"$ref\": \"#/refs/signal\"}]\n  }\n};\n\nGeo.schema = {\n  \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n  \"title\": \"Geo transform\",\n  \"description\": \"Performs a cartographic projection. Given longitude and latitude values, sets corresponding x and y properties for a mark.\",\n  \"type\": \"object\",\n  \"properties\": dl.extend({\n    \"type\": {\"enum\": [\"geo\"]},\n    \"lon\": {\n      \"description\": \"The input longitude values.\",\n      \"oneOf\": [{\"type\": \"string\"}, {\"$ref\": \"#/refs/signal\"}]\n    },\n    \"lat\": {\n      \"description\": \"The input latitude values.\",\n      \"oneOf\": [{\"type\": \"string\"}, {\"$ref\": \"#/refs/signal\"}]\n    },\n    \"output\": {\n      \"type\": \"object\",\n      \"description\": \"Rename the output data fields\",\n      \"properties\": {\n        \"x\": {\"type\": \"string\", \"default\": \"layout_x\"},\n        \"y\": {\"type\": \"string\", \"default\": \"layout_y\"}\n      },\n      \"additionalProperties\": false\n    }\n  }, Geo.baseSchema),\n  \"required\": [\"type\", \"lon\", \"lat\"],\n  \"additionalProperties\": false\n};\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/transforms/Geo.js\n ** module id = 122\n ** module chunks = 0\n **/","var d3 = require('d3'),\n    dl = require('datalib'),\n    Tuple = require('vega-dataflow').Tuple,\n    log = require('vega-logging'),\n    Geo = require('./Geo'),\n    Transform = require('./Transform');\n\nfunction GeoPath(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, Geo.Parameters);\n  Transform.addParameters(this, {\n    field: {type: 'field', default: null},\n  });\n\n  this._output = {\n    'path': 'layout_path'\n  };\n  return this.mutates(true);\n}\n\nvar prototype = (GeoPath.prototype = Object.create(Transform.prototype));\nprototype.constructor = GeoPath;\n\nprototype.transform = function(input) {\n  log.debug(input, ['geopath']);\n\n  var output = this._output,\n      geojson = this.param('field').accessor || dl.identity,\n      proj = Geo.d3Projection.call(this),\n      path = d3.geo.path().projection(proj);\n\n  function set(t) {\n    Tuple.set(t, output.path, path(geojson(t)));\n  }\n\n  input.add.forEach(set);\n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n    input.rem.forEach(set);\n  }\n\n  input.fields[output.path] = 1;\n  return input;\n};\n\nmodule.exports = GeoPath;\n\nGeoPath.schema = {\n  \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n  \"title\": \"GeoPath transform\",\n  \"description\": \"Creates paths for geographic regions, such as countries, states and counties.\",\n  \"type\": \"object\",\n  \"properties\": dl.extend({\n    \"type\": {\"enum\": [\"geopath\"]},\n    \"field\": {\n      \"description\": \"The data field containing GeoJSON Feature data.\",\n      \"oneOf\": [{\"type\": \"string\"}, {\"$ref\": \"#/refs/signal\"}]\n    },\n    \"output\": {\n      \"type\": \"object\",\n      \"description\": \"Rename the output data fields\",\n      \"properties\": {\n        \"path\": {\"type\": \"string\", \"default\": \"layout_path\"}\n      },\n      \"additionalProperties\": false\n    }\n  }, Geo.baseSchema),\n  \"required\": [\"type\"],\n  \"additionalProperties\": false\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/transforms/GeoPath.js\n ** module id = 123\n ** module chunks = 0\n **/","var d3 = require('d3'),\n    dl = require('datalib'),\n    Tuple = require('vega-dataflow').Tuple,\n    log = require('vega-logging'),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform');\n\nfunction Hierarchy(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    // hierarchy parameters\n    sort: {type: 'array<field>', default: null},\n    children: {type: 'field', default: 'children'},\n    parent: {type: 'field', default: 'parent'},\n    field: {type: 'value', default: null},\n    // layout parameters\n    mode: {type: 'value', default: 'tidy'}, // tidy, cluster, partition\n    size: {type: 'array<value>', default: require('./screen').size},\n    nodesize: {type: 'array<value>', default: null},\n    orient: {type: 'value', default: 'cartesian'}\n  });\n\n  this._mode = null;\n  this._output = {\n    'x':      'layout_x',\n    'y':      'layout_y',\n    'width':  'layout_width',\n    'height': 'layout_height',\n    'depth':  'layout_depth'\n  };\n  return this.mutates(true);\n}\n\nvar PARTITION = 'partition';\n\nvar SEPARATION = {\n  cartesian: function(a, b) { return (a.parent === b.parent ? 1 : 2); },\n  radial: function(a, b) { return (a.parent === b.parent ? 1 : 2) / a.depth; }\n};\n\nvar prototype = (Hierarchy.prototype = Object.create(BatchTransform.prototype));\nprototype.constructor = Hierarchy;\n\nprototype.batchTransform = function(input, data) {\n  log.debug(input, ['hierarchy layout']);\n\n  // get variables\n  var layout = this._layout,\n      output = this._output,\n      mode   = this.param('mode'),\n      sort   = this.param('sort'),\n      nodesz = this.param('nodesize'),\n      parent = this.param('parent').accessor,\n      root = data.filter(function(d) { return parent(d) === null; })[0];\n\n  if (mode !== this._mode) {\n    this._mode = mode;\n    if (mode === 'tidy') mode = 'tree';\n    layout = (this._layout = d3.layout[mode]());\n  }\n\n  input.fields[output.x] = 1;\n  input.fields[output.y] = 1;\n  input.fields[output.depth] = 1;\n  if (mode === PARTITION) {\n    input.fields[output.width] = 1;\n    input.fields[output.height] = 1;\n    layout.value(this.param('field').accessor);\n  } else {\n    layout.separation(SEPARATION[this.param('orient')]);\n  }\n\n  if (nodesz.length && mode !== PARTITION) {\n    layout.nodeSize(nodesz);\n  } else {\n    layout.size(this.param('size'));\n  }\n\n  layout\n    .sort(sort.field.length ? dl.comparator(sort.field) : null)\n    .children(this.param('children').accessor)\n    .nodes(root);\n\n  // copy layout values to nodes\n  data.forEach(function(n) {\n    Tuple.set(n, output.x, n.x);\n    Tuple.set(n, output.y, n.y);\n    Tuple.set(n, output.depth, n.depth);\n    if (mode === PARTITION) {\n      Tuple.set(n, output.width, n.dx);\n      Tuple.set(n, output.height, n.dy);\n    }\n  });\n\n  // return changeset\n  return input;\n};\n\nmodule.exports = Hierarchy;\n\nHierarchy.schema = {\n  \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n  \"title\": \"Hierarchy transform\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"type\": {\"enum\": [\"hierarchy\"]},\n    \"sort\": {\n      \"description\": \"A list of fields to use as sort criteria for sibling nodes.\",\n      \"oneOf\": [\n        {\n          \"type\": \"array\",\n          \"items\": {\"oneOf\": [{\"type\": \"string\"}, {\"$ref\": \"#/refs/signal\"}]}\n        },\n        {\"$ref\": \"#/refs/signal\"}\n      ]\n    },\n    \"children\": {\n      \"description\": \"The data field for the children node array\",\n      \"oneOf\": [{\"type\": \"string\"}, {\"$ref\": \"#/refs/signal\"}],\n      \"default\": \"children\"\n    },\n    \"parent\": {\n      \"description\": \"The data field for the parent node\",\n      \"oneOf\": [{\"type\": \"string\"}, {\"$ref\": \"#/refs/signal\"}],\n      \"default\": \"parent\"\n    },\n    \"field\": {\n      \"description\": \"The value for the area of each leaf-level node for partition layouts.\",\n      \"oneOf\": [{\"type\": \"string\"}, {\"$ref\": \"#/refs/signal\"}]\n    },\n    \"mode\": {\n      \"description\": \"The layout algorithm mode to use.\",\n      \"oneOf\": [\n        {\"enum\": [\"tidy\", \"cluster\", \"partition\"]},\n        {\"$ref\": \"#/refs/signal\"}\n      ],\n      \"default\": \"tidy\"\n    },\n    \"orient\": {\n      \"description\": \"The layout orientation to use.\",\n      \"oneOf\": [\n        {\"enum\": [\"cartesian\", \"radial\"]},\n        {\"$ref\": \"#/refs/signal\"}\n      ],\n      \"default\": \"cartesian\"\n    },\n    \"size\": {\n      \"description\": \"The dimensions of the tree layout\",\n      \"oneOf\": [\n        {\n          \"type\": \"array\",\n          \"items\": {\"oneOf\": [{\"type\": \"number\"}, {\"$ref\": \"#/refs/signal\"}]},\n          \"minItems\": 2,\n          \"maxItems\": 2\n        },\n        {\"$ref\": \"#/refs/signal\"}\n      ],\n      \"default\": [500, 500]\n    },\n    \"nodesize\": {\n      \"description\": \"Sets a fixed x,y size for each node (overrides the size parameter)\",\n      \"oneOf\": [\n        {\n          \"type\": \"array\",\n          \"items\": {\"oneOf\": [{\"type\": \"number\"}, {\"$ref\": \"#/refs/signal\"}]},\n          \"minItems\": 2,\n          \"maxItems\": 2\n        },\n        {\"$ref\": \"#/refs/signal\"}\n      ],\n      \"default\": null\n    },\n    \"output\": {\n      \"type\": \"object\",\n      \"description\": \"Rename the output data fields\",\n      \"properties\": {\n        \"x\": {\"type\": \"string\", \"default\": \"layout_x\"},\n        \"y\": {\"type\": \"string\", \"default\": \"layout_y\"},\n        \"width\": {\"type\": \"string\", \"default\": \"layout_width\"},\n        \"height\": {\"type\": \"string\", \"default\": \"layout_height\"},\n        \"depth\": {\"type\": \"string\", \"default\": \"layout_depth\"}\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false,\n  \"required\": [\"type\"]\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/transforms/Hierarchy.js\n ** module id = 124\n ** module chunks = 0\n **/","var dl = require('datalib'),\n    log = require('vega-logging'),\n    Tuple = require('vega-dataflow').Tuple,\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform');\n\nfunction Impute(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    groupby: {type: 'array<field>'},\n    orderby: {type: 'array<field>'},\n    field:   {type: 'field'},\n    method:  {type: 'value', default: 'value'},\n    value:   {type: 'value', default: 0}\n  });\n\n  return this.router(true).produces(true);\n}\n\nvar prototype = (Impute.prototype = Object.create(BatchTransform.prototype));\nprototype.constructor = Impute;\n\nprototype.batchTransform = function(input, data) {\n  log.debug(input, ['imputing']);\n\n  var groupby = this.param('groupby'),\n      orderby = this.param('orderby'),\n      method = this.param('method'),\n      value = this.param('value'),\n      field = this.param('field'),\n      get = field.accessor,\n      name = field.field,\n      prev = this._imputed || [], curr = [],\n      groups = partition(data, groupby.accessor, orderby.accessor),\n      domain = groups.domain,\n      group, i, j, n, m, t;\n\n  function getval(x) {\n    return x == null ? null : get(x);\n  }\n\n  for (j=0, m=groups.length; j<m; ++j) {\n    group = groups[j];\n\n    // determine imputation value\n    if (method !== 'value') {\n      value = dl[method](group, getval);\n    }\n\n    // add tuples for missing values\n    for (i=0, n=group.length; i<n; ++i) {\n      if (group[i] == null) {\n        t = tuple(groupby.field, group.values, orderby.field, domain[i]);\n        t[name] = value;\n        curr.push(t);\n      }\n    }\n  }\n\n  // update changeset with imputed tuples\n  for (i=0, n=curr.length; i<n; ++i) {\n    input.add.push(curr[i]);\n  }\n  for (i=0, n=prev.length; i<n; ++i) {\n    input.rem.push(prev[i]);\n  }\n  this._imputed = curr;\n\n  return input;\n};\n\nfunction tuple(gb, gv, ob, ov) {\n  var t = {_imputed: true}, i;\n  for (i=0; i<gv.length; ++i) t[gb[i]] = gv[i];\n  for (i=0; i<ov.length; ++i) t[ob[i]] = ov[i];\n  return Tuple.ingest(t);\n}\n\nfunction partition(data, groupby, orderby) {\n  var groups = [],\n      get = function(f) { return f(x); },\n      val = function(d) { return (x=d, orderby.map(get)); },\n      map, i, x, k, g, domain, lut, N;\n\n  domain = groups.domain = dl.unique(data, val);\n  N = domain.length;\n  lut = domain.reduce(function(m, d, i) {\n    return (m[d] = {value:d, index:i}, m);\n  }, {});\n\n  // partition data points into groups\n  for (map={}, i=0; i<data.length; ++i) {\n    x = data[i];\n    k = groupby == null ? [] : groupby.map(get);\n    g = map[k] || (groups.push(map[k] = Array(N)), map[k].values = k, map[k]);\n    g[lut[val(x)].index] = x;\n  }\n\n  return groups;\n}\n\nmodule.exports = Impute;\n\nImpute.schema = {\n  \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n  \"title\": \"Impute transform\",\n  \"description\": \"Performs imputation of missing values.\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"type\": {\"enum\": [\"impute\"]},\n    \"method\": {\n      \"description\": \"The imputation method to use.\",\n      \"oneOf\": [\n        {\"enum\": [\"value\", \"mean\", \"median\", \"min\", \"max\"]},\n        {\"$ref\": \"#/refs/signal\"}\n      ],\n      \"default\": \"value\"\n    },\n    \"value\": {\n      \"description\": \"The value to use for missing data if the method is 'value'.\",\n      \"oneOf\": [\n        {\"type\": \"number\"},\n        {\"type\": \"string\"},\n        {\"type\": \"boolean\"},\n        {\"type\": \"null\"},\n        {\"$ref\": \"#/refs/signal\"}\n      ],\n      \"default\": 0\n    },\n    \"field\": {\n      \"description\": \"The data field to impute.\",\n      \"oneOf\": [{\"type\": \"string\"}, {\"$ref\": \"#/refs/signal\"}]\n    },\n    \"groupby\": {\n      \"description\": \"A list of fields to group the data into series.\",\n      \"oneOf\": [\n        {\n          \"type\": \"array\",\n          \"items\": {\"oneOf\": [{\"type\": \"string\"}, {\"$ref\": \"#/refs/signal\"}]}\n        },\n        {\"$ref\": \"#/refs/signal\"}\n      ],\n    },\n    \"orderby\": {\n      \"description\": \"A list of fields to determine ordering within series.\",\n      \"oneOf\": [\n        {\n          \"type\": \"array\",\n          \"items\": {\"oneOf\": [{\"type\": \"string\"}, {\"$ref\": \"#/refs/signal\"}]}\n        },\n        {\"$ref\": \"#/refs/signal\"}\n      ],\n    }\n  },\n  \"additionalProperties\": false,\n  \"required\": [\"type\", \"groupby\", \"orderby\", \"field\"]\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/transforms/Impute.js\n ** module id = 125\n ** module chunks = 0\n **/","var Tuple = require('vega-dataflow').Tuple,\n    log = require('vega-logging'),\n    Transform = require('./Transform');\n\nfunction Lookup(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    on:      {type: 'data'},\n    onKey:   {type: 'field', default: null},\n    as:      {type: 'array<value>'},\n    keys:    {type: 'array<field>', default: ['data']},\n    default: {type: 'value'}\n  });\n\n  return this.mutates(true);\n}\n\nvar prototype = (Lookup.prototype = Object.create(Transform.prototype));\nprototype.constructor = Lookup;\n\nprototype.transform = function(input, reset) {\n  log.debug(input, ['lookup']);\n\n  var on = this.param('on'),\n      onLast = on.source.last(),\n      onData = on.source.values(),\n      onKey = this.param('onKey'),\n      onF = onKey.field,\n      keys = this.param('keys'),\n      get = keys.accessor,\n      as = this.param('as'),\n      defaultValue = this.param('default'),\n      lut = this._lut,\n      i, v;\n\n  // build lookup table on init, withKey modified, or tuple add/rem\n  if (lut == null || this._on !== onF || onF && onLast.fields[onF] ||\n      onLast.add.length || onLast.rem.length)\n  {\n    if (onF) { // build hash from withKey field\n      onKey = onKey.accessor;\n      for (lut={}, i=0; i<onData.length; ++i) {\n        lut[onKey(v = onData[i])] = v;\n      }\n    } else { // otherwise, use index-based lookup\n      lut = onData;\n    }\n    this._lut = lut;\n    this._on = onF;\n    reset = true;\n  }\n\n  function set(t) {\n    for (var i=0; i<get.length; ++i) {\n      var v = lut[get[i](t)] || defaultValue;\n      Tuple.set(t, as[i], v);\n    }\n  }\n\n  input.add.forEach(set);\n  var run = keys.field.some(function(f) { return input.fields[f]; });\n  if (run || reset) {\n    input.mod.forEach(set);\n    input.rem.forEach(set);\n  }\n\n  as.forEach(function(k) { input.fields[k] = 1; });\n  return input;\n};\n\nmodule.exports = Lookup;\n\nLookup.schema = {\n  \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n  \"title\": \"Lookup transform\",\n  \"description\": \"Extends a data set by looking up values in another data set.\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"type\": {\"enum\": [\"lookup\"]},\n    \"on\": {\n      \"type\": \"string\",\n      \"description\": \"The name of the secondary data set on which to lookup values.\"\n    },\n    \"onKey\": {\n      \"description\": \"The key field to lookup, or null for index-based lookup.\",\n      \"oneOf\": [{\"type\": \"string\"}, {\"$ref\": \"#/refs/signal\"}]\n    },\n    \"keys\": {\n      \"description\": \"One or more fields in the primary data set to match against the secondary data set.\",\n      \"type\": \"array\",\n      \"items\": {\"oneOf\": [{\"type\": \"string\"}, {\"$ref\": \"#/refs/signal\"}]}\n    },\n    \"as\": {\n      \"type\": \"array\",\n      \"description\": \"The names of the fields in which to store looked-up values.\",\n      \"items\": {\"type\": \"string\"}\n    },\n    \"default\": {\n      // \"type\": \"any\",\n      \"description\": \"The default value to use if a lookup match fails.\"\n    }\n  },\n  \"required\": [\"type\", \"on\", \"as\", \"keys\"],\n  \"additionalProperties\": false\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/transforms/Lookup.js\n ** module id = 126\n ** module chunks = 0\n **/","var dl = require('datalib'),\n    Tuple = require('vega-dataflow').Tuple,\n    log = require('vega-logging'),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform');\n\nfunction Pie(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    field:      {type: 'field', default: null},\n    startAngle: {type: 'value', default: 0},\n    endAngle:   {type: 'value', default: 2 * Math.PI},\n    sort:       {type: 'value', default: false}\n  });\n\n  this._output = {\n    'start': 'layout_start',\n    'end':   'layout_end',\n    'mid':   'layout_mid'\n  };\n\n  return this.mutates(true);\n}\n\nvar prototype = (Pie.prototype = Object.create(BatchTransform.prototype));\nprototype.constructor = Pie;\n\nfunction ones() { return 1; }\n\nprototype.batchTransform = function(input, data) {\n  log.debug(input, ['pie']);\n\n  var output = this._output,\n      field = this.param('field').accessor || ones,\n      start = this.param('startAngle'),\n      stop = this.param('endAngle'),\n      sort = this.param('sort');\n\n  var values = data.map(field),\n      a = start,\n      k = (stop - start) / dl.sum(values),\n      index = dl.range(data.length),\n      i, t, v;\n\n  if (sort) {\n    index.sort(function(a, b) {\n      return values[a] - values[b];\n    });\n  }\n\n  for (i=0; i<index.length; ++i) {\n    t = data[index[i]];\n    v = values[index[i]];\n    Tuple.set(t, output.start, a);\n    Tuple.set(t, output.mid, (a + 0.5 * v * k));\n    Tuple.set(t, output.end, (a += v * k));\n  }\n\n  input.fields[output.start] = 1;\n  input.fields[output.end] = 1;\n  input.fields[output.mid] = 1;\n  return input;\n};\n\nmodule.exports = Pie;\n\nPie.schema = {\n  \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n  \"title\": \"Pie transform\",\n  \"description\": \"Computes a pie chart layout.\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"type\": {\"enum\": [\"pie\"]},\n    \"field\": {\n      \"oneOf\": [{\"type\": \"string\"}, {\"$ref\": \"#/refs/signal\"}],\n      \"description\": \"The data values to encode as angular spans. \" +\n        \"If this property is omitted, all pie slices will have equal spans.\"\n    },\n    \"startAngle\": {\n      \"oneOf\": [\n        {\n          \"type\": \"number\",\n          \"minimum\": 0,\n          \"maximum\": 2 * Math.PI\n        },\n        {\"$ref\": \"#/refs/signal\"}\n      ],\n      \"default\": 0\n    },\n    \"endAngle\": {\n      \"oneOf\": [\n        {\n          \"type\": \"number\",\n          \"minimum\": 0,\n          \"maximum\": 2 * Math.PI\n        },\n        {\"$ref\": \"#/refs/signal\"}\n      ],\n      \"default\": 2 * Math.PI,\n    },\n    \"sort\": {\n      \"description\": \" If true, will sort the data prior to computing angles.\",\n      \"oneOf\": [{\"type\": \"boolean\"}, {\"$ref\": \"#/refs/signal\"}],\n      \"default\": false\n    },\n    \"output\": {\n      \"type\": \"object\",\n      \"description\": \"Rename the output data fields\",\n      \"properties\": {\n        \"start\": {\"type\": \"string\", \"default\": \"layout_start\"},\n        \"end\": {\"type\": \"string\", \"default\": \"layout_end\"},\n        \"mid\": {\"type\": \"string\", \"default\": \"layout_mid\"}\n      }\n    }\n  },\n  \"required\": [\"type\"]\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/transforms/Pie.js\n ** module id = 127\n ** module chunks = 0\n **/","var Tuple = require('vega-dataflow').Tuple,\n    log = require('vega-logging'),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform');\n\nfunction Rank(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    field: {type: 'field', default: null},\n    normalize: {type: 'value', default: false}\n  });\n\n  this._output = {\n    'rank': 'rank'\n  };\n\n  return this.mutates(true);\n}\n\nvar prototype = (Rank.prototype = Object.create(BatchTransform.prototype));\nprototype.constructor = Rank;\n\nprototype.batchTransform = function(input, data) {\n  log.debug(input, ['rank']);\n\n  var rank  = this._output.rank,\n      norm  = this.param('normalize'),\n      field = this.param('field').accessor,\n      keys = {}, \n      i, len = data.length, klen, d, f;\n\n  // If we have a field accessor, first compile distinct keys.\n  if (field) {\n    for (i=0, klen=0; i<len; ++i) {\n      d = data[i];\n      keys[f=field(d)] = keys[f] || (keys[f] = ++klen);\n    }\n  }\n\n  // Assign ranks to all tuples.\n  for (i=0; i<len && (d=data[i]); ++i) {\n    if (field && (f=field(d))) {\n      Tuple.set(d, rank, norm ? keys[f] / klen : keys[f]);\n    } else {\n      Tuple.set(d, rank, norm ? (i+1) / len : (i+1));\n    }\n  }\n\n  input.fields[rank] = 1;\n  return input;\n};\n\nmodule.exports = Rank;\n\nRank.schema = {\n  \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n  \"title\": \"Rank transform\",\n  \"description\": \"Computes ascending rank scores for data tuples.\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"type\": {\"enum\": [\"rank\"]},\n    \"field\": {\n      \"oneOf\": [{\"type\": \"string\"}, {\"$ref\": \"#/refs/signal\"}],\n      \"description\": \"A key field to used to rank tuples. \" +\n        \"If undefined, tuples will be ranked in their observed order.\"\n    },\n    \"normalize\": {\n      \"description\": \"If true, values of the output field will lie in the range [0, 1].\",\n      \"oneOf\": [{\"type\": \"boolean\"}, {\"$ref\": \"#/refs/signal\"}],\n      \"default\": false\n    },\n    \"output\": {\n      \"type\": \"object\",\n      \"description\": \"Rename the output data fields\",\n      \"properties\": {\n        \"rank\": {\"type\": \"string\", \"default\": \"rank\"}\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false,\n  \"required\": [\"type\"]\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/transforms/Rank.js\n ** module id = 128\n ** module chunks = 0\n **/","var dl = require('datalib'),\n    log  = require('vega-logging'),\n    Transform = require('./Transform');\n\nfunction Sort(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {by: {type: 'array<field>'} });\n  this.router(true);\n}\n\nvar prototype = (Sort.prototype = Object.create(Transform.prototype));\nprototype.constructor = Sort;\n\nprototype.transform = function(input) {\n  log.debug(input, ['sorting']);\n\n  if (input.add.length || input.mod.length || input.rem.length) {\n    input.sort = dl.comparator(this.param('by').field);\n  }\n  return input;\n};\n\nmodule.exports = Sort;\n\nSort.schema = {\n  \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n  \"title\": \"Sort transform\",\n  \"description\": \"Sorts the values of a data set.\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"type\": {\"enum\": [\"sort\"]},\n    \"by\": {\n      \"oneOf\": [\n        {\"type\": \"string\"},\n        {\"type\": \"array\", \"items\": {\"type\": \"string\"}}\n      ],\n      \"description\": \"A list of fields to use as sort criteria.\"\n    }\n  },\n  \"required\": [\"type\", \"by\"]\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/transforms/Sort.js\n ** module id = 129\n ** module chunks = 0\n **/","var dl = require('datalib'),\n    Tuple = require('vega-dataflow').Tuple,\n    log = require('vega-logging'),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform');\n\nfunction Stack(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    groupby: {type: 'array<field>'},\n    sortby: {type: 'array<field>'},\n    field: {type: 'field'},\n    offset: {type: 'value', default: 'zero'}\n  });\n\n  this._output = {\n    'start': 'layout_start',\n    'end':   'layout_end',\n    'mid':   'layout_mid'\n  };\n  return this.mutates(true);\n}\n\nvar prototype = (Stack.prototype = Object.create(BatchTransform.prototype));\nprototype.constructor = Stack;\n\nprototype.batchTransform = function(input, data) {\n  log.debug(input, ['stacking']);\n\n  var groupby = this.param('groupby').accessor,\n      sortby = dl.comparator(this.param('sortby').field),\n      field = this.param('field').accessor,\n      offset = this.param('offset'),\n      output = this._output;\n\n  // partition, sum, and sort the stack groups\n  var groups = partition(data, groupby, sortby, field);\n\n  // compute stack layouts per group\n  for (var i=0, max=groups.max; i<groups.length; ++i) {\n    var group = groups[i],\n        sum = group.sum,\n        off = offset==='center' ? (max - sum)/2 : 0,\n        scale = offset==='normalize' ? (1/sum) : 1,\n        j, x, a, b = off, v = 0;\n\n    // set stack coordinates for each datum in group\n    for (j=0; j<group.length; ++j) {\n      x = group[j];\n      a = b; // use previous value for start point\n      v += field(x);\n      b = scale * v + off; // compute end point\n      Tuple.set(x, output.start, a);\n      Tuple.set(x, output.end, b);\n      Tuple.set(x, output.mid, 0.5 * (a + b));\n    }\n  }\n\n  input.fields[output.start] = 1;\n  input.fields[output.end] = 1;\n  input.fields[output.mid] = 1;\n  return input;\n};\n\nfunction partition(data, groupby, sortby, field) {\n  var groups = [],\n      get = function(f) { return f(x); },\n      map, i, x, k, g, s, max;\n\n  // partition data points into stack groups\n  if (groupby == null) {\n    groups.push(data.slice());\n  } else {\n    for (map={}, i=0; i<data.length; ++i) {\n      x = data[i];\n      k = groupby.map(get);\n      g = map[k] || (groups.push(map[k] = []), map[k]);\n      g.push(x);\n    }\n  }\n\n  // compute sums of groups, sort groups as needed\n  for (k=0, max=0; k<groups.length; ++k) {\n    g = groups[k];\n    for (i=0, s=0; i<g.length; ++i) {\n      s += field(g[i]);\n    }\n    g.sum = s;\n    if (s > max) max = s;\n    if (sortby != null) g.sort(sortby);\n  }\n  groups.max = max;\n\n  return groups;\n}\n\nmodule.exports = Stack;\n\nStack.schema = {\n  \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n  \"title\": \"Stack transform\",\n  \"description\": \"Computes layout values for stacked graphs, as in stacked bar charts or stream graphs.\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"type\": {\"enum\": [\"stack\"]},\n    \"groupby\": {\n      \"description\": \"A list of fields to split the data into groups (stacks).\",\n      \"oneOf\": [\n        {\n          \"type\": \"array\",\n          \"items\": {\"oneOf\": [{\"type\": \"string\"}, {\"$ref\": \"#/refs/signal\"}]}\n        },\n        {\"$ref\": \"#/refs/signal\"}\n      ],\n    },\n    \"sortby\": {\n      \"description\": \"A list of fields to determine the sort order of stacks.\",\n      \"oneOf\": [\n        {\n          \"type\": \"array\",\n          \"items\": {\"oneOf\": [{\"type\": \"string\"}, {\"$ref\": \"#/refs/signal\"}]}\n        },\n        {\"$ref\": \"#/refs/signal\"}\n      ],\n    },\n    \"field\": {\n      \"description\": \"The data field that determines the thickness/height of stacks.\",\n      \"oneOf\": [{\"type\": \"string\"}, {\"$ref\": \"#/refs/signal\"}]\n    },\n    \"offset\": {\n      \"description\": \"The baseline offset\",\n      \"oneOf\": [{\"enum\": [\"zero\", \"center\", \"normalize\"]}, {\"$ref\": \"#/refs/signal\"}],\n      \"default\": \"zero\"\n    },\n    \"output\": {\n      \"type\": \"object\",\n      \"description\": \"Rename the output data fields\",\n      \"properties\": {\n        \"start\": {\"type\": \"string\", \"default\": \"layout_start\"},\n        \"end\": {\"type\": \"string\", \"default\": \"layout_end\"},\n        \"mid\": {\"type\": \"string\", \"default\": \"layout_mid\"}\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false,\n  \"required\": [\"type\", \"groupby\", \"field\"]\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/transforms/Stack.js\n ** module id = 130\n ** module chunks = 0\n **/","var dl = require('datalib'),\n    Tuple = require('vega-dataflow').Tuple,\n    log = require('vega-logging'),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform');\n\nfunction Treeify(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    groupby: {type: 'array<field>'}\n  });\n\n  this._output = {\n    'children': 'children',\n    'parent':   'parent'\n  };\n  return this.router(true).produces(true);\n}\n\nvar prototype = (Treeify.prototype = Object.create(BatchTransform.prototype));\nprototype.constructor = Treeify;\n\nprototype.batchTransform = function(input, data) {\n  log.debug(input, ['treeifying']);\n\n  var fields = this.param('groupby').field,\n      childField = this._output.children,\n      parentField = this._output.parent,\n      summary = [{name:'*', ops: ['values'], as: [childField]}],\n      aggrs = fields.map(function(f) {\n        return dl.groupby(f).summarize(summary);\n      }),\n      prev = this._internal || [], curr = [], i, n;\n\n  function level(index, node, values) {\n    var vals = aggrs[index].execute(values);\n\n    node[childField] = vals;\n    vals.forEach(function(n) {\n      n[parentField] = node;\n      curr.push(Tuple.ingest(n));\n      if (index+1 < fields.length) level(index+1, n, n[childField]);\n      else n[childField].forEach(function(c) { c[parentField] = n; });\n    });\n  }\n\n  var root = Tuple.ingest({});\n  root[parentField] = null;\n  curr.push(root);\n  level(0, root, data);\n\n  // update changeset with internal nodes\n  for (i=0, n=curr.length; i<n; ++i) {\n    input.add.push(curr[i]);\n  }\n  for (i=0, n=prev.length; i<n; ++i) {\n    input.rem.push(prev[i]);\n  }\n  this._internal = curr;\n\n  return input;\n};\n\nmodule.exports = Treeify;\n\nTreeify.schema = {\n  \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n  \"title\": \"Treeify transform\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"type\": {\"enum\": [\"treeify\"]},\n    \"groupby\": {\n      \"description\": \"An ordered list of fields by which to group tuples into a tree.\",\n      \"oneOf\": [\n        {\n          \"type\": \"array\",\n          \"items\": {\"oneOf\": [{\"type\": \"string\"}, {\"$ref\": \"#/refs/signal\"}]}\n        },\n        {\"$ref\": \"#/refs/signal\"}\n      ]\n    },\n    \"output\": {\n      \"type\": \"object\",\n      \"description\": \"Rename the output data fields\",\n      \"properties\": {\n        \"children\": {\"type\": \"string\", \"default\": \"children\"},\n        \"parent\": {\"type\": \"string\", \"default\": \"parent\"}\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false,\n  \"required\": [\"type\", \"groupby\"]\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/transforms/Treeify.js\n ** module id = 131\n ** module chunks = 0\n **/","var d3 = require('d3'),\n    dl = require('datalib'),\n    Tuple = require('vega-dataflow').Tuple,\n    log = require('vega-logging'),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform');\n\nvar defaultRatio = 0.5 * (1 + Math.sqrt(5));\n\nfunction Treemap(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    // hierarchy parameters\n    sort: {type: 'array<field>', default: ['-value']},\n    children: {type: 'field', default: 'children'},\n    parent: {type: 'field', default: 'parent'},\n    field: {type: 'field', default: 'value'},\n    // treemap parameters\n    size: {type: 'array<value>', default: require('./screen').size},\n    round: {type: 'value', default: true},\n    sticky: {type: 'value', default: false},\n    ratio: {type: 'value', default: defaultRatio},\n    padding: {type: 'value', default: null},\n    mode: {type: 'value', default: 'squarify'}\n  });\n\n  this._layout = d3.layout.treemap();\n\n  this._output = {\n    'x':      'layout_x',\n    'y':      'layout_y',\n    'width':  'layout_width',\n    'height': 'layout_height',\n    'depth':  'layout_depth',\n  };\n  return this.mutates(true);\n}\n\nvar prototype = (Treemap.prototype = Object.create(BatchTransform.prototype));\nprototype.constructor = Treemap;\n\nprototype.batchTransform = function(input, data) {\n  log.debug(input, ['treemap']);\n\n  // get variables\n  var layout = this._layout,\n      output = this._output,\n      sticky = this.param('sticky'),\n      parent = this.param('parent').accessor,\n      root = data.filter(function(d) { return parent(d) === null; })[0];\n\n  // layout.sticky resets state _regardless_ of input value\n  // so, we perform out own check first\n  if (layout.sticky() !== sticky) { layout.sticky(sticky); }\n\n  // configure layout\n  layout\n    .sort(dl.comparator(this.param('sort').field))\n    .children(this.param('children').accessor)\n    .value(this.param('field').accessor)\n    .size(this.param('size'))\n    .round(this.param('round'))\n    .ratio(this.param('ratio'))\n    .padding(this.param('padding'))\n    .mode(this.param('mode'))\n    .nodes(root);\n\n  // copy layout values to nodes\n  data.forEach(function(n) {\n    Tuple.set(n, output.x, n.x);\n    Tuple.set(n, output.y, n.y);\n    Tuple.set(n, output.width, n.dx);\n    Tuple.set(n, output.height, n.dy);\n    Tuple.set(n, output.depth, n.depth);\n  });\n\n  // return changeset\n  input.fields[output.x] = 1;\n  input.fields[output.y] = 1;\n  input.fields[output.width] = 1;\n  input.fields[output.height] = 1;\n  input.fields[output.depth] = 1;\n  return input;\n};\n\nmodule.exports = Treemap;\n\nTreemap.schema = {\n  \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n  \"title\": \"Treemap transform\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"type\": {\"enum\": [\"treemap\"]},\n    \"sort\": {\n      \"description\": \"A list of fields to use as sort criteria for sibling nodes.\",\n      \"oneOf\": [\n        {\n          \"type\": \"array\",\n          \"items\": {\"oneOf\": [{\"type\": \"string\"}, {\"$ref\": \"#/refs/signal\"}]}\n        },\n        {\"$ref\": \"#/refs/signal\"}\n      ],\n      \"default\": [\"-value\"]\n    },\n    \"children\": {\n      \"description\": \"The data field for the children node array\",\n      \"oneOf\": [{\"type\": \"string\"}, {\"$ref\": \"#/refs/signal\"}],\n      \"default\": \"children\"\n    },\n    \"parent\": {\n      \"description\": \"The data field for the parent node\",\n      \"oneOf\": [{\"type\": \"string\"}, {\"$ref\": \"#/refs/signal\"}],\n      \"default\": \"parent\"\n    },\n    \"field\": {\n      \"description\": \"The values to use to determine the area of each leaf-level treemap cell.\",\n      \"oneOf\": [{\"type\": \"string\"}, {\"$ref\": \"#/refs/signal\"}]\n    },\n    \"mode\": {\n      \"description\": \"The treemap layout algorithm to use.\",\n      \"oneOf\": [\n        {\"enum\": [\"squarify\", \"slice\", \"dice\", \"slice-dice\"]},\n        {\"$ref\": \"#/refs/signal\"}\n      ],\n      \"default\": \"squarify\"\n    },\n    \"size\": {\n      \"description\": \"The dimensions of the treemap layout\",\n      \"oneOf\": [\n        {\n          \"type\": \"array\",\n          \"items\": {\"oneOf\": [{\"type\": \"number\"}, {\"$ref\": \"#/refs/signal\"}]},\n          \"minItems\": 2,\n          \"maxItems\": 2\n        },\n        {\"$ref\": \"#/refs/signal\"}\n      ],\n      \"default\": [500, 500]\n    },\n    \"round\": {\n      \"description\": \"If true, treemap cell dimensions will be rounded to integer pixels.\",\n      \"oneOf\": [{\"type\": \"boolean\"}, {\"$ref\": \"#/refs/signal\"}],\n      \"default\": true\n    },\n    \"sticky\": {\n      \"description\": \"If true, repeated runs of the treemap will use cached partition boundaries.\",\n      \"oneOf\": [{\"type\": \"boolean\"}, {\"$ref\": \"#/refs/signal\"}],\n      \"default\": false\n    },\n    \"ratio\": {\n      \"description\": \"The target aspect ratio for the layout to optimize.\",\n      \"oneOf\": [{\"type\": \"number\"}, {\"$ref\": \"#/refs/signal\"}],\n      \"default\": defaultRatio\n    },\n    \"padding\": {\n      \"oneOf\": [\n        {\"type\": \"number\"},\n        {\n          \"type\": \"array\",\n          \"items\": {\"oneOf\": [{\"type\": \"number\"}, {\"$ref\": \"#/refs/signal\"}]},\n          \"minItems\": 4,\n          \"maxItems\": 4\n        },\n        {\"$ref\": \"#/refs/signal\"}\n      ],\n      \"description\": \"he padding (in pixels) to provide around internal nodes in the treemap.\"\n    },\n    \"output\": {\n      \"type\": \"object\",\n      \"description\": \"Rename the output data fields\",\n      \"properties\": {\n        \"x\": {\"type\": \"string\", \"default\": \"layout_x\"},\n        \"y\": {\"type\": \"string\", \"default\": \"layout_y\"},\n        \"width\": {\"type\": \"string\", \"default\": \"layout_width\"},\n        \"height\": {\"type\": \"string\", \"default\": \"layout_height\"},\n        \"depth\": {\"type\": \"string\", \"default\": \"layout_depth\"}\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false,\n  \"required\": [\"type\"]\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/transforms/Treemap.js\n ** module id = 132\n ** module chunks = 0\n **/","var d3 = require('d3'),\n    Tuple = require('vega-dataflow/src/Tuple'),\n    log = require('vega-logging'),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform');\n\nfunction Voronoi(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    clipExtent: {type: 'array<value>', default: require('./screen').extent},\n    x: {type: 'field', default: 'layout_x'},\n    y: {type: 'field', default: 'layout_y'}\n  });\n\n  this._layout = d3.geom.voronoi();\n  this._output = {'path': 'layout_path'};\n\n  return this.mutates(true);\n}\n\nvar prototype = (Voronoi.prototype = Object.create(BatchTransform.prototype));\nprototype.constructor = Voronoi;\n\nprototype.batchTransform = function(input, data) {\n  log.debug(input, ['voronoi']);\n\n  // get variables\n  var pathname = this._output.path;\n\n  // configure layout\n  var polygons = this._layout\n    .clipExtent(this.param('clipExtent'))\n    .x(this.param('x').accessor)\n    .y(this.param('y').accessor)\n    (data);\n\n  // build and assign path strings\n  for (var i=0; i<data.length; ++i) {\n    Tuple.set(data[i], pathname, 'M' + polygons[i].join('L') + 'Z');\n  }\n\n  // return changeset\n  input.fields[pathname] = 1;\n  return input;\n};\n\nmodule.exports = Voronoi;\n\nVoronoi.schema = {\n  \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n  \"title\": \"Voronoi transform\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"type\": {\"enum\": [\"voronoi\"]},\n    \"clipExtent\": {\n      \"description\": \"The min and max points at which to clip the voronoi diagram.\",\n      \"oneOf\": [\n        {\n          \"type\": \"array\",\n          \"items\": {\n            \"oneOf\": [\n              {\n                \"type\": \"array\",\n                \"items\": {\"oneOf\": [{\"type\": \"number\"}, {\"$ref\": \"#/refs/signal\"}]},\n                \"minItems\": 2,\n                \"maxItems\": 2\n              },\n              {\"$ref\": \"#/refs/signal\"}\n            ]\n          },\n          \"minItems\": 2,\n          \"maxItems\": 2\n        },\n        {\"$ref\": \"#/refs/signal\"}\n      ],\n      \"default\": [[-1e5,-1e5],[1e5,1e5]]\n    },\n    \"x\": {\n      \"description\": \"The input x coordinates.\",\n      \"oneOf\": [{\"type\": \"string\"}, {\"$ref\": \"#/refs/signal\"}]\n    },\n    \"y\": {\n      \"description\": \"The input y coordinates.\",\n      \"oneOf\": [{\"type\": \"string\"}, {\"$ref\": \"#/refs/signal\"}]\n    },\n    \"output\": {\n      \"type\": \"object\",\n      \"description\": \"Rename the output data fields\",\n      \"properties\": {\n        \"path\": {\"type\": \"string\", \"default\": \"layout_path\"}\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false,\n  \"required\": [\"type\"]\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/transforms/Voronoi.js\n ** module id = 133\n ** module chunks = 0\n **/","var dl = require('datalib'),\n    d3 = require('d3'),\n    d3_cloud = require('d3-cloud'),\n    canvas = require('vega-scenegraph').canvas,\n    Tuple = require('vega-dataflow/src/Tuple'),\n    log = require('vega-logging'),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform');\n\nfunction Wordcloud(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    size: {type: 'array<value>', default: require('./screen').size},\n    text: {type: 'field', default: 'data'},\n    rotate: {type: 'field|value', default: 0},\n    font: {type: 'field|value', default: {value: 'sans-serif'}},\n    fontSize: {type: 'field|value', default: 14},\n    fontStyle: {type: 'field|value', default: {value: 'normal'}},\n    fontWeight: {type: 'field|value', default: {value: 'normal'}},\n    fontScale: {type: 'array<value>', default: [10, 50]},\n    padding: {type: 'value', default: 1},\n    spiral: {type: 'value', default: 'archimedean'}\n  });\n\n  this._layout = d3_cloud().canvas(canvas.instance);\n\n  this._output = {\n    'x':          'layout_x',\n    'y':          'layout_y',\n    'font':       'layout_font',\n    'fontSize':   'layout_fontSize',\n    'fontStyle':  'layout_fontStyle',\n    'fontWeight': 'layout_fontWeight',\n    'rotate':     'layout_rotate',\n  };\n\n  return this.mutates(true);\n}\n\nvar prototype = (Wordcloud.prototype = Object.create(BatchTransform.prototype));\nprototype.constructor = Wordcloud;\n\nfunction get(p) {\n  return (p && p.accessor) || p;\n}\n\nfunction wrap(tuple) {\n  var x = Object.create(tuple);\n  x._tuple = tuple;\n  return x;\n}\n\nprototype.batchTransform = function(input, data) {\n  log.debug(input, ['wordcloud']);\n\n  // get variables\n  var layout = this._layout,\n      output = this._output,\n      fontSize = this.param('fontSize'),\n      range = fontSize.accessor && this.param('fontScale'),\n      size, scale;\n  fontSize = fontSize.accessor || d3.functor(fontSize);\n\n  // create font size scaling function as needed\n  if (range.length) {\n    scale = d3.scale.sqrt()\n      .domain(dl.extent(data, size=fontSize))\n      .range(range);\n    fontSize = function(x) { return scale(size(x)); };\n  }\n\n  // configure layout\n  layout\n    .size(this.param('size'))\n    .text(get(this.param('text')))\n    .padding(this.param('padding'))\n    .spiral(this.param('spiral'))\n    .rotate(get(this.param('rotate')))\n    .font(get(this.param('font')))\n    .fontStyle(get(this.param('fontStyle')))\n    .fontWeight(get(this.param('fontWeight')))\n    .fontSize(fontSize)\n    .words(data.map(wrap)) // wrap to avoid tuple writes\n    .on('end', function(words) {\n      var size = layout.size(),\n          dx = size[0] >> 1,\n          dy = size[1] >> 1,\n          w, t, i, len;\n\n      for (i=0, len=words.length; i<len; ++i) {\n        w = words[i];\n        t = w._tuple;\n        Tuple.set(t, output.x, w.x + dx);\n        Tuple.set(t, output.y, w.y + dy);\n        Tuple.set(t, output.font, w.font);\n        Tuple.set(t, output.fontSize, w.size);\n        Tuple.set(t, output.fontStyle, w.style);\n        Tuple.set(t, output.fontWeight, w.weight);\n        Tuple.set(t, output.rotate, w.rotate);\n      }\n    })\n    .start();\n\n  // return changeset\n  for (var key in output) input.fields[output[key]] = 1;\n  return input;\n};\n\nmodule.exports = Wordcloud;\n\nvar Parameter = require('./Parameter');\nWordcloud.schema = {\n  \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n  \"title\": \"Wordcloud transform\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"type\": {\"enum\": [\"wordcloud\"]},\n    \"size\": {\n      \"description\": \"The dimensions of the wordcloud layout\",\n      \"oneOf\": [\n        {\n          \"type\": \"array\",\n          \"items\": {\"oneOf\": [{\"type\": \"number\"}, {\"$ref\": \"#/refs/signal\"}]},\n          \"minItems\": 2,\n          \"maxItems\": 2\n        },\n        {\"$ref\": \"#/refs/signal\"}\n      ],\n      \"default\": [900, 500]\n    },\n    \"font\": {\n      \"description\": \"The font face to use for a word.\",\n      \"oneOf\": [{\"type\": \"string\"}, Parameter.schema, {\"$ref\": \"#/refs/signal\"}],\n      \"default\": \"sans-serif\"\n    },\n    \"fontStyle\": {\n      \"description\": \"The font style to use for a word.\",\n      \"oneOf\": [{\"type\": \"string\"}, Parameter.schema, {\"$ref\": \"#/refs/signal\"}],\n      \"default\": \"normal\"\n    },\n    \"fontWeight\": {\n      \"description\": \"The font weight to use for a word.\",\n      \"oneOf\": [{\"type\": \"string\"}, Parameter.schema, {\"$ref\": \"#/refs/signal\"}],\n      \"default\": \"normal\"\n    },\n    \"fontSize\": {\n      \"description\": \"The font size to use for a word.\",\n      \"oneOf\": [{\"type\": \"number\"}, Parameter.schema, {\"type\": \"string\"}, {\"$ref\": \"#/refs/signal\"}],\n      \"default\": 14\n    },\n    \"fontScale\": {\n      \"description\": \"The minimum and maximum scaled font sizes, or null to prevent scaling.\",\n      \"oneOf\": [\n        { \"type\": \"null\" },\n        {\n          \"type\": \"array\",\n          \"minItems\": 2,\n          \"maxItems\": 2,\n          \"items\": {\"oneOf\": [{\"type\":\"number\"}, {\"$ref\": \"#/refs/signal\"}]}\n        }\n      ],\n      \"default\": [10, 50]\n    },\n    \"rotate\": {\n      \"description\": \"The field or number to set the roration angle (in degrees).\",\n      \"oneOf\": [\n        {\"type\": \"number\"}, {\"type\": \"string\"},\n        Parameter.schema, {\"$ref\": \"#/refs/signal\"}\n      ],\n      \"default\": 0\n    },\n    \"text\": {\n      \"description\": \"The field containing the text to use for each word.\",\n      \"oneOf\": [{\"type\": \"string\"}, Parameter.schema, {\"$ref\": \"#/refs/signal\"}],\n      \"default\": 'data'\n    },\n    \"spiral\": {\n      \"description\": \"The type of spiral used for positioning words, either 'archimedean' or 'rectangular'.\",\n      \"oneOf\": [{\"enum\": [\"archimedean\", \"rectangular\"]}, Parameter.schema, {\"$ref\": \"#/refs/signal\"}],\n      \"default\": \"archimedean\"\n    },\n    \"padding\": {\n      \"description\": \"The padding around each word.\",\n      \"oneOf\": [{\"type\": \"number\"}, Parameter.schema, {\"$ref\": \"#/refs/signal\"}],\n      \"default\": 1\n    },\n    \"output\": {\n      \"type\": \"object\",\n      \"description\": \"Rename the output data fields\",\n      \"properties\": {\n        \"x\": {\"type\": \"string\", \"default\": \"layout_x\"},\n        \"y\": {\"type\": \"string\", \"default\": \"layout_y\"},\n        \"font\": {\"type\": \"string\", \"default\": \"layout_font\"},\n        \"fontSize\": {\"type\": \"string\", \"default\": \"layout_fontSize\"},\n        \"fontStyle\": {\"type\": \"string\", \"default\": \"layout_fontStyle\"},\n        \"fontWeight\": {\"type\": \"string\", \"default\": \"layout_fontWeight\"},\n        \"rotate\": {\"type\": \"string\", \"default\": \"layout_rotate\"}\n      },\n      \"additionalProperties\": false\n    }\n  },\n  \"additionalProperties\": false,\n  \"required\": [\"type\"]\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/transforms/Wordcloud.js\n ** module id = 134\n ** module chunks = 0\n **/","// Word cloud layout by Jason Davies, https://www.jasondavies.com/wordcloud/\n// Algorithm due to Jonathan Feinberg, http://static.mrfeinberg.com/bv_ch03.pdf\n\nvar dispatch = require(\"d3-dispatch\").dispatch;\n\nvar cloudRadians = Math.PI / 180,\n    cw = 1 << 11 >> 5,\n    ch = 1 << 11;\n\nmodule.exports = function() {\n  var size = [256, 256],\n      text = cloudText,\n      font = cloudFont,\n      fontSize = cloudFontSize,\n      fontStyle = cloudFontNormal,\n      fontWeight = cloudFontNormal,\n      rotate = cloudRotate,\n      padding = cloudPadding,\n      spiral = archimedeanSpiral,\n      words = [],\n      timeInterval = Infinity,\n      event = dispatch(\"word\", \"end\"),\n      timer = null,\n      random = Math.random,\n      cloud = {},\n      canvas = cloudCanvas;\n\n  cloud.canvas = function(_) {\n    return arguments.length ? (canvas = functor(_), cloud) : canvas;\n  };\n\n  cloud.start = function() {\n    var contextAndRatio = getContext(canvas()),\n        board = zeroArray((size[0] >> 5) * size[1]),\n        bounds = null,\n        n = words.length,\n        i = -1,\n        tags = [],\n        data = words.map(function(d, i) {\n          d.text = text.call(this, d, i);\n          d.font = font.call(this, d, i);\n          d.style = fontStyle.call(this, d, i);\n          d.weight = fontWeight.call(this, d, i);\n          d.rotate = rotate.call(this, d, i);\n          d.size = ~~fontSize.call(this, d, i);\n          d.padding = padding.call(this, d, i);\n          return d;\n        }).sort(function(a, b) { return b.size - a.size; });\n\n    if (timer) clearInterval(timer);\n    timer = setInterval(step, 0);\n    step();\n\n    return cloud;\n\n    function step() {\n      var start = Date.now();\n      while (Date.now() - start < timeInterval && ++i < n && timer) {\n        var d = data[i];\n        d.x = (size[0] * (random() + .5)) >> 1;\n        d.y = (size[1] * (random() + .5)) >> 1;\n        cloudSprite(contextAndRatio, d, data, i);\n        if (d.hasText && place(board, d, bounds)) {\n          tags.push(d);\n          event.word(d);\n          if (bounds) cloudBounds(bounds, d);\n          else bounds = [{x: d.x + d.x0, y: d.y + d.y0}, {x: d.x + d.x1, y: d.y + d.y1}];\n          // Temporary hack\n          d.x -= size[0] >> 1;\n          d.y -= size[1] >> 1;\n        }\n      }\n      if (i >= n) {\n        cloud.stop();\n        event.end(tags, bounds);\n      }\n    }\n  }\n\n  cloud.stop = function() {\n    if (timer) {\n      clearInterval(timer);\n      timer = null;\n    }\n    return cloud;\n  };\n\n  function getContext(canvas) {\n    canvas.width = canvas.height = 1;\n    var ratio = Math.sqrt(canvas.getContext(\"2d\").getImageData(0, 0, 1, 1).data.length >> 2);\n    canvas.width = (cw << 5) / ratio;\n    canvas.height = ch / ratio;\n\n    var context = canvas.getContext(\"2d\");\n    context.fillStyle = context.strokeStyle = \"red\";\n    context.textAlign = \"center\";\n\n    return {context: context, ratio: ratio};\n  }\n\n  function place(board, tag, bounds) {\n    var perimeter = [{x: 0, y: 0}, {x: size[0], y: size[1]}],\n        startX = tag.x,\n        startY = tag.y,\n        maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]),\n        s = spiral(size),\n        dt = random() < .5 ? 1 : -1,\n        t = -dt,\n        dxdy,\n        dx,\n        dy;\n\n    while (dxdy = s(t += dt)) {\n      dx = ~~dxdy[0];\n      dy = ~~dxdy[1];\n\n      if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta) break;\n\n      tag.x = startX + dx;\n      tag.y = startY + dy;\n\n      if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 ||\n          tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1]) continue;\n      // TODO only check for collisions within current bounds.\n      if (!bounds || !cloudCollide(tag, board, size[0])) {\n        if (!bounds || collideRects(tag, bounds)) {\n          var sprite = tag.sprite,\n              w = tag.width >> 5,\n              sw = size[0] >> 5,\n              lx = tag.x - (w << 4),\n              sx = lx & 0x7f,\n              msx = 32 - sx,\n              h = tag.y1 - tag.y0,\n              x = (tag.y + tag.y0) * sw + (lx >> 5),\n              last;\n          for (var j = 0; j < h; j++) {\n            last = 0;\n            for (var i = 0; i <= w; i++) {\n              board[x + i] |= (last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0);\n            }\n            x += sw;\n          }\n          delete tag.sprite;\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  cloud.timeInterval = function(_) {\n    return arguments.length ? (timeInterval = _ == null ? Infinity : _, cloud) : timeInterval;\n  };\n\n  cloud.words = function(_) {\n    return arguments.length ? (words = _, cloud) : words;\n  };\n\n  cloud.size = function(_) {\n    return arguments.length ? (size = [+_[0], +_[1]], cloud) : size;\n  };\n\n  cloud.font = function(_) {\n    return arguments.length ? (font = functor(_), cloud) : font;\n  };\n\n  cloud.fontStyle = function(_) {\n    return arguments.length ? (fontStyle = functor(_), cloud) : fontStyle;\n  };\n\n  cloud.fontWeight = function(_) {\n    return arguments.length ? (fontWeight = functor(_), cloud) : fontWeight;\n  };\n\n  cloud.rotate = function(_) {\n    return arguments.length ? (rotate = functor(_), cloud) : rotate;\n  };\n\n  cloud.text = function(_) {\n    return arguments.length ? (text = functor(_), cloud) : text;\n  };\n\n  cloud.spiral = function(_) {\n    return arguments.length ? (spiral = spirals[_] || _, cloud) : spiral;\n  };\n\n  cloud.fontSize = function(_) {\n    return arguments.length ? (fontSize = functor(_), cloud) : fontSize;\n  };\n\n  cloud.padding = function(_) {\n    return arguments.length ? (padding = functor(_), cloud) : padding;\n  };\n\n  cloud.random = function(_) {\n    return arguments.length ? (random = _, cloud) : random;\n  };\n\n  cloud.on = function() {\n    var value = event.on.apply(event, arguments);\n    return value === event ? cloud : value;\n  };\n\n  return cloud;\n};\n\nfunction cloudText(d) {\n  return d.text;\n}\n\nfunction cloudFont() {\n  return \"serif\";\n}\n\nfunction cloudFontNormal() {\n  return \"normal\";\n}\n\nfunction cloudFontSize(d) {\n  return Math.sqrt(d.value);\n}\n\nfunction cloudRotate() {\n  return (~~(Math.random() * 6) - 3) * 30;\n}\n\nfunction cloudPadding() {\n  return 1;\n}\n\n// Fetches a monochrome sprite bitmap for the specified text.\n// Load in batches for speed.\nfunction cloudSprite(contextAndRatio, d, data, di) {\n  if (d.sprite) return;\n  var c = contextAndRatio.context,\n      ratio = contextAndRatio.ratio;\n\n  c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);\n  var x = 0,\n      y = 0,\n      maxh = 0,\n      n = data.length;\n  --di;\n  while (++di < n) {\n    d = data[di];\n    c.save();\n    c.font = d.style + \" \" + d.weight + \" \" + ~~((d.size + 1) / ratio) + \"px \" + d.font;\n    var w = c.measureText(d.text + \"m\").width * ratio,\n        h = d.size << 1;\n    if (d.rotate) {\n      var sr = Math.sin(d.rotate * cloudRadians),\n          cr = Math.cos(d.rotate * cloudRadians),\n          wcr = w * cr,\n          wsr = w * sr,\n          hcr = h * cr,\n          hsr = h * sr;\n      w = (Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 0x1f) >> 5 << 5;\n      h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));\n    } else {\n      w = (w + 0x1f) >> 5 << 5;\n    }\n    if (h > maxh) maxh = h;\n    if (x + w >= (cw << 5)) {\n      x = 0;\n      y += maxh;\n      maxh = 0;\n    }\n    if (y + h >= ch) break;\n    c.translate((x + (w >> 1)) / ratio, (y + (h >> 1)) / ratio);\n    if (d.rotate) c.rotate(d.rotate * cloudRadians);\n    c.fillText(d.text, 0, 0);\n    if (d.padding) c.lineWidth = 2 * d.padding, c.strokeText(d.text, 0, 0);\n    c.restore();\n    d.width = w;\n    d.height = h;\n    d.xoff = x;\n    d.yoff = y;\n    d.x1 = w >> 1;\n    d.y1 = h >> 1;\n    d.x0 = -d.x1;\n    d.y0 = -d.y1;\n    d.hasText = true;\n    x += w;\n  }\n  var pixels = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data,\n      sprite = [];\n  while (--di >= 0) {\n    d = data[di];\n    if (!d.hasText) continue;\n    var w = d.width,\n        w32 = w >> 5,\n        h = d.y1 - d.y0;\n    // Zero the buffer\n    for (var i = 0; i < h * w32; i++) sprite[i] = 0;\n    x = d.xoff;\n    if (x == null) return;\n    y = d.yoff;\n    var seen = 0,\n        seenRow = -1;\n    for (var j = 0; j < h; j++) {\n      for (var i = 0; i < w; i++) {\n        var k = w32 * j + (i >> 5),\n            m = pixels[((y + j) * (cw << 5) + (x + i)) << 2] ? 1 << (31 - (i % 32)) : 0;\n        sprite[k] |= m;\n        seen |= m;\n      }\n      if (seen) seenRow = j;\n      else {\n        d.y0++;\n        h--;\n        j--;\n        y++;\n      }\n    }\n    d.y1 = d.y0 + seenRow;\n    d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);\n  }\n}\n\n// Use mask-based collision detection.\nfunction cloudCollide(tag, board, sw) {\n  sw >>= 5;\n  var sprite = tag.sprite,\n      w = tag.width >> 5,\n      lx = tag.x - (w << 4),\n      sx = lx & 0x7f,\n      msx = 32 - sx,\n      h = tag.y1 - tag.y0,\n      x = (tag.y + tag.y0) * sw + (lx >> 5),\n      last;\n  for (var j = 0; j < h; j++) {\n    last = 0;\n    for (var i = 0; i <= w; i++) {\n      if (((last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0))\n          & board[x + i]) return true;\n    }\n    x += sw;\n  }\n  return false;\n}\n\nfunction cloudBounds(bounds, d) {\n  var b0 = bounds[0],\n      b1 = bounds[1];\n  if (d.x + d.x0 < b0.x) b0.x = d.x + d.x0;\n  if (d.y + d.y0 < b0.y) b0.y = d.y + d.y0;\n  if (d.x + d.x1 > b1.x) b1.x = d.x + d.x1;\n  if (d.y + d.y1 > b1.y) b1.y = d.y + d.y1;\n}\n\nfunction collideRects(a, b) {\n  return a.x + a.x1 > b[0].x && a.x + a.x0 < b[1].x && a.y + a.y1 > b[0].y && a.y + a.y0 < b[1].y;\n}\n\nfunction archimedeanSpiral(size) {\n  var e = size[0] / size[1];\n  return function(t) {\n    return [e * (t *= .1) * Math.cos(t), t * Math.sin(t)];\n  };\n}\n\nfunction rectangularSpiral(size) {\n  var dy = 4,\n      dx = dy * size[0] / size[1],\n      x = 0,\n      y = 0;\n  return function(t) {\n    var sign = t < 0 ? -1 : 1;\n    // See triangular numbers: T_n = n * (n + 1) / 2.\n    switch ((Math.sqrt(1 + 4 * sign * t) - sign) & 3) {\n      case 0:  x += dx; break;\n      case 1:  y += dy; break;\n      case 2:  x -= dx; break;\n      default: y -= dy; break;\n    }\n    return [x, y];\n  };\n}\n\n// TODO reuse arrays?\nfunction zeroArray(n) {\n  var a = [],\n      i = -1;\n  while (++i < n) a[i] = 0;\n  return a;\n}\n\nfunction cloudCanvas() {\n  return document.createElement(\"canvas\");\n}\n\nfunction functor(d) {\n  return typeof d === \"function\" ? d : function() { return d; };\n}\n\nvar spirals = {\n  archimedean: archimedeanSpiral,\n  rectangular: rectangularSpiral\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/d3-cloud/index.js\n ** module id = 135\n ** module chunks = 0\n **/","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.d3_dispatch = {})));\n}(this, function (exports) { 'use strict';\n\n  function dispatch() {\n    return new Dispatch(arguments);\n  }\n\n  function Dispatch(types) {\n    var i = -1,\n        n = types.length,\n        callbacksByType = {},\n        callbackByName = {},\n        type,\n        that = this;\n\n    that.on = function(type, callback) {\n      type = parseType(type);\n\n      // Return the current callback, if any.\n      if (arguments.length < 2) {\n        return (callback = callbackByName[type.name]) && callback.value;\n      }\n\n      // If a type was specified\n      if (type.type) {\n        var callbacks = callbacksByType[type.type],\n            callback0 = callbackByName[type.name],\n            i;\n\n        // Remove the current callback, if any, using copy-on-remove.\n        if (callback0) {\n          callback0.value = null;\n          i = callbacks.indexOf(callback0);\n          callbacksByType[type.type] = callbacks = callbacks.slice(0, i).concat(callbacks.slice(i + 1));\n          delete callbackByName[type.name];\n        }\n\n        // Add the new callback, if any.\n        if (callback) {\n          callback = {value: callback};\n          callbackByName[type.name] = callback;\n          callbacks.push(callback);\n        }\n      }\n\n      // Otherwise, if a null callback was specified, remove all callbacks with the given name.\n      else if (callback == null) {\n        for (var otherType in callbacksByType) {\n          if (callback = callbackByName[otherType + type.name]) {\n            callback.value = null;\n            callbacks = callbacksByType[otherType];\n            i = callbacks.indexOf(callback);\n            callbacksByType[otherType] = callbacks.slice(0, i).concat(callbacks.slice(i + 1));\n            delete callbackByName[callback.name];\n          }\n        }\n      }\n\n      return that;\n    };\n\n    while (++i < n) {\n      type = types[i] + \"\";\n      if (!type || (type in that)) throw new Error(\"illegal or duplicate type: \" + type);\n      callbacksByType[type] = [];\n      that[type] = applier(type);\n    }\n\n    function parseType(type) {\n      var i = (type += \"\").indexOf(\".\"), name = type;\n      if (i >= 0) type = type.slice(0, i); else name += \".\";\n      if (type && !callbacksByType.hasOwnProperty(type)) throw new Error(\"unknown type: \" + type);\n      return {type: type, name: name};\n    }\n\n    function applier(type) {\n      return function() {\n        var callbacks = callbacksByType[type], // Defensive reference; copy-on-remove.\n            callbackValue,\n            i = -1,\n            n = callbacks.length;\n\n        while (++i < n) {\n          if (callbackValue = callbacks[i].value) {\n            callbackValue.apply(this, arguments);\n          }\n        }\n\n        return that;\n      };\n    }\n  }\n\n  dispatch.prototype = Dispatch.prototype;\n\n  var version = \"0.2.6\";\n\n  exports.version = version;\n  exports.dispatch = dispatch;\n\n}));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/d3-dispatch/build/d3-dispatch.js\n ** module id = 136\n ** module chunks = 0\n **/","var dl = require('datalib'),\n    log = require('vega-logging'),\n    df = require('vega-dataflow'),\n    Node = df.Node, // jshint ignore:line\n    Tuple = df.Tuple,\n    Deps = df.Dependencies;\n\nvar Types = {\n  INSERT: \"insert\",\n  REMOVE: \"remove\",\n  UPSERT: \"upsert\",\n  TOGGLE: \"toggle\",\n  CLEAR:  \"clear\"\n};\n\nvar EMPTY = [];\n\nfunction filter(fields, value, src, dest) {\n  var splice = true, len = fields.length, i, j, f, v;\n  for (i = src.length - 1; i >= 0; --i) {\n    for (j=0; j<len; ++j) {\n      f = fields[j];\n      v = value && f(value) || value;\n      if (f(src[i]) !== v) {\n        splice = false;\n        break;\n      }\n    }\n\n    if (splice) dest.push.apply(dest, src.splice(i, 1));\n    splice = true;\n  }\n}\n\nfunction insert(input, datum, source) {\n  var t = Tuple.ingest(datum);\n  input.add.push(t);\n  source._data.push(t);\n}\n\nfunction parseModify(model, def, ds) {\n  var signal = def.signal ? dl.field(def.signal) : null,\n      signalName  = signal ? signal[0] : null,\n      predicate   = def.predicate ? model.predicate(def.predicate.name || def.predicate) : null,\n      exprTrigger = def.test ? model.expr(def.test) : null,\n      reeval  = (predicate === null && exprTrigger === null),\n      isClear = def.type === Types.CLEAR,\n      fields  = dl.array(def.field || 'data'),\n      getters = fields.map(dl.accessor),\n      setters = fields.map(dl.mutator),\n      node = new Node(model).router(isClear);\n\n  node.evaluate = function(input) {\n    var db, sg;\n\n    if (predicate !== null) {  // TODO: predicate args\n      db = model.values(Deps.DATA, predicate.data || EMPTY);\n      sg = model.values(Deps.SIGNALS, predicate.signals || EMPTY);\n      reeval = predicate.call(predicate, {}, db, sg, model._predicates);\n    }\n\n    if (exprTrigger !== null) {\n      sg = model.values(Deps.SIGNALS, exprTrigger.globals || EMPTY);\n      reeval = exprTrigger.fn();\n    }\n\n    log.debug(input, [def.type+\"ing\", reeval]);\n    if (!reeval || (!isClear && !input.signals[signalName])) return input;\n\n    var value = signal ? model.signalRef(def.signal) : null,\n        d = model.data(ds.name),\n        t = null, add = [], rem = [], up = 0, datum;\n\n    if (dl.isObject(value)) {\n      datum = value;\n      if (!def.field) {\n        fields = dl.keys(datum);\n        getters = fields.map(dl.accessor);\n        setters = fields.map(dl.mutator);\n      }\n    } else {\n      datum = {};\n      setters.forEach(function(f) { f(datum, value); });\n    }\n\n    // We have to modify ds._data so that subsequent pulses contain\n    // our dynamic data. W/o modifying ds._data, only the output\n    // collector will contain dynamic tuples.\n    if (def.type === Types.INSERT) {\n      insert(input, datum, d);\n    } else if (def.type === Types.REMOVE) {\n      filter(getters, value, input.mod, input.rem);\n      filter(getters, value, input.add, rem);\n      filter(getters, value, d._data, rem);\n    } else if (def.type === Types.UPSERT) {\n      input.mod.forEach(function(x) {\n        var every = getters.every(function(f) {\n          return f(x) === f(datum);\n        });\n\n        if (every) up = (dl.extend(x, datum), up+1);\n      });\n\n      if (up === 0) insert(input, datum, d);\n    } else if (def.type === Types.TOGGLE) {\n      // If tuples are in mod, remove them.\n      filter(getters, value, input.mod, rem);\n      input.rem.push.apply(input.rem, rem);\n\n      // If tuples are in add, they've been added to backing data source,\n      // but no downstream operators will have seen it yet.\n      filter(getters, value, input.add, add);\n\n      if (add.length || rem.length) {\n        d._data = d._data.filter(function(x) {\n          return rem.indexOf(x) < 0 && add.indexOf(x) < 0;\n        });\n      } else {\n        // If the tuples aren't seen in the changeset, add a new tuple.\n        // Note, tuple might be in input.rem, but we ignore this and just\n        // re-add a new tuple for simplicity.\n        input.add.push(t=Tuple.ingest(datum));\n        d._data.push(t);\n      }\n    } else if (def.type === Types.CLEAR) {\n      input.rem.push.apply(input.rem, input.mod.splice(0));\n      input.add.splice(0);\n      d._data.splice(0);\n    }\n\n    fields.forEach(function(f) { input.fields[f] = 1; });\n    return input;\n  };\n\n  if (signalName) node.dependency(Deps.SIGNALS, signalName);\n\n  if (predicate) {\n    node.dependency(Deps.DATA, predicate.data);\n    node.dependency(Deps.SIGNALS, predicate.signals);\n  }\n\n  if (exprTrigger) {\n    node.dependency(Deps.SIGNALS, exprTrigger.globals);\n    node.dependency(Deps.DATA,    exprTrigger.dataSources);\n  }\n\n  return node;\n}\n\nmodule.exports = parseModify;\nparseModify.schema = {\n  \"defs\": {\n    \"modify\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"oneOf\": [{\n          \"properties\": {\n            \"type\": {\"enum\": [\n              Types.INSERT, Types.REMOVE, Types.UPSERT, Types.TOGGLE\n            ]},\n            \"signal\": {\"type\": \"string\"},\n            \"field\": {\"type\": \"string\"}\n          },\n          \"required\": [\"type\", \"signal\"]\n        }, {\n          \"properties\": {\n            \"type\": {\"enum\": [Types.CLEAR]},\n            \"predicate\": {\"type\": \"string\"}  // TODO predicate args\n          },\n          \"required\": [\"type\", \"predicate\"]\n        },\n        {\n          \"properties\": {\n            \"type\": {\"enum\": [Types.CLEAR]},\n            \"test\": {\"type\": \"string\"}\n          },\n          \"required\": [\"type\", \"test\"]\n        }]\n      }\n    }\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/parse/modify.js\n ** module id = 137\n ** module chunks = 0\n **/","module.exports = (function() {\n  \"use strict\";\n\n  /*\n   * Generated by PEG.js 0.9.0.\n   *\n   * http://pegjs.org/\n   */\n\n  function peg$subclass(child, parent) {\n    function ctor() { this.constructor = child; }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n  }\n\n  function peg$SyntaxError(message, expected, found, location) {\n    this.message  = message;\n    this.expected = expected;\n    this.found    = found;\n    this.location = location;\n    this.name     = \"SyntaxError\";\n\n    if (typeof Error.captureStackTrace === \"function\") {\n      Error.captureStackTrace(this, peg$SyntaxError);\n    }\n  }\n\n  peg$subclass(peg$SyntaxError, Error);\n\n  function peg$parse(input) {\n    var options = arguments.length > 1 ? arguments[1] : {},\n        parser  = this,\n\n        peg$FAILED = {},\n\n        peg$startRuleFunctions = { start: peg$parsestart },\n        peg$startRuleFunction  = peg$parsestart,\n\n        peg$c0 = \",\",\n        peg$c1 = { type: \"literal\", value: \",\", description: \"\\\",\\\"\" },\n        peg$c2 = function(o, m) { return [o].concat(m); },\n        peg$c3 = function(o) { return [o]; },\n        peg$c4 = \"[\",\n        peg$c5 = { type: \"literal\", value: \"[\", description: \"\\\"[\\\"\" },\n        peg$c6 = \"]\",\n        peg$c7 = { type: \"literal\", value: \"]\", description: \"\\\"]\\\"\" },\n        peg$c8 = \">\",\n        peg$c9 = { type: \"literal\", value: \">\", description: \"\\\">\\\"\" },\n        peg$c10 = function(f1, f2, o) {\n            return {\n              start: f1, middle: o, end: f2,\n              str: '['+f1.str+', '+f2.str+'] > '+o.str};\n            },\n        peg$c11 = function(s, f) {\n            s.filters = f;\n            s.str += f.map(function(x) { return '['+x+']'; }).join('');\n            return s;\n          },\n        peg$c12 = function(s) { return s; },\n        peg$c13 = \"(\",\n        peg$c14 = { type: \"literal\", value: \"(\", description: \"\\\"(\\\"\" },\n        peg$c15 = \")\",\n        peg$c16 = { type: \"literal\", value: \")\", description: \"\\\")\\\"\" },\n        peg$c17 = function(m) {\n            return {\n              stream: m,\n              str: '('+m.map(function(m) { return m.str; }).join(', ')+')'\n            };\n          },\n        peg$c18 = \"@\",\n        peg$c19 = { type: \"literal\", value: \"@\", description: \"\\\"@\\\"\" },\n        peg$c20 = \":\",\n        peg$c21 = { type: \"literal\", value: \":\", description: \"\\\":\\\"\" },\n        peg$c22 = function(n, e) { return {event: e, name: n, str: '@'+n+':'+e}; },\n        peg$c23 = function(m, e) { return {event: e, mark: m, str: m+':'+e}; },\n        peg$c24 = function(t, e) { return {event: e, target: t, str: t+':'+e}; },\n        peg$c25 = function(e) { return {event: e, str: e}; },\n        peg$c26 = function(s) { return {signal: s, str: s}; },\n        peg$c27 = \"rect\",\n        peg$c28 = { type: \"literal\", value: \"rect\", description: \"\\\"rect\\\"\" },\n        peg$c29 = \"symbol\",\n        peg$c30 = { type: \"literal\", value: \"symbol\", description: \"\\\"symbol\\\"\" },\n        peg$c31 = \"path\",\n        peg$c32 = { type: \"literal\", value: \"path\", description: \"\\\"path\\\"\" },\n        peg$c33 = \"arc\",\n        peg$c34 = { type: \"literal\", value: \"arc\", description: \"\\\"arc\\\"\" },\n        peg$c35 = \"area\",\n        peg$c36 = { type: \"literal\", value: \"area\", description: \"\\\"area\\\"\" },\n        peg$c37 = \"line\",\n        peg$c38 = { type: \"literal\", value: \"line\", description: \"\\\"line\\\"\" },\n        peg$c39 = \"rule\",\n        peg$c40 = { type: \"literal\", value: \"rule\", description: \"\\\"rule\\\"\" },\n        peg$c41 = \"image\",\n        peg$c42 = { type: \"literal\", value: \"image\", description: \"\\\"image\\\"\" },\n        peg$c43 = \"text\",\n        peg$c44 = { type: \"literal\", value: \"text\", description: \"\\\"text\\\"\" },\n        peg$c45 = \"group\",\n        peg$c46 = { type: \"literal\", value: \"group\", description: \"\\\"group\\\"\" },\n        peg$c47 = \"mousedown\",\n        peg$c48 = { type: \"literal\", value: \"mousedown\", description: \"\\\"mousedown\\\"\" },\n        peg$c49 = \"mouseup\",\n        peg$c50 = { type: \"literal\", value: \"mouseup\", description: \"\\\"mouseup\\\"\" },\n        peg$c51 = \"click\",\n        peg$c52 = { type: \"literal\", value: \"click\", description: \"\\\"click\\\"\" },\n        peg$c53 = \"dblclick\",\n        peg$c54 = { type: \"literal\", value: \"dblclick\", description: \"\\\"dblclick\\\"\" },\n        peg$c55 = \"wheel\",\n        peg$c56 = { type: \"literal\", value: \"wheel\", description: \"\\\"wheel\\\"\" },\n        peg$c57 = \"keydown\",\n        peg$c58 = { type: \"literal\", value: \"keydown\", description: \"\\\"keydown\\\"\" },\n        peg$c59 = \"keypress\",\n        peg$c60 = { type: \"literal\", value: \"keypress\", description: \"\\\"keypress\\\"\" },\n        peg$c61 = \"keyup\",\n        peg$c62 = { type: \"literal\", value: \"keyup\", description: \"\\\"keyup\\\"\" },\n        peg$c63 = \"mousewheel\",\n        peg$c64 = { type: \"literal\", value: \"mousewheel\", description: \"\\\"mousewheel\\\"\" },\n        peg$c65 = \"mousemove\",\n        peg$c66 = { type: \"literal\", value: \"mousemove\", description: \"\\\"mousemove\\\"\" },\n        peg$c67 = \"mouseout\",\n        peg$c68 = { type: \"literal\", value: \"mouseout\", description: \"\\\"mouseout\\\"\" },\n        peg$c69 = \"mouseover\",\n        peg$c70 = { type: \"literal\", value: \"mouseover\", description: \"\\\"mouseover\\\"\" },\n        peg$c71 = \"mouseenter\",\n        peg$c72 = { type: \"literal\", value: \"mouseenter\", description: \"\\\"mouseenter\\\"\" },\n        peg$c73 = \"touchstart\",\n        peg$c74 = { type: \"literal\", value: \"touchstart\", description: \"\\\"touchstart\\\"\" },\n        peg$c75 = \"touchmove\",\n        peg$c76 = { type: \"literal\", value: \"touchmove\", description: \"\\\"touchmove\\\"\" },\n        peg$c77 = \"touchend\",\n        peg$c78 = { type: \"literal\", value: \"touchend\", description: \"\\\"touchend\\\"\" },\n        peg$c79 = \"dragenter\",\n        peg$c80 = { type: \"literal\", value: \"dragenter\", description: \"\\\"dragenter\\\"\" },\n        peg$c81 = \"dragover\",\n        peg$c82 = { type: \"literal\", value: \"dragover\", description: \"\\\"dragover\\\"\" },\n        peg$c83 = \"dragleave\",\n        peg$c84 = { type: \"literal\", value: \"dragleave\", description: \"\\\"dragleave\\\"\" },\n        peg$c85 = function(e) { return e; },\n        peg$c86 = /^[a-zA-Z0-9_\\-]/,\n        peg$c87 = { type: \"class\", value: \"[a-zA-Z0-9_-]\", description: \"[a-zA-Z0-9_-]\" },\n        peg$c88 = function(n) { return n.join(''); },\n        peg$c89 = /^[a-zA-Z0-9\\-_  #.>+~[\\]=|\\^$*]/,\n        peg$c90 = { type: \"class\", value: \"[a-zA-Z0-9-_  #\\\\.\\\\>\\\\+~\\\\[\\\\]=|\\\\^\\\\$\\\\*]\", description: \"[a-zA-Z0-9-_  #\\\\.\\\\>\\\\+~\\\\[\\\\]=|\\\\^\\\\$\\\\*]\" },\n        peg$c91 = function(c) { return c.join(''); },\n        peg$c92 = /^['\"a-zA-Z0-9_().><=! \\t-&|~]/,\n        peg$c93 = { type: \"class\", value: \"['\\\"a-zA-Z0-9_\\\\(\\\\)\\\\.\\\\>\\\\<\\\\=\\\\! \\\\t-&|~]\", description: \"['\\\"a-zA-Z0-9_\\\\(\\\\)\\\\.\\\\>\\\\<\\\\=\\\\! \\\\t-&|~]\" },\n        peg$c94 = function(v) { return v.join(''); },\n        peg$c95 = /^[ \\t\\r\\n]/,\n        peg$c96 = { type: \"class\", value: \"[ \\\\t\\\\r\\\\n]\", description: \"[ \\\\t\\\\r\\\\n]\" },\n\n        peg$currPos          = 0,\n        peg$savedPos         = 0,\n        peg$posDetailsCache  = [{ line: 1, column: 1, seenCR: false }],\n        peg$maxFailPos       = 0,\n        peg$maxFailExpected  = [],\n        peg$silentFails      = 0,\n\n        peg$result;\n\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n      }\n\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n\n    function text() {\n      return input.substring(peg$savedPos, peg$currPos);\n    }\n\n    function location() {\n      return peg$computeLocation(peg$savedPos, peg$currPos);\n    }\n\n    function expected(description) {\n      throw peg$buildException(\n        null,\n        [{ type: \"other\", description: description }],\n        input.substring(peg$savedPos, peg$currPos),\n        peg$computeLocation(peg$savedPos, peg$currPos)\n      );\n    }\n\n    function error(message) {\n      throw peg$buildException(\n        message,\n        null,\n        input.substring(peg$savedPos, peg$currPos),\n        peg$computeLocation(peg$savedPos, peg$currPos)\n      );\n    }\n\n    function peg$computePosDetails(pos) {\n      var details = peg$posDetailsCache[pos],\n          p, ch;\n\n      if (details) {\n        return details;\n      } else {\n        p = pos - 1;\n        while (!peg$posDetailsCache[p]) {\n          p--;\n        }\n\n        details = peg$posDetailsCache[p];\n        details = {\n          line:   details.line,\n          column: details.column,\n          seenCR: details.seenCR\n        };\n\n        while (p < pos) {\n          ch = input.charAt(p);\n          if (ch === \"\\n\") {\n            if (!details.seenCR) { details.line++; }\n            details.column = 1;\n            details.seenCR = false;\n          } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n            details.line++;\n            details.column = 1;\n            details.seenCR = true;\n          } else {\n            details.column++;\n            details.seenCR = false;\n          }\n\n          p++;\n        }\n\n        peg$posDetailsCache[pos] = details;\n        return details;\n      }\n    }\n\n    function peg$computeLocation(startPos, endPos) {\n      var startPosDetails = peg$computePosDetails(startPos),\n          endPosDetails   = peg$computePosDetails(endPos);\n\n      return {\n        start: {\n          offset: startPos,\n          line:   startPosDetails.line,\n          column: startPosDetails.column\n        },\n        end: {\n          offset: endPos,\n          line:   endPosDetails.line,\n          column: endPosDetails.column\n        }\n      };\n    }\n\n    function peg$fail(expected) {\n      if (peg$currPos < peg$maxFailPos) { return; }\n\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n\n      peg$maxFailExpected.push(expected);\n    }\n\n    function peg$buildException(message, expected, found, location) {\n      function cleanupExpected(expected) {\n        var i = 1;\n\n        expected.sort(function(a, b) {\n          if (a.description < b.description) {\n            return -1;\n          } else if (a.description > b.description) {\n            return 1;\n          } else {\n            return 0;\n          }\n        });\n\n        while (i < expected.length) {\n          if (expected[i - 1] === expected[i]) {\n            expected.splice(i, 1);\n          } else {\n            i++;\n          }\n        }\n      }\n\n      function buildMessage(expected, found) {\n        function stringEscape(s) {\n          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\n\n          return s\n            .replace(/\\\\/g,   '\\\\\\\\')\n            .replace(/\"/g,    '\\\\\"')\n            .replace(/\\x08/g, '\\\\b')\n            .replace(/\\t/g,   '\\\\t')\n            .replace(/\\n/g,   '\\\\n')\n            .replace(/\\f/g,   '\\\\f')\n            .replace(/\\r/g,   '\\\\r')\n            .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return '\\\\x0' + hex(ch); })\n            .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return '\\\\x'  + hex(ch); })\n            .replace(/[\\u0100-\\u0FFF]/g,         function(ch) { return '\\\\u0' + hex(ch); })\n            .replace(/[\\u1000-\\uFFFF]/g,         function(ch) { return '\\\\u'  + hex(ch); });\n        }\n\n        var expectedDescs = new Array(expected.length),\n            expectedDesc, foundDesc, i;\n\n        for (i = 0; i < expected.length; i++) {\n          expectedDescs[i] = expected[i].description;\n        }\n\n        expectedDesc = expected.length > 1\n          ? expectedDescs.slice(0, -1).join(\", \")\n              + \" or \"\n              + expectedDescs[expected.length - 1]\n          : expectedDescs[0];\n\n        foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n\n        return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n      }\n\n      if (expected !== null) {\n        cleanupExpected(expected);\n      }\n\n      return new peg$SyntaxError(\n        message !== null ? message : buildMessage(expected, found),\n        expected,\n        found,\n        location\n      );\n    }\n\n    function peg$parsestart() {\n      var s0;\n\n      s0 = peg$parsemerged();\n\n      return s0;\n    }\n\n    function peg$parsemerged() {\n      var s0, s1, s2, s3, s4, s5;\n\n      s0 = peg$currPos;\n      s1 = peg$parseordered();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsesep();\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 44) {\n            s3 = peg$c0;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c1); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parsesep();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsemerged();\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c2(s1, s5);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parseordered();\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c3(s1);\n        }\n        s0 = s1;\n      }\n\n      return s0;\n    }\n\n    function peg$parseordered() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 91) {\n        s1 = peg$c4;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c5); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsesep();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsefiltered();\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parsesep();\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 44) {\n                s5 = peg$c0;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c1); }\n              }\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parsesep();\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$parsefiltered();\n                  if (s7 !== peg$FAILED) {\n                    s8 = peg$parsesep();\n                    if (s8 !== peg$FAILED) {\n                      if (input.charCodeAt(peg$currPos) === 93) {\n                        s9 = peg$c6;\n                        peg$currPos++;\n                      } else {\n                        s9 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c7); }\n                      }\n                      if (s9 !== peg$FAILED) {\n                        s10 = peg$parsesep();\n                        if (s10 !== peg$FAILED) {\n                          if (input.charCodeAt(peg$currPos) === 62) {\n                            s11 = peg$c8;\n                            peg$currPos++;\n                          } else {\n                            s11 = peg$FAILED;\n                            if (peg$silentFails === 0) { peg$fail(peg$c9); }\n                          }\n                          if (s11 !== peg$FAILED) {\n                            s12 = peg$parsesep();\n                            if (s12 !== peg$FAILED) {\n                              s13 = peg$parseordered();\n                              if (s13 !== peg$FAILED) {\n                                peg$savedPos = s0;\n                                s1 = peg$c10(s3, s7, s13);\n                                s0 = s1;\n                              } else {\n                                peg$currPos = s0;\n                                s0 = peg$FAILED;\n                              }\n                            } else {\n                              peg$currPos = s0;\n                              s0 = peg$FAILED;\n                            }\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsefiltered();\n      }\n\n      return s0;\n    }\n\n    function peg$parsefiltered() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      s1 = peg$parsestream();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parsefilter();\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parsefilter();\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c11(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parsestream();\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c12(s1);\n        }\n        s0 = s1;\n      }\n\n      return s0;\n    }\n\n    function peg$parsestream() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s1 = peg$c13;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c14); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsemerged();\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 41) {\n            s3 = peg$c15;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c16); }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c17(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 64) {\n          s1 = peg$c18;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c19); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsename();\n          if (s2 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 58) {\n              s3 = peg$c20;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c21); }\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parseeventType();\n              if (s4 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c22(s2, s4);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parsemarkType();\n          if (s1 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 58) {\n              s2 = peg$c20;\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c21); }\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parseeventType();\n              if (s3 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c23(s1, s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parsecss();\n            if (s1 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 58) {\n                s2 = peg$c20;\n                peg$currPos++;\n              } else {\n                s2 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c21); }\n              }\n              if (s2 !== peg$FAILED) {\n                s3 = peg$parseeventType();\n                if (s3 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c24(s1, s3);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              s1 = peg$parseeventType();\n              if (s1 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c25(s1);\n              }\n              s0 = s1;\n              if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n                s1 = peg$parsename();\n                if (s1 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c26(s1);\n                }\n                s0 = s1;\n              }\n            }\n          }\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parsemarkType() {\n      var s0;\n\n      if (input.substr(peg$currPos, 4) === peg$c27) {\n        s0 = peg$c27;\n        peg$currPos += 4;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c28); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.substr(peg$currPos, 6) === peg$c29) {\n          s0 = peg$c29;\n          peg$currPos += 6;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c30); }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.substr(peg$currPos, 4) === peg$c31) {\n            s0 = peg$c31;\n            peg$currPos += 4;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c32); }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 3) === peg$c33) {\n              s0 = peg$c33;\n              peg$currPos += 3;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c34); }\n            }\n            if (s0 === peg$FAILED) {\n              if (input.substr(peg$currPos, 4) === peg$c35) {\n                s0 = peg$c35;\n                peg$currPos += 4;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c36); }\n              }\n              if (s0 === peg$FAILED) {\n                if (input.substr(peg$currPos, 4) === peg$c37) {\n                  s0 = peg$c37;\n                  peg$currPos += 4;\n                } else {\n                  s0 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c38); }\n                }\n                if (s0 === peg$FAILED) {\n                  if (input.substr(peg$currPos, 4) === peg$c39) {\n                    s0 = peg$c39;\n                    peg$currPos += 4;\n                  } else {\n                    s0 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c40); }\n                  }\n                  if (s0 === peg$FAILED) {\n                    if (input.substr(peg$currPos, 5) === peg$c41) {\n                      s0 = peg$c41;\n                      peg$currPos += 5;\n                    } else {\n                      s0 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c42); }\n                    }\n                    if (s0 === peg$FAILED) {\n                      if (input.substr(peg$currPos, 4) === peg$c43) {\n                        s0 = peg$c43;\n                        peg$currPos += 4;\n                      } else {\n                        s0 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c44); }\n                      }\n                      if (s0 === peg$FAILED) {\n                        if (input.substr(peg$currPos, 5) === peg$c45) {\n                          s0 = peg$c45;\n                          peg$currPos += 5;\n                        } else {\n                          s0 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c46); }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseeventType() {\n      var s0;\n\n      if (input.substr(peg$currPos, 9) === peg$c47) {\n        s0 = peg$c47;\n        peg$currPos += 9;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c48); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.substr(peg$currPos, 7) === peg$c49) {\n          s0 = peg$c49;\n          peg$currPos += 7;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c50); }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.substr(peg$currPos, 5) === peg$c51) {\n            s0 = peg$c51;\n            peg$currPos += 5;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c52); }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 8) === peg$c53) {\n              s0 = peg$c53;\n              peg$currPos += 8;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c54); }\n            }\n            if (s0 === peg$FAILED) {\n              if (input.substr(peg$currPos, 5) === peg$c55) {\n                s0 = peg$c55;\n                peg$currPos += 5;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c56); }\n              }\n              if (s0 === peg$FAILED) {\n                if (input.substr(peg$currPos, 7) === peg$c57) {\n                  s0 = peg$c57;\n                  peg$currPos += 7;\n                } else {\n                  s0 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c58); }\n                }\n                if (s0 === peg$FAILED) {\n                  if (input.substr(peg$currPos, 8) === peg$c59) {\n                    s0 = peg$c59;\n                    peg$currPos += 8;\n                  } else {\n                    s0 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c60); }\n                  }\n                  if (s0 === peg$FAILED) {\n                    if (input.substr(peg$currPos, 5) === peg$c61) {\n                      s0 = peg$c61;\n                      peg$currPos += 5;\n                    } else {\n                      s0 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c62); }\n                    }\n                    if (s0 === peg$FAILED) {\n                      if (input.substr(peg$currPos, 10) === peg$c63) {\n                        s0 = peg$c63;\n                        peg$currPos += 10;\n                      } else {\n                        s0 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c64); }\n                      }\n                      if (s0 === peg$FAILED) {\n                        if (input.substr(peg$currPos, 9) === peg$c65) {\n                          s0 = peg$c65;\n                          peg$currPos += 9;\n                        } else {\n                          s0 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c66); }\n                        }\n                        if (s0 === peg$FAILED) {\n                          if (input.substr(peg$currPos, 8) === peg$c67) {\n                            s0 = peg$c67;\n                            peg$currPos += 8;\n                          } else {\n                            s0 = peg$FAILED;\n                            if (peg$silentFails === 0) { peg$fail(peg$c68); }\n                          }\n                          if (s0 === peg$FAILED) {\n                            if (input.substr(peg$currPos, 9) === peg$c69) {\n                              s0 = peg$c69;\n                              peg$currPos += 9;\n                            } else {\n                              s0 = peg$FAILED;\n                              if (peg$silentFails === 0) { peg$fail(peg$c70); }\n                            }\n                            if (s0 === peg$FAILED) {\n                              if (input.substr(peg$currPos, 10) === peg$c71) {\n                                s0 = peg$c71;\n                                peg$currPos += 10;\n                              } else {\n                                s0 = peg$FAILED;\n                                if (peg$silentFails === 0) { peg$fail(peg$c72); }\n                              }\n                              if (s0 === peg$FAILED) {\n                                if (input.substr(peg$currPos, 10) === peg$c73) {\n                                  s0 = peg$c73;\n                                  peg$currPos += 10;\n                                } else {\n                                  s0 = peg$FAILED;\n                                  if (peg$silentFails === 0) { peg$fail(peg$c74); }\n                                }\n                                if (s0 === peg$FAILED) {\n                                  if (input.substr(peg$currPos, 9) === peg$c75) {\n                                    s0 = peg$c75;\n                                    peg$currPos += 9;\n                                  } else {\n                                    s0 = peg$FAILED;\n                                    if (peg$silentFails === 0) { peg$fail(peg$c76); }\n                                  }\n                                  if (s0 === peg$FAILED) {\n                                    if (input.substr(peg$currPos, 8) === peg$c77) {\n                                      s0 = peg$c77;\n                                      peg$currPos += 8;\n                                    } else {\n                                      s0 = peg$FAILED;\n                                      if (peg$silentFails === 0) { peg$fail(peg$c78); }\n                                    }\n                                    if (s0 === peg$FAILED) {\n                                      if (input.substr(peg$currPos, 9) === peg$c79) {\n                                        s0 = peg$c79;\n                                        peg$currPos += 9;\n                                      } else {\n                                        s0 = peg$FAILED;\n                                        if (peg$silentFails === 0) { peg$fail(peg$c80); }\n                                      }\n                                      if (s0 === peg$FAILED) {\n                                        if (input.substr(peg$currPos, 8) === peg$c81) {\n                                          s0 = peg$c81;\n                                          peg$currPos += 8;\n                                        } else {\n                                          s0 = peg$FAILED;\n                                          if (peg$silentFails === 0) { peg$fail(peg$c82); }\n                                        }\n                                        if (s0 === peg$FAILED) {\n                                          if (input.substr(peg$currPos, 9) === peg$c83) {\n                                            s0 = peg$c83;\n                                            peg$currPos += 9;\n                                          } else {\n                                            s0 = peg$FAILED;\n                                            if (peg$silentFails === 0) { peg$fail(peg$c84); }\n                                          }\n                                        }\n                                      }\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parsefilter() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 91) {\n        s1 = peg$c4;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c5); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseexpr();\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 93) {\n            s3 = peg$c6;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c7); }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c85(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parsename() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c86.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c87); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c86.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c87); }\n          }\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c88(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsecss() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c89.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c90); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c89.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c90); }\n          }\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c91(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parseexpr() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c92.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c93); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c92.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c93); }\n          }\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c94(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parsesep() {\n      var s0, s1;\n\n      s0 = [];\n      if (peg$c95.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c96); }\n      }\n      while (s1 !== peg$FAILED) {\n        s0.push(s1);\n        if (peg$c95.test(input.charAt(peg$currPos))) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c96); }\n        }\n      }\n\n      return s0;\n    }\n\n    peg$result = peg$startRuleFunction();\n\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail({ type: \"end\", description: \"end of input\" });\n      }\n\n      throw peg$buildException(\n        null,\n        peg$maxFailExpected,\n        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n        peg$maxFailPos < input.length\n          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n      );\n    }\n  }\n\n  return {\n    SyntaxError: peg$SyntaxError,\n    parse:       peg$parse\n  };\n})();\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-event-selector/index.js\n ** module id = 138\n ** module chunks = 0\n **/","var dl = require('datalib'),\n    template = dl.template,\n    expr = require('vega-expression'),\n    args = ['datum', 'event', 'signals'];\n\nvar compile = expr.compiler(args, {\n  idWhiteList: args,\n  fieldVar:    args[0],\n  globalVar:   function(id) {\n    return 'this.sig[' + dl.str(id) + ']._value';\n  },\n  functions:   function(codegen) {\n    var fn = expr.functions(codegen);\n    fn.eventItem  = 'event.vg.getItem';\n    fn.eventGroup = 'event.vg.getGroup';\n    fn.eventX     = 'event.vg.getX';\n    fn.eventY     = 'event.vg.getY';\n    fn.open       = 'window.open';\n    fn.scale      = scaleGen(codegen, false);\n    fn.iscale     = scaleGen(codegen, true);\n    fn.inrange    = 'this.defs.inrange';\n    fn.indata     = indataGen(codegen);\n    fn.format     = 'this.defs.format';\n    fn.timeFormat = 'this.defs.timeFormat';\n    fn.utcFormat  = 'this.defs.utcFormat';\n    return fn;\n  },\n  functionDefs: function(/*codegen*/) {\n    return {\n      'scale':      scale,\n      'inrange':    inrange,\n      'indata':     indata,\n      'format':     numberFormat,\n      'timeFormat': timeFormat,\n      'utcFormat':  utcFormat\n    };\n  }\n});\n\nfunction scaleGen(codegen, invert) {\n  return function(args) {\n    args = args.map(codegen);\n    var n = args.length;\n    if (n < 2 || n > 3) {\n      throw Error(\"scale takes exactly 2 or 3 arguments.\");\n    }\n    return 'this.defs.scale(this.model, ' + invert + ', ' +\n      args[0] + ',' + args[1] + (n > 2 ? ',' + args[2] : '') + ')';\n  };\n}\n\nfunction scale(model, invert, name, value, scope) {\n  if (!scope || !scope.scale) {\n    scope = (scope && scope.mark) ? scope.mark.group : model.scene().items[0];\n  }\n  // Verify scope is valid\n  if (model.group(scope._id) !== scope) {\n    throw Error('Scope for scale \"'+name+'\" is not a valid group item.');\n  }\n  var s = scope.scale(name);\n  return !s ? value : (invert ? s.invert(value) : s(value));\n}\n\nfunction inrange(val, a, b, exclusive) {\n  var min = a, max = b;\n  if (a > b) { min = b; max = a; }\n  return exclusive ?\n    (min < val && max > val) :\n    (min <= val && max >= val);\n}\n\nfunction indataGen(codegen) {\n  return function(args, globals, fields, dataSources) {\n    var data;\n    if (args.length !== 3) {\n      throw Error(\"indata takes 3 arguments.\");\n    }\n    if (args[0].type !== 'Literal') {\n      throw Error(\"Data source name must be a literal for indata.\");\n    }\n\n    data = args[0].value;\n    dataSources[data] = 1;\n    if (args[2].type === 'Literal') {\n      indataGen.model.requestIndex(data, args[2].value);\n    }\n\n    args = args.map(codegen);\n    return 'this.defs.indata(this.model,' + \n      args[0] + ',' + args[1] + ',' + args[2] + ')';\n  };\n}\n\nfunction indata(model, dataname, val, field) {\n  var data = model.data(dataname),\n      index = data.getIndex(field);\n  return index[val] > 0;\n}\n\nfunction numberFormat(specifier, v) {\n  return template.format(specifier, 'number')(v);\n}\n\nfunction timeFormat(specifier, d) {\n  return template.format(specifier, 'time')(d);\n}\n\nfunction utcFormat(specifier, d) {\n  return template.format(specifier, 'utc')(d);\n}\n\nfunction wrap(model) {\n  return function(str) {\n    indataGen.model = model;\n    var x = compile(str);\n    x.model = model;\n    x.sig = model ? model._signals : {};\n    return x;\n  };\n}\n\nwrap.scale = scale;\nwrap.codegen = compile.codegen;\nmodule.exports = wrap;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/parse/expr.js\n ** module id = 139\n ** module chunks = 0\n **/","var parser = require('./parser'),\n    codegen = require('./codegen');\n\nvar expr = module.exports = {\n  parse: function(input, opt) {\n      return parser.parse('('+input+')', opt);\n    },\n  code: function(opt) {\n      return codegen(opt);\n    },\n  compiler: function(args, opt) {\n      args = args.slice();\n      var generator = codegen(opt),\n          len = args.length,\n          compile = function(str) {\n            var value = generator(expr.parse(str));\n            args[len] = '\"use strict\"; return (' + value.code + ');';\n            var fn = Function.apply(null, args);\n            value.fn = (args.length > 8) ?\n              function() { return fn.apply(value, arguments); } :\n              function(a, b, c, d, e, f, g) {\n                return fn.call(value, a, b, c, d, e, f, g);\n              }; // call often faster than apply, use if args low enough\n            return value;\n          };\n      compile.codegen = generator;\n      return compile;\n    },\n  functions: require('./functions'),\n  constants: require('./constants')\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-expression/src/index.js\n ** module id = 140\n ** module chunks = 0\n **/","/*\n  The following expression parser is based on Esprima (http://esprima.org/).\n  Original header comment and license for Esprima is included here:\n\n  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>\n  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n/* istanbul ignore next */\nmodule.exports = (function() {\n  'use strict';\n\n  var Token,\n      TokenName,\n      Syntax,\n      PropertyKind,\n      Messages,\n      Regex,\n      source,\n      strict,\n      index,\n      lineNumber,\n      lineStart,\n      length,\n      lookahead,\n      state,\n      extra;\n\n  Token = {\n      BooleanLiteral: 1,\n      EOF: 2,\n      Identifier: 3,\n      Keyword: 4,\n      NullLiteral: 5,\n      NumericLiteral: 6,\n      Punctuator: 7,\n      StringLiteral: 8,\n      RegularExpression: 9\n  };\n\n  TokenName = {};\n  TokenName[Token.BooleanLiteral] = 'Boolean';\n  TokenName[Token.EOF] = '<end>';\n  TokenName[Token.Identifier] = 'Identifier';\n  TokenName[Token.Keyword] = 'Keyword';\n  TokenName[Token.NullLiteral] = 'Null';\n  TokenName[Token.NumericLiteral] = 'Numeric';\n  TokenName[Token.Punctuator] = 'Punctuator';\n  TokenName[Token.StringLiteral] = 'String';\n  TokenName[Token.RegularExpression] = 'RegularExpression';\n\n  Syntax = {\n      AssignmentExpression: 'AssignmentExpression',\n      ArrayExpression: 'ArrayExpression',\n      BinaryExpression: 'BinaryExpression',\n      CallExpression: 'CallExpression',\n      ConditionalExpression: 'ConditionalExpression',\n      ExpressionStatement: 'ExpressionStatement',\n      Identifier: 'Identifier',\n      Literal: 'Literal',\n      LogicalExpression: 'LogicalExpression',\n      MemberExpression: 'MemberExpression',\n      ObjectExpression: 'ObjectExpression',\n      Program: 'Program',\n      Property: 'Property',\n      UnaryExpression: 'UnaryExpression'\n  };\n\n  PropertyKind = {\n      Data: 1,\n      Get: 2,\n      Set: 4\n  };\n\n  // Error messages should be identical to V8.\n  Messages = {\n      UnexpectedToken:  'Unexpected token %0',\n      UnexpectedNumber:  'Unexpected number',\n      UnexpectedString:  'Unexpected string',\n      UnexpectedIdentifier:  'Unexpected identifier',\n      UnexpectedReserved:  'Unexpected reserved word',\n      UnexpectedEOS:  'Unexpected end of input',\n      NewlineAfterThrow:  'Illegal newline after throw',\n      InvalidRegExp: 'Invalid regular expression',\n      UnterminatedRegExp:  'Invalid regular expression: missing /',\n      InvalidLHSInAssignment:  'Invalid left-hand side in assignment',\n      InvalidLHSInForIn:  'Invalid left-hand side in for-in',\n      MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n      NoCatchOrFinally:  'Missing catch or finally after try',\n      UnknownLabel: 'Undefined label \\'%0\\'',\n      Redeclaration: '%0 \\'%1\\' has already been declared',\n      IllegalContinue: 'Illegal continue statement',\n      IllegalBreak: 'Illegal break statement',\n      IllegalReturn: 'Illegal return statement',\n      StrictModeWith:  'Strict mode code may not include a with statement',\n      StrictCatchVariable:  'Catch variable may not be eval or arguments in strict mode',\n      StrictVarName:  'Variable name may not be eval or arguments in strict mode',\n      StrictParamName:  'Parameter name eval or arguments is not allowed in strict mode',\n      StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\n      StrictFunctionName:  'Function name may not be eval or arguments in strict mode',\n      StrictOctalLiteral:  'Octal literals are not allowed in strict mode.',\n      StrictDelete:  'Delete of an unqualified identifier in strict mode.',\n      StrictDuplicateProperty:  'Duplicate data property in object literal not allowed in strict mode',\n      AccessorDataProperty:  'Object literal may not have data and accessor property with the same name',\n      AccessorGetSet:  'Object literal may not have multiple get/set accessors with the same name',\n      StrictLHSAssignment:  'Assignment to eval or arguments is not allowed in strict mode',\n      StrictLHSPostfix:  'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n      StrictLHSPrefix:  'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n      StrictReservedWord:  'Use of future reserved word in strict mode'\n  };\n\n  // See also tools/generate-unicode-regex.py.\n  Regex = {\n      NonAsciiIdentifierStart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]'),\n      NonAsciiIdentifierPart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]')\n  };\n\n  // Ensure the condition is true, otherwise throw an error.\n  // This is only to have a better contract semantic, i.e. another safety net\n  // to catch a logic error. The condition shall be fulfilled in normal case.\n  // Do NOT use this to enforce a certain condition on any user input.\n\n  function assert(condition, message) {\n      if (!condition) {\n          throw new Error('ASSERT: ' + message);\n      }\n  }\n\n  function isDecimalDigit(ch) {\n      return (ch >= 0x30 && ch <= 0x39);   // 0..9\n  }\n\n  function isHexDigit(ch) {\n      return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n  }\n\n  function isOctalDigit(ch) {\n      return '01234567'.indexOf(ch) >= 0;\n  }\n\n  // 7.2 White Space\n\n  function isWhiteSpace(ch) {\n      return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||\n          (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);\n  }\n\n  // 7.3 Line Terminators\n\n  function isLineTerminator(ch) {\n      return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);\n  }\n\n  // 7.6 Identifier Names and Identifiers\n\n  function isIdentifierStart(ch) {\n      return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n          (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n          (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n          (ch === 0x5C) ||                      // \\ (backslash)\n          ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));\n  }\n\n  function isIdentifierPart(ch) {\n      return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n          (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n          (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n          (ch >= 0x30 && ch <= 0x39) ||         // 0..9\n          (ch === 0x5C) ||                      // \\ (backslash)\n          ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));\n  }\n\n  // 7.6.1.2 Future Reserved Words\n\n  function isFutureReservedWord(id) {\n      switch (id) {\n      case 'class':\n      case 'enum':\n      case 'export':\n      case 'extends':\n      case 'import':\n      case 'super':\n          return true;\n      default:\n          return false;\n      }\n  }\n\n  function isStrictModeReservedWord(id) {\n      switch (id) {\n      case 'implements':\n      case 'interface':\n      case 'package':\n      case 'private':\n      case 'protected':\n      case 'public':\n      case 'static':\n      case 'yield':\n      case 'let':\n          return true;\n      default:\n          return false;\n      }\n  }\n\n  // 7.6.1.1 Keywords\n\n  function isKeyword(id) {\n      if (strict && isStrictModeReservedWord(id)) {\n          return true;\n      }\n\n      // 'const' is specialized as Keyword in V8.\n      // 'yield' and 'let' are for compatiblity with SpiderMonkey and ES.next.\n      // Some others are from future reserved words.\n\n      switch (id.length) {\n      case 2:\n          return (id === 'if') || (id === 'in') || (id === 'do');\n      case 3:\n          return (id === 'var') || (id === 'for') || (id === 'new') ||\n              (id === 'try') || (id === 'let');\n      case 4:\n          return (id === 'this') || (id === 'else') || (id === 'case') ||\n              (id === 'void') || (id === 'with') || (id === 'enum');\n      case 5:\n          return (id === 'while') || (id === 'break') || (id === 'catch') ||\n              (id === 'throw') || (id === 'const') || (id === 'yield') ||\n              (id === 'class') || (id === 'super');\n      case 6:\n          return (id === 'return') || (id === 'typeof') || (id === 'delete') ||\n              (id === 'switch') || (id === 'export') || (id === 'import');\n      case 7:\n          return (id === 'default') || (id === 'finally') || (id === 'extends');\n      case 8:\n          return (id === 'function') || (id === 'continue') || (id === 'debugger');\n      case 10:\n          return (id === 'instanceof');\n      default:\n          return false;\n      }\n  }\n\n  function skipComment() {\n      var ch, start;\n\n      start = (index === 0);\n      while (index < length) {\n          ch = source.charCodeAt(index);\n\n          if (isWhiteSpace(ch)) {\n              ++index;\n          } else if (isLineTerminator(ch)) {\n              ++index;\n              if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {\n                  ++index;\n              }\n              ++lineNumber;\n              lineStart = index;\n              start = true;\n          } else {\n              break;\n          }\n      }\n  }\n\n  function scanHexEscape(prefix) {\n      var i, len, ch, code = 0;\n\n      len = (prefix === 'u') ? 4 : 2;\n      for (i = 0; i < len; ++i) {\n          if (index < length && isHexDigit(source[index])) {\n              ch = source[index++];\n              code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n          } else {\n              return '';\n          }\n      }\n      return String.fromCharCode(code);\n  }\n\n  function scanUnicodeCodePointEscape() {\n      var ch, code, cu1, cu2;\n\n      ch = source[index];\n      code = 0;\n\n      // At least, one hex digit is required.\n      if (ch === '}') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      while (index < length) {\n          ch = source[index++];\n          if (!isHexDigit(ch)) {\n              break;\n          }\n          code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n      }\n\n      if (code > 0x10FFFF || ch !== '}') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      // UTF-16 Encoding\n      if (code <= 0xFFFF) {\n          return String.fromCharCode(code);\n      }\n      cu1 = ((code - 0x10000) >> 10) + 0xD800;\n      cu2 = ((code - 0x10000) & 1023) + 0xDC00;\n      return String.fromCharCode(cu1, cu2);\n  }\n\n  function getEscapedIdentifier() {\n      var ch, id;\n\n      ch = source.charCodeAt(index++);\n      id = String.fromCharCode(ch);\n\n      // '\\u' (U+005C, U+0075) denotes an escaped character.\n      if (ch === 0x5C) {\n          if (source.charCodeAt(index) !== 0x75) {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n          ++index;\n          ch = scanHexEscape('u');\n          if (!ch || ch === '\\\\' || !isIdentifierStart(ch.charCodeAt(0))) {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n          id = ch;\n      }\n\n      while (index < length) {\n          ch = source.charCodeAt(index);\n          if (!isIdentifierPart(ch)) {\n              break;\n          }\n          ++index;\n          id += String.fromCharCode(ch);\n\n          // '\\u' (U+005C, U+0075) denotes an escaped character.\n          if (ch === 0x5C) {\n              id = id.substr(0, id.length - 1);\n              if (source.charCodeAt(index) !== 0x75) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n              ++index;\n              ch = scanHexEscape('u');\n              if (!ch || ch === '\\\\' || !isIdentifierPart(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n              id += ch;\n          }\n      }\n\n      return id;\n  }\n\n  function getIdentifier() {\n      var start, ch;\n\n      start = index++;\n      while (index < length) {\n          ch = source.charCodeAt(index);\n          if (ch === 0x5C) {\n              // Blackslash (U+005C) marks Unicode escape sequence.\n              index = start;\n              return getEscapedIdentifier();\n          }\n          if (isIdentifierPart(ch)) {\n              ++index;\n          } else {\n              break;\n          }\n      }\n\n      return source.slice(start, index);\n  }\n\n  function scanIdentifier() {\n      var start, id, type;\n\n      start = index;\n\n      // Backslash (U+005C) starts an escaped character.\n      id = (source.charCodeAt(index) === 0x5C) ? getEscapedIdentifier() : getIdentifier();\n\n      // There is no keyword or literal with only one character.\n      // Thus, it must be an identifier.\n      if (id.length === 1) {\n          type = Token.Identifier;\n      } else if (isKeyword(id)) {\n          type = Token.Keyword;\n      } else if (id === 'null') {\n          type = Token.NullLiteral;\n      } else if (id === 'true' || id === 'false') {\n          type = Token.BooleanLiteral;\n      } else {\n          type = Token.Identifier;\n      }\n\n      return {\n          type: type,\n          value: id,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  // 7.7 Punctuators\n\n  function scanPunctuator() {\n      var start = index,\n          code = source.charCodeAt(index),\n          code2,\n          ch1 = source[index],\n          ch2,\n          ch3,\n          ch4;\n\n      switch (code) {\n\n      // Check for most common single-character punctuators.\n      case 0x2E:  // . dot\n      case 0x28:  // ( open bracket\n      case 0x29:  // ) close bracket\n      case 0x3B:  // ; semicolon\n      case 0x2C:  // , comma\n      case 0x7B:  // { open curly brace\n      case 0x7D:  // } close curly brace\n      case 0x5B:  // [\n      case 0x5D:  // ]\n      case 0x3A:  // :\n      case 0x3F:  // ?\n      case 0x7E:  // ~\n          ++index;\n          if (extra.tokenize) {\n              if (code === 0x28) {\n                  extra.openParenToken = extra.tokens.length;\n              } else if (code === 0x7B) {\n                  extra.openCurlyToken = extra.tokens.length;\n              }\n          }\n          return {\n              type: Token.Punctuator,\n              value: String.fromCharCode(code),\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n\n      default:\n          code2 = source.charCodeAt(index + 1);\n\n          // '=' (U+003D) marks an assignment or comparison operator.\n          if (code2 === 0x3D) {\n              switch (code) {\n              case 0x2B:  // +\n              case 0x2D:  // -\n              case 0x2F:  // /\n              case 0x3C:  // <\n              case 0x3E:  // >\n              case 0x5E:  // ^\n              case 0x7C:  // |\n              case 0x25:  // %\n              case 0x26:  // &\n              case 0x2A:  // *\n                  index += 2;\n                  return {\n                      type: Token.Punctuator,\n                      value: String.fromCharCode(code) + String.fromCharCode(code2),\n                      lineNumber: lineNumber,\n                      lineStart: lineStart,\n                      start: start,\n                      end: index\n                  };\n\n              case 0x21: // !\n              case 0x3D: // =\n                  index += 2;\n\n                  // !== and ===\n                  if (source.charCodeAt(index) === 0x3D) {\n                      ++index;\n                  }\n                  return {\n                      type: Token.Punctuator,\n                      value: source.slice(start, index),\n                      lineNumber: lineNumber,\n                      lineStart: lineStart,\n                      start: start,\n                      end: index\n                  };\n              }\n          }\n      }\n\n      // 4-character punctuator: >>>=\n\n      ch4 = source.substr(index, 4);\n\n      if (ch4 === '>>>=') {\n          index += 4;\n          return {\n              type: Token.Punctuator,\n              value: ch4,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // 3-character punctuators: === !== >>> <<= >>=\n\n      ch3 = ch4.substr(0, 3);\n\n      if (ch3 === '>>>' || ch3 === '<<=' || ch3 === '>>=') {\n          index += 3;\n          return {\n              type: Token.Punctuator,\n              value: ch3,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // Other 2-character punctuators: ++ -- << >> && ||\n      ch2 = ch3.substr(0, 2);\n\n      if ((ch1 === ch2[1] && ('+-<>&|'.indexOf(ch1) >= 0)) || ch2 === '=>') {\n          index += 2;\n          return {\n              type: Token.Punctuator,\n              value: ch2,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // 1-character punctuators: < > = ! + - * % & | ^ /\n\n      if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {\n          ++index;\n          return {\n              type: Token.Punctuator,\n              value: ch1,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n  }\n\n  // 7.8.3 Numeric Literals\n\n  function scanHexLiteral(start) {\n      var number = '';\n\n      while (index < length) {\n          if (!isHexDigit(source[index])) {\n              break;\n          }\n          number += source[index++];\n      }\n\n      if (number.length === 0) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseInt('0x' + number, 16),\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function scanOctalLiteral(start) {\n      var number = '0' + source[index++];\n      while (index < length) {\n          if (!isOctalDigit(source[index])) {\n              break;\n          }\n          number += source[index++];\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseInt(number, 8),\n          octal: true,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function scanNumericLiteral() {\n      var number, start, ch;\n\n      ch = source[index];\n      assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),\n          'Numeric literal must start with a decimal digit or a decimal point');\n\n      start = index;\n      number = '';\n      if (ch !== '.') {\n          number = source[index++];\n          ch = source[index];\n\n          // Hex number starts with '0x'.\n          // Octal number starts with '0'.\n          if (number === '0') {\n              if (ch === 'x' || ch === 'X') {\n                  ++index;\n                  return scanHexLiteral(start);\n              }\n              if (isOctalDigit(ch)) {\n                  return scanOctalLiteral(start);\n              }\n\n              // decimal number starts with '0' such as '09' is illegal.\n              if (ch && isDecimalDigit(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n          }\n\n          while (isDecimalDigit(source.charCodeAt(index))) {\n              number += source[index++];\n          }\n          ch = source[index];\n      }\n\n      if (ch === '.') {\n          number += source[index++];\n          while (isDecimalDigit(source.charCodeAt(index))) {\n              number += source[index++];\n          }\n          ch = source[index];\n      }\n\n      if (ch === 'e' || ch === 'E') {\n          number += source[index++];\n\n          ch = source[index];\n          if (ch === '+' || ch === '-') {\n              number += source[index++];\n          }\n          if (isDecimalDigit(source.charCodeAt(index))) {\n              while (isDecimalDigit(source.charCodeAt(index))) {\n                  number += source[index++];\n              }\n          } else {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseFloat(number),\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  // 7.8.4 String Literals\n\n  function scanStringLiteral() {\n      var str = '', quote, start, ch, code, unescaped, restore, octal = false, startLineNumber, startLineStart;\n      startLineNumber = lineNumber;\n      startLineStart = lineStart;\n\n      quote = source[index];\n      assert((quote === '\\'' || quote === '\"'),\n          'String literal must starts with a quote');\n\n      start = index;\n      ++index;\n\n      while (index < length) {\n          ch = source[index++];\n\n          if (ch === quote) {\n              quote = '';\n              break;\n          } else if (ch === '\\\\') {\n              ch = source[index++];\n              if (!ch || !isLineTerminator(ch.charCodeAt(0))) {\n                  switch (ch) {\n                  case 'u':\n                  case 'x':\n                      if (source[index] === '{') {\n                          ++index;\n                          str += scanUnicodeCodePointEscape();\n                      } else {\n                          restore = index;\n                          unescaped = scanHexEscape(ch);\n                          if (unescaped) {\n                              str += unescaped;\n                          } else {\n                              index = restore;\n                              str += ch;\n                          }\n                      }\n                      break;\n                  case 'n':\n                      str += '\\n';\n                      break;\n                  case 'r':\n                      str += '\\r';\n                      break;\n                  case 't':\n                      str += '\\t';\n                      break;\n                  case 'b':\n                      str += '\\b';\n                      break;\n                  case 'f':\n                      str += '\\f';\n                      break;\n                  case 'v':\n                      str += '\\x0B';\n                      break;\n\n                  default:\n                      if (isOctalDigit(ch)) {\n                          code = '01234567'.indexOf(ch);\n\n                          // \\0 is not octal escape sequence\n                          if (code !== 0) {\n                              octal = true;\n                          }\n\n                          if (index < length && isOctalDigit(source[index])) {\n                              octal = true;\n                              code = code * 8 + '01234567'.indexOf(source[index++]);\n\n                              // 3 digits are only allowed when string starts\n                              // with 0, 1, 2, 3\n                              if ('0123'.indexOf(ch) >= 0 &&\n                                      index < length &&\n                                      isOctalDigit(source[index])) {\n                                  code = code * 8 + '01234567'.indexOf(source[index++]);\n                              }\n                          }\n                          str += String.fromCharCode(code);\n                      } else {\n                          str += ch;\n                      }\n                      break;\n                  }\n              } else {\n                  ++lineNumber;\n                  if (ch ===  '\\r' && source[index] === '\\n') {\n                      ++index;\n                  }\n                  lineStart = index;\n              }\n          } else if (isLineTerminator(ch.charCodeAt(0))) {\n              break;\n          } else {\n              str += ch;\n          }\n      }\n\n      if (quote !== '') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.StringLiteral,\n          value: str,\n          octal: octal,\n          startLineNumber: startLineNumber,\n          startLineStart: startLineStart,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function testRegExp(pattern, flags) {\n      var tmp = pattern,\n          value;\n\n      if (flags.indexOf('u') >= 0) {\n          // Replace each astral symbol and every Unicode code point\n          // escape sequence with a single ASCII symbol to avoid throwing on\n          // regular expressions that are only valid in combination with the\n          // `/u` flag.\n          // Note: replacing with the ASCII symbol `x` might cause false\n          // negatives in unlikely scenarios. For example, `[\\u{61}-b]` is a\n          // perfectly valid pattern that is equivalent to `[a-b]`, but it\n          // would be replaced by `[x-b]` which throws an error.\n          tmp = tmp\n              .replace(/\\\\u\\{([0-9a-fA-F]+)\\}/g, function ($0, $1) {\n                  if (parseInt($1, 16) <= 0x10FFFF) {\n                      return 'x';\n                  }\n                  throwError({}, Messages.InvalidRegExp);\n              })\n              .replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, 'x');\n      }\n\n      // First, detect invalid regular expressions.\n      try {\n          value = new RegExp(tmp);\n      } catch (e) {\n          throwError({}, Messages.InvalidRegExp);\n      }\n\n      // Return a regular expression object for this pattern-flag pair, or\n      // `null` in case the current environment doesn't support the flags it\n      // uses.\n      try {\n          return new RegExp(pattern, flags);\n      } catch (exception) {\n          return null;\n      }\n  }\n\n  function scanRegExpBody() {\n      var ch, str, classMarker, terminated, body;\n\n      ch = source[index];\n      assert(ch === '/', 'Regular expression literal must start with a slash');\n      str = source[index++];\n\n      classMarker = false;\n      terminated = false;\n      while (index < length) {\n          ch = source[index++];\n          str += ch;\n          if (ch === '\\\\') {\n              ch = source[index++];\n              // ECMA-262 7.8.5\n              if (isLineTerminator(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnterminatedRegExp);\n              }\n              str += ch;\n          } else if (isLineTerminator(ch.charCodeAt(0))) {\n              throwError({}, Messages.UnterminatedRegExp);\n          } else if (classMarker) {\n              if (ch === ']') {\n                  classMarker = false;\n              }\n          } else {\n              if (ch === '/') {\n                  terminated = true;\n                  break;\n              } else if (ch === '[') {\n                  classMarker = true;\n              }\n          }\n      }\n\n      if (!terminated) {\n          throwError({}, Messages.UnterminatedRegExp);\n      }\n\n      // Exclude leading and trailing slash.\n      body = str.substr(1, str.length - 2);\n      return {\n          value: body,\n          literal: str\n      };\n  }\n\n  function scanRegExpFlags() {\n      var ch, str, flags, restore;\n\n      str = '';\n      flags = '';\n      while (index < length) {\n          ch = source[index];\n          if (!isIdentifierPart(ch.charCodeAt(0))) {\n              break;\n          }\n\n          ++index;\n          if (ch === '\\\\' && index < length) {\n              ch = source[index];\n              if (ch === 'u') {\n                  ++index;\n                  restore = index;\n                  ch = scanHexEscape('u');\n                  if (ch) {\n                      flags += ch;\n                      for (str += '\\\\u'; restore < index; ++restore) {\n                          str += source[restore];\n                      }\n                  } else {\n                      index = restore;\n                      flags += 'u';\n                      str += '\\\\u';\n                  }\n                  throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\n              } else {\n                  str += '\\\\';\n                  throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n          } else {\n              flags += ch;\n              str += ch;\n          }\n      }\n\n      return {\n          value: flags,\n          literal: str\n      };\n  }\n\n  function scanRegExp() {\n      var start, body, flags, value;\n\n      lookahead = null;\n      skipComment();\n      start = index;\n\n      body = scanRegExpBody();\n      flags = scanRegExpFlags();\n      value = testRegExp(body.value, flags.value);\n\n      if (extra.tokenize) {\n          return {\n              type: Token.RegularExpression,\n              value: value,\n              regex: {\n                  pattern: body.value,\n                  flags: flags.value\n              },\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      return {\n          literal: body.literal + flags.literal,\n          value: value,\n          regex: {\n              pattern: body.value,\n              flags: flags.value\n          },\n          start: start,\n          end: index\n      };\n  }\n\n  function collectRegex() {\n      var pos, loc, regex, token;\n\n      skipComment();\n\n      pos = index;\n      loc = {\n          start: {\n              line: lineNumber,\n              column: index - lineStart\n          }\n      };\n\n      regex = scanRegExp();\n\n      loc.end = {\n          line: lineNumber,\n          column: index - lineStart\n      };\n\n      if (!extra.tokenize) {\n          // Pop the previous token, which is likely '/' or '/='\n          if (extra.tokens.length > 0) {\n              token = extra.tokens[extra.tokens.length - 1];\n              if (token.range[0] === pos && token.type === 'Punctuator') {\n                  if (token.value === '/' || token.value === '/=') {\n                      extra.tokens.pop();\n                  }\n              }\n          }\n\n          extra.tokens.push({\n              type: 'RegularExpression',\n              value: regex.literal,\n              regex: regex.regex,\n              range: [pos, index],\n              loc: loc\n          });\n      }\n\n      return regex;\n  }\n\n  function isIdentifierName(token) {\n      return token.type === Token.Identifier ||\n          token.type === Token.Keyword ||\n          token.type === Token.BooleanLiteral ||\n          token.type === Token.NullLiteral;\n  }\n\n  function advanceSlash() {\n      var prevToken,\n          checkToken;\n      // Using the following algorithm:\n      // https://github.com/mozilla/sweet.js/wiki/design\n      prevToken = extra.tokens[extra.tokens.length - 1];\n      if (!prevToken) {\n          // Nothing before that: it cannot be a division.\n          return collectRegex();\n      }\n      if (prevToken.type === 'Punctuator') {\n          if (prevToken.value === ']') {\n              return scanPunctuator();\n          }\n          if (prevToken.value === ')') {\n              checkToken = extra.tokens[extra.openParenToken - 1];\n              if (checkToken &&\n                      checkToken.type === 'Keyword' &&\n                      (checkToken.value === 'if' ||\n                       checkToken.value === 'while' ||\n                       checkToken.value === 'for' ||\n                       checkToken.value === 'with')) {\n                  return collectRegex();\n              }\n              return scanPunctuator();\n          }\n          if (prevToken.value === '}') {\n              // Dividing a function by anything makes little sense,\n              // but we have to check for that.\n              if (extra.tokens[extra.openCurlyToken - 3] &&\n                      extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {\n                  // Anonymous function.\n                  checkToken = extra.tokens[extra.openCurlyToken - 4];\n                  if (!checkToken) {\n                      return scanPunctuator();\n                  }\n              } else if (extra.tokens[extra.openCurlyToken - 4] &&\n                      extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {\n                  // Named function.\n                  checkToken = extra.tokens[extra.openCurlyToken - 5];\n                  if (!checkToken) {\n                      return collectRegex();\n                  }\n              } else {\n                  return scanPunctuator();\n              }\n              return scanPunctuator();\n          }\n          return collectRegex();\n      }\n      if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {\n          return collectRegex();\n      }\n      return scanPunctuator();\n  }\n\n  function advance() {\n      var ch;\n\n      skipComment();\n\n      if (index >= length) {\n          return {\n              type: Token.EOF,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: index,\n              end: index\n          };\n      }\n\n      ch = source.charCodeAt(index);\n\n      if (isIdentifierStart(ch)) {\n          return scanIdentifier();\n      }\n\n      // Very common: ( and ) and ;\n      if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {\n          return scanPunctuator();\n      }\n\n      // String literal starts with single quote (U+0027) or double quote (U+0022).\n      if (ch === 0x27 || ch === 0x22) {\n          return scanStringLiteral();\n      }\n\n\n      // Dot (.) U+002E can also start a floating-point number, hence the need\n      // to check the next character.\n      if (ch === 0x2E) {\n          if (isDecimalDigit(source.charCodeAt(index + 1))) {\n              return scanNumericLiteral();\n          }\n          return scanPunctuator();\n      }\n\n      if (isDecimalDigit(ch)) {\n          return scanNumericLiteral();\n      }\n\n      // Slash (/) U+002F can also start a regex.\n      if (extra.tokenize && ch === 0x2F) {\n          return advanceSlash();\n      }\n\n      return scanPunctuator();\n  }\n\n  function collectToken() {\n      var loc, token, value, entry;\n\n      skipComment();\n      loc = {\n          start: {\n              line: lineNumber,\n              column: index - lineStart\n          }\n      };\n\n      token = advance();\n      loc.end = {\n          line: lineNumber,\n          column: index - lineStart\n      };\n\n      if (token.type !== Token.EOF) {\n          value = source.slice(token.start, token.end);\n          entry = {\n              type: TokenName[token.type],\n              value: value,\n              range: [token.start, token.end],\n              loc: loc\n          };\n          if (token.regex) {\n              entry.regex = {\n                  pattern: token.regex.pattern,\n                  flags: token.regex.flags\n              };\n          }\n          extra.tokens.push(entry);\n      }\n\n      return token;\n  }\n\n  function lex() {\n      var token;\n\n      token = lookahead;\n      index = token.end;\n      lineNumber = token.lineNumber;\n      lineStart = token.lineStart;\n\n      lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n\n      index = token.end;\n      lineNumber = token.lineNumber;\n      lineStart = token.lineStart;\n\n      return token;\n  }\n\n  function peek() {\n      var pos, line, start;\n\n      pos = index;\n      line = lineNumber;\n      start = lineStart;\n      lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n      index = pos;\n      lineNumber = line;\n      lineStart = start;\n  }\n\n  function Position() {\n      this.line = lineNumber;\n      this.column = index - lineStart;\n  }\n\n  function SourceLocation() {\n      this.start = new Position();\n      this.end = null;\n  }\n\n  function WrappingSourceLocation(startToken) {\n      if (startToken.type === Token.StringLiteral) {\n          this.start = {\n              line: startToken.startLineNumber,\n              column: startToken.start - startToken.startLineStart\n          };\n      } else {\n          this.start = {\n              line: startToken.lineNumber,\n              column: startToken.start - startToken.lineStart\n          };\n      }\n      this.end = null;\n  }\n\n  function Node() {\n      // Skip comment.\n      index = lookahead.start;\n      if (lookahead.type === Token.StringLiteral) {\n          lineNumber = lookahead.startLineNumber;\n          lineStart = lookahead.startLineStart;\n      } else {\n          lineNumber = lookahead.lineNumber;\n          lineStart = lookahead.lineStart;\n      }\n      if (extra.range) {\n          this.range = [index, 0];\n      }\n      if (extra.loc) {\n          this.loc = new SourceLocation();\n      }\n  }\n\n  function WrappingNode(startToken) {\n      if (extra.range) {\n          this.range = [startToken.start, 0];\n      }\n      if (extra.loc) {\n          this.loc = new WrappingSourceLocation(startToken);\n      }\n  }\n\n  WrappingNode.prototype = Node.prototype = {\n\n      finish: function () {\n          if (extra.range) {\n              this.range[1] = index;\n          }\n          if (extra.loc) {\n              this.loc.end = new Position();\n              if (extra.source) {\n                  this.loc.source = extra.source;\n              }\n          }\n      },\n\n      finishArrayExpression: function (elements) {\n          this.type = Syntax.ArrayExpression;\n          this.elements = elements;\n          this.finish();\n          return this;\n      },\n\n      finishAssignmentExpression: function (operator, left, right) {\n          this.type = Syntax.AssignmentExpression;\n          this.operator = operator;\n          this.left = left;\n          this.right = right;\n          this.finish();\n          return this;\n      },\n\n      finishBinaryExpression: function (operator, left, right) {\n          this.type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression : Syntax.BinaryExpression;\n          this.operator = operator;\n          this.left = left;\n          this.right = right;\n          this.finish();\n          return this;\n      },\n\n      finishCallExpression: function (callee, args) {\n          this.type = Syntax.CallExpression;\n          this.callee = callee;\n          this.arguments = args;\n          this.finish();\n          return this;\n      },\n\n      finishConditionalExpression: function (test, consequent, alternate) {\n          this.type = Syntax.ConditionalExpression;\n          this.test = test;\n          this.consequent = consequent;\n          this.alternate = alternate;\n          this.finish();\n          return this;\n      },\n\n      finishExpressionStatement: function (expression) {\n          this.type = Syntax.ExpressionStatement;\n          this.expression = expression;\n          this.finish();\n          return this;\n      },\n\n      finishIdentifier: function (name) {\n          this.type = Syntax.Identifier;\n          this.name = name;\n          this.finish();\n          return this;\n      },\n\n      finishLiteral: function (token) {\n          this.type = Syntax.Literal;\n          this.value = token.value;\n          this.raw = source.slice(token.start, token.end);\n          if (token.regex) {\n              if (this.raw == '//') {\n                this.raw = '/(?:)/';\n              }\n              this.regex = token.regex;\n          }\n          this.finish();\n          return this;\n      },\n\n      finishMemberExpression: function (accessor, object, property) {\n          this.type = Syntax.MemberExpression;\n          this.computed = accessor === '[';\n          this.object = object;\n          this.property = property;\n          this.finish();\n          return this;\n      },\n\n      finishObjectExpression: function (properties) {\n          this.type = Syntax.ObjectExpression;\n          this.properties = properties;\n          this.finish();\n          return this;\n      },\n\n      finishProgram: function (body) {\n          this.type = Syntax.Program;\n          this.body = body;\n          this.finish();\n          return this;\n      },\n\n      finishProperty: function (kind, key, value) {\n          this.type = Syntax.Property;\n          this.key = key;\n          this.value = value;\n          this.kind = kind;\n          this.finish();\n          return this;\n      },\n\n      finishUnaryExpression: function (operator, argument) {\n          this.type = Syntax.UnaryExpression;\n          this.operator = operator;\n          this.argument = argument;\n          this.prefix = true;\n          this.finish();\n          return this;\n      }\n  };\n\n  // Return true if there is a line terminator before the next token.\n\n  function peekLineTerminator() {\n      var pos, line, start, found;\n\n      pos = index;\n      line = lineNumber;\n      start = lineStart;\n      skipComment();\n      found = lineNumber !== line;\n      index = pos;\n      lineNumber = line;\n      lineStart = start;\n\n      return found;\n  }\n\n  // Throw an exception\n\n  function throwError(token, messageFormat) {\n      var error,\n          args = Array.prototype.slice.call(arguments, 2),\n          msg = messageFormat.replace(\n              /%(\\d)/g,\n              function (whole, index) {\n                  assert(index < args.length, 'Message reference must be in range');\n                  return args[index];\n              }\n          );\n\n      if (typeof token.lineNumber === 'number') {\n          error = new Error('Line ' + token.lineNumber + ': ' + msg);\n          error.index = token.start;\n          error.lineNumber = token.lineNumber;\n          error.column = token.start - lineStart + 1;\n      } else {\n          error = new Error('Line ' + lineNumber + ': ' + msg);\n          error.index = index;\n          error.lineNumber = lineNumber;\n          error.column = index - lineStart + 1;\n      }\n\n      error.description = msg;\n      throw error;\n  }\n\n  function throwErrorTolerant() {\n      try {\n          throwError.apply(null, arguments);\n      } catch (e) {\n          if (extra.errors) {\n              extra.errors.push(e);\n          } else {\n              throw e;\n          }\n      }\n  }\n\n\n  // Throw an exception because of the token.\n\n  function throwUnexpected(token) {\n      if (token.type === Token.EOF) {\n          throwError(token, Messages.UnexpectedEOS);\n      }\n\n      if (token.type === Token.NumericLiteral) {\n          throwError(token, Messages.UnexpectedNumber);\n      }\n\n      if (token.type === Token.StringLiteral) {\n          throwError(token, Messages.UnexpectedString);\n      }\n\n      if (token.type === Token.Identifier) {\n          throwError(token, Messages.UnexpectedIdentifier);\n      }\n\n      if (token.type === Token.Keyword) {\n          if (isFutureReservedWord(token.value)) {\n              throwError(token, Messages.UnexpectedReserved);\n          } else if (strict && isStrictModeReservedWord(token.value)) {\n              throwErrorTolerant(token, Messages.StrictReservedWord);\n              return;\n          }\n          throwError(token, Messages.UnexpectedToken, token.value);\n      }\n\n      // BooleanLiteral, NullLiteral, or Punctuator.\n      throwError(token, Messages.UnexpectedToken, token.value);\n  }\n\n  // Expect the next token to match the specified punctuator.\n  // If not, an exception will be thrown.\n\n  function expect(value) {\n      var token = lex();\n      if (token.type !== Token.Punctuator || token.value !== value) {\n          throwUnexpected(token);\n      }\n  }\n\n  /**\n   * @name expectTolerant\n   * @description Quietly expect the given token value when in tolerant mode, otherwise delegates\n   * to <code>expect(value)</code>\n   * @param {String} value The value we are expecting the lookahead token to have\n   * @since 2.0\n   */\n  function expectTolerant(value) {\n      if (extra.errors) {\n          var token = lookahead;\n          if (token.type !== Token.Punctuator && token.value !== value) {\n              throwErrorTolerant(token, Messages.UnexpectedToken, token.value);\n          } else {\n              lex();\n          }\n      } else {\n          expect(value);\n      }\n  }\n\n  // Return true if the next token matches the specified punctuator.\n\n  function match(value) {\n      return lookahead.type === Token.Punctuator && lookahead.value === value;\n  }\n\n  // Return true if the next token matches the specified keyword\n\n  function matchKeyword(keyword) {\n      return lookahead.type === Token.Keyword && lookahead.value === keyword;\n  }\n\n  function consumeSemicolon() {\n      var line;\n\n      // Catch the very common case first: immediately a semicolon (U+003B).\n      if (source.charCodeAt(index) === 0x3B || match(';')) {\n          lex();\n          return;\n      }\n\n      line = lineNumber;\n      skipComment();\n      if (lineNumber !== line) {\n          return;\n      }\n\n      if (lookahead.type !== Token.EOF && !match('}')) {\n          throwUnexpected(lookahead);\n      }\n  }\n\n  // 11.1.4 Array Initialiser\n\n  function parseArrayInitialiser() {\n      var elements = [], node = new Node();\n\n      expect('[');\n\n      while (!match(']')) {\n          if (match(',')) {\n              lex();\n              elements.push(null);\n          } else {\n              elements.push(parseAssignmentExpression());\n\n              if (!match(']')) {\n                  expect(',');\n              }\n          }\n      }\n\n      lex();\n\n      return node.finishArrayExpression(elements);\n  }\n\n  // 11.1.5 Object Initialiser\n\n  function parseObjectPropertyKey() {\n      var token, node = new Node();\n\n      token = lex();\n\n      // Note: This function is called only from parseObjectProperty(), where\n      // EOF and Punctuator tokens are already filtered out.\n\n      if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {\n          if (strict && token.octal) {\n              throwErrorTolerant(token, Messages.StrictOctalLiteral);\n          }\n          return node.finishLiteral(token);\n      }\n\n      return node.finishIdentifier(token.value);\n  }\n\n  function parseObjectProperty() {\n      var token, key, id, value, node = new Node();\n\n      token = lookahead;\n\n      if (token.type === Token.Identifier) {\n          id = parseObjectPropertyKey();\n          expect(':');\n          value = parseAssignmentExpression();\n          return node.finishProperty('init', id, value);\n      }\n      if (token.type === Token.EOF || token.type === Token.Punctuator) {\n          throwUnexpected(token);\n      } else {\n          key = parseObjectPropertyKey();\n          expect(':');\n          value = parseAssignmentExpression();\n          return node.finishProperty('init', key, value);\n      }\n  }\n\n  function parseObjectInitialiser() {\n      var properties = [], property, name, key, kind, map = {}, toString = String, node = new Node();\n\n      expect('{');\n\n      while (!match('}')) {\n          property = parseObjectProperty();\n\n          if (property.key.type === Syntax.Identifier) {\n              name = property.key.name;\n          } else {\n              name = toString(property.key.value);\n          }\n          kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;\n\n          key = '$' + name;\n          if (Object.prototype.hasOwnProperty.call(map, key)) {\n              if (map[key] === PropertyKind.Data) {\n                  if (strict && kind === PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.StrictDuplicateProperty);\n                  } else if (kind !== PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.AccessorDataProperty);\n                  }\n              } else {\n                  if (kind === PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.AccessorDataProperty);\n                  } else if (map[key] & kind) {\n                      throwErrorTolerant({}, Messages.AccessorGetSet);\n                  }\n              }\n              map[key] |= kind;\n          } else {\n              map[key] = kind;\n          }\n\n          properties.push(property);\n\n          if (!match('}')) {\n              expectTolerant(',');\n          }\n      }\n\n      expect('}');\n\n      return node.finishObjectExpression(properties);\n  }\n\n  // 11.1.6 The Grouping Operator\n\n  function parseGroupExpression() {\n      var expr;\n\n      expect('(');\n\n      ++state.parenthesisCount;\n\n      expr = parseExpression();\n\n      expect(')');\n\n      return expr;\n  }\n\n\n  // 11.1 Primary Expressions\n\n  var legalKeywords = {\"if\":1, \"this\":1};\n\n  function parsePrimaryExpression() {\n      var type, token, expr, node;\n\n      if (match('(')) {\n          return parseGroupExpression();\n      }\n\n      if (match('[')) {\n          return parseArrayInitialiser();\n      }\n\n      if (match('{')) {\n          return parseObjectInitialiser();\n      }\n\n      type = lookahead.type;\n      node = new Node();\n\n      if (type === Token.Identifier || legalKeywords[lookahead.value]) {\n          expr = node.finishIdentifier(lex().value);\n      } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {\n          if (strict && lookahead.octal) {\n              throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);\n          }\n          expr = node.finishLiteral(lex());\n      } else if (type === Token.Keyword) {\n          throw new Error(\"Disabled.\");\n      } else if (type === Token.BooleanLiteral) {\n          token = lex();\n          token.value = (token.value === 'true');\n          expr = node.finishLiteral(token);\n      } else if (type === Token.NullLiteral) {\n          token = lex();\n          token.value = null;\n          expr = node.finishLiteral(token);\n      } else if (match('/') || match('/=')) {\n          if (typeof extra.tokens !== 'undefined') {\n              expr = node.finishLiteral(collectRegex());\n          } else {\n              expr = node.finishLiteral(scanRegExp());\n          }\n          peek();\n      } else {\n          throwUnexpected(lex());\n      }\n\n      return expr;\n  }\n\n  // 11.2 Left-Hand-Side Expressions\n\n  function parseArguments() {\n      var args = [];\n\n      expect('(');\n\n      if (!match(')')) {\n          while (index < length) {\n              args.push(parseAssignmentExpression());\n              if (match(')')) {\n                  break;\n              }\n              expectTolerant(',');\n          }\n      }\n\n      expect(')');\n\n      return args;\n  }\n\n  function parseNonComputedProperty() {\n      var token, node = new Node();\n\n      token = lex();\n\n      if (!isIdentifierName(token)) {\n          throwUnexpected(token);\n      }\n\n      return node.finishIdentifier(token.value);\n  }\n\n  function parseNonComputedMember() {\n      expect('.');\n\n      return parseNonComputedProperty();\n  }\n\n  function parseComputedMember() {\n      var expr;\n\n      expect('[');\n\n      expr = parseExpression();\n\n      expect(']');\n\n      return expr;\n  }\n\n  function parseLeftHandSideExpressionAllowCall() {\n      var expr, args, property, startToken, previousAllowIn = state.allowIn;\n\n      startToken = lookahead;\n      state.allowIn = true;\n      expr = parsePrimaryExpression();\n\n      for (;;) {\n          if (match('.')) {\n              property = parseNonComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n          } else if (match('(')) {\n              args = parseArguments();\n              expr = new WrappingNode(startToken).finishCallExpression(expr, args);\n          } else if (match('[')) {\n              property = parseComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n          } else {\n              break;\n          }\n      }\n      state.allowIn = previousAllowIn;\n\n      return expr;\n  }\n\n  // 11.3 Postfix Expressions\n\n  function parsePostfixExpression() {\n      var expr = parseLeftHandSideExpressionAllowCall();\n\n      if (lookahead.type === Token.Punctuator) {\n          if ((match('++') || match('--')) && !peekLineTerminator()) {\n              throw new Error(\"Disabled.\");\n          }\n      }\n\n      return expr;\n  }\n\n  // 11.4 Unary Operators\n\n  function parseUnaryExpression() {\n      var token, expr, startToken;\n\n      if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {\n          expr = parsePostfixExpression();\n      } else if (match('++') || match('--')) {\n          throw new Error(\"Disabled.\");\n      } else if (match('+') || match('-') || match('~') || match('!')) {\n          startToken = lookahead;\n          token = lex();\n          expr = parseUnaryExpression();\n          expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n      } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n          throw new Error(\"Disabled.\");\n      } else {\n          expr = parsePostfixExpression();\n      }\n\n      return expr;\n  }\n\n  function binaryPrecedence(token, allowIn) {\n      var prec = 0;\n\n      if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\n          return 0;\n      }\n\n      switch (token.value) {\n      case '||':\n          prec = 1;\n          break;\n\n      case '&&':\n          prec = 2;\n          break;\n\n      case '|':\n          prec = 3;\n          break;\n\n      case '^':\n          prec = 4;\n          break;\n\n      case '&':\n          prec = 5;\n          break;\n\n      case '==':\n      case '!=':\n      case '===':\n      case '!==':\n          prec = 6;\n          break;\n\n      case '<':\n      case '>':\n      case '<=':\n      case '>=':\n      case 'instanceof':\n          prec = 7;\n          break;\n\n      case 'in':\n          prec = allowIn ? 7 : 0;\n          break;\n\n      case '<<':\n      case '>>':\n      case '>>>':\n          prec = 8;\n          break;\n\n      case '+':\n      case '-':\n          prec = 9;\n          break;\n\n      case '*':\n      case '/':\n      case '%':\n          prec = 11;\n          break;\n\n      default:\n          break;\n      }\n\n      return prec;\n  }\n\n  // 11.5 Multiplicative Operators\n  // 11.6 Additive Operators\n  // 11.7 Bitwise Shift Operators\n  // 11.8 Relational Operators\n  // 11.9 Equality Operators\n  // 11.10 Binary Bitwise Operators\n  // 11.11 Binary Logical Operators\n\n  function parseBinaryExpression() {\n      var marker, markers, expr, token, prec, stack, right, operator, left, i;\n\n      marker = lookahead;\n      left = parseUnaryExpression();\n\n      token = lookahead;\n      prec = binaryPrecedence(token, state.allowIn);\n      if (prec === 0) {\n          return left;\n      }\n      token.prec = prec;\n      lex();\n\n      markers = [marker, lookahead];\n      right = parseUnaryExpression();\n\n      stack = [left, token, right];\n\n      while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {\n\n          // Reduce: make a binary expression from the three topmost entries.\n          while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {\n              right = stack.pop();\n              operator = stack.pop().value;\n              left = stack.pop();\n              markers.pop();\n              expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);\n              stack.push(expr);\n          }\n\n          // Shift.\n          token = lex();\n          token.prec = prec;\n          stack.push(token);\n          markers.push(lookahead);\n          expr = parseUnaryExpression();\n          stack.push(expr);\n      }\n\n      // Final reduce to clean-up the stack.\n      i = stack.length - 1;\n      expr = stack[i];\n      markers.pop();\n      while (i > 1) {\n          expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);\n          i -= 2;\n      }\n\n      return expr;\n  }\n\n  // 11.12 Conditional Operator\n\n  function parseConditionalExpression() {\n      var expr, previousAllowIn, consequent, alternate, startToken;\n\n      startToken = lookahead;\n\n      expr = parseBinaryExpression();\n\n      if (match('?')) {\n          lex();\n          previousAllowIn = state.allowIn;\n          state.allowIn = true;\n          consequent = parseAssignmentExpression();\n          state.allowIn = previousAllowIn;\n          expect(':');\n          alternate = parseAssignmentExpression();\n\n          expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);\n      }\n\n      return expr;\n  }\n\n  // 11.13 Assignment Operators\n\n  function parseAssignmentExpression() {\n      var oldParenthesisCount, token, expr, startToken;\n\n      oldParenthesisCount = state.parenthesisCount;\n\n      startToken = lookahead;\n      token = lookahead;\n\n      expr = parseConditionalExpression();\n\n      return expr;\n  }\n\n  // 11.14 Comma Operator\n\n  function parseExpression() {\n      var expr = parseAssignmentExpression();\n\n      if (match(',')) {\n          throw new Error(\"Disabled.\"); // no sequence expressions\n      }\n\n      return expr;\n  }\n\n  // 12.4 Expression Statement\n\n  function parseExpressionStatement(node) {\n      var expr = parseExpression();\n      consumeSemicolon();\n      return node.finishExpressionStatement(expr);\n  }\n\n  // 12 Statements\n\n  function parseStatement() {\n      var type = lookahead.type,\n          expr,\n          node;\n\n      if (type === Token.EOF) {\n          throwUnexpected(lookahead);\n      }\n\n      if (type === Token.Punctuator && lookahead.value === '{') {\n          throw new Error(\"Disabled.\"); // block statement\n      }\n\n      node = new Node();\n\n      if (type === Token.Punctuator) {\n          switch (lookahead.value) {\n          case ';':\n              throw new Error(\"Disabled.\"); // empty statement\n          case '(':\n              return parseExpressionStatement(node);\n          default:\n              break;\n          }\n      } else if (type === Token.Keyword) {\n          throw new Error(\"Disabled.\"); // keyword\n      }\n\n      expr = parseExpression();\n      consumeSemicolon();\n      return node.finishExpressionStatement(expr);\n  }\n\n  // 14 Program\n\n  function parseSourceElement() {\n      if (lookahead.type === Token.Keyword) {\n          switch (lookahead.value) {\n          case 'const':\n          case 'let':\n              throw new Error(\"Disabled.\");\n          case 'function':\n              throw new Error(\"Disabled.\");\n          default:\n              return parseStatement();\n          }\n      }\n\n      if (lookahead.type !== Token.EOF) {\n          return parseStatement();\n      }\n  }\n\n  function parseSourceElements() {\n      var sourceElement, sourceElements = [], token, directive, firstRestricted;\n\n      while (index < length) {\n          token = lookahead;\n          if (token.type !== Token.StringLiteral) {\n              break;\n          }\n\n          sourceElement = parseSourceElement();\n          sourceElements.push(sourceElement);\n          if (sourceElement.expression.type !== Syntax.Literal) {\n              // this is not directive\n              break;\n          }\n          directive = source.slice(token.start + 1, token.end - 1);\n          if (directive === 'use strict') {\n              strict = true;\n              if (firstRestricted) {\n                  throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n              }\n          } else {\n              if (!firstRestricted && token.octal) {\n                  firstRestricted = token;\n              }\n          }\n      }\n\n      while (index < length) {\n          sourceElement = parseSourceElement();\n          if (typeof sourceElement === 'undefined') {\n              break;\n          }\n          sourceElements.push(sourceElement);\n      }\n      return sourceElements;\n  }\n\n  function parseProgram() {\n      var body, node;\n\n      skipComment();\n      peek();\n      node = new Node();\n      strict = true; // assume strict\n\n      body = parseSourceElements();\n      return node.finishProgram(body);\n  }\n\n  function filterTokenLocation() {\n      var i, entry, token, tokens = [];\n\n      for (i = 0; i < extra.tokens.length; ++i) {\n          entry = extra.tokens[i];\n          token = {\n              type: entry.type,\n              value: entry.value\n          };\n          if (entry.regex) {\n              token.regex = {\n                  pattern: entry.regex.pattern,\n                  flags: entry.regex.flags\n              };\n          }\n          if (extra.range) {\n              token.range = entry.range;\n          }\n          if (extra.loc) {\n              token.loc = entry.loc;\n          }\n          tokens.push(token);\n      }\n\n      extra.tokens = tokens;\n  }\n\n  function tokenize(code, options) {\n      var toString,\n          tokens;\n\n      toString = String;\n      if (typeof code !== 'string' && !(code instanceof String)) {\n          code = toString(code);\n      }\n\n      source = code;\n      index = 0;\n      lineNumber = (source.length > 0) ? 1 : 0;\n      lineStart = 0;\n      length = source.length;\n      lookahead = null;\n      state = {\n          allowIn: true,\n          labelSet: {},\n          inFunctionBody: false,\n          inIteration: false,\n          inSwitch: false,\n          lastCommentStart: -1\n      };\n\n      extra = {};\n\n      // Options matching.\n      options = options || {};\n\n      // Of course we collect tokens here.\n      options.tokens = true;\n      extra.tokens = [];\n      extra.tokenize = true;\n      // The following two fields are necessary to compute the Regex tokens.\n      extra.openParenToken = -1;\n      extra.openCurlyToken = -1;\n\n      extra.range = (typeof options.range === 'boolean') && options.range;\n      extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n      if (typeof options.tolerant === 'boolean' && options.tolerant) {\n          extra.errors = [];\n      }\n\n      try {\n          peek();\n          if (lookahead.type === Token.EOF) {\n              return extra.tokens;\n          }\n\n          lex();\n          while (lookahead.type !== Token.EOF) {\n              try {\n                  lex();\n              } catch (lexError) {\n                  if (extra.errors) {\n                      extra.errors.push(lexError);\n                      // We have to break on the first error\n                      // to avoid infinite loops.\n                      break;\n                  } else {\n                      throw lexError;\n                  }\n              }\n          }\n\n          filterTokenLocation();\n          tokens = extra.tokens;\n          if (typeof extra.errors !== 'undefined') {\n              tokens.errors = extra.errors;\n          }\n      } catch (e) {\n          throw e;\n      } finally {\n          extra = {};\n      }\n      return tokens;\n  }\n\n  function parse(code, options) {\n      var program, toString;\n\n      toString = String;\n      if (typeof code !== 'string' && !(code instanceof String)) {\n          code = toString(code);\n      }\n\n      source = code;\n      index = 0;\n      lineNumber = (source.length > 0) ? 1 : 0;\n      lineStart = 0;\n      length = source.length;\n      lookahead = null;\n      state = {\n          allowIn: true,\n          labelSet: {},\n          parenthesisCount: 0,\n          inFunctionBody: false,\n          inIteration: false,\n          inSwitch: false,\n          lastCommentStart: -1\n      };\n\n      extra = {};\n      if (typeof options !== 'undefined') {\n          extra.range = (typeof options.range === 'boolean') && options.range;\n          extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n          if (extra.loc && options.source !== null && options.source !== undefined) {\n              extra.source = toString(options.source);\n          }\n\n          if (typeof options.tokens === 'boolean' && options.tokens) {\n              extra.tokens = [];\n          }\n          if (typeof options.tolerant === 'boolean' && options.tolerant) {\n              extra.errors = [];\n          }\n      }\n\n      try {\n          program = parseProgram();\n          if (typeof extra.tokens !== 'undefined') {\n              filterTokenLocation();\n              program.tokens = extra.tokens;\n          }\n          if (typeof extra.errors !== 'undefined') {\n              program.errors = extra.errors;\n          }\n      } catch (e) {\n          throw e;\n      } finally {\n          extra = {};\n      }\n\n      return program;\n  }\n\n  return {\n    tokenize: tokenize,\n    parse: parse\n  };\n\n})();\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-expression/src/parser.js\n ** module id = 141\n ** module chunks = 0\n **/","function toMap(list) {\n  var map = {}, i, n;\n  for (i=0, n=list.length; i<n; ++i) map[list[i]] = 1;\n  return map;\n}\n\nfunction keys(object) {\n  var list = [], k;\n  for (k in object) list.push(k);\n  return list;\n}\n\nmodule.exports = function(opt) {\n  opt = opt || {};\n  var constants = opt.constants || require('./constants'),\n      functions = (opt.functions || require('./functions'))(codegen),\n      functionDefs = opt.functionDefs ? opt.functionDefs(codegen) : {},\n      idWhiteList = opt.idWhiteList ? toMap(opt.idWhiteList) : null,\n      idBlackList = opt.idBlackList ? toMap(opt.idBlackList) : null,\n      memberDepth = 0,\n      FIELD_VAR = opt.fieldVar || 'datum',\n      GLOBAL_VAR = opt.globalVar || 'signals',\n      globals = {},\n      fields = {},\n      dataSources = {};\n\n  function codegen_wrap(ast) {\n    var retval = {\n      code: codegen(ast),\n      globals: keys(globals),\n      fields: keys(fields),\n      dataSources: keys(dataSources),\n      defs: functionDefs\n    };\n    globals = {};\n    fields = {};\n    dataSources = {};\n    return retval;\n  }\n\n  /* istanbul ignore next */\n  var lookupGlobal = typeof GLOBAL_VAR === 'function' ? GLOBAL_VAR :\n    function (id) {\n      return GLOBAL_VAR + '[\"' + id + '\"]';\n    };\n\n  function codegen(ast) {\n    if (typeof ast === 'string') return ast;\n    var generator = CODEGEN_TYPES[ast.type];\n    if (generator == null) {\n      throw new Error('Unsupported type: ' + ast.type);\n    }\n    return generator(ast);\n  }\n\n  var CODEGEN_TYPES = {\n    'Literal': function(n) {\n        return n.raw;\n      },\n    'Identifier': function(n) {\n        var id = n.name;\n        if (memberDepth > 0) {\n          return id;\n        }\n        if (constants.hasOwnProperty(id)) {\n          return constants[id];\n        }\n        if (idWhiteList) {\n          if (idWhiteList.hasOwnProperty(id)) {\n            return id;\n          } else {\n            globals[id] = 1;\n            return lookupGlobal(id);\n          }\n        }\n        if (idBlackList && idBlackList.hasOwnProperty(id)) {\n          throw new Error('Illegal identifier: ' + id);\n        }\n        return id;\n      },\n    'Program': function(n) {\n        return n.body.map(codegen).join('\\n');\n      },\n    'MemberExpression': function(n) {\n        var d = !n.computed;\n        var o = codegen(n.object);\n        if (d) memberDepth += 1;\n        var p = codegen(n.property);\n        if (o === FIELD_VAR) { fields[p] = 1; } // HACKish...\n        if (d) memberDepth -= 1;\n        return o + (d ? '.'+p : '['+p+']');\n      },\n    'CallExpression': function(n) {\n        if (n.callee.type !== 'Identifier') {\n          throw new Error('Illegal callee type: ' + n.callee.type);\n        }\n        var callee = n.callee.name;\n        var args = n.arguments;\n        var fn = functions.hasOwnProperty(callee) && functions[callee];\n        if (!fn) throw new Error('Unrecognized function: ' + callee);\n        return fn instanceof Function ?\n          fn(args, globals, fields, dataSources) :\n          fn + '(' + args.map(codegen).join(',') + ')';\n      },\n    'ArrayExpression': function(n) {\n        return '[' + n.elements.map(codegen).join(',') + ']';\n      },\n    'BinaryExpression': function(n) {\n        return '(' + codegen(n.left) + n.operator + codegen(n.right) + ')';\n      },\n    'UnaryExpression': function(n) {\n        return '(' + n.operator + codegen(n.argument) + ')';\n      },\n    'ConditionalExpression': function(n) {\n        return '(' + codegen(n.test) +\n          '?' + codegen(n.consequent) +\n          ':' + codegen(n.alternate) +\n          ')';\n      },\n    'LogicalExpression': function(n) {\n        return '(' + codegen(n.left) + n.operator + codegen(n.right) + ')';\n      },\n    'ObjectExpression': function(n) {\n        return '{' + n.properties.map(codegen).join(',') + '}';\n      },\n    'Property': function(n) {\n        memberDepth += 1;\n        var k = codegen(n.key);\n        memberDepth -= 1;\n        return k + ':' + codegen(n.value);\n      },\n    'ExpressionStatement': function(n) {\n        return codegen(n.expression);\n      }\n  };\n\n  codegen_wrap.functions = functions;\n  codegen_wrap.functionDefs = functionDefs;\n  codegen_wrap.constants = constants;\n  return codegen_wrap;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-expression/src/codegen.js\n ** module id = 142\n ** module chunks = 0\n **/","module.exports = {\n  'NaN':     'NaN',\n  'E':       'Math.E',\n  'LN2':     'Math.LN2',\n  'LN10':    'Math.LN10',\n  'LOG2E':   'Math.LOG2E',\n  'LOG10E':  'Math.LOG10E',\n  'PI':      'Math.PI',\n  'SQRT1_2': 'Math.SQRT1_2',\n  'SQRT2':   'Math.SQRT2'\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-expression/src/constants.js\n ** module id = 143\n ** module chunks = 0\n **/","module.exports = function(codegen) {\n\n  function fncall(name, args, cast, type) {\n    var obj = codegen(args[0]);\n    if (cast) {\n      obj = cast + '(' + obj + ')';\n      if (cast.lastIndexOf('new ', 0) === 0) obj = '(' + obj + ')';\n    }\n    return obj + '.' + name + (type < 0 ? '' : type === 0 ?\n      '()' :\n      '(' + args.slice(1).map(codegen).join(',') + ')');\n  }\n\n  function fn(name, cast, type) {\n    return function(args) {\n      return fncall(name, args, cast, type);\n    };\n  }\n\n  var DATE = 'new Date',\n      STRING = 'String',\n      REGEXP = 'RegExp';\n\n  return {\n    // MATH functions\n    'isNaN':    'isNaN',\n    'isFinite': 'isFinite',\n    'abs':      'Math.abs',\n    'acos':     'Math.acos',\n    'asin':     'Math.asin',\n    'atan':     'Math.atan',\n    'atan2':    'Math.atan2',\n    'ceil':     'Math.ceil',\n    'cos':      'Math.cos',\n    'exp':      'Math.exp',\n    'floor':    'Math.floor',\n    'log':      'Math.log',\n    'max':      'Math.max',\n    'min':      'Math.min',\n    'pow':      'Math.pow',\n    'random':   'Math.random',\n    'round':    'Math.round',\n    'sin':      'Math.sin',\n    'sqrt':     'Math.sqrt',\n    'tan':      'Math.tan',\n\n    'clamp': function(args) {\n      if (args.length < 3)\n        throw new Error('Missing arguments to clamp function.');\n      if (args.length > 3)\n        throw new Error('Too many arguments to clamp function.');\n      var a = args.map(codegen);\n      return 'Math.max('+a[1]+', Math.min('+a[2]+','+a[0]+'))';\n    },\n\n    // DATE functions\n    'now':             'Date.now',\n    'utc':             'Date.UTC',\n    'datetime':        DATE,\n    'date':            fn('getDate', DATE, 0),\n    'day':             fn('getDay', DATE, 0),\n    'year':            fn('getFullYear', DATE, 0),\n    'month':           fn('getMonth', DATE, 0),\n    'hours':           fn('getHours', DATE, 0),\n    'minutes':         fn('getMinutes', DATE, 0),\n    'seconds':         fn('getSeconds', DATE, 0),\n    'milliseconds':    fn('getMilliseconds', DATE, 0),\n    'time':            fn('getTime', DATE, 0),\n    'timezoneoffset':  fn('getTimezoneOffset', DATE, 0),\n    'utcdate':         fn('getUTCDate', DATE, 0),\n    'utcday':          fn('getUTCDay', DATE, 0),\n    'utcyear':         fn('getUTCFullYear', DATE, 0),\n    'utcmonth':        fn('getUTCMonth', DATE, 0),\n    'utchours':        fn('getUTCHours', DATE, 0),\n    'utcminutes':      fn('getUTCMinutes', DATE, 0),\n    'utcseconds':      fn('getUTCSeconds', DATE, 0),\n    'utcmilliseconds': fn('getUTCMilliseconds', DATE, 0),\n\n    // shared sequence functions\n    'length':      fn('length', null, -1),\n    'indexof':     fn('indexOf', null),\n    'lastindexof': fn('lastIndexOf', null),\n\n    // STRING functions\n    'parseFloat':  'parseFloat',\n    'parseInt':    'parseInt',\n    'upper':       fn('toUpperCase', STRING, 0),\n    'lower':       fn('toLowerCase', STRING, 0),\n    'slice':       fn('slice', STRING),\n    'substring':   fn('substring', STRING),\n    'replace':     fn('replace', STRING),\n\n    // REGEXP functions\n    'regexp':  REGEXP,\n    'test':    fn('test', REGEXP),\n\n    // Control Flow functions\n    'if': function(args) {\n        if (args.length < 3)\n          throw new Error('Missing arguments to if function.');\n        if (args.length > 3)\n          throw new Error('Too many arguments to if function.');\n        var a = args.map(codegen);\n        return a[0]+'?'+a[1]+':'+a[2];\n      }\n  };\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-expression/src/functions.js\n ** module id = 144\n ** module chunks = 0\n **/","var lgnd = require('../scene/legend');\n\nfunction parseLegends(model, spec, legends, group) {\n  (spec || []).forEach(function(def, index) {\n    legends[index] = legends[index] || lgnd(model);\n    parseLegend(def, index, legends[index], group);\n  });\n}\n\nfunction parseLegend(def, index, legend, group) {\n  // legend scales\n  legend.size  (def.size   ? group.scale(def.size)   : null);\n  legend.shape (def.shape  ? group.scale(def.shape)  : null);\n  legend.fill  (def.fill   ? group.scale(def.fill)   : null);\n  legend.stroke(def.stroke ? group.scale(def.stroke) : null);\n\n  // legend orientation\n  if (def.orient) legend.orient(def.orient);\n\n  // legend offset\n  if (def.offset != null) legend.offset(def.offset);\n\n  // legend title\n  legend.title(def.title || null);\n\n  // legend values\n  legend.values(def.values || null);\n\n  // legend label formatting\n  legend.format(def.format !== undefined ? def.format : null);\n  legend.formatType(def.formatType || null);\n\n  // style properties\n  var p = def.properties;\n  legend.titleProperties(p && p.title || {});\n  legend.labelProperties(p && p.labels || {});\n  legend.legendProperties(p && p.legend || {});\n  legend.symbolProperties(p && p.symbols || {});\n  legend.gradientProperties(p && p.gradient || {});\n}\n\nmodule.exports = parseLegends;\n\nparseLegends.schema = {\n  \"defs\": {\n    \"legend\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"size\": {\"type\": \"string\"},\n        \"shape\": {\"type\": \"string\"},\n        \"fill\": {\"type\": \"string\"},\n        \"stroke\": {\"type\": \"string\"},\n        \"orient\": {\"enum\": [\"left\", \"right\"], \"default\": \"right\"},\n        \"offset\": {\"type\": \"number\"},\n        \"title\": {\"type\": \"string\"},\n        \"values\": {\"type\": \"array\"},\n        \"format\": {\"type\": \"string\"},\n        \"formatType\": {\"enum\": [\"time\", \"utc\", \"string\", \"number\"]},\n        \"properties\": {\n          \"type\": \"object\",\n          \"properties\": {\n            \"title\": {\"$ref\": \"#/defs/propset\"},\n            \"labels\": {\"$ref\": \"#/defs/propset\"},\n            \"legend\": {\"$ref\": \"#/defs/propset\"},\n            \"symbols\": {\"$ref\": \"#/defs/propset\"},\n            \"gradient\": {\"$ref\": \"#/defs/propset\"}\n          },\n          \"additionalProperties\": false\n        }\n      },\n      \"additionalProperties\": false,\n      \"anyOf\": [\n        {\"required\": [\"size\"]},\n        {\"required\": [\"shape\"]},\n        {\"required\": [\"fill\"]},\n        {\"required\": [\"stroke\"]}\n      ]\n    }\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/parse/legends.js\n ** module id = 145\n ** module chunks = 0\n **/","var d3 = require('d3'),\n    dl = require('datalib'),\n    Gradient = require('vega-scenegraph').Gradient,\n    parseProperties = require('../parse/properties'),\n    parseMark = require('../parse/mark'),\n    util = require('../util');\n\nfunction lgnd(model) {\n  var size  = null,\n      shape = null,\n      fill  = null,\n      stroke  = null,\n      spacing = null,\n      values  = null,\n      formatString = null,\n      formatType   = null,\n      title  = null,\n      config = model.config().legend,\n      orient = config.orient,\n      offset = config.offset,\n      padding = config.padding,\n      tickArguments = [5],\n      legendStyle = {},\n      symbolStyle = {},\n      gradientStyle = {},\n      titleStyle = {},\n      labelStyle = {},\n      m = { // Legend marks as references for updates\n        titles:  {},\n        symbols: {},\n        labels:  {},\n        gradient: {}\n      };\n\n  var legend = {},\n      legendDef = {};\n\n  function reset() { legendDef.type = null; }\n  function ingest(d, i) { return {data: d, index: i}; }\n\n  legend.def = function() {\n    var scale = size || shape || fill || stroke;\n\n    if (!legendDef.type) {\n      legendDef = (scale===fill || scale===stroke) && !discrete(scale.type) ?\n        quantDef(scale) : ordinalDef(scale);\n    }\n    legendDef.orient = orient;\n    legendDef.offset = offset;\n    legendDef.padding = padding;\n    legendDef.margin = config.margin;\n    return legendDef;\n  };\n\n  function discrete(type) {\n    return type==='ordinal' || type==='quantize' ||\n           type==='quantile' || type==='threshold';\n  }\n\n  function ordinalDef(scale) {\n    var def = o_legend_def(size, shape, fill, stroke);\n\n    // generate data\n    var data = (values == null ?\n      (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) :\n      values).map(ingest);\n\n    var fmt = util.getTickFormat(scale, data.length, formatType, formatString);\n\n    // determine spacing between legend entries\n    var fs, range, offset, pad=5, domain = d3.range(data.length);\n    if (size) {\n      range = data.map(function(x) { return Math.sqrt(size(x.data)); });\n      offset = d3.max(range);\n      range = range.reduce(function(a,b,i,z) {\n          if (i > 0) a[i] = a[i-1] + z[i-1]/2 + pad;\n          return (a[i] += b/2, a); }, [0]).map(Math.round);\n    } else {\n      offset = Math.round(Math.sqrt(config.symbolSize));\n      range = spacing ||\n        (fs = labelStyle.fontSize) && (fs.value + pad) ||\n        (config.labelFontSize + pad);\n      range = domain.map(function(d,i) {\n        return Math.round(offset/2 + i*range);\n      });\n    }\n\n    // account for padding and title size\n    var sz = padding, ts;\n    if (title) {\n      ts = titleStyle.fontSize;\n      sz += 5 + ((ts && ts.value) || config.titleFontSize);\n    }\n    for (var i=0, n=range.length; i<n; ++i) range[i] += sz;\n\n    // build scale for label layout\n    def.scales = def.scales || [{}];\n    dl.extend(def.scales[0], {\n      name: 'legend',\n      type: 'ordinal',\n      points: true,\n      domain: domain,\n      range: range\n    });\n\n    // update legend def\n    var tdata = (title ? [title] : []).map(ingest);\n    data.forEach(function(d) {\n      d.label = fmt(d.data);\n      d.offset = offset;\n    });\n    def.marks[0].from = function() { return tdata; };\n    def.marks[1].from = function() { return data; };\n    def.marks[2].from = def.marks[1].from;\n\n    return def;\n  }\n\n  function o_legend_def(size, shape, fill, stroke) {\n    // setup legend marks\n    var titles  = dl.extend(m.titles, legendTitle(config)),\n        symbols = dl.extend(m.symbols, legendSymbols(config)),\n        labels  = dl.extend(m.labels, vLegendLabels(config));\n\n    // extend legend marks\n    legendSymbolExtend(symbols, size, shape, fill, stroke);\n\n    // add / override custom style properties\n    dl.extend(titles.properties.update,  titleStyle);\n    dl.extend(symbols.properties.update, symbolStyle);\n    dl.extend(labels.properties.update,  labelStyle);\n\n    // padding from legend border\n    titles.properties.enter.x.value += padding;\n    titles.properties.enter.y.value += padding;\n    labels.properties.enter.x.offset += padding + 1;\n    symbols.properties.enter.x.offset = padding + 1;\n    labels.properties.update.x.offset += padding + 1;\n    symbols.properties.update.x.offset = padding + 1;\n\n    dl.extend(legendDef, {\n      type: 'group',\n      interactive: false,\n      properties: {\n        enter: parseProperties(model, 'group', legendStyle),\n        legendPosition: {\n          encode: legendPosition,\n          signals: [], scales:[], data: [], fields: []\n        }\n      }\n    });\n\n    legendDef.marks = [titles, symbols, labels].map(function(m) { return parseMark(model, m); });\n    return legendDef;\n  }\n\n  function quantDef(scale) {\n    var def = q_legend_def(scale),\n        dom = scale.domain(),\n        data  = (values == null ? dom : values).map(ingest),\n        width = (gradientStyle.width && gradientStyle.width.value) || config.gradientWidth,\n        fmt = util.getTickFormat(scale, data.length, formatType, formatString);\n\n    // build scale for label layout\n    def.scales = def.scales || [{}];\n    var layoutSpec = dl.extend(def.scales[0], {\n      name: 'legend',\n      type: scale.type,\n      round: true,\n      zero: false,\n      domain: [dom[0], dom[dom.length-1]],\n      range: [padding, width+padding]\n    });\n    if (scale.type==='pow') layoutSpec.exponent = scale.exponent();\n\n    // update legend def\n    var tdata = (title ? [title] : []).map(ingest);\n    data.forEach(function(d,i) {\n      d.label = fmt(d.data);\n      d.align = i==(data.length-1) ? 'right' : i===0 ? 'left' : 'center';\n    });\n\n    def.marks[0].from = function() { return tdata; };\n    def.marks[1].from = function() { return [1]; };\n    def.marks[2].from = function() { return data; };\n    return def;\n  }\n\n  function q_legend_def(scale) {\n    // setup legend marks\n    var titles = dl.extend(m.titles, legendTitle(config)),\n        gradient = dl.extend(m.gradient, legendGradient(config)),\n        labels = dl.extend(m.labels, hLegendLabels(config)),\n        grad = new Gradient();\n\n    // setup color gradient\n    var dom = scale.domain(),\n        min = dom[0],\n        max = dom[dom.length-1],\n        f = scale.copy().domain([min, max]).range([0,1]);\n\n    var stops = (scale.type !== 'linear' && scale.ticks) ?\n      scale.ticks.call(scale, 15) : dom;\n    if (min !== stops[0]) stops.unshift(min);\n    if (max !== stops[stops.length-1]) stops.push(max);\n\n    for (var i=0, n=stops.length; i<n; ++i) {\n      grad.stop(f(stops[i]), scale(stops[i]));\n    }\n    gradient.properties.enter.fill = {value: grad};\n\n    // add / override custom style properties\n    dl.extend(titles.properties.update, titleStyle);\n    dl.extend(gradient.properties.update, gradientStyle);\n    dl.extend(labels.properties.update, labelStyle);\n\n    // account for gradient size\n    var gp = gradient.properties, gh = gradientStyle.height,\n        hh = (gh && gh.value) || gp.enter.height.value;\n    labels.properties.enter.y.value = hh;\n    labels.properties.update.y.value = hh;\n\n    // account for title size as needed\n    if (title) {\n      var tp = titles.properties, fs = titleStyle.fontSize,\n          sz = 4 + ((fs && fs.value) || tp.enter.fontSize.value);\n      gradient.properties.enter.y.value += sz;\n      labels.properties.enter.y.value += sz;\n      gradient.properties.update.y.value += sz;\n      labels.properties.update.y.value += sz;\n    }\n\n    // padding from legend border\n    titles.properties.enter.x.value += padding;\n    titles.properties.enter.y.value += padding;\n    gradient.properties.enter.x.value += padding;\n    gradient.properties.enter.y.value += padding;\n    labels.properties.enter.y.value += padding;\n    gradient.properties.update.x.value += padding;\n    gradient.properties.update.y.value += padding;\n    labels.properties.update.y.value += padding;\n\n    dl.extend(legendDef, {\n      type: 'group',\n      interactive: false,\n      properties: {\n        enter: parseProperties(model, 'group', legendStyle),\n        legendPosition: {\n          encode: legendPosition,\n          signals: [], scales: [], data: [], fields: []\n        }\n      }\n    });\n\n    legendDef.marks = [titles, gradient, labels].map(function(m) { return parseMark(model, m); });\n    return legendDef;\n  }\n\n  legend.size = function(x) {\n    if (!arguments.length) return size;\n    if (size !== x) { size = x; reset(); }\n    return legend;\n  };\n\n  legend.shape = function(x) {\n    if (!arguments.length) return shape;\n    if (shape !== x) { shape = x; reset(); }\n    return legend;\n  };\n\n  legend.fill = function(x) {\n    if (!arguments.length) return fill;\n    if (fill !== x) { fill = x; reset(); }\n    return legend;\n  };\n\n  legend.stroke = function(x) {\n    if (!arguments.length) return stroke;\n    if (stroke !== x) { stroke = x; reset(); }\n    return legend;\n  };\n\n  legend.title = function(x) {\n    if (!arguments.length) return title;\n    if (title !== x) { title = x; reset(); }\n    return legend;\n  };\n\n  legend.format = function(x) {\n    if (!arguments.length) return formatString;\n    if (formatString !== x) {\n      formatString = x;\n      reset();\n    }\n    return legend;\n  };\n\n  legend.formatType = function(x) {\n    if (!arguments.length) return formatType;\n    if (formatType !== x) {\n      formatType = x;\n      reset();\n    }\n    return legend;\n  };\n\n  legend.spacing = function(x) {\n    if (!arguments.length) return spacing;\n    if (spacing !== +x) { spacing = +x; reset(); }\n    return legend;\n  };\n\n  legend.orient = function(x) {\n    if (!arguments.length) return orient;\n    orient = x in LEGEND_ORIENT ? x + '' : config.orient;\n    return legend;\n  };\n\n  legend.offset = function(x) {\n    if (!arguments.length) return offset;\n    offset = +x;\n    return legend;\n  };\n\n  legend.values = function(x) {\n    if (!arguments.length) return values;\n    values = x;\n    return legend;\n  };\n\n  legend.legendProperties = function(x) {\n    if (!arguments.length) return legendStyle;\n    legendStyle = x;\n    return legend;\n  };\n\n  legend.symbolProperties = function(x) {\n    if (!arguments.length) return symbolStyle;\n    symbolStyle = x;\n    return legend;\n  };\n\n  legend.gradientProperties = function(x) {\n    if (!arguments.length) return gradientStyle;\n    gradientStyle = x;\n    return legend;\n  };\n\n  legend.labelProperties = function(x) {\n    if (!arguments.length) return labelStyle;\n    labelStyle = x;\n    return legend;\n  };\n\n  legend.titleProperties = function(x) {\n    if (!arguments.length) return titleStyle;\n    titleStyle = x;\n    return legend;\n  };\n\n  legend.reset = function() {\n    reset();\n    return legend;\n  };\n\n  return legend;\n}\n\nvar LEGEND_ORIENT = {left: 'x1', right: 'x2'};\n\nfunction legendPosition(item, group, trans, db, signals, predicates) {\n  var o = trans ? {} : item, i,\n      def = item.mark.def,\n      offset = def.offset,\n      orient = def.orient,\n      pad = def.padding * 2,\n      ao  = orient === 'left' ? 0 : group.width,\n      lw  = ~~item.bounds.width() + (item.width ? 0 : pad),\n      lh  = ~~item.bounds.height() + (item.height ? 0 : pad),\n      pos = group._legendPositions ||\n        (group._legendPositions = {right: 0.5, left: 0.5});\n\n  o.x = 0.5;\n  o.width = lw;\n  o.y = pos[orient];\n  pos[orient] += (o.height = lh) + def.margin;\n\n  // Calculate axis offset. \n  var axes  = group.axes, \n      items = group.axisItems,\n      bound = LEGEND_ORIENT[orient];\n  for (i=0; i<axes.length; ++i) {\n    if (axes[i].orient() === orient) {\n      ao = Math.max(ao, Math.abs(items[i].bounds[bound]));\n    }\n  }\n\n  if (orient === 'left') {\n    o.x -= ao + offset + lw;\n  } else {\n    o.x += ao + offset;\n  }\n\n  if (trans) trans.interpolate(item, o);\n  var enc = item.mark.def.properties.enter.encode;\n  enc.call(enc, item, group, trans, db, signals, predicates);\n  return true;\n}\n\nfunction legendSymbolExtend(mark, size, shape, fill, stroke) {\n  var e = mark.properties.enter,\n      u = mark.properties.update;\n  if (size)   e.size   = u.size   = {scale: size.scaleName,   field: 'data'};\n  if (shape)  e.shape  = u.shape  = {scale: shape.scaleName,  field: 'data'};\n  if (fill)   e.fill   = u.fill   = {scale: fill.scaleName,   field: 'data'};\n  if (stroke) e.stroke = u.stroke = {scale: stroke.scaleName, field: 'data'};\n}\n\nfunction legendTitle(config) {\n  return {\n    type: 'text',\n    interactive: false,\n    key: 'data',\n    properties: {\n      enter: {\n        x: {value: 0},\n        y: {value: 0},\n        fill: {value: config.titleColor},\n        font: {value: config.titleFont},\n        fontSize: {value: config.titleFontSize},\n        fontWeight: {value: config.titleFontWeight},\n        baseline: {value: 'top'},\n        text: {field: 'data'},\n        opacity: {value: 1e-6}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: { opacity: {value: 1} }\n    }\n  };\n}\n\nfunction legendSymbols(config) {\n  return {\n    type: 'symbol',\n    interactive: false,\n    key: 'data',\n    properties: {\n      enter: {\n        x: {field: 'offset', mult: 0.5},\n        y: {scale: 'legend', field: 'index'},\n        shape: {value: config.symbolShape},\n        size: {value: config.symbolSize},\n        stroke: {value: config.symbolColor},\n        strokeWidth: {value: config.symbolStrokeWidth},\n        opacity: {value: 1e-6}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: {\n        x: {field: 'offset', mult: 0.5},\n        y: {scale: 'legend', field: 'index'},\n        opacity: {value: 1}\n      }\n    }\n  };\n}\n\nfunction vLegendLabels(config) {\n  return {\n    type: 'text',\n    interactive: false,\n    key: 'data',\n    properties: {\n      enter: {\n        x: {field: 'offset', offset: 5},\n        y: {scale: 'legend', field: 'index'},\n        fill: {value: config.labelColor},\n        font: {value: config.labelFont},\n        fontSize: {value: config.labelFontSize},\n        align: {value: config.labelAlign},\n        baseline: {value: config.labelBaseline},\n        text: {field: 'label'},\n        opacity: {value: 1e-6}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: {\n        opacity: {value: 1},\n        x: {field: 'offset', offset: 5},\n        y: {scale: 'legend', field: 'index'},\n      }\n    }\n  };\n}\n\nfunction legendGradient(config) {\n  return {\n    type: 'rect',\n    interactive: false,\n    properties: {\n      enter: {\n        x: {value: 0},\n        y: {value: 0},\n        width: {value: config.gradientWidth},\n        height: {value: config.gradientHeight},\n        stroke: {value: config.gradientStrokeColor},\n        strokeWidth: {value: config.gradientStrokeWidth},\n        opacity: {value: 1e-6}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: {\n        x: {value: 0},\n        y: {value: 0},\n        opacity: {value: 1}\n      }\n    }\n  };\n}\n\nfunction hLegendLabels(config) {\n  return {\n    type: 'text',\n    interactive: false,\n    key: 'data',\n    properties: {\n      enter: {\n        x: {scale: 'legend', field: 'data'},\n        y: {value: 20},\n        dy: {value: 2},\n        fill: {value: config.labelColor},\n        font: {value: config.labelFont},\n        fontSize: {value: config.labelFontSize},\n        align: {field: 'align'},\n        baseline: {value: 'top'},\n        text: {field: 'label'},\n        opacity: {value: 1e-6}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: {\n        x: {scale: 'legend', field: 'data'},\n        y: {value: 20},\n        opacity: {value: 1}\n      }\n    }\n  };\n}\n\nmodule.exports = lgnd;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/scene/legend.js\n ** module id = 146\n ** module chunks = 0\n **/","var parseMark = require('./mark'),\n    parseProperties = require('./properties');\n\nfunction parseRootMark(model, spec, width, height) {\n  return {\n    type:       'group',\n    width:      width,\n    height:     height,\n    properties: defaults(spec.scene || {}, model),\n    scales:     spec.scales  || [],\n    axes:       spec.axes    || [],\n    legends:    spec.legends || [],\n    marks:      (spec.marks || []).map(function(m) { return parseMark(model, m); })\n  };\n}\n\nvar PROPERTIES = [\n  'fill', 'fillOpacity', 'stroke', 'strokeOpacity',\n  'strokeWidth', 'strokeDash', 'strokeDashOffset'\n];\n\nfunction defaults(spec, model) {\n  var config = model.config().scene,\n      props = {}, i, n, m, p, s;\n\n  for (i=0, n=m=PROPERTIES.length; i<n; ++i) {\n    p = PROPERTIES[i];\n    if ((s=spec[p]) !== undefined) {\n      props[p] = s.signal ? s : {value: s};\n    } else if (config[p]) {\n      props[p] = {value: config[p]};\n    } else {\n      --m;\n    }\n  }\n\n  return m ? {update: parseProperties(model, 'group', props)} : {};\n}\n\nmodule.exports = parseRootMark;\n\nparseRootMark.schema = {\n  \"defs\": {\n    \"container\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"scene\": {\n          \"type\": \"object\",\n          \"properties\": {\n            \"fill\": {\n              \"oneOf\": [{\"type\": \"string\"}, {\"$ref\": \"#/refs/signal\"}]\n            },\n            \"fillOpacity\": {\n              \"oneOf\": [{\"type\": \"number\"}, {\"$ref\": \"#/refs/signal\"}]\n            },\n            \"stroke\": {\n              \"oneOf\": [{\"type\": \"string\"}, {\"$ref\": \"#/refs/signal\"}]\n            },\n            \"strokeOpacity\": {\n              \"oneOf\": [{\"type\": \"number\"}, {\"$ref\": \"#/refs/signal\"}]\n            },\n            \"strokeWidth\": {\n              \"oneOf\": [{\"type\": \"number\"}, {\"$ref\": \"#/refs/signal\"}]\n            },\n            \"strokeDash\": {\n              \"oneOf\": [\n                {\"type\": \"array\", \"items\": {\"type\": \"number\"}}, \n                {\"$ref\": \"#/refs/signal\"}\n              ]\n            },\n            \"strokeDashOffset\": {\n              \"oneOf\": [{\"type\": \"number\"}, {\"$ref\": \"#/refs/signal\"}]\n            },\n          }\n        },\n        \"scales\": {\n          \"type\": \"array\",\n          \"items\": {\"$ref\": \"#/defs/scale\"}\n        },\n        \"axes\": {\n          \"type\": \"array\",\n          \"items\": {\"$ref\": \"#/defs/axis\"}\n        },\n        \"legends\": {\n          \"type\": \"array\",\n          \"items\": {\"$ref\": \"#/defs/legend\"}\n        },\n        \"marks\": {\n          \"type\": \"array\",\n          \"items\": {\"oneOf\":[{\"$ref\": \"#/defs/groupMark\"}, {\"$ref\": \"#/defs/visualMark\"}]}\n        }\n      }\n    },\n\n\n    \"groupMark\": {\n      \"allOf\": [\n        {\n          \"properties\": { \"type\": {\"enum\": [\"group\"]} },\n          \"required\": [\"type\"]\n        },\n        {\"$ref\": \"#/defs/mark\"},\n        {\"$ref\": \"#/defs/container\"}\n      ]\n    },\n\n    \"visualMark\": {\n      \"allOf\": [\n        {\n          \"not\": { \"properties\": { \"type\": {\"enum\": [\"group\"]} } },\n        },\n        {\"$ref\": \"#/defs/mark\"}\n      ]\n    }\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/parse/marks.js\n ** module id = 147\n ** module chunks = 0\n **/","var dl = require('datalib');\n\nfunction parsePadding(pad) {\n  return pad == null ? 'auto' :\n    dl.isObject(pad) ? pad :\n    dl.isNumber(pad) ? {top:pad, left:pad, right:pad, bottom:pad} :\n    pad === 'strict' ? pad : 'auto';\n}\n\nmodule.exports = parsePadding;\nparsePadding.schema = {\n  \"defs\": {\n    \"padding\": {\n      \"oneOf\": [{\n        \"enum\": [\"strict\", \"auto\"]\n      }, {\n        \"type\": \"number\"\n      }, {\n        \"type\": \"object\",\n        \"properties\": {\n          \"top\": {\"type\": \"number\"},\n          \"bottom\": {\"type\": \"number\"},\n          \"left\": {\"type\": \"number\"},\n          \"right\": {\"type\": \"number\"}\n        },\n        \"additionalProperties\": false\n      }]\n    }\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/parse/padding.js\n ** module id = 148\n ** module chunks = 0\n **/","var dl = require('datalib');\n\nvar types = {\n  '=':   parseComparator,\n  '==':  parseComparator,\n  '!=':  parseComparator,\n  '>':   parseComparator,\n  '>=':  parseComparator,\n  '<':   parseComparator,\n  '<=':  parseComparator,\n  'and': parseLogical,\n  '&&':  parseLogical,\n  'or':  parseLogical,\n  '||':  parseLogical,\n  'in':  parseIn\n};\n\nvar nullScale = function() { return 0; };\nnullScale.invert = nullScale;\n\nfunction parsePredicates(model, spec) {\n  (spec || []).forEach(function(s) {\n    var parse = types[s.type](model, s);\n\n    /* jshint evil:true */\n    var pred  = Function(\"args\", \"db\", \"signals\", \"predicates\", parse.code);\n    pred.root = function() { return model.scene().items[0]; }; // For global scales\n    pred.nullScale = nullScale;\n    pred.isFunction = dl.isFunction;\n    pred.signals = parse.signals;\n    pred.data = parse.data;\n\n    model.predicate(s.name, pred);\n  });\n\n  return spec;\n}\n\nfunction parseSignal(signal, signals) {\n  var s = dl.field(signal),\n      code = \"signals[\"+s.map(dl.str).join(\"][\")+\"]\";\n  signals[s[0]] = 1;\n  return code;\n}\n\nfunction parseOperands(model, operands) {\n  var decl = [], defs = [],\n      signals = {}, db = {};\n\n  function setSignal(s) { signals[s] = 1; }\n  function setData(d) { db[d] = 1; }\n\n  dl.array(operands).forEach(function(o, i) {\n    var name = \"o\" + i,\n        def = \"\";\n\n    if (o.value !== undefined) {\n      def = dl.str(o.value);\n    } else if (o.arg) {\n      def = \"args[\"+dl.str(o.arg)+\"]\";\n    } else if (o.signal) {\n      def = parseSignal(o.signal, signals);\n    } else if (o.predicate) {\n      var ref = o.predicate,\n          predName = ref && (ref.name || ref),\n          pred = model.predicate(predName),\n          p = \"predicates[\"+dl.str(predName)+\"]\";\n\n      pred.signals.forEach(setSignal);\n      pred.data.forEach(setData);\n\n      if (dl.isObject(ref)) {\n        dl.keys(ref).forEach(function(k) {\n          if (k === \"name\") return;\n          var i = ref[k];\n          def += \"args[\"+dl.str(k)+\"] = \";\n          if (i.signal) {\n            def += parseSignal(i.signal, signals);\n          } else if (i.arg) {\n            def += \"args[\"+dl.str(i.arg)+\"]\";\n          }\n          def += \", \";\n        });\n      }\n\n      def += p+\".call(\"+p+\", args, db, signals, predicates)\";\n    }\n\n    decl.push(name);\n    defs.push(name+\"=(\"+def+\")\");\n  });\n\n  return {\n    code: \"var \" + decl.join(\", \") + \";\\n\" + defs.join(\";\\n\") + \";\\n\",\n    signals: dl.keys(signals),\n    data: dl.keys(db)\n  };\n}\n\nfunction parseComparator(model, spec) {\n  var ops = parseOperands(model, spec.operands);\n  if (spec.type === '=') spec.type = '==';\n\n  ops.code += \"o0 = o0 instanceof Date ? o0.getTime() : o0;\\n\" +\n    \"o1 = o1 instanceof Date ? o1.getTime() : o1;\\n\";\n\n  return {\n    code: ops.code + \"return \" + [\"o0\", \"o1\"].join(spec.type) + \";\",\n    signals: ops.signals,\n    data: ops.data\n  };\n}\n\nfunction parseLogical(model, spec) {\n  var ops = parseOperands(model, spec.operands),\n      o = [], i = 0, len = spec.operands.length;\n\n  while (o.push(\"o\"+i++) < len);\n  if (spec.type === 'and') spec.type = '&&';\n  else if (spec.type === 'or') spec.type = '||';\n\n  return {\n    code: ops.code + \"return \" + o.join(spec.type) + \";\",\n    signals: ops.signals,\n    data: ops.data\n  };\n}\n\nfunction parseIn(model, spec) {\n  var o = [spec.item], code = \"\";\n  if (spec.range) o.push.apply(o, spec.range);\n  if (spec.scale) {\n    code = parseScale(spec.scale, o);\n  }\n\n  var ops = parseOperands(model, o);\n  code = ops.code + code + \"\\n  var ordSet = null;\\n\";\n\n  if (spec.data) {\n    var field = dl.field(spec.field).map(dl.str);\n    code += \"var where = function(d) { return d[\"+field.join(\"][\")+\"] == o0 };\\n\";\n    code += \"return db[\"+dl.str(spec.data)+\"].filter(where).length > 0;\";\n  } else if (spec.range) {\n    // TODO: inclusive/exclusive range?\n    if (spec.scale) {\n      code += \"if (scale.length == 2) {\\n\" + // inverting ordinal scales\n        \"  ordSet = scale(o1, o2);\\n\" +\n        \"} else {\\n\" +\n        \"  o1 = scale(o1);\\no2 = scale(o2);\\n\" +\n        \"}\";\n    }\n\n    code += \"return ordSet !== null ? ordSet.indexOf(o0) !== -1 :\\n\" +\n      \"  o1 < o2 ? o1 <= o0 && o0 <= o2 : o2 <= o0 && o0 <= o1;\";\n  }\n\n  return {\n    code: code,\n    signals: ops.signals,\n    data: ops.data.concat(spec.data ? [spec.data] : [])\n  };\n}\n\n// Populate ops such that ultimate scale/inversion function will be in `scale` var.\nfunction parseScale(spec, ops) {\n  var code = \"var scale = \",\n      idx  = ops.length;\n\n  if (dl.isString(spec)) {\n    ops.push({ value: spec });\n    code += \"this.root().scale(o\"+idx+\")\";\n  } else if (spec.arg) {  // Scale function is being passed as an arg\n    ops.push(spec);\n    code += \"o\"+idx;\n  } else if (spec.name) { // Full scale parameter {name: ..}\n    ops.push(dl.isString(spec.name) ? {value: spec.name} : spec.name);\n    code += \"(this.isFunction(o\"+idx+\") ? o\"+idx+\" : \";\n    if (spec.scope) {\n      ops.push(spec.scope);\n      code += \"((o\"+(idx+1)+\".scale || this.root().scale)(o\"+idx+\") || this.nullScale)\";\n    } else {\n      code += \"this.root().scale(o\"+idx+\")\";\n    }\n    code += \")\";\n  }\n\n  if (spec.invert === true) {  // Allow spec.invert.arg?\n    code += \".invert\";\n  }\n\n  return code+\";\\n\";\n}\n\nmodule.exports = parsePredicates;\nparsePredicates.schema = {\n  \"refs\": {\n    \"operand\": {\n      \"type\": \"object\",\n      \"oneOf\": [\n        {\n          \"properties\": {\"value\": {}},\n          \"required\": [\"value\"]\n        },\n        {\n          \"properties\": {\"arg\": {\"type\": \"string\"}},\n          \"required\": [\"arg\"]\n        },\n        {\"$ref\": \"#/refs/signal\"},\n        {\n          \"properties\": {\n            \"predicate\": {\n              \"oneOf\": [\n                {\"type\": \"string\"},\n                {\n                  \"type\": \"object\",\n                  \"properties\": {\"name\": {\"type\": \"string\"}},\n                  \"required\": [\"name\"]\n                }\n              ]\n            }\n          },\n          \"required\": [\"predicate\"]\n        }\n      ]\n    }\n  },\n\n  \"defs\": {\n    \"predicate\": {\n      \"type\": \"object\",\n      \"oneOf\": [{\n        \"properties\": {\n          \"name\": {\"type\": \"string\"},\n          \"type\": {\"enum\": [\"==\", \"!=\", \">\", \"<\", \">=\", \"<=\"]},\n          \"operands\": {\n            \"type\": \"array\",\n            \"items\": {\"$ref\": \"#/refs/operand\"},\n            \"minItems\": 2,\n            \"maxItems\": 2\n          }\n        },\n        \"required\": [\"name\", \"type\", \"operands\"]\n      }, {\n        \"properties\": {\n          \"name\": {\"type\": \"string\"},\n          \"type\": {\"enum\": [\"and\", \"&&\", \"or\", \"||\"]},\n          \"operands\": {\n            \"type\": \"array\",\n            \"items\": {\"$ref\": \"#/refs/operand\"},\n            \"minItems\": 2\n          }\n        },\n        \"required\": [\"name\", \"type\", \"operands\"]\n      }, {\n        \"properties\": {\n          \"name\": {\"type\": \"string\"},\n          \"type\": {\"enum\": [\"in\"]},\n          \"item\": {\"$ref\": \"#/refs/operand\"}\n        },\n\n        \"oneOf\": [\n          {\n            \"properties\": {\n              \"range\": {\n                \"type\": \"array\",\n                \"items\": {\"$ref\": \"#/refs/operand\"},\n                \"minItems\": 2\n              },\n              \"scale\": {\"$ref\": \"#/refs/scopedScale\"}\n            },\n            \"required\": [\"range\"]\n          },\n          {\n            \"properties\": {\n              \"data\": {\"type\": \"string\"},\n              \"field\": {\"type\": \"string\"}\n            },\n            \"required\": [\"data\", \"field\"]\n          }\n        ],\n\n        \"required\": [\"name\", \"type\", \"item\"]\n      }]\n    }\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/parse/predicates.js\n ** module id = 149\n ** module chunks = 0\n **/","var dl = require('datalib'),\n    expr = require('./expr'),\n    SIGNALS = require('vega-dataflow').Dependencies.SIGNALS;\n\nvar RESERVED = ['datum', 'event', 'signals', 'width', 'height', 'padding']\n    .concat(dl.keys(expr.codegen.functions));\n\nfunction parseSignals(model, spec) {\n  // process each signal definition\n  (spec || []).forEach(function(s) {\n    if (RESERVED.indexOf(s.name) !== -1) {\n      throw Error('Signal name \"'+s.name+'\" is a '+\n        'reserved keyword ('+RESERVED.join(', ')+').');\n    }\n\n    var signal = model.signal(s.name, s.init)\n      .verbose(s.verbose);\n\n    if (s.init && s.init.expr) {\n      s.init.expr = model.expr(s.init.expr);\n      signal.value(exprVal(model, s.init));\n    }\n\n    if (s.expr) {\n      s.expr = model.expr(s.expr);\n      signal.evaluate = function(input) {\n        var val = exprVal(model, s),\n            sg  = input.signals;\n        if (val !== signal.value() || signal.verbose()) {\n          signal.value(val);\n          sg[s.name] = 1;\n        }\n        return sg[s.name] ? input : model.doNotPropagate;\n      };\n      signal.dependency(SIGNALS, s.expr.globals);\n      s.expr.globals.forEach(function(dep) {\n        model.signal(dep).addListener(signal);\n      });\n    }\n  });\n\n  return spec;\n}\n\nfunction exprVal(model, spec) {\n  var e = spec.expr, v = e.fn();\n  return spec.scale ? parseSignals.scale(model, spec, v) : v;\n}\n\nparseSignals.scale = function scale(model, spec, value, datum, evt) {\n  var def = spec.scale,\n      name  = def.name || def.signal || def,\n      scope = def.scope, e;\n\n  if (scope) {\n    if (scope.signal) {\n      scope = model.signalRef(scope.signal);\n    } else if (dl.isString(scope)) { // Scope is an expression\n      e = def._expr = (def._expr || model.expr(scope));\n      scope = e.fn(datum, evt);\n    }\n  }\n\n  return expr.scale(model, def.invert, name, value, scope);\n};\n\nmodule.exports = parseSignals;\nparseSignals.schema = {\n  \"refs\": {\n    \"signal\": {\n      \"title\": \"SignalRef\",\n      \"type\": \"object\",\n      \"properties\": {\"signal\": {\"type\": \"string\"}},\n      \"required\": [\"signal\"]\n    },\n\n    \"scopedScale\": {\n      \"oneOf\": [\n        {\"type\": \"string\"},\n        {\n          \"type\": \"object\",\n          \"properties\": {\n            \"name\": {\n              \"oneOf\": [{\"$ref\": \"#/refs/signal\"}, {\"type\": \"string\"}]\n            },\n            \"scope\": {\n              \"oneOf\": [\n                {\"$ref\": \"#/refs/signal\"},\n                {\"type\": \"string\"}\n              ]\n            },\n            \"invert\": {\"type\": \"boolean\", \"default\": false}\n          },\n\n          \"additionalProperties\": false,\n          \"required\": [\"name\"]\n        }\n      ]\n    }\n  },\n\n  \"defs\": {\n    \"signal\": {\n      \"type\": \"object\",\n\n      \"properties\": {\n        \"name\": {\n          \"type\": \"string\",\n          \"not\": {\"enum\": RESERVED}\n        },\n        \"init\": {},\n        \"verbose\": {\"type\": \"boolean\", \"default\": false},\n        \"expr\": {\"type\": \"string\"},\n        \"scale\": {\"$ref\": \"#/refs/scopedScale\"},\n        \"streams\": {\"$ref\": \"#/defs/streams\"}\n      },\n\n      \"additionalProperties\": false,\n      \"required\": [\"name\"]\n    }\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/parse/signals.js\n ** module id = 150\n ** module chunks = 0\n **/","var dl  = require('datalib'),\n    log = require('vega-logging'),\n    Model = require('../core/Model'),\n    View  = require('../core/View');\n\n/**\n * Parse graph specification\n * @param spec (object)\n * @param config (optional object)\n * @param viewFactory (optional function)\n * @param callback (error, model)\n */\n function parseSpec(spec /*, [config,] [viewFactory,] callback */) {\n  // do not assign any values to callback, as it will change arguments\n  var arglen = arguments.length,\n      argidx = 2,\n      cb = arguments[arglen-1],\n      model = new Model(),\n      viewFactory = View.factory;\n\n  if (arglen > argidx && dl.isFunction(arguments[arglen - argidx])) {\n    viewFactory = arguments[arglen - argidx];\n    ++argidx;\n  }\n  if (arglen > argidx && dl.isObject(arguments[arglen - argidx])) {\n    model.config(arguments[arglen - argidx]);\n  }\n\n  if (dl.isObject(spec)) {\n    parse(spec);\n  } else if (dl.isString(spec)) {\n    var opts = dl.extend({url: spec}, model.config().load);\n    dl.json(opts, function(err, spec) {\n      if (err) done('SPECIFICATION LOAD FAILED: ' + err);\n      else parse(spec);\n    });\n  } else {\n    done('INVALID SPECIFICATION: Must be a valid JSON object or URL.');\n  }\n\n  function parse(spec) {\n    try {\n      // protect against subsequent spec modification\n      spec = dl.duplicate(spec);\n\n      var parsers = require('./'),\n          width   = spec.width || 500,\n          height  = spec.height || 500,\n          padding = parsers.padding(spec.padding);\n\n      // create signals for width, height, padding, and cursor\n      model.signal('width', width);\n      model.signal('height', height);\n      model.signal('padding', padding);\n      cursor(spec);\n\n      // initialize model\n      model.defs({\n        width:      width,\n        height:     height,\n        padding:    padding,\n        viewport:   spec.viewport || null,\n        background: parsers.background(spec.background),\n        signals:    parsers.signals(model, spec.signals),\n        predicates: parsers.predicates(model, spec.predicates),\n        marks:      parsers.marks(model, spec, width, height),\n        data:       parsers.data(model, spec.data, done)\n      });\n    } catch (err) { done(err); }\n  }\n\n  function cursor(spec) {\n    var signals = spec.signals || (spec.signals=[]),  def;\n    signals.some(function(sg) {\n      return (sg.name === 'cursor') ? (def=sg, true) : false;\n    });\n\n    if (!def) signals.push(def={name: 'cursor', streams: []});\n\n    // Add a stream def at the head, so that custom defs can override it.\n    def.init = def.init || {};\n    def.streams.unshift({\n      type: 'mousemove',\n      expr: 'eventItem().cursor === cursor.default ? cursor : {default: eventItem().cursor}'\n    });\n  }\n\n  function done(err) {\n    var view;\n    if (err) {\n      log.error(err);\n    } else {\n      view = viewFactory(model.buildIndexes());\n    }\n\n    if (cb) {\n      if (cb.length > 1) cb(err, view);\n      else if (!err) cb(view);\n      cb = null;\n    }\n  }\n}\n\nmodule.exports = parseSpec;\n\nparseSpec.schema = {\n  \"defs\": {\n    \"spec\": {\n      \"title\": \"Vega visualization specification\",\n      \"type\": \"object\",\n\n      \"allOf\": [{\"$ref\": \"#/defs/container\"}, {\n        \"properties\": {\n          \"width\": {\"type\": \"number\"},\n          \"height\": {\"type\": \"number\"},\n          \"viewport\": {\n            \"type\": \"array\",\n            \"items\": {\"type\": \"number\"},\n            \"maxItems\": 2\n          },\n\n          \"background\": {\"$ref\": \"#/defs/background\"},\n          \"padding\": {\"$ref\": \"#/defs/padding\"},\n\n          \"signals\": {\n            \"type\": \"array\",\n            \"items\": {\"$ref\": \"#/defs/signal\"}\n          },\n\n          \"predicates\": {\n            \"type\": \"array\",\n            \"items\": {\"$ref\": \"#/defs/predicate\"}\n          },\n\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\"$ref\": \"#/defs/data\"}\n          }\n        }\n      }]\n    }\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/parse/spec.js\n ** module id = 151\n ** module chunks = 0\n **/","var dl = require('datalib'),\n    df = require('vega-dataflow'),\n    ChangeSet = df.ChangeSet,\n    Base = df.Graph.prototype,\n    Node  = df.Node, // jshint ignore:line\n    GroupBuilder = require('../scene/GroupBuilder'),\n    visit = require('../scene/visit'),\n    compiler = require('../parse/expr'),\n    config = require('./config');\n\nfunction Model(cfg) {\n  this._defs = {};\n  this._predicates = {};\n\n  this._scene  = null;  // Root scenegraph node.\n  this._groups = null;  // Index of group items.\n\n  this._node = null;\n  this._builder = null; // Top-level scenegraph builder.\n\n  this._reset = {axes: false, legends: false};\n\n  this.config(cfg);\n  this.expr = compiler(this);\n  Base.init.call(this);\n}\n\nvar prototype = (Model.prototype = Object.create(Base));\nprototype.constructor = Model;\n\nprototype.defs = function(defs) {\n  if (!arguments.length) return this._defs;\n  this._defs = defs;\n  return this;\n};\n\nprototype.config = function(cfg) {\n  if (!arguments.length) return this._config;\n  this._config = Object.create(config);\n  for (var name in cfg) {\n    var x = cfg[name], y = this._config[name];\n    if (dl.isObject(x) && dl.isObject(y)) {\n      this._config[name] = dl.extend({}, y, x);\n    } else {\n      this._config[name] = x;\n    }\n  }\n\n  return this;\n};\n\nprototype.width = function(width) {\n  if (this._defs) this._defs.width = width;\n  if (this._defs && this._defs.marks) this._defs.marks.width = width;\n  if (this._scene) {\n    this._scene.items[0].width = width;\n    this._scene.items[0]._dirty = true;\n  }\n  this._reset.axes = true;\n  return this;\n};\n\nprototype.height = function(height) {\n  if (this._defs) this._defs.height = height;\n  if (this._defs && this._defs.marks) this._defs.marks.height = height;\n  if (this._scene) {\n    this._scene.items[0].height = height;\n    this._scene.items[0]._dirty = true;\n  }\n  this._reset.axes = true;\n  return this;\n};\n\nprototype.node = function() {\n  return this._node || (this._node = new Node(this));\n};\n\nprototype.data = function() {\n  var data = Base.data.apply(this, arguments);\n  if (arguments.length > 1) {  // new Datasource\n    this.node().addListener(data.pipeline()[0]);\n  }\n  return data;\n};\n\nfunction predicates(name) {\n  var m = this, pred = {};\n  if (!dl.isArray(name)) return this._predicates[name];\n  name.forEach(function(n) { pred[n] = m._predicates[n]; });\n  return pred;\n}\n\nprototype.predicate = function(name, predicate) {\n  if (arguments.length === 1) return predicates.call(this, name);\n  return (this._predicates[name] = predicate);\n};\n\nprototype.predicates = function() { return this._predicates; };\n\nprototype.scene = function(renderer) {\n  if (!arguments.length) return this._scene;\n\n  if (this._builder) {\n    this.node().removeListener(this._builder);\n    this._builder._groupBuilder.disconnect();\n  }\n\n  var m = this,\n      b = this._builder = new Node(this);\n\n  b.evaluate = function(input) {\n    if (b._groupBuilder) return input;\n\n    var gb = b._groupBuilder = new GroupBuilder(m, m._defs.marks, m._scene={}),\n        p  = gb.pipeline();\n\n    m._groups = {};\n    this.addListener(gb.connect());\n    p[p.length-1].addListener(renderer);\n    return input;\n  };\n\n  this.addListener(b);\n  return this;\n};\n\nprototype.group = function(id, item) {\n  var groups = this._groups;\n  if (arguments.length === 1) return groups[id];\n  return (groups[id] = item, this);\n};\n\nprototype.reset = function() {\n  if (this._scene && this._reset.axes) {\n    visit(this._scene, function(item) {\n      if (item.axes) item.axes.forEach(function(axis) { axis.reset(); });\n    });\n    this._reset.axes = false;\n  }\n  if (this._scene && this._reset.legends) {\n    visit(this._scene, function(item) {\n      if (item.legends) item.legends.forEach(function(l) { l.reset(); });\n    });\n    this._reset.legends = false;\n  }\n  return this;\n};\n\nprototype.addListener = function(l) {\n  this.node().addListener(l);\n};\n\nprototype.removeListener = function(l) {\n  this.node().removeListener(l);\n};\n\nprototype.fire = function(cs) {\n  if (!cs) cs = ChangeSet.create();\n  this.propagate(cs, this.node());\n};\n\nmodule.exports = Model;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/core/Model.js\n ** module id = 152\n ** module chunks = 0\n **/","var dl = require('datalib'),\n    df = require('vega-dataflow'),\n    Node  = df.Node, // jshint ignore:line\n    Deps  = df.Dependencies,\n    Tuple = df.Tuple,\n    Collector = df.Collector,\n    log = require('vega-logging'),\n    Builder = require('./Builder'),\n    Scale = require('./Scale'),\n    parseAxes = require('../parse/axes'),\n    parseLegends = require('../parse/legends');\n\nfunction GroupBuilder() {\n  this._children = {};\n  this._scaler = null;\n  this._recursor = null;\n\n  this._scales = {};\n  this.scale = scale.bind(this);\n  return arguments.length ? this.init.apply(this, arguments) : this;\n}\n\nvar Types = GroupBuilder.TYPES = {\n  GROUP:  \"group\",\n  MARK:   \"mark\",\n  AXIS:   \"axis\",\n  LEGEND: \"legend\"\n};\n\nvar proto = (GroupBuilder.prototype = new Builder());\n\nproto.init = function(graph, def) {\n  var builder = this, name;\n\n  this._scaler = new Node(graph);\n\n  (def.scales||[]).forEach(function(s) {\n    s = builder.scale((name=s.name), new Scale(graph, s, builder));\n    builder.scale(name+\":prev\", s);\n    builder._scaler.addListener(s);  // Scales should be computed after group is encoded\n  });\n\n  this._recursor = new Node(graph);\n  this._recursor.evaluate = recurse.bind(this);\n\n  var scales = (def.axes||[]).reduce(function(acc, x) {\n    return (acc[x.scale] = 1, acc);\n  }, {});\n\n  scales = (def.legends||[]).reduce(function(acc, x) {\n    return (acc[x.size || x.shape || x.fill || x.stroke], acc);\n  }, scales);\n\n  this._recursor.dependency(Deps.SCALES, dl.keys(scales));\n\n  // We only need a collector for up-propagation of bounds calculation,\n  // so only GroupBuilders, and not regular Builders, have collectors.\n  this._collector = new Collector(graph);\n\n  return Builder.prototype.init.apply(this, arguments);\n};\n\nproto.evaluate = function() {\n  var output  = Builder.prototype.evaluate.apply(this, arguments),\n      model   = this._graph,\n      builder = this,\n      scales = this._scales,\n      items  = this._mark.items;\n\n  // If scales need to be reevaluated, we need to send all group items forward.\n  if (output.mod.length < items.length) {\n    var fullUpdate = dl.keys(scales).some(function(s) {\n      return scales[s].reevaluate(output);\n    });\n\n    if (fullUpdate) {\n      output.mod = output.mod.concat(Tuple.idFilter(items, output.mod));\n    }\n  }\n\n  output.add.forEach(function(group) { buildGroup.call(builder, output, group); });\n  output.rem.forEach(function(group) { model.group(group._id, null); });\n  return output;\n};\n\nproto.pipeline = function() {\n  return [this, this._scaler, this._recursor, this._collector, this._bounder];\n};\n\nproto.disconnect = function() {\n  var builder = this;\n  dl.keys(builder._children).forEach(function(group_id) {\n    builder._children[group_id].forEach(function(c) {\n      builder._recursor.removeListener(c.builder);\n      c.builder.disconnect();\n    });\n  });\n\n  builder._children = {};\n  return Builder.prototype.disconnect.call(this);\n};\n\nproto.child = function(name, group_id) {\n  var children = this._children[group_id],\n      i = 0, len = children.length,\n      child;\n\n  for (; i<len; ++i) {\n    child = children[i];\n    if (child.type == Types.MARK && child.builder._def.name == name) break;\n  }\n\n  return child.builder;\n};\n\nfunction recurse(input) {\n  var builder = this,\n      hasMarks = dl.array(this._def.marks).length > 0,\n      hasAxes = dl.array(this._def.axes).length > 0,\n      hasLegends = dl.array(this._def.legends).length > 0,\n      i, j, c, len, group, pipeline, def, inline = false;\n\n  for (i=0, len=input.add.length; i<len; ++i) {\n    group = input.add[i];\n    if (hasMarks) buildMarks.call(this, input, group);\n    if (hasAxes)  buildAxes.call(this, input, group);\n    if (hasLegends) buildLegends.call(this, input, group);\n  }\n\n  // Wire up new children builders in reverse to minimize graph rewrites.\n  for (i=input.add.length-1; i>=0; --i) {\n    group = input.add[i];\n    for (j=this._children[group._id].length-1; j>=0; --j) {\n      c = this._children[group._id][j];\n      c.builder.connect();\n      pipeline = c.builder.pipeline();\n      def = c.builder._def;\n\n      // This new child needs to be built during this propagation cycle.\n      // We could add its builder as a listener off the _recursor node,\n      // but try to inline it if we can to minimize graph dispatches.\n      inline = (def.type !== Types.GROUP);\n      inline = inline && (this._graph.data(c.from) !== undefined);\n      inline = inline && (pipeline[pipeline.length-1].listeners().length === 1); // Reactive geom source\n      inline = inline && (def.from && !def.from.mark); // Reactive geom target\n      c.inline = inline;\n\n      if (inline) this._graph.evaluate(input, c.builder);\n      else this._recursor.addListener(c.builder);\n    }\n  }\n\n  function removeTemp(c) {\n    if (c.type == Types.MARK && !c.inline &&\n        builder._graph.data(c.from) !== undefined) {\n      builder._recursor.removeListener(c.builder);\n    }\n  }\n\n  function updateAxis(a) {\n    var scale = a.scale();\n    if (!input.scales[scale.scaleName]) return;\n    a.reset().def();\n  }\n\n  function updateLegend(l) {\n    var scale = l.size() || l.shape() || l.fill() || l.stroke();\n    if (!input.scales[scale.scaleName]) return;\n    l.reset().def();\n  }\n\n  for (i=0, len=input.mod.length; i<len; ++i) {\n    group = input.mod[i];\n\n    // Remove temporary connection for marks that draw from a source\n    if (hasMarks) builder._children[group._id].forEach(removeTemp);\n\n    // Update axis data defs\n    if (hasAxes) group.axes.forEach(updateAxis);\n\n    // Update legend data defs\n    if (hasLegends) group.legends.forEach(updateLegend);\n  }\n\n  function disconnectChildren(c) {\n    builder._recursor.removeListener(c.builder);\n    c.builder.disconnect();\n  }\n\n  for (i=0, len=input.rem.length; i<len; ++i) {\n    group = input.rem[i];\n    // For deleted groups, disconnect their children\n    builder._children[group._id].forEach(disconnectChildren);\n    delete builder._children[group._id];\n  }\n\n  return input;\n}\n\nfunction scale(name, x) {\n  var group = this, s = null;\n  if (arguments.length === 2) return (group._scales[name] = x, x);\n  while (s == null) {\n    s = group._scales[name];\n    group = group.mark ? group.mark.group : group._parent;\n    if (!group) break;\n  }\n  return s;\n}\n\nfunction buildGroup(input, group) {\n  log.debug(input, [\"building group\", group._id]);\n\n  group._scales = group._scales || {};\n  group.scale = scale.bind(group);\n\n  group.items = group.items || [];\n  this._children[group._id] = this._children[group._id] || [];\n\n  group.axes = group.axes || [];\n  group.axisItems = group.axisItems || [];\n\n  group.legends = group.legends || [];\n  group.legendItems = group.legendItems || [];\n\n  // Index group by ID to enable safe scoped scale lookups.\n  this._graph.group(group._id, group);\n}\n\nfunction buildMarks(input, group) {\n  log.debug(input, [\"building children marks #\"+group._id]);\n  var marks = this._def.marks,\n      mark, from, inherit, i, len, b;\n\n  for (i=0, len=marks.length; i<len; ++i) {\n    mark = marks[i];\n    from = mark.from || {};\n    inherit = group.datum._facetID;\n    group.items[i] = {group: group, _scaleRefs: {}};\n    b = (mark.type === Types.GROUP) ? new GroupBuilder() : new Builder();\n    b.init(this._graph, mark, group.items[i], this, group._id, inherit);\n    this._children[group._id].push({\n      builder: b,\n      from: from.data || (from.mark ? (\"vg_\" + group._id + \"_\" + from.mark) : inherit),\n      type: Types.MARK\n    });\n  }\n}\n\nfunction buildAxes(input, group) {\n  var axes = group.axes,\n      axisItems = group.axisItems,\n      builder = this;\n\n  parseAxes(this._graph, this._def.axes, axes, group);\n  axes.forEach(function(a, i) {\n    var scale = builder._def.axes[i].scale,\n        def = a.def(),\n        b = null;\n\n    axisItems[i] = {group: group, axis: a, layer: def.layer};\n    b = (def.type === Types.GROUP) ? new GroupBuilder() : new Builder();\n    b.init(builder._graph, def, axisItems[i], builder)\n      .dependency(Deps.SCALES, scale);\n    builder._children[group._id].push({ builder: b, type: Types.AXIS, scale: scale });\n  });\n}\n\nfunction buildLegends(input, group) {\n  var legends = group.legends,\n      legendItems = group.legendItems,\n      builder = this;\n\n  parseLegends(this._graph, this._def.legends, legends, group);\n  legends.forEach(function(l, i) {\n    var scale = l.size() || l.shape() || l.fill() || l.stroke(),\n        def = l.def(),\n        b = null;\n\n    legendItems[i] = {group: group, legend: l};\n    b = (def.type === Types.GROUP) ? new GroupBuilder() : new Builder();\n    b.init(builder._graph, def, legendItems[i], builder)\n      .dependency(Deps.SCALES, scale);\n    builder._children[group._id].push({ builder: b, type: Types.LEGEND, scale: scale });\n  });\n}\n\nmodule.exports = GroupBuilder;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/scene/GroupBuilder.js\n ** module id = 153\n ** module chunks = 0\n **/","var dl = require('datalib'),\n    log = require('vega-logging'),\n    Item = require('vega-scenegraph').Item,\n    df = require('vega-dataflow'),\n    Node = df.Node, // jshint ignore:line\n    Deps = df.Dependencies,\n    Tuple = df.Tuple,\n    ChangeSet = df.ChangeSet,\n    Sentinel = {},\n    Encoder  = require('./Encoder'),\n    Bounder  = require('./Bounder'),\n    parseData = require('../parse/data');\n\nfunction Builder() {\n  return arguments.length ? this.init.apply(this, arguments) : this;\n}\n\nvar Status = Builder.STATUS = {\n  ENTER:  'enter',\n  UPDATE: 'update',\n  EXIT:   'exit'\n};\n\nvar CONNECTED = 1, DISCONNECTED = 2;\n\nvar proto = (Builder.prototype = new Node());\n\nproto.init = function(graph, def, mark, parent, parent_id, inheritFrom) {\n  Node.prototype.init.call(this, graph)\n    .router(true)\n    .collector(true);\n\n  this._def   = def;\n  this._mark  = mark;\n  this._from  = (def.from ? def.from.data : null) || inheritFrom;\n  this._ds    = dl.isString(this._from) ? graph.data(this._from) : null;\n  this._map   = {};\n  this._status = null; // Connected or disconnected?\n\n  mark.def = def;\n  mark.marktype = def.type;\n  mark.interactive = (def.interactive !== false);\n  mark.items = [];\n  if (dl.isValid(def.name)) mark.name = def.name;\n\n  this._parent = parent;\n  this._parent_id = parent_id;\n\n  if (def.from && (def.from.mark || def.from.transform || def.from.modify)) {\n    inlineDs.call(this);\n  }\n\n  // Non-group mark builders are super nodes. Encoder and Bounder remain\n  // separate operators but are embedded and called by Builder.evaluate.\n  this._isSuper = (this._def.type !== 'group');\n  this._encoder = new Encoder(this._graph, this._mark, this);\n  this._bounder = new Bounder(this._graph, this._mark);\n  this._output  = null; // Output changeset for reactive geom as Bounder reflows\n\n  if (this._ds) { this._encoder.dependency(Deps.DATA, this._from); }\n\n  // Since Builders are super nodes, copy over encoder dependencies\n  // (bounder has no registered dependencies).\n  this.dependency(Deps.DATA, this._encoder.dependency(Deps.DATA));\n  this.dependency(Deps.SCALES, this._encoder.dependency(Deps.SCALES));\n  this.dependency(Deps.SIGNALS, this._encoder.dependency(Deps.SIGNALS));\n\n  return this;\n};\n\n// Reactive geometry and mark-level transformations are handled here\n// because they need their group's data-joined context.\nfunction inlineDs() {\n  var from = this._def.from,\n      geom = from.mark,\n      src, name, spec, sibling, output, input, node;\n\n  if (geom) {\n    sibling = this.sibling(geom);\n    src  = sibling._isSuper ? sibling : sibling._bounder;\n    name = ['vg', this._parent_id, geom, src.listeners(true).length].join('_');\n    spec = {\n      name: name,\n      transform: from.transform,\n      modify: from.modify\n    };\n  } else {\n    src = this._graph.data(this._from);\n    if (!src) throw Error('Data source \"'+this._from+'\" is not defined.');\n    name = ['vg', this._from, this._def.type, src.listeners(true).length].join('_');\n    spec = {\n      name: name,\n      source: this._from,\n      transform: from.transform,\n      modify: from.modify\n    };\n  }\n\n  this._from = name;\n  this._ds = parseData.datasource(this._graph, spec);\n\n  if (geom) {\n    // Bounder reflows, so we need an intermediary node to propagate\n    // the output constructed by the Builder.\n    node = new Node(this._graph).addListener(this._ds.listener());\n    node.evaluate = function(input) {\n      var out  = ChangeSet.create(input),\n          sout = sibling._output;\n\n      out.add = sout.add;\n      out.mod = sout.mod;\n      out.rem = sout.rem;\n      return out;\n    };\n    src.addListener(node);\n  } else {\n    // At this point, we have a new datasource but it is empty as\n    // the propagation cycle has already crossed the datasources.\n    // So, we repulse just this datasource. This should be safe\n    // as the ds isn't connected to the scenegraph yet.\n    output = this._ds.source().last();\n    input  = ChangeSet.create(output);\n\n    input.add = output.add;\n    input.mod = output.mod;\n    input.rem = output.rem;\n    input.stamp = null;\n    this._graph.propagate(input, this._ds.listener(), output.stamp);\n  }\n}\n\nproto.ds = function() { return this._ds; };\nproto.parent   = function() { return this._parent; };\nproto.encoder  = function() { return this._encoder; };\nproto.pipeline = function() { return [this]; };\n\nproto.connect = function() {\n  var builder = this;\n\n  this._graph.connect(this.pipeline());\n  this._encoder._scales.forEach(function(s) {\n    if (!(s = builder._parent.scale(s))) return;\n    s.addListener(builder);\n  });\n\n  if (this._parent) {\n    if (this._isSuper) this.addListener(this._parent._collector);\n    else this._bounder.addListener(this._parent._collector);\n  }\n\n  return (this._status = CONNECTED, this);\n};\n\nproto.disconnect = function() {\n  var builder = this;\n  if (!this._listeners.length) return this;\n\n  function disconnectScales(scales) {\n    for(var i=0, len=scales.length, s; i<len; ++i) {\n      if (!(s = builder._parent.scale(scales[i]))) continue;\n      s.removeListener(builder);\n    }\n  }\n\n  Node.prototype.disconnect.call(this);\n  this._graph.disconnect(this.pipeline());\n  disconnectScales(this._encoder._scales);\n  disconnectScales(dl.keys(this._mark._scaleRefs));\n\n  return (this._status = DISCONNECTED, this);\n};\n\nproto.sibling = function(name) {\n  return this._parent.child(name, this._parent_id);\n};\n\nproto.evaluate = function(input) {\n  log.debug(input, ['building', (this._from || this._def.from), this._def.type]);\n\n  var self = this,\n      def = this._mark.def,\n      props  = def.properties || {},\n      update = props.update   || {},\n      output = ChangeSet.create(input),\n      fullUpdate, fcs, data, name;\n\n  if (this._ds) {\n    // We need to determine if any encoder dependencies have been updated.\n    // However, the encoder's data source will likely be updated, and shouldn't\n    // trigger all items to mod.\n    data = output.data[(name=this._ds.name())];\n    output.data[name] = null;\n    fullUpdate = this._encoder.reevaluate(output);\n    output.data[name] = data;\n\n    fcs = this._ds.last();\n    if (!fcs) throw Error('Builder evaluated before backing DataSource.');\n    if (fcs.stamp > this._stamp) {\n      join.call(this, fcs, output, this._ds.values(), true, fullUpdate);\n    } else if (fullUpdate) {\n      output.mod = this._mark.items.slice();\n    }\n  } else {\n    data = dl.isFunction(this._def.from) ? this._def.from() : [Sentinel];\n    join.call(this, input, output, data);\n  }\n\n  // Stash output before Bounder for downstream reactive geometry.\n  this._output = output = this._graph.evaluate(output, this._encoder);\n\n  // Add any new scale references to the dependency list, and ensure\n  // they're connected.\n  if (update.nested && update.nested.length && this._status === CONNECTED) {\n    dl.keys(this._mark._scaleRefs).forEach(function(s) {\n      var scale = self._parent.scale(s);\n      if (!scale) return;\n\n      scale.addListener(self);\n      self.dependency(Deps.SCALES, s);\n      self._encoder.dependency(Deps.SCALES, s);\n    });\n  }\n\n  // Supernodes calculate bounds too, but only on items marked dirty.\n  if (this._isSuper) {\n    output.mod = output.mod.filter(function(x) { return x._dirty; });\n    output = this._graph.evaluate(output, this._bounder);\n  }\n\n  return output;\n};\n\nfunction newItem() {\n  var item = Tuple.ingest(new Item(this._mark));\n\n  // For the root node's item\n  if (this._def.width)  Tuple.set(item, 'width',  this._def.width);\n  if (this._def.height) Tuple.set(item, 'height', this._def.height);\n  return item;\n}\n\nfunction join(input, output, data, ds, fullUpdate) {\n  var keyf = keyFunction(this._def.key || (ds ? '_id' : null)),\n      prev = this._mark.items || [],\n      rem  = ds ? input.rem : prev,\n      mod  = Tuple.idMap((!ds || fullUpdate) ? data : input.mod),\n      next = [],\n      i, key, len, item, datum, enter, diff;\n\n  // Only mark rems as exiting. Due to keyf, there may be an add/mod\n  // tuple that replaces it.\n  for (i=0, len=rem.length; i<len; ++i) {\n    item = (rem[i] === prev[i]) ? prev[i] :\n      keyf ? this._map[keyf(rem[i])] : rem[i];\n    item.status = Status.EXIT;\n  }\n\n  for(i=0, len=data.length; i<len; ++i) {\n    datum = data[i];\n    item  = keyf ? this._map[key = keyf(datum)] : prev[i];\n    enter = item ? false : (item = newItem.call(this), true);\n    item.status = enter ? Status.ENTER : Status.UPDATE;\n    diff = !enter && item.datum !== datum;\n    item.datum = datum;\n\n    if (keyf) {\n      Tuple.set(item, 'key', key);\n      this._map[key] = item;\n    }\n\n    if (enter) {\n      output.add.push(item);\n    } else if (diff || mod[datum._id]) {\n      output.mod.push(item);\n    }\n\n    next.push(item);\n  }\n\n  for (i=0, len=rem.length; i<len; ++i) {\n    item = (rem[i] === prev[i]) ? prev[i] :\n      keyf ? this._map[key = keyf(rem[i])] : rem[i];\n    if (item.status === Status.EXIT) {\n      item._dirty = true;\n      input.dirty.push(item);\n      next.push(item);\n      output.rem.push(item);\n      if (keyf) this._map[key] = null;\n    }\n  }\n\n  return (this._mark.items = next, output);\n}\n\nfunction keyFunction(key) {\n  if (key == null) return null;\n  var f = dl.array(key).map(dl.accessor);\n  return function(d) {\n    for (var s='', i=0, n=f.length; i<n; ++i) {\n      if (i>0) s += '|';\n      s += String(f[i](d));\n    }\n    return s;\n  };\n}\n\nmodule.exports = Builder;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/scene/Builder.js\n ** module id = 154\n ** module chunks = 0\n **/","var dl = require('datalib'),\n    log = require('vega-logging'),\n    df = require('vega-dataflow'),\n    Node = df.Node, // jshint ignore:line\n    Deps = df.Dependencies,\n    bound = require('vega-scenegraph').bound;\n\nvar EMPTY = {};\n\nfunction Encoder(graph, mark, builder) {\n  var props  = mark.def.properties || {},\n      enter  = props.enter,\n      update = props.update,\n      exit   = props.exit;\n\n  Node.prototype.init.call(this, graph);\n\n  this._mark = mark;\n  this._builder = builder;\n  var s = this._scales = [];\n\n  // Only scales used in the 'update' property set are set as\n  // encoder depedencies to have targeted reevaluations. However,\n  // we still want scales in 'enter' and 'exit' to be evaluated\n  // before the encoder.\n  if (enter) s.push.apply(s, enter.scales);\n\n  if (update) {\n    this.dependency(Deps.DATA, update.data);\n    this.dependency(Deps.SIGNALS, update.signals);\n    this.dependency(Deps.FIELDS, update.fields);\n    this.dependency(Deps.SCALES, update.scales);\n    s.push.apply(s, update.scales);\n  }\n\n  if (exit) s.push.apply(s, exit.scales);\n\n  return this.mutates(true);\n}\n\nvar proto = (Encoder.prototype = new Node());\n\nproto.evaluate = function(input) {\n  log.debug(input, ['encoding', this._mark.def.type]);\n  var graph = this._graph,\n      props = this._mark.def.properties || {},\n      items = this._mark.items,\n      enter  = props.enter,\n      update = props.update,\n      exit   = props.exit,\n      dirty  = input.dirty,\n      preds  = graph.predicates(),\n      req = input.request,\n      group = this._mark.group,\n      guide = group && (group.mark.axis || group.mark.legend),\n      db = EMPTY, sg = EMPTY, i, len, item, prop;\n\n  if (req && !guide) {\n    if ((prop = props[req]) && input.mod.length) {\n      db = prop.data ? graph.values(Deps.DATA, prop.data) : null;\n      sg = prop.signals ? graph.values(Deps.SIGNALS, prop.signals) : null;\n\n      for (i=0, len=input.mod.length; i<len; ++i) {\n        item = input.mod[i];\n        encode.call(this, prop, item, input.trans, db, sg, preds, dirty);\n      }\n    }\n\n    return input; // exit early if given request\n  }\n\n  db = values(Deps.DATA, graph, input, props);\n  sg = values(Deps.SIGNALS, graph, input, props);\n\n  // Items marked for removal are at the tail of items. Process them first.\n  for (i=0, len=input.rem.length; i<len; ++i) {\n    item = input.rem[i];\n    if (exit) encode.call(this, exit, item, input.trans, db, sg, preds, dirty);\n    if (input.trans && !exit) input.trans.interpolate(item, EMPTY);\n    else if (!input.trans) items.pop();\n  }\n\n  var update_status = require('./Builder').STATUS.UPDATE;\n  for (i=0, len=input.add.length; i<len; ++i) {\n    item = input.add[i];\n    if (enter)  encode.call(this, enter,  item, input.trans, db, sg, preds, dirty);\n    if (update) encode.call(this, update, item, input.trans, db, sg, preds, dirty);\n    item.status = update_status;\n  }\n\n  if (update) {\n    for (i=0, len=input.mod.length; i<len; ++i) {\n      item = input.mod[i];\n      encode.call(this, update, item, input.trans, db, sg, preds, dirty);\n    }\n  }\n\n  return input;\n};\n\n// Only marshal necessary data and signal values\nfunction values(type, graph, input, props) {\n  var p, x, o, add = input.add.length;\n  if ((p=props.enter) && (x=p[type]).length && add) {\n    o = graph.values(type, x, (o=o||{}));\n  }\n  if ((p=props.exit) && (x=p[type]).length && input.rem.length) {\n    o = graph.values(type, x, (o=o||{}));\n  }\n  if ((p=props.update) && (x=p[type]).length && (add || input.mod.length)) {\n    o = graph.values(type, x, (o=o||{}));\n  }\n  return o || EMPTY;\n}\n\nfunction encode(prop, item, trans, db, sg, preds, dirty) {\n  var enc = prop.encode,\n      wasDirty = item._dirty,\n      isDirty  = enc.call(enc, item, item.mark.group||item, trans, db, sg, preds);\n\n  item._dirty = isDirty || wasDirty;\n  if (isDirty && !wasDirty) dirty.push(item);\n}\n\n// If a specified property set called, or update property set\n// uses nested fieldrefs, reevaluate all items.\nproto.reevaluate = function(pulse) {\n  var def = this._mark.def,\n      props = def.properties || {},\n      reeval = dl.isFunction(def.from) || def.orient || pulse.request ||\n        Node.prototype.reevaluate.call(this, pulse);\n\n  return reeval || (props.update ? nestedRefs.call(this) : false);\n};\n\n// Test if any nested refs trigger a reflow of mark items.\nfunction nestedRefs() {\n  var refs = this._mark.def.properties.update.nested,\n      parent = this._builder,\n      level = 0,\n      i = 0, len = refs.length,\n      ref, ds, stamp;\n\n  for (; i<len; ++i) {\n    ref = refs[i];\n\n    // Scale references are resolved via this._mark._scaleRefs which are\n    // added to dependency lists + connected in Builder.evaluate.\n    if (ref.scale) continue;\n\n    for (; level<ref.level; ++level) {\n      parent = parent.parent();\n      ds = parent.ds();\n    }\n\n    // Compare stamps to determine if a change in a group's properties\n    // or data should trigger a reeval. We cannot check anything fancier\n    // (e.g., pulse.fields) as the ref may use item.datum.\n    stamp = (ref.group ? parent.encoder() : ds.last())._stamp;\n    if (stamp > this._stamp) return true;\n  }\n\n  return false;\n}\n\n// Short-circuit encoder if user specifies items\nEncoder.update = function(graph, trans, request, items, dirty) {\n  items = dl.array(items);\n  var preds = graph.predicates(),\n      db = graph.values(Deps.DATA),\n      sg = graph.values(Deps.SIGNALS),\n      i, len, item, props, prop;\n\n  for (i=0, len=items.length; i<len; ++i) {\n    item = items[i];\n    props = item.mark.def.properties;\n    prop = props && props[request];\n    if (prop) {\n      encode.call(null, prop, item, trans, db, sg, preds, dirty);\n      bound.item(item);\n    }\n  }\n\n};\n\nmodule.exports = Encoder;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/scene/Encoder.js\n ** module id = 155\n ** module chunks = 0\n **/","var dl = require('datalib'),\n    df = require('vega-dataflow'),\n    scene = require('vega-scenegraph'),\n    Node = df.Node, // jshint ignore:line\n    log = require('vega-logging'),\n    bound = scene.bound,\n    Bounds = scene.Bounds,\n    Encoder = require('./Encoder');\n\nfunction Bounder(graph, mark) {\n  this._mark = mark;\n  return Node.prototype.init.call(this, graph)\n    .router(true)\n    .reflows(true)\n    .mutates(true);\n}\n\nvar proto = (Bounder.prototype = new Node());\n\nproto.evaluate = function(input) {\n  log.debug(input, ['bounds', this._mark.marktype]);\n\n  var mark  = this._mark,\n      type  = mark.marktype,\n      isGrp = type === 'group',\n      items = mark.items,\n      hasLegends = dl.array(mark.def.legends).length > 0,\n      bounds  = mark.bounds,\n      rebound = !bounds || input.rem.length,\n      i, ilen, j, jlen, group, legend;\n\n  if (type === 'line' || type === 'area') {\n    bound.mark(mark, null, isGrp && !hasLegends);\n  } else {\n    input.add.forEach(function(item) {\n      bound.item(item);\n      rebound = rebound || (bounds && !bounds.encloses(item.bounds));\n    });\n\n    input.mod.forEach(function(item) {\n      rebound = rebound || (bounds && bounds.alignsWith(item.bounds));\n      bound.item(item);\n    });\n\n    if (rebound) {\n      bounds = mark.bounds && mark.bounds.clear() || (mark.bounds = new Bounds());\n      for (i=0, ilen=items.length; i<ilen; ++i) bounds.union(items[i].bounds);\n    }\n  }\n\n  if (isGrp && hasLegends) {\n    for (i=0, ilen=items.length; i<ilen; ++i) {\n      group = items[i];\n      group._legendPositions = null;\n      for (j=0, jlen=group.legendItems.length; j<jlen; ++j) {\n        legend = group.legendItems[j];\n        Encoder.update(this._graph, input.trans, 'legendPosition', legend.items, input.dirty);\n        bound.mark(legend, null, false);\n      }\n    }\n\n    bound.mark(mark, null, true);\n  }\n\n  return df.ChangeSet.create(input, true);\n};\n\nmodule.exports = Bounder;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/scene/Bounder.js\n ** module id = 156\n ** module chunks = 0\n **/","var d3 = require('d3'),\n    dl = require('datalib'),\n    df = require('vega-dataflow'),\n    log = require('vega-logging'),\n    Node = df.Node, // jshint ignore:line\n    Deps = df.Dependencies,\n    Aggregate = require('../transforms/Aggregate');\n\nvar Properties = {\n  width: 1,\n  height: 1\n};\n\nvar Types = {\n  LINEAR: 'linear',\n  ORDINAL: 'ordinal',\n  LOG: 'log',\n  POWER: 'pow',\n  SQRT: 'sqrt',\n  TIME: 'time',\n  TIME_UTC: 'utc',\n  QUANTILE: 'quantile',\n  QUANTIZE: 'quantize',\n  THRESHOLD: 'threshold'\n};\n\nvar DataRef = {\n  DOMAIN: 'domain',\n  RANGE: 'range',\n\n  COUNT: 'count',\n  GROUPBY: 'groupby',\n  MIN: 'min',\n  MAX: 'max',\n  VALUE: 'value',\n\n  ASC: 'asc',\n  DESC: 'desc'\n};\n\nfunction Scale(graph, def, parent) {\n  this._def     = def;\n  this._parent  = parent;\n  this._updated = false;\n  return Node.prototype.init.call(this, graph).reflows(true);\n}\n\nvar proto = (Scale.prototype = new Node());\n\nproto.evaluate = function(input) {\n  var self = this,\n      fn = function(group) { scale.call(self, group); };\n\n  this._updated = false;\n  input.add.forEach(fn);\n  input.mod.forEach(fn);\n\n  // Scales are at the end of an encoding pipeline, so they should forward a\n  // reflow pulse. Thus, if multiple scales update in the parent group, we don't\n  // reevaluate child marks multiple times.\n  if (this._updated) {\n    input.scales[this._def.name] = 1;\n    log.debug(input, [\"scale\", this._def.name]);\n  }\n  return df.ChangeSet.create(input, true);\n};\n\n// All of a scale's dependencies are registered during propagation as we parse\n// dataRefs. So a scale must be responsible for connecting itself to dependents.\nproto.dependency = function(type, deps) {\n  if (arguments.length == 2) {\n    var method = (type === Deps.DATA ? 'data' : 'signal');\n    deps = dl.array(deps);\n    for (var i=0, len=deps.length; i<len; ++i) {\n      this._graph[method](deps[i]).addListener(this._parent);\n    }\n  }\n\n  return Node.prototype.dependency.call(this, type, deps);\n};\n\nfunction scale(group) {\n  var name = this._def.name,\n      prev = name + ':prev',\n      s = instance.call(this, group.scale(name)),\n      m = s.type===Types.ORDINAL ? ordinal : quantitative,\n      rng = range.call(this, group);\n\n  m.call(this, s, rng, group);\n\n  group.scale(name, s);\n  group.scale(prev, group.scale(prev) || s);\n\n  return s;\n}\n\nfunction instance(scale) {\n  var config = this._graph.config(),\n      type = this._def.type || Types.LINEAR;\n  if (!scale || type !== scale.type) {\n    var ctor = config.scale[type] || d3.scale[type];\n    if (!ctor) throw Error('Unrecognized scale type: ' + type);\n    (scale = ctor()).type = scale.type || type;\n    scale.scaleName = this._def.name;\n    scale._prev = {};\n  }\n  return scale;\n}\n\nfunction ordinal(scale, rng, group) {\n  var def = this._def,\n      prev = scale._prev,\n      dataDrivenRange = false,\n      pad = signal.call(this, def.padding) || 0,\n      outer = def.outerPadding == null ? pad : signal.call(this, def.outerPadding),\n      points = def.points && signal.call(this, def.points),\n      round = signal.call(this, def.round) || def.round == null,\n      domain, str, spatial=true;\n\n  // range pre-processing for data-driven ranges\n  if (dl.isObject(def.range) && !dl.isArray(def.range)) {\n    dataDrivenRange = true;\n    rng = dataRef.call(this, DataRef.RANGE, def.range, scale, group);\n  }\n\n  // domain\n  domain = dataRef.call(this, DataRef.DOMAIN, def.domain, scale, group);\n  if (domain && !dl.equal(prev.domain, domain)) {\n    scale.domain(domain);\n    prev.domain = domain;\n    this._updated = true;\n  }\n\n  // range\n  if (!dl.equal(prev.range, rng)) {\n    // width-defined range\n    if (def.bandSize) {\n      var bw = signal.call(this, def.bandSize),\n          len = domain.length,\n          space = def.points ? (pad*bw) : (pad*bw*(len-1) + 2*outer),\n          start;\n      if (rng[0] > rng[1]) {\n        start = rng[1] || 0;\n        rng = [start + (bw * len + space), start];\n      } else {\n        start = rng[0] || 0;\n        rng = [start, start + (bw * len + space)];\n      }\n\n      if (def.reverse) rng = rng.reverse();\n    }\n\n    str = typeof rng[0] === 'string';\n    if (str || rng.length > 2 || rng.length===1 || dataDrivenRange) {\n      scale.range(rng); // color or shape values\n      spatial = false;\n    } else if (points && round) {\n      scale.rangeRoundPoints(rng, pad);\n    } else if (points) {\n      scale.rangePoints(rng, pad);\n    } else if (round) {\n      scale.rangeRoundBands(rng, pad, outer);\n    } else {\n      scale.rangeBands(rng, pad, outer);\n    }\n\n    prev.range = rng;\n    this._updated = true;\n  }\n\n  if (!scale.invert && spatial) invertOrdinal(scale);\n}\n\n// \"Polyfill\" ordinal scale inversion. Currently, only ordinal scales\n// with ordered numeric ranges are supported.\nvar bisect = d3.bisector(dl.numcmp).right,\n    findAsc = function(a, x) { return bisect(a,x) - 1; },\n    findDsc = d3.bisector(function(a,b) { return -1 * dl.numcmp(a,b); }).left;\n\nfunction invertOrdinal(scale) {\n  scale.invert = function(x, y) {\n    var rng = scale.range(),\n        asc = rng[0] < rng[1],\n        find = asc ? findAsc : findDsc;\n\n    if (arguments.length === 1) {\n      if (!dl.isNumber(x)) {\n        throw Error('Ordinal scale inversion is only supported for numeric input ('+x+').');\n      }\n      return scale.domain()[find(rng, x)];\n\n    } else if (arguments.length === 2) {  // Invert extents\n      if (!dl.isNumber(x) || !dl.isNumber(y)) {\n        throw Error('Extents to ordinal invert are not numbers ('+x+', '+y+').');\n      }\n\n      var domain = scale.domain(),\n          a = find(rng, x),\n          b = find(rng, y),\n          n = rng.length - 1, r;\n      if (b < a) { r = a; a = b; b = a; } // ensure a <= b\n      if (a < 0) a = 0;\n      if (b > n) b = n;\n\n      return (asc ? dl.range(a, b+1) : dl.range(b, a-1, -1))\n        .map(function(i) { return domain[i]; });\n    }\n  };\n}\n\nfunction quantitative(scale, rng, group) {\n  var def = this._def,\n      prev = scale._prev,\n      round = signal.call(this, def.round),\n      exponent = signal.call(this, def.exponent),\n      clamp = signal.call(this, def.clamp),\n      nice = signal.call(this, def.nice),\n      domain, interval;\n\n  // domain\n  domain = (def.type === Types.QUANTILE) ?\n    dataRef.call(this, DataRef.DOMAIN, def.domain, scale, group) :\n    domainMinMax.call(this, scale, group);\n  if (domain && !dl.equal(prev.domain, domain)) {\n    scale.domain(domain);\n    prev.domain = domain;\n    this._updated = true;\n  }\n\n  // range\n  // vertical scales should flip by default, so use XOR here\n  if (signal.call(this, def.range) === 'height') rng = rng.reverse();\n  if (rng && !dl.equal(prev.range, rng)) {\n    scale[round && scale.rangeRound ? 'rangeRound' : 'range'](rng);\n    prev.range = rng;\n    this._updated = true;\n  }\n\n  if (exponent && def.type===Types.POWER) scale.exponent(exponent);\n  if (clamp) scale.clamp(true);\n  if (nice) {\n    if (def.type === Types.TIME) {\n      interval = d3.time[nice];\n      if (!interval) log.error('Unrecognized interval: ' + interval);\n      scale.nice(interval);\n    } else {\n      scale.nice();\n    }\n  }\n}\n\nfunction isUniques(scale) {\n  return scale.type === Types.ORDINAL || scale.type === Types.QUANTILE;\n}\n\nfunction getRefs(def) {\n  return def.fields || dl.array(def);\n}\n\nfunction inherits(refs) {\n  return refs.some(function(r) {\n    if (!r.data) return true;\n    return r.data && dl.array(r.field).some(function(f) {\n      return f.parent;\n    });\n  });\n}\n\nfunction getFields(ref, group) {\n  return dl.array(ref.field).map(function(f) {\n    return f.parent ?\n      dl.accessor(f.parent)(group.datum) :\n      f; // String or {'signal'}\n  });\n}\n\n// Scale datarefs can be computed over multiple schema types.\n// This function determines the type of aggregator created, and\n// what data is sent to it: values, tuples, or multi-tuples that must\n// be standardized into a consistent schema.\nfunction aggrType(def, scale) {\n  var refs = getRefs(def);\n\n  // If we're operating over only a single domain, send full tuples\n  // through for efficiency (fewer accessor creations/calls)\n  if (refs.length == 1 && dl.array(refs[0].field).length == 1) {\n    return Aggregate.TYPES.TUPLE;\n  }\n\n  // With quantitative scales, we only care about min/max.\n  if (!isUniques(scale)) return Aggregate.TYPES.VALUE;\n\n  // If we don't sort, then we can send values directly to aggrs as well\n  if (!dl.isObject(def.sort)) return Aggregate.TYPES.VALUE;\n\n  return Aggregate.TYPES.MULTI;\n}\n\nfunction getCache(which, def, scale, group) {\n  var refs = getRefs(def),\n      inherit = inherits(refs),\n      atype = aggrType(def, scale),\n      uniques = isUniques(scale),\n      sort = def.sort,\n      ck = '_'+which,\n      fields = getFields(refs[0], group);\n\n  if (scale[ck] || this[ck]) return scale[ck] || this[ck];\n\n  var cache = new Aggregate(this._graph).type(atype),\n      groupby, summarize;\n\n  // If a scale's dataref doesn't inherit data from the group, we can\n  // store the dataref aggregator at the Scale (dataflow node) level.\n  if (inherit) {\n    scale[ck] = cache;\n  } else {\n    this[ck]  = cache;\n  }\n\n  if (uniques) {\n    if (atype === Aggregate.TYPES.VALUE) {\n      groupby = [{ name: DataRef.GROUPBY, get: dl.identity }];\n      summarize = {'*': DataRef.COUNT};\n    } else if (atype === Aggregate.TYPES.TUPLE) {\n      groupby = [{ name: DataRef.GROUPBY, get: dl.$(fields[0]) }];\n      summarize = dl.isObject(sort) ? [{\n        field: DataRef.VALUE,\n        get:  dl.$(sort.field),\n        ops: [sort.op]\n      }] : {'*': DataRef.COUNT};\n    } else {  // atype === Aggregate.TYPES.MULTI\n      groupby   = DataRef.GROUPBY;\n      summarize = [{ field: DataRef.VALUE, ops: [sort.op] }];\n    }\n  } else {\n    groupby = [];\n    summarize = [{\n      field: DataRef.VALUE,\n      get: (atype == Aggregate.TYPES.TUPLE) ? dl.$(fields[0]) : dl.identity,\n      ops: [DataRef.MIN, DataRef.MAX],\n      as:  [DataRef.MIN, DataRef.MAX]\n    }];\n  }\n\n  cache.param('groupby', groupby)\n    .param('summarize', summarize);\n\n  return (cache._lastUpdate = -1, cache);\n}\n\nfunction dataRef(which, def, scale, group) {\n  if (def == null) { return []; }\n  if (dl.isArray(def)) return def.map(signal.bind(this));\n\n  var self = this, graph = this._graph,\n      refs = getRefs(def),\n      inherit = inherits(refs),\n      atype = aggrType(def, scale),\n      cache = getCache.apply(this, arguments),\n      sort  = def.sort,\n      uniques = isUniques(scale),\n      i, rlen, j, flen, ref, fields, field, data, from, cmp;\n\n  function addDep(s) {\n    self.dependency(Deps.SIGNALS, s);\n  }\n\n  if (inherit || (!inherit && cache._lastUpdate < this._stamp)) {\n    for (i=0, rlen=refs.length; i<rlen; ++i) {\n      ref = refs[i];\n      from = ref.data || group.datum._facetID;\n      data = graph.data(from).last();\n\n      if (data.stamp <= this._stamp) continue;\n\n      fields = getFields(ref, group);\n      for (j=0, flen=fields.length; j<flen; ++j) {\n        field = fields[j];\n\n        if (atype === Aggregate.TYPES.VALUE) {\n          cache.accessors(null, field);\n        } else if (atype === Aggregate.TYPES.MULTI) {\n          cache.accessors(field, ref.sort || sort.field);\n        } // Else (Tuple-case) is handled by the aggregator accessors by default\n\n        cache.evaluate(data);\n      }\n\n      this.dependency(Deps.DATA, from);\n      cache.dependency(Deps.SIGNALS).forEach(addDep);\n    }\n\n    cache._lastUpdate = this._stamp;\n\n    data = cache.aggr().result();\n    if (uniques) {\n      if (dl.isObject(sort)) {\n        cmp = sort.op + '_' + DataRef.VALUE;\n        cmp = dl.comparator(cmp);\n      } else if (sort === true) {\n        cmp = dl.comparator(DataRef.GROUPBY);\n      }\n\n      if (cmp) data = data.sort(cmp);\n      cache._values = data.map(function(d) { return d[DataRef.GROUPBY]; });\n    } else {\n      data = data[0];\n      cache._values = !dl.isValid(data) ? [] : [data[DataRef.MIN], data[DataRef.MAX]];\n    }\n  }\n\n  return cache._values;\n}\n\nfunction signal(v) {\n  if (!v || !v.signal) return v;\n  var s = v.signal, ref;\n  this.dependency(Deps.SIGNALS, (ref = dl.field(s))[0]);\n  return this._graph.signalRef(ref);\n}\n\nfunction domainMinMax(scale, group) {\n  var def = this._def,\n      domain = [null, null], s, z;\n\n  if (def.domain !== undefined) {\n    domain = (!dl.isObject(def.domain)) ? domain :\n      dataRef.call(this, DataRef.DOMAIN, def.domain, scale, group);\n  }\n\n  z = domain.length - 1;\n  if (def.domainMin !== undefined) {\n    if (dl.isObject(def.domainMin)) {\n      if (def.domainMin.signal) {\n        domain[0] = dl.isValid(s=signal.call(this, def.domainMin)) ? s : domain[0];\n      } else {\n        domain[0] = dataRef.call(this, DataRef.DOMAIN+DataRef.MIN, def.domainMin, scale, group)[0];\n      }\n    } else {\n      domain[0] = def.domainMin;\n    }\n  }\n  if (def.domainMax !== undefined) {\n    if (dl.isObject(def.domainMax)) {\n      if (def.domainMax.signal) {\n        domain[z] = dl.isValid(s=signal.call(this, def.domainMax)) ? s : domain[z];\n      } else {\n        domain[z] = dataRef.call(this, DataRef.DOMAIN+DataRef.MAX, def.domainMax, scale, group)[1];\n      }\n    } else {\n      domain[z] = def.domainMax;\n    }\n  }\n  if (def.type !== Types.LOG && def.type !== Types.TIME && (def.zero || def.zero===undefined)) {\n    domain[0] = Math.min(0, domain[0]);\n    domain[z] = Math.max(0, domain[z]);\n  }\n  return domain;\n}\n\nfunction range(group) {\n  var def = this._def,\n      config = this._graph.config(),\n      rangeVal = signal.call(this, def.range),\n      rng = [null, null];\n\n  if (rangeVal !== undefined) {\n    if (typeof rangeVal === 'string') {\n      if (Properties[rangeVal]) {\n        rng = [0, group[rangeVal]];\n      } else if (config.range[rangeVal]) {\n        rng = config.range[rangeVal];\n      } else {\n        log.error('Unrecogized range: ' + rangeVal);\n        return rng;\n      }\n    } else if (dl.isArray(rangeVal)) {\n      rng = dl.duplicate(rangeVal).map(signal.bind(this));\n    } else if (dl.isObject(rangeVal)) {\n      return null; // early exit\n    } else {\n      rng = [0, rangeVal];\n    }\n  }\n  if (def.rangeMin !== undefined) {\n    rng[0] = def.rangeMin.signal ?\n      signal.call(this, def.rangeMin) :\n      def.rangeMin;\n  }\n  if (def.rangeMax !== undefined) {\n    rng[rng.length-1] = def.rangeMax.signal ?\n      signal.call(this, def.rangeMax) :\n      def.rangeMax;\n  }\n\n  if (def.reverse !== undefined) {\n    var rev = signal.call(this, def.reverse);\n    if (dl.isObject(rev)) {\n      rev = dl.accessor(rev.field)(group.datum);\n    }\n    if (rev) rng = rng.reverse();\n  }\n\n  return rng;\n}\n\nmodule.exports = Scale;\n\nvar rangeDef = [\n  {\"enum\": [\"width\", \"height\", \"shapes\", \"category10\", \"category20\", \"category20b\", \"category20c\"]},\n  {\n    \"type\": \"array\",\n    \"items\": {\"oneOf\": [{\"type\":\"string\"}, {\"type\": \"number\"}, {\"$ref\": \"#/refs/signal\"}]}\n  },\n  {\"$ref\": \"#/refs/signal\"}\n];\n\nScale.schema = {\n  \"refs\": {\n    \"data\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"data\": {\n          \"oneOf\": [\n            {\"type\": \"string\"},\n            {\n              \"type\": \"object\",\n              \"properties\": {\n                \"fields\": {\n                  \"type\": \"array\",\n                  \"items\": {\"$ref\": \"#/refs/data\"}\n                }\n              },\n              \"required\": [\"fields\"]\n            }\n          ]\n        },\n        \"field\": {\n          \"oneOf\": [\n            {\"type\": \"string\"},\n            {\n              \"type\": \"array\",\n              \"items\": {\"type\": \"string\"}\n            },\n            {\n              \"type\": \"object\",\n              \"properties\": {\n                \"parent\": {\"type\": \"string\"}\n              },\n              \"required\": [\"parent\"]\n            },\n            {\n              \"type\": \"array\",\n              \"items\": {\n                \"type\": \"object\",\n                \"properties\": {\n                  \"parent\": {\"type\": \"string\"}\n                },\n                \"required\": [\"parent\"]\n              }\n            }\n          ]\n        },\n        \"sort\": {\n          \"oneOf\": [{\"type\": \"boolean\"}, {\n            \"type\": \"object\",\n            \"properties\": {\n              \"field\": {\"type\": \"string\"},\n              \"op\": {\"enum\": require('../transforms/Aggregate').VALID_OPS}\n            }\n          }]\n        }\n      },\n      \"additionalProperties\": false\n    }\n  },\n\n  \"defs\": {\n    \"scale\": {\n      \"title\": \"Scale function\",\n      \"type\": \"object\",\n\n      \"allOf\": [{\n        \"properties\": {\n          \"name\": {\"type\": \"string\"},\n\n          \"type\": {\n            \"enum\": [Types.LINEAR, Types.ORDINAL, Types.TIME, Types.TIME_UTC, Types.LOG,\n              Types.POWER, Types.SQRT, Types.QUANTILE, Types.QUANTIZE, Types.THRESHOLD],\n            \"default\": Types.LINEAR\n          },\n\n          \"domain\": {\n            \"oneOf\": [\n              {\n                \"type\": \"array\",\n                \"items\": {\n                  \"oneOf\": [\n                    {\"type\":\"string\"},\n                    {\"type\": \"number\"},\n                    {\"$ref\": \"#/refs/signal\"}\n                  ]\n                }\n              },\n              {\"$ref\": \"#/refs/data\"},\n              {\n                \"type\": \"object\",\n                \"properties\": {\n                  \"fields\": {\n                    \"type\": \"array\",\n                    \"items\": {\"$ref\": \"#/refs/data\"}\n                  }\n                },\n                \"required\": [\"fields\"],\n              }\n            ]\n          },\n\n          \"domainMin\": {\n            \"oneOf\": [\n              {\"type\": \"number\"},\n              {\"$ref\": \"#/refs/data\"},\n              {\"$ref\": \"#/refs/signal\"}\n            ]\n          },\n\n          \"domainMax\": {\n            \"oneOf\": [\n              {\"type\": \"number\"},\n              {\"$ref\": \"#/refs/data\"},\n              {\"$ref\": \"#/refs/signal\"}\n            ]\n          },\n\n          \"rangeMin\": {\n            \"oneOf\": [\n              {\"type\":\"string\"},\n              {\"type\": \"number\"},\n              {\"$ref\": \"#/refs/signal\"}\n            ]\n          },\n\n          \"rangeMax\": {\n            \"oneOf\": [\n              {\"type\":\"string\"},\n              {\"type\": \"number\"},\n              {\"$ref\": \"#/refs/signal\"}\n            ]\n          },\n\n          \"reverse\": {\n            \"oneOf\": [\n              {\"type\": \"boolean\"},\n              {\"$ref\": \"#/refs/data\"}\n            ],\n          },\n          \"round\": {\"type\": \"boolean\"}\n        },\n\n        \"required\": [\"name\"]\n      }, {\n        \"oneOf\": [{\n          \"properties\": {\n            \"type\": {\"enum\": [Types.ORDINAL]},\n\n            \"range\": {\n              \"oneOf\": rangeDef.concat({\"$ref\": \"#/refs/data\"})\n            },\n\n            \"points\": {\"oneOf\": [{\"type\": \"boolean\"}, {\"$ref\": \"#/refs/signal\"}]},\n            \"padding\": {\"oneOf\": [{\"type\": \"number\"}, {\"$ref\": \"#/refs/signal\"}]},\n            \"outerPadding\": {\"oneOf\": [{\"type\": \"number\"}, {\"$ref\": \"#/refs/signal\"}]},\n            \"bandSize\": {\"oneOf\": [{\"type\": \"number\"}, {\"$ref\": \"#/refs/signal\"}]}\n          },\n          \"required\": [\"type\"]\n        }, {\n          \"properties\": {\n            \"type\": {\"enum\": [Types.TIME, Types.TIME_UTC]},\n            \"range\": {\"oneOf\": rangeDef},\n            \"clamp\": {\"oneOf\": [{\"type\": \"boolean\"}, {\"$ref\": \"#/refs/signal\"}]},\n            \"nice\": {\"oneOf\": [{\"enum\": [\"second\", \"minute\", \"hour\",\n              \"day\", \"week\", \"month\", \"year\"]}, {\"$ref\": \"#/refs/signal\"}]}\n          },\n          \"required\": [\"type\"]\n        }, {\n          \"anyOf\": [{\n            \"properties\": {\n              \"type\": {\"enum\": [Types.LINEAR, Types.LOG, Types.POWER, Types.SQRT,\n                Types.QUANTILE, Types.QUANTIZE, Types.THRESHOLD], \"default\": Types.LINEAR},\n              \"range\": {\"oneOf\": rangeDef},\n              \"clamp\": {\"oneOf\": [{\"type\": \"boolean\"}, {\"$ref\": \"#/refs/signal\"}]},\n              \"nice\": {\"oneOf\": [{\"type\": \"boolean\"}, {\"$ref\": \"#/refs/signal\"}]},\n              \"zero\": {\"oneOf\": [{\"type\": \"boolean\"}, {\"$ref\": \"#/refs/signal\"}]}\n            }\n          }, {\n            \"properties\": {\n              \"type\": {\"enum\": [Types.POWER]},\n              \"exponent\": {\"oneOf\": [{\"type\": \"number\"}, {\"$ref\": \"#/refs/signal\"}]}\n            },\n            \"required\": [\"type\"]\n          }]\n        }]\n      }]\n    }\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/scene/Scale.js\n ** module id = 157\n ** module chunks = 0\n **/","module.exports = function visit(node, func) {\n  var i, n, s, m, items;\n  if (func(node)) return true;\n\n  var sets = ['items', 'axisItems', 'legendItems'];\n  for (s=0, m=sets.length; s<m; ++s) {\n    if ((items = node[sets[s]])) {\n      for (i=0, n=items.length; i<n; ++i) {\n        if (visit(items[i], func)) return true;\n      }\n    }\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/scene/visit.js\n ** module id = 158\n ** module chunks = 0\n **/","var d3 = require('d3'),\n    config = {};\n\nconfig.load = {\n  // base url for loading external data files\n  // used only for server-side operation\n  baseURL: '',\n  // Allows domain restriction when using data loading via XHR.\n  // To enable, set it to a list of allowed domains\n  // e.g., ['wikipedia.org', 'eff.org']\n  domainWhiteList: false\n};\n\n// inset padding for automatic padding calculation\nconfig.autopadInset = 5;\n\n// extensible scale lookup table\n// all d3.scale.* instances also supported\nconfig.scale = {\n  time: d3.time.scale,\n  utc:  d3.time.scale.utc\n};\n\n// default rendering settings\nconfig.render = {\n  retina: true\n};\n\n// root scenegraph group\nconfig.scene = {\n  fill: undefined,\n  fillOpacity: undefined,\n  stroke: undefined,\n  strokeOpacity: undefined,\n  strokeWidth: undefined,\n  strokeDash: undefined,\n  strokeDashOffset: undefined\n};\n\n// default axis properties\nconfig.axis = {\n  orient: 'bottom',\n  ticks: 10,\n  padding: 3,\n  axisColor: '#000',\n  axisWidth: 1,\n  gridColor: '#000',\n  gridOpacity: 0.15,\n  tickColor: '#000',\n  tickLabelColor: '#000',\n  tickWidth: 1,\n  tickSize: 6,\n  tickLabelFontSize: 11,\n  tickLabelFont: 'sans-serif',\n  titleColor: '#000',\n  titleFont: 'sans-serif',\n  titleFontSize: 11,\n  titleFontWeight: 'bold',\n  titleOffset: 'auto',\n  titleOffsetAutoMin: 30,\n  titleOffsetAutoMax: Infinity,\n  titleOffsetAutoMargin: 4\n};\n\n// default legend properties\nconfig.legend = {\n  orient: 'right',\n  offset: 20,\n  padding: 3, // padding between legend items and border\n  margin: 2,  // extra margin between two consecutive legends\n  gradientStrokeColor: '#888',\n  gradientStrokeWidth: 1,\n  gradientHeight: 16,\n  gradientWidth: 100,\n  labelColor: '#000',\n  labelFontSize: 10,\n  labelFont: 'sans-serif',\n  labelAlign: 'left',\n  labelBaseline: 'middle',\n  labelOffset: 8,\n  symbolShape: 'circle',\n  symbolSize: 50,\n  symbolColor: '#888',\n  symbolStrokeWidth: 1,\n  titleColor: '#000',\n  titleFont: 'sans-serif',\n  titleFontSize: 11,\n  titleFontWeight: 'bold'\n};\n\n// default color values\nconfig.color = {\n  rgb: [128, 128, 128],\n  lab: [50, 0, 0],\n  hcl: [0, 0, 50],\n  hsl: [0, 0, 0.5]\n};\n\n// default scale ranges\nconfig.range = {\n  category10:  d3.scale.category10().range(),\n  category20:  d3.scale.category20().range(),\n  category20b: d3.scale.category20b().range(),\n  category20c: d3.scale.category20c().range(),\n  shapes: [\n    'circle',\n    'cross',\n    'diamond',\n    'square',\n    'triangle-down',\n    'triangle-up'\n  ]\n};\n\nmodule.exports = config;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/core/config.js\n ** module id = 159\n ** module chunks = 0\n **/","var d3 = require('d3'),\n    dl = require('datalib'),\n    df = require('vega-dataflow'),\n    sg = require('vega-scenegraph').render,\n    log = require('vega-logging'),\n    Deps = df.Dependencies,\n    parseStreams = require('../parse/streams'),\n    Encoder = require('../scene/Encoder'),\n    Transition = require('../scene/Transition');\n\nfunction View(el, width, height) {\n  this._el    = null;\n  this._model = null;\n  this._width   = this.__width = width || 500;\n  this._height  = this.__height = height || 300;\n  this._bgcolor = null;\n  this._cursor  = true; // Set cursor based on hover propset?\n  this._autopad = 1;\n  this._padding = {top:0, left:0, bottom:0, right:0};\n  this._viewport = null;\n  this._renderer = null;\n  this._handler  = null;\n  this._streamer = null; // Targeted update for streaming changes\n  this._skipSignals = false; // Batch set signals can skip reevaluation.\n  this._changeset = null;\n  this._repaint = true; // Full re-render on every re-init\n  this._renderers = sg;\n  this._io  = null;\n  this._api = {}; // Stash streaming data API sandboxes.\n}\n\nvar prototype = View.prototype;\n\nprototype.model = function(model) {\n  if (!arguments.length) return this._model;\n  if (this._model !== model) {\n    this._model = model;\n    this._streamer = new df.Node(model);\n    this._streamer._rank = -1;  // HACK: To reduce re-ranking churn.\n    this._changeset = df.ChangeSet.create();\n    if (this._handler) this._handler.model(model);\n  }\n  return this;\n};\n\n// Sandboxed streaming data API\nfunction streaming(src) {\n  var view = this,\n      ds = this._model.data(src);\n  if (!ds) return log.error('Data source \"'+src+'\" is not defined.');\n\n  var listener = ds.pipeline()[0],\n      streamer = this._streamer,\n      api = {};\n\n  // If we have it stashed, don't create a new closure.\n  if (this._api[src]) return this._api[src];\n\n  api.insert = function(vals) {\n    ds.insert(dl.duplicate(vals));  // Don't pollute the environment\n    streamer.addListener(listener);\n    view._changeset.data[src] = 1;\n    return api;\n  };\n\n  api.update = function() {\n    streamer.addListener(listener);\n    view._changeset.data[src] = 1;\n    return (ds.update.apply(ds, arguments), api);\n  };\n\n  api.remove = function() {\n    streamer.addListener(listener);\n    view._changeset.data[src] = 1;\n    return (ds.remove.apply(ds, arguments), api);\n  };\n\n  api.values = function() { return ds.values(); };\n\n  return (this._api[src] = api);\n}\n\nprototype.data = function(data) {\n  var v = this;\n  if (!arguments.length) return v._model.values();\n  else if (dl.isString(data)) return streaming.call(v, data);\n  else if (dl.isObject(data)) {\n    dl.keys(data).forEach(function(k) {\n      var api = streaming.call(v, k);\n      data[k](api);\n    });\n  }\n  return this;\n};\n\nvar VIEW_SIGNALS = dl.toMap(['width', 'height', 'padding']);\n\nprototype.signal = function(name, value, skip) {\n  var m = this._model,\n      key, values;\n\n  // Getter. Returns the value for the specified signal, or\n  // returns all signal values.\n  if (!arguments.length) {\n    return m.values(Deps.SIGNALS);\n  } else if (arguments.length === 1 && dl.isString(name)) {\n    return m.values(Deps.SIGNALS, name);\n  }\n\n  // Setter. Can be done in batch or individually. In either case,\n  // the final argument determines if set signals should be skipped.\n  if (dl.isObject(name)) {\n    values = name;\n    skip = value;\n  } else {\n    values = {};\n    values[name] = value;\n  }\n  for (key in values) {\n    if (VIEW_SIGNALS[key]) {\n      this[key](values[key]);\n    } else {\n      setSignal.call(this, key, values[key]);\n    }\n  }\n  return (this._skipSignals = skip, this);\n};\n\nfunction setSignal(name, value) {\n  var cs = this._changeset,\n      sg = this._model.signal(name);\n  if (!sg) return log.error('Signal \"'+name+'\" is not defined.');\n\n  this._streamer.addListener(sg.value(value));\n  cs.signals[name] = 1;\n  cs.reflow = true;\n}\n\nprototype.width = function(width) {\n  if (!arguments.length) return this.__width;\n  if (this.__width !== width) {\n    this._width = this.__width = width;\n    this.model().width(width);\n    this.initialize();\n    if (this._strict) this._autopad = 1;\n    setSignal.call(this, 'width', width);\n  }\n  return this;\n};\n\nprototype.height = function(height) {\n  if (!arguments.length) return this.__height;\n  if (this.__height !== height) {\n    this._height = this.__height = height;\n    this.model().height(height);\n    this.initialize();\n    if (this._strict) this._autopad = 1;\n    setSignal.call(this, 'height', height);\n  }\n  return this;\n};\n\nprototype.background = function(bgcolor) {\n  if (!arguments.length) return this._bgcolor;\n  if (this._bgcolor !== bgcolor) {\n    this._bgcolor = bgcolor;\n    this.initialize();\n  }\n  return this;\n};\n\nprototype.padding = function(pad) {\n  if (!arguments.length) return this._padding;\n  if (this._padding !== pad) {\n    if (dl.isString(pad)) {\n      this._autopad = 1;\n      this._padding = {top:0, left:0, bottom:0, right:0};\n      this._strict = (pad === 'strict');\n    } else {\n      this._autopad = 0;\n      this._padding = pad;\n      this._strict = false;\n    }\n    if (this._renderer) this._renderer.resize(this._width, this._height, this._padding);\n    if (this._handler)  this._handler.padding(this._padding);\n    setSignal.call(this, 'padding', this._padding);\n  }\n  return (this._repaint = true, this);\n};\n\nprototype.autopad = function(opt) {\n  if (this._autopad < 1) return this;\n  else this._autopad = 0;\n\n  var b = this.model().scene().bounds,\n      pad = this._padding,\n      config = this.model().config(),\n      inset = config.autopadInset,\n      l = b.x1 < 0 ? Math.ceil(-b.x1) + inset : 0,\n      t = b.y1 < 0 ? Math.ceil(-b.y1) + inset : 0,\n      r = b.x2 > this._width  ? Math.ceil(+b.x2 - this._width) + inset : 0;\n  b = b.y2 > this._height ? Math.ceil(+b.y2 - this._height) + inset : 0;\n  pad = {left:l, top:t, right:r, bottom:b};\n\n  if (this._strict) {\n    this._autopad = 0;\n    this._padding = pad;\n    this._width = Math.max(0, this.__width - (l+r));\n    this._height = Math.max(0, this.__height - (t+b));\n\n    this._model.width(this._width).height(this._height).reset();\n    setSignal.call(this, 'width', this._width);\n    setSignal.call(this, 'height', this._height);\n    setSignal.call(this, 'padding', pad);\n\n    this.initialize().update({props:'enter'}).update({props:'update'});\n  } else {\n    this.padding(pad).update(opt);\n  }\n  return this;\n};\n\nprototype.viewport = function(size) {\n  if (!arguments.length) return this._viewport;\n  if (this._viewport !== size) {\n    this._viewport = size;\n    this.initialize();\n  }\n  return this;\n};\n\nprototype.renderer = function(type) {\n  if (!arguments.length) return this._renderer;\n  if (this._renderers[type]) type = this._renderers[type];\n  else if (dl.isString(type)) throw new Error('Unknown renderer: ' + type);\n  else if (!type) throw new Error('No renderer specified');\n\n  if (this._io !== type) {\n    this._io = type;\n    this._renderer = null;\n    this.initialize();\n    if (this._build) this.render();\n  }\n  return this;\n};\n\nprototype.initialize = function(el) {\n  var v = this, prevHandler,\n      w = v._width, h = v._height, pad = v._padding, bg = v._bgcolor,\n      config = this.model().config();\n\n  if (!arguments.length || el === null) {\n    el = this._el ? this._el.parentNode : null;\n    if (!el) return this;  // This View cannot init w/o an\n  }\n\n  // clear pre-existing container\n  d3.select(el).select('div.vega').remove();\n\n  // add div container\n  this._el = el = d3.select(el)\n    .append('div')\n    .attr('class', 'vega')\n    .style('position', 'relative')\n    .node();\n  if (v._viewport) {\n    d3.select(el)\n      .style('width',  (v._viewport[0] || w)+'px')\n      .style('height', (v._viewport[1] || h)+'px')\n      .style('overflow', 'auto');\n  }\n\n  // renderer\n  sg.canvas.Renderer.RETINA = config.render.retina;\n  v._renderer = (v._renderer || new this._io.Renderer(config.load))\n    .initialize(el, w, h, pad)\n    .background(bg);\n\n  // input handler\n  prevHandler = v._handler;\n  v._handler = new this._io.Handler()\n    .initialize(el, pad, v);\n\n  if (prevHandler) {\n    prevHandler.handlers().forEach(function(h) {\n      v._handler.on(h.type, h.handler);\n    });\n  } else {\n    // Register event listeners for signal stream definitions.\n    v._detach = parseStreams(this);\n  }\n\n  return (this._repaint = true, this);\n};\n\nprototype.destroy = function() {\n  if (this._detach) this._detach();\n};\n\nfunction build() {\n  var v = this;\n  v._renderNode = new df.Node(v._model)\n    .router(true);\n\n  v._renderNode.evaluate = function(input) {\n    log.debug(input, ['rendering']);\n\n    var s = v._model.scene(),\n        h = v._handler;\n\n    if (h && h.scene) h.scene(s);\n\n    if (input.trans) {\n      input.trans.start(function(items) { v._renderer.render(s, items); });\n    } else if (v._repaint) {\n      v._renderer.render(s);\n    } else if (input.dirty.length) {\n      v._renderer.render(s, input.dirty);\n    }\n\n    if (input.dirty.length) {\n      input.dirty.forEach(function(i) { i._dirty = false; });\n      s.items[0]._dirty = false;\n    }\n\n    v._repaint = v._skipSignals = false;\n    return input;\n  };\n\n  return (v._model.scene(v._renderNode), true);\n}\n\nprototype.update = function(opt) {\n  opt = opt || {};\n  var v = this,\n      model = this._model,\n      streamer = this._streamer,\n      cs = this._changeset,\n      trans = opt.duration ? new Transition(opt.duration, opt.ease) : null;\n\n  if (trans) cs.trans = trans;\n  if (opt.props !== undefined) {\n    if (dl.keys(cs.data).length > 0) {\n      throw Error(\n        'New data values are not reflected in the visualization.' +\n        ' Please call view.update() before updating a specified property set.'\n      );\n    }\n\n    cs.reflow  = true;\n    cs.request = opt.props;\n  }\n\n  var built = v._build;\n  v._build = v._build || build.call(this);\n\n  // If specific items are specified, short-circuit dataflow graph.\n  // Else-If there are streaming updates, perform a targeted propagation.\n  // Otherwise, re-evaluate the entire model (datasources + scene).\n  if (opt.items && built) {\n    Encoder.update(model, opt.trans, opt.props, opt.items, cs.dirty);\n    v._renderNode.evaluate(cs);\n  } else if (streamer.listeners().length && built) {\n    // Include re-evaluation entire model when repaint flag is set\n    if (this._repaint) streamer.addListener(model.node());\n    model.propagate(cs, streamer, null, this._skipSignals);\n    streamer.disconnect();\n  } else {\n    model.fire(cs);\n  }\n\n  v._changeset = df.ChangeSet.create();\n\n  return v.autopad(opt);\n};\n\nprototype.toImageURL = function(type) {\n  var v = this, Renderer;\n\n  // lookup appropriate renderer\n  switch (type || 'png') {\n    case 'canvas':\n    case 'png':\n      Renderer = sg.canvas.Renderer; break;\n    case 'svg':\n      Renderer = sg.svg.string.Renderer; break;\n    default: throw Error('Unrecognized renderer type: ' + type);\n  }\n\n  var retina = sg.canvas.Renderer.RETINA;\n  sg.canvas.Renderer.RETINA = false; // ignore retina screen\n\n  // render the scenegraph\n  var ren = new Renderer(v._model.config.load)\n    .initialize(null, v._width, v._height, v._padding)\n    .background(v._bgcolor)\n    .render(v._model.scene());\n\n  sg.canvas.Renderer.RETINA = retina; // restore retina settings\n\n  // return data url\n  if (type === 'svg') {\n    var blob = new Blob([ren.svg()], {type: 'image/svg+xml'});\n    return window.URL.createObjectURL(blob);\n  } else {\n    return ren.canvas().toDataURL('image/png');\n  }\n};\n\nprototype.render = function(items) {\n  this._renderer.render(this._model.scene(), items);\n  return this;\n};\n\nprototype.on = function() {\n  this._handler.on.apply(this._handler, arguments);\n  return this;\n};\n\nprototype.onSignal = function(name, handler) {\n  var sg = this._model.signal(name);\n  return (sg ?\n    sg.on(handler) : log.error('Signal \"'+name+'\" is not defined.'), this);\n};\n\nprototype.off = function() {\n  this._handler.off.apply(this._handler, arguments);\n  return this;\n};\n\nprototype.offSignal = function(name, handler) {\n  var sg = this._model.signal(name);\n  return (sg ?\n    sg.off(handler) : log.error('Signal \"'+name+'\" is not defined.'), this);\n};\n\nView.factory = function(model) {\n  var HeadlessView = require('./HeadlessView');\n  return function(opt) {\n    opt = opt || {};\n    var defs = model.defs();\n    var v = (opt.el ? new View() : new HeadlessView())\n      .model(model)\n      .renderer(opt.renderer || 'canvas')\n      .width(defs.width)\n      .height(defs.height)\n      .background(defs.background)\n      .padding(defs.padding)\n      .viewport(defs.viewport)\n      .initialize(opt.el);\n\n    if (opt.data) v.data(opt.data);\n\n    // Register handlers for the hover propset and cursors.\n    if (opt.el) {\n      if (opt.hover !== false) {\n        v.on('mouseover', function(evt, item) {\n          if (item && item.hasPropertySet('hover')) {\n            this.update({props:'hover', items:item});\n          }\n        })\n        .on('mouseout', function(evt, item) {\n          if (item && item.hasPropertySet('hover')) {\n            this.update({props:'update', items:item});\n          }\n        });\n      }\n\n      if (opt.cursor !== false) {\n        // If value is a string, it is a custom value set by the user.\n        // In this case, the user is responsible for maintaining the cursor state\n        // and control only reverts back to this handler if set back to 'default'.\n        v.onSignal('cursor', function(name, value) {\n          var body = d3.select('body');\n          if (dl.isString(value)) {\n            v._cursor = value === 'default';\n            body.style('cursor', value);\n          } else if (dl.isObject(value) && v._cursor) {\n            body.style('cursor', value.default);\n          }\n        });\n      }\n    }\n\n    return v;\n  };\n};\n\nmodule.exports = View;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/core/View.js\n ** module id = 160\n ** module chunks = 0\n **/","var d3 = require('d3'),\n    dl = require('datalib'),\n    df = require('vega-dataflow'),\n    selector = require('vega-event-selector'),\n    parseSignals = require('./signals');\n\nvar GATEKEEPER = '_vgGATEKEEPER',\n    EVALUATOR  = '_vgEVALUATOR';\n\nvar vgEvent = {\n  getItem: function() { return this.item; },\n  getGroup: function(name) { return name ? this.name[name] : this.group; },\n  getXY: function(item) {\n      var p = {x: this.x, y: this.y};\n      if (typeof item === 'string') {\n        item = this.name[item];\n      }\n      for (; item; item = item.mark && item.mark.group) {\n        p.x -= item.x || 0;\n        p.y -= item.y || 0;\n      }\n      return p;\n    },\n  getX: function(item) { return this.getXY(item).x; },\n  getY: function(item) { return this.getXY(item).y; }\n};\n\nfunction parseStreams(view) {\n  var model = view.model(),\n      trueFn  = model.expr('true'),\n      falseFn = model.expr('false'),\n      spec    = model.defs().signals,\n      registry = {handlers: {}, nodes: {}},\n      internal = dl.duplicate(registry),  // Internal event processing\n      external = dl.duplicate(registry);  // External event processing\n\n  dl.array(spec).forEach(function(sig) {\n    var signal = model.signal(sig.name);\n    if (sig.expr) return;  // Cannot have an expr and stream definition.\n\n    dl.array(sig.streams).forEach(function(stream) {\n      var sel = selector.parse(stream.type),\n          exp = model.expr(stream.expr);\n      mergedStream(signal, sel, exp, stream);\n    });\n  });\n\n  // We register the event listeners all together so that if multiple\n  // signals are registered on the same event, they will receive the\n  // new value on the same pulse.\n  dl.keys(internal.handlers).forEach(function(type) {\n    view.on(type, function(evt, item) {\n      evt.preventDefault(); // stop text selection\n      extendEvent(evt, item);\n      fire(internal, type, (item && item.datum) || {}, evt);\n    });\n  });\n\n  // add external event listeners\n  dl.keys(external.handlers).forEach(function(type) {\n    if (typeof window === 'undefined') return; // No external support\n\n    var h = external.handlers[type],\n        t = type.split(':'), // --> no element pseudo-selectors\n        elt = (t[0] === 'window') ? [window] :\n              window.document.querySelectorAll(t[0]);\n\n    function handler(evt) {\n      extendEvent(evt);\n      fire(external, type, d3.select(this).datum(), evt);\n    }\n\n    for (var i=0; i<elt.length; ++i) {\n      elt[i].addEventListener(t[1], handler);\n    }\n\n    h.elements = elt;\n    h.listener = handler;\n  });\n\n  // remove external event listeners\n  external.detach = function() {\n    dl.keys(external.handlers).forEach(function(type) {\n      var h = external.handlers[type],\n          t = type.split(':'),\n          elt = dl.array(h.elements);\n\n      for (var i=0; i<elt.length; ++i) {\n        elt[i].removeEventListener(t[1], h.listener);\n      }\n    });\n  };\n\n  // export detach method\n  return external.detach;\n\n  // -- helper functions -----\n\n  function extendEvent(evt, item) {\n    var mouse = d3.mouse((d3.event=evt, view.renderer().scene())),\n        pad = view.padding(),\n        names = {}, mark, group, i;\n\n    if (item) {\n      mark = item.mark;\n      group = mark.marktype === 'group' ? item : mark.group;\n      for (i=item; i!=null; i=i.mark.group) {\n        if (i.mark.def.name) {\n          names[i.mark.def.name] = i;\n        }\n      }\n    }\n    names.root = view.model().scene().items[0];\n\n    evt.vg = Object.create(vgEvent);\n    evt.vg.group = group;\n    evt.vg.item = item || {};\n    evt.vg.name = names;\n    evt.vg.x = mouse[0] - pad.left;\n    evt.vg.y = mouse[1] - pad.top;\n  }\n\n  function fire(registry, type, datum, evt) {\n    var handlers = registry.handlers[type],\n        node = registry.nodes[type],\n        cs = df.ChangeSet.create(null, true),\n        filtered = false,\n        val, i, n, h;\n\n    function invoke(f) {\n      return !f.fn(datum, evt);\n    }\n\n    for (i=0, n=handlers.length; i<n; ++i) {\n      h = handlers[i];\n      filtered = h.filters.some(invoke);\n      if (filtered) continue;\n\n      val = h.exp.fn(datum, evt);\n      if (h.spec.scale) {\n        val = parseSignals.scale(model, h.spec, val, datum, evt);\n      }\n\n      if (val !== h.signal.value() || h.signal.verbose()) {\n        h.signal.value(val);\n        cs.signals[h.signal.name()] = 1;\n      }\n    }\n\n    model.propagate(cs, node);\n  }\n\n  function mergedStream(sig, selector, exp, spec) {\n    selector.forEach(function(s) {\n      if (s.event)       domEvent(sig, s, exp, spec);\n      else if (s.signal) signal(sig, s, exp, spec);\n      else if (s.start)  orderedStream(sig, s, exp, spec);\n      else if (s.stream) {\n        if (s.filters) s.stream.forEach(function(ms) {\n          ms.filters = dl.array(ms.filters).concat(s.filters);\n        });\n        mergedStream(sig, s.stream, exp, spec);\n      }\n    });\n  }\n\n  function domEvent(sig, selector, exp, spec) {\n    var evt = selector.event,\n        name = selector.name,\n        mark = selector.mark,\n        target   = selector.target,\n        filters  = dl.array(selector.filters),\n        registry = target ? external : internal,\n        type = target ? target+':'+evt : evt,\n        node = registry.nodes[type] || (registry.nodes[type] = new df.Node(model)),\n        handlers = registry.handlers[type] || (registry.handlers[type] = []);\n\n    if (name) {\n      filters.push('!!event.vg.name[\"' + name + '\"]'); // Mimic event bubbling\n    } else if (mark) {\n      filters.push('event.vg.item.mark && event.vg.item.mark.marktype==='+dl.str(mark));\n    }\n\n    handlers.push({\n      signal: sig,\n      exp: exp,\n      spec: spec,\n      filters: filters.map(function(f) { return model.expr(f); })\n    });\n\n    node.addListener(sig);\n  }\n\n  function signal(sig, selector, exp, spec) {\n    var n = sig.name(), s = model.signal(n+EVALUATOR, null);\n    s.evaluate = function(input) {\n      if (!input.signals[selector.signal]) return model.doNotPropagate;\n      var val = exp.fn();\n      if (spec.scale) {\n        val = parseSignals.scale(model, spec, val);\n      }\n\n      if (val !== sig.value() || sig.verbose()) {\n        sig.value(val);\n        input.signals[n] = 1;\n        input.reflow = true;\n      }\n\n      return input;\n    };\n    s.dependency(df.Dependencies.SIGNALS, selector.signal);\n    s.addListener(sig);\n    model.signal(selector.signal).addListener(s);\n  }\n\n  function orderedStream(sig, selector, exp, spec) {\n    var name = sig.name(),\n        gk = name + GATEKEEPER,\n        middle  = selector.middle,\n        filters = middle.filters || (middle.filters = []),\n        gatekeeper = model.signal(gk) || model.signal(gk, false);\n\n    // Register an anonymous signal to act as a gatekeeper. Its value is\n    // true or false depending on whether the start or end streams occur.\n    // The middle signal then simply filters for the gatekeeper's value.\n    mergedStream(gatekeeper, [selector.start], trueFn, {});\n    mergedStream(gatekeeper, [selector.end], falseFn, {});\n\n    filters.push(gatekeeper.name());\n    mergedStream(sig, [selector.middle], exp, spec);\n  }\n}\n\nmodule.exports = parseStreams;\nparseStreams.schema = {\n  \"defs\": {\n    \"streams\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n\n        \"properties\": {\n          \"type\": {\"type\": \"string\"},\n          \"expr\": {\"type\": \"string\"},\n          \"scale\": {\"$ref\": \"#/refs/scopedScale\"}\n        },\n\n        \"additionalProperties\": false,\n        \"required\": [\"type\", \"expr\"]\n      }\n    }\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/parse/streams.js\n ** module id = 161\n ** module chunks = 0\n **/","var d3 = require('d3'),\n    bound = require('vega-scenegraph').bound,\n    Tuple = require('vega-dataflow').Tuple,\n    Status = require('./Builder').STATUS;\n\nfunction Transition(duration, ease) {\n  this.duration = duration || 500;\n  this.ease = ease && d3.ease(ease) || d3.ease('cubic-in-out');\n  this.updates = {next: null};\n}\n\nvar prototype = Transition.prototype;\n\nvar skip = {\n  'text': 1,\n  'url':  1\n};\n\nprototype.interpolate = function(item, values) {\n  var key, curr, next, interp, list = null;\n\n  for (key in values) {\n    curr = item[key];\n    next = values[key];\n    if (curr !== next) {\n      if (skip[key] || curr === undefined) {\n        // skip interpolation for specific keys or undefined start values\n        Tuple.set(item, key, next);\n      } else if (typeof curr === 'number' && !isFinite(curr)) {\n        // for NaN or infinite numeric values, skip to final value\n        Tuple.set(item, key, next);\n      } else {\n        // otherwise lookup interpolator\n        interp = d3.interpolate(curr, next);\n        interp.property = key;\n        (list || (list=[])).push(interp);\n      }\n    }\n  }\n\n  if (list === null && item.status === Status.EXIT) {\n    list = []; // ensure exiting items are included\n  }\n\n  if (list != null) {\n    list.item = item;\n    list.ease = item.mark.ease || this.ease;\n    list.next = this.updates.next;\n    this.updates.next = list;\n  }\n  return this;\n};\n\nprototype.start = function(callback) {\n  var t = this, prev = t.updates, curr = prev.next;\n  for (; curr!=null; prev=curr, curr=prev.next) {\n    if (curr.item.status === Status.EXIT) {\n      // Only mark item as exited when it is removed.\n      curr.item.status = Status.UPDATE;\n      curr.remove = true;\n    }\n  }\n  t.callback = callback;\n  d3.timer(function(elapsed) { return step.call(t, elapsed); });\n};\n\nfunction step(elapsed) {\n  var list = this.updates, prev = list, curr = prev.next,\n      duration = this.duration,\n      item, delay, f, e, i, n, stop = true;\n\n  for (; curr!=null; prev=curr, curr=prev.next) {\n    item = curr.item;\n    delay = item.delay || 0;\n\n    f = (elapsed - delay) / duration;\n    if (f < 0) { stop = false; continue; }\n    if (f > 1) f = 1;\n    e = curr.ease(f);\n\n    for (i=0, n=curr.length; i<n; ++i) {\n      item[curr[i].property] = curr[i](e);\n    }\n    item.touch();\n    bound.item(item);\n\n    if (f === 1) {\n      if (curr.remove) {\n        item.status = Status.EXIT;\n        item.remove();\n      }\n      prev.next = curr.next;\n      curr = prev;\n    } else {\n      stop = false;\n    }\n  }\n\n  this.callback();\n  return stop;\n}\n\nmodule.exports = Transition;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/scene/Transition.js\n ** module id = 162\n ** module chunks = 0\n **/","var sg = require('vega-scenegraph').render,\n    canvas = sg.canvas,\n    svg = sg.svg.string,\n    View = require('./View');\n\nfunction HeadlessView(width, height, model) {\n  View.call(this, width, height, model);\n  this._type = 'canvas';\n  this._renderers = {canvas: canvas, svg: svg};\n}\n\nvar prototype = (HeadlessView.prototype = new View());\n\nprototype.renderer = function(type) {\n  if(type) this._type = type;\n  return View.prototype.renderer.apply(this, arguments);\n};\n\nprototype.canvas = function() {\n  return (this._type === 'canvas') ? this._renderer.canvas() : null;\n};\n\nprototype.canvasAsync = function(callback) {\n  var r = this._renderer, view = this;\n\n  function wait() {\n    if (r.pendingImages() === 0) {\n      view.render(); // re-render with all images\n      callback(view.canvas());\n    } else {\n      setTimeout(wait, 10);\n    }\n  }\n\n  // if images loading, poll until ready\n  if (this._type !== 'canvas') return null;\n  if (r.pendingImages() > 0) { wait(); } else { callback(this.canvas()); }\n};\n\nprototype.svg = function() {\n  return (this._type === 'svg') ? this._renderer.svg() : null;\n};\n\nprototype.initialize = function() {\n  var w = this._width,\n      h = this._height,\n      bg  = this._bgcolor,\n      pad = this._padding,\n      config = this.model().config();\n\n  if (this._viewport) {\n    w = this._viewport[0] - (pad ? pad.left + pad.right : 0);\n    h = this._viewport[1] - (pad ? pad.top + pad.bottom : 0);\n  }\n\n  this._renderer = (this._renderer || new this._io.Renderer(config.load))\n    .initialize(null, w, h, pad)\n    .background(bg);\n\n  return this;\n};\n\nmodule.exports = HeadlessView;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/core/HeadlessView.js\n ** module id = 163\n ** module chunks = 0\n **/","var dl = require('datalib'),\n    parse = require('../parse'),\n    Scale = require('../scene/Scale'),\n    config = require('./config');\n\nfunction compile(module, opt, schema) {\n  var s = module.schema;\n  if (!s) return;\n  if (s.refs) dl.extend(schema.refs, s.refs);\n  if (s.defs) dl.extend(schema.defs, s.defs);\n}\n\nmodule.exports = function(opt) {\n  var schema = null;\n  opt = opt || {};\n\n  // Compile if we're not loading the schema from a URL.\n  // Load from a URL to extend the existing base schema.\n  if (opt.url) {\n    schema = dl.json(dl.extend({url: opt.url}, config.load));\n  } else {\n    schema = {\n      \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n      \"title\": \"Vega Visualization Specification Language\",\n      \"defs\": {},\n      \"refs\": {},\n      \"$ref\": \"#/defs/spec\"\n    };\n\n    dl.keys(parse).forEach(function(k) { compile(parse[k], opt, schema); });\n\n    // Scales aren't in the parser, add schema manually\n    compile(Scale, opt, schema);\n  }\n\n  // Extend schema to support custom mark properties or property sets.\n  if (opt.properties) dl.keys(opt.properties).forEach(function(k) {\n    schema.defs.propset.properties[k] = {\"$ref\": \"#/refs/\"+opt.properties[k]+\"Value\"};\n  });\n\n  if (opt.propertySets) dl.keys(opt.propertySets).forEach(function(k) {\n    schema.defs.mark.properties.properties.properties[k] = {\"$ref\": \"#/defs/propset\"};\n  });\n\n  return schema;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega/src/core/schema.js\n ** module id = 164\n ** module chunks = 0\n **/","\"use strict\";\nvar vlBin = require('./bin');\nvar vlChannel = require('./channel');\nvar vlData = require('./data');\nvar vlEncoding = require('./encoding');\nvar vlFieldDef = require('./fielddef');\nvar vlCompile = require('./compile/compile');\nvar vlShorthand = require('./shorthand');\nvar vlSpec = require('./spec');\nvar vlTimeUnit = require('./timeunit');\nvar vlType = require('./type');\nvar vlValidate = require('./validate');\nvar vlUtil = require('./util');\nexports.bin = vlBin;\nexports.channel = vlChannel;\nexports.compile = vlCompile.compile;\nexports.data = vlData;\nexports.encoding = vlEncoding;\nexports.fieldDef = vlFieldDef;\nexports.shorthand = vlShorthand;\nexports.spec = vlSpec;\nexports.timeUnit = vlTimeUnit;\nexports.type = vlType;\nexports.util = vlUtil;\nexports.validate = vlValidate;\nexports.version = '__VERSION__';\n//# sourceMappingURL=vl.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-lite/src/vl.js\n ** module id = 165\n ** module chunks = 0\n **/","\"use strict\";\nvar channel_1 = require('./channel');\nfunction autoMaxBins(channel) {\n    switch (channel) {\n        case channel_1.ROW:\n        case channel_1.COLUMN:\n        case channel_1.SIZE:\n        case channel_1.SHAPE:\n            return 6;\n        default:\n            return 10;\n    }\n}\nexports.autoMaxBins = autoMaxBins;\n//# sourceMappingURL=bin.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-lite/src/bin.js\n ** module id = 166\n ** module chunks = 0\n **/","\"use strict\";\nvar util_1 = require('./util');\n(function (Channel) {\n    Channel[Channel[\"X\"] = 'x'] = \"X\";\n    Channel[Channel[\"Y\"] = 'y'] = \"Y\";\n    Channel[Channel[\"ROW\"] = 'row'] = \"ROW\";\n    Channel[Channel[\"COLUMN\"] = 'column'] = \"COLUMN\";\n    Channel[Channel[\"SHAPE\"] = 'shape'] = \"SHAPE\";\n    Channel[Channel[\"SIZE\"] = 'size'] = \"SIZE\";\n    Channel[Channel[\"COLOR\"] = 'color'] = \"COLOR\";\n    Channel[Channel[\"TEXT\"] = 'text'] = \"TEXT\";\n    Channel[Channel[\"DETAIL\"] = 'detail'] = \"DETAIL\";\n    Channel[Channel[\"LABEL\"] = 'label'] = \"LABEL\";\n    Channel[Channel[\"PATH\"] = 'path'] = \"PATH\";\n    Channel[Channel[\"ORDER\"] = 'order'] = \"ORDER\";\n})(exports.Channel || (exports.Channel = {}));\nvar Channel = exports.Channel;\nexports.X = Channel.X;\nexports.Y = Channel.Y;\nexports.ROW = Channel.ROW;\nexports.COLUMN = Channel.COLUMN;\nexports.SHAPE = Channel.SHAPE;\nexports.SIZE = Channel.SIZE;\nexports.COLOR = Channel.COLOR;\nexports.TEXT = Channel.TEXT;\nexports.DETAIL = Channel.DETAIL;\nexports.LABEL = Channel.LABEL;\nexports.PATH = Channel.PATH;\nexports.ORDER = Channel.ORDER;\nexports.CHANNELS = [exports.X, exports.Y, exports.ROW, exports.COLUMN, exports.SIZE, exports.SHAPE, exports.COLOR, exports.PATH, exports.ORDER, exports.TEXT, exports.DETAIL, exports.LABEL];\n;\nfunction supportMark(channel, mark) {\n    return !!getSupportedMark(channel)[mark];\n}\nexports.supportMark = supportMark;\nfunction getSupportedMark(channel) {\n    switch (channel) {\n        case exports.X:\n        case exports.Y:\n        case exports.COLOR:\n        case exports.DETAIL:\n        case exports.ORDER:\n        case exports.ROW:\n        case exports.COLUMN:\n            return {\n                point: true, tick: true, circle: true, square: true,\n                bar: true, line: true, area: true, text: true\n            };\n        case exports.SIZE:\n            return {\n                point: true, tick: true, circle: true, square: true,\n                bar: true, text: true\n            };\n        case exports.SHAPE:\n            return { point: true };\n        case exports.TEXT:\n            return { text: true };\n        case exports.PATH:\n            return { line: true };\n    }\n    return {};\n}\nexports.getSupportedMark = getSupportedMark;\n;\nfunction getSupportedRole(channel) {\n    switch (channel) {\n        case exports.X:\n        case exports.Y:\n        case exports.COLOR:\n        case exports.LABEL:\n            return {\n                measure: true,\n                dimension: true\n            };\n        case exports.ROW:\n        case exports.COLUMN:\n        case exports.SHAPE:\n        case exports.DETAIL:\n            return {\n                measure: false,\n                dimension: true\n            };\n        case exports.SIZE:\n        case exports.TEXT:\n            return {\n                measure: true,\n                dimension: false\n            };\n        case exports.PATH:\n            return {\n                measure: false,\n                dimension: true\n            };\n    }\n    throw new Error('Invalid encoding channel' + channel);\n}\nexports.getSupportedRole = getSupportedRole;\nfunction hasScale(channel) {\n    return !util_1.contains([exports.DETAIL, exports.PATH, exports.TEXT, exports.LABEL, exports.ORDER], channel);\n}\nexports.hasScale = hasScale;\n//# sourceMappingURL=channel.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-lite/src/channel.js\n ** module id = 167\n ** module chunks = 0\n **/","\"use strict\";\nvar util_1 = require('datalib/src/util');\nexports.keys = util_1.keys;\nexports.extend = util_1.extend;\nexports.duplicate = util_1.duplicate;\nexports.isArray = util_1.isArray;\nexports.vals = util_1.vals;\nexports.truncate = util_1.truncate;\nexports.toMap = util_1.toMap;\nexports.isObject = util_1.isObject;\nvar generate_1 = require('datalib/src/generate');\nexports.range = generate_1.range;\nfunction contains(array, item) {\n    return array.indexOf(item) > -1;\n}\nexports.contains = contains;\nfunction without(array, items) {\n    return array.filter(function (item) {\n        return !contains(items, item);\n    });\n}\nexports.without = without;\nfunction forEach(obj, f, thisArg) {\n    if (obj.forEach) {\n        obj.forEach.call(thisArg, f);\n    }\n    else {\n        for (var k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                f.call(thisArg, obj[k], k, obj);\n            }\n        }\n    }\n}\nexports.forEach = forEach;\nfunction reduce(obj, f, init, thisArg) {\n    if (obj.reduce) {\n        return obj.reduce.call(thisArg, f, init);\n    }\n    else {\n        for (var k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                init = f.call(thisArg, init, obj[k], k, obj);\n            }\n        }\n        return init;\n    }\n}\nexports.reduce = reduce;\nfunction map(obj, f, thisArg) {\n    if (obj.map) {\n        return obj.map.call(thisArg, f);\n    }\n    else {\n        var output = [];\n        for (var k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                output.push(f.call(thisArg, obj[k], k, obj));\n            }\n        }\n        return output;\n    }\n}\nexports.map = map;\nfunction any(arr, f) {\n    var i = 0;\n    for (var k = 0; k < arr.length; k++) {\n        if (f(arr[k], k, i++)) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.any = any;\nfunction all(arr, f) {\n    var i = 0;\n    for (var k = 0; k < arr.length; k++) {\n        if (!f(arr[k], k, i++)) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.all = all;\nfunction mergeDeep(dest) {\n    var src = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        src[_i - 1] = arguments[_i];\n    }\n    for (var i = 0; i < src.length; i++) {\n        dest = deepMerge_(dest, src[i]);\n    }\n    return dest;\n}\nexports.mergeDeep = mergeDeep;\n;\nfunction deepMerge_(dest, src) {\n    if (typeof src !== 'object' || src === null) {\n        return dest;\n    }\n    for (var p in src) {\n        if (!src.hasOwnProperty(p)) {\n            continue;\n        }\n        if (src[p] === undefined) {\n            continue;\n        }\n        if (typeof src[p] !== 'object' || src[p] === null) {\n            dest[p] = src[p];\n        }\n        else if (typeof dest[p] !== 'object' || dest[p] === null) {\n            dest[p] = mergeDeep(src[p].constructor === Array ? [] : {}, src[p]);\n        }\n        else {\n            mergeDeep(dest[p], src[p]);\n        }\n    }\n    return dest;\n}\nvar dlBin = require('datalib/src/bins/bins');\nfunction getbins(stats, maxbins) {\n    return dlBin({\n        min: stats.min,\n        max: stats.max,\n        maxbins: maxbins\n    });\n}\nexports.getbins = getbins;\nfunction error(message) {\n    console.error('[VL Error]', message);\n}\nexports.error = error;\n//# sourceMappingURL=util.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-lite/src/util.js\n ** module id = 168\n ** module chunks = 0\n **/","\"use strict\";\nvar type_1 = require('./type');\n(function (DataFormat) {\n    DataFormat[DataFormat[\"JSON\"] = 'json'] = \"JSON\";\n    DataFormat[DataFormat[\"CSV\"] = 'csv'] = \"CSV\";\n    DataFormat[DataFormat[\"TSV\"] = 'tsv'] = \"TSV\";\n})(exports.DataFormat || (exports.DataFormat = {}));\nvar DataFormat = exports.DataFormat;\nexports.SUMMARY = 'summary';\nexports.SOURCE = 'source';\nexports.STACKED_SCALE = 'stacked_scale';\nexports.LAYOUT = 'layout';\nexports.types = {\n    'boolean': type_1.Type.NOMINAL,\n    'number': type_1.Type.QUANTITATIVE,\n    'integer': type_1.Type.QUANTITATIVE,\n    'date': type_1.Type.TEMPORAL,\n    'string': type_1.Type.NOMINAL\n};\n//# sourceMappingURL=data.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-lite/src/data.js\n ** module id = 169\n ** module chunks = 0\n **/","\"use strict\";\n(function (Type) {\n    Type[Type[\"QUANTITATIVE\"] = 'quantitative'] = \"QUANTITATIVE\";\n    Type[Type[\"ORDINAL\"] = 'ordinal'] = \"ORDINAL\";\n    Type[Type[\"TEMPORAL\"] = 'temporal'] = \"TEMPORAL\";\n    Type[Type[\"NOMINAL\"] = 'nominal'] = \"NOMINAL\";\n})(exports.Type || (exports.Type = {}));\nvar Type = exports.Type;\nexports.QUANTITATIVE = Type.QUANTITATIVE;\nexports.ORDINAL = Type.ORDINAL;\nexports.TEMPORAL = Type.TEMPORAL;\nexports.NOMINAL = Type.NOMINAL;\nexports.SHORT_TYPE = {\n    quantitative: 'Q',\n    temporal: 'T',\n    nominal: 'N',\n    ordinal: 'O'\n};\nexports.TYPE_FROM_SHORT_TYPE = {\n    Q: exports.QUANTITATIVE,\n    T: exports.TEMPORAL,\n    O: exports.ORDINAL,\n    N: exports.NOMINAL\n};\nfunction getFullName(type) {\n    var typeString = type;\n    return exports.TYPE_FROM_SHORT_TYPE[typeString.toUpperCase()] ||\n        typeString.toLowerCase();\n}\nexports.getFullName = getFullName;\n//# sourceMappingURL=type.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-lite/src/type.js\n ** module id = 170\n ** module chunks = 0\n **/","\"use strict\";\nvar channel_1 = require('./channel');\nvar util_1 = require('./util');\nfunction countRetinal(encoding) {\n    var count = 0;\n    if (encoding.color) {\n        count++;\n    }\n    if (encoding.size) {\n        count++;\n    }\n    if (encoding.shape) {\n        count++;\n    }\n    return count;\n}\nexports.countRetinal = countRetinal;\nfunction channels(encoding) {\n    return channel_1.CHANNELS.filter(function (channel) {\n        return has(encoding, channel);\n    });\n}\nexports.channels = channels;\nfunction has(encoding, channel) {\n    var channelEncoding = encoding && encoding[channel];\n    return channelEncoding && (channelEncoding.field !== undefined ||\n        (util_1.isArray(channelEncoding) && channelEncoding.length > 0));\n}\nexports.has = has;\nfunction isAggregate(encoding) {\n    return util_1.any(channel_1.CHANNELS, function (channel) {\n        if (has(encoding, channel) && encoding[channel].aggregate) {\n            return true;\n        }\n        return false;\n    });\n}\nexports.isAggregate = isAggregate;\nfunction fieldDefs(encoding) {\n    var arr = [];\n    channel_1.CHANNELS.forEach(function (channel) {\n        if (has(encoding, channel)) {\n            if (util_1.isArray(encoding[channel])) {\n                encoding[channel].forEach(function (fieldDef) {\n                    arr.push(fieldDef);\n                });\n            }\n            else {\n                arr.push(encoding[channel]);\n            }\n        }\n    });\n    return arr;\n}\nexports.fieldDefs = fieldDefs;\n;\nfunction forEach(encoding, f, thisArg) {\n    var i = 0;\n    channel_1.CHANNELS.forEach(function (channel) {\n        if (has(encoding, channel)) {\n            if (util_1.isArray(encoding[channel])) {\n                encoding[channel].forEach(function (fieldDef) {\n                    f.call(thisArg, fieldDef, channel, i++);\n                });\n            }\n            else {\n                f.call(thisArg, encoding[channel], channel, i++);\n            }\n        }\n    });\n}\nexports.forEach = forEach;\nfunction map(encoding, f, thisArg) {\n    var arr = [];\n    channel_1.CHANNELS.forEach(function (channel) {\n        if (has(encoding, channel)) {\n            if (util_1.isArray(encoding[channel])) {\n                encoding[channel].forEach(function (fieldDef) {\n                    arr.push(f.call(thisArg, fieldDef, channel, encoding));\n                });\n            }\n            else {\n                arr.push(f.call(thisArg, encoding[channel], channel, encoding));\n            }\n        }\n    });\n    return arr;\n}\nexports.map = map;\nfunction reduce(encoding, f, init, thisArg) {\n    var r = init;\n    channel_1.CHANNELS.forEach(function (channel) {\n        if (has(encoding, channel)) {\n            if (util_1.isArray(encoding[channel])) {\n                encoding[channel].forEach(function (fieldDef) {\n                    r = f.call(thisArg, r, fieldDef, channel, encoding);\n                });\n            }\n            else {\n                r = f.call(thisArg, r, encoding[channel], channel, encoding);\n            }\n        }\n    });\n    return r;\n}\nexports.reduce = reduce;\n//# sourceMappingURL=encoding.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-lite/src/encoding.js\n ** module id = 171\n ** module chunks = 0\n **/","\"use strict\";\nvar aggregate_1 = require('./aggregate');\nvar timeunit_1 = require('./timeunit');\nvar type_1 = require('./type');\nvar util_1 = require('./util');\nexports.aggregate = {\n    type: 'string',\n    enum: aggregate_1.AGGREGATE_OPS,\n    supportedEnums: {\n        quantitative: aggregate_1.AGGREGATE_OPS,\n        ordinal: ['median', 'min', 'max'],\n        nominal: [],\n        temporal: ['mean', 'median', 'min', 'max'],\n        '': ['count']\n    },\n    supportedTypes: util_1.toMap([type_1.QUANTITATIVE, type_1.NOMINAL, type_1.ORDINAL, type_1.TEMPORAL, ''])\n};\nfunction field(fieldDef, opt) {\n    if (opt === void 0) { opt = {}; }\n    var prefix = (opt.datum ? 'datum.' : '') + (opt.prefn || '');\n    var suffix = opt.suffix || '';\n    var field = fieldDef.field;\n    if (isCount(fieldDef)) {\n        return prefix + 'count' + suffix;\n    }\n    else if (opt.fn) {\n        return prefix + opt.fn + '_' + field + suffix;\n    }\n    else if (!opt.nofn && fieldDef.bin) {\n        return prefix + 'bin_' + field + (opt.binSuffix || suffix || '_start');\n    }\n    else if (!opt.nofn && !opt.noAggregate && fieldDef.aggregate) {\n        return prefix + fieldDef.aggregate + '_' + field + suffix;\n    }\n    else if (!opt.nofn && fieldDef.timeUnit) {\n        return prefix + fieldDef.timeUnit + '_' + field + suffix;\n    }\n    else {\n        return prefix + field;\n    }\n}\nexports.field = field;\nfunction _isFieldDimension(fieldDef) {\n    return util_1.contains([type_1.NOMINAL, type_1.ORDINAL], fieldDef.type) || !!fieldDef.bin ||\n        (fieldDef.type === type_1.TEMPORAL && !!fieldDef.timeUnit);\n}\nfunction isDimension(fieldDef) {\n    return fieldDef && fieldDef.field && _isFieldDimension(fieldDef);\n}\nexports.isDimension = isDimension;\nfunction isMeasure(fieldDef) {\n    return fieldDef && fieldDef.field && !_isFieldDimension(fieldDef);\n}\nexports.isMeasure = isMeasure;\nexports.COUNT_DISPLAYNAME = 'Number of Records';\nfunction count() {\n    return { field: '*', aggregate: aggregate_1.AggregateOp.COUNT, type: type_1.QUANTITATIVE, displayName: exports.COUNT_DISPLAYNAME };\n}\nexports.count = count;\nfunction isCount(fieldDef) {\n    return fieldDef.aggregate === aggregate_1.AggregateOp.COUNT;\n}\nexports.isCount = isCount;\nfunction cardinality(fieldDef, stats, filterNull) {\n    if (filterNull === void 0) { filterNull = {}; }\n    var stat = stats[fieldDef.field], type = fieldDef.type;\n    if (fieldDef.bin) {\n        var bin_1 = fieldDef.bin;\n        var maxbins = (typeof bin_1 === 'boolean') ? undefined : bin_1.maxbins;\n        if (maxbins === undefined) {\n            maxbins = 10;\n        }\n        var bins = util_1.getbins(stat, maxbins);\n        return (bins.stop - bins.start) / bins.step;\n    }\n    if (type === type_1.TEMPORAL) {\n        var timeUnit = fieldDef.timeUnit;\n        switch (timeUnit) {\n            case timeunit_1.TimeUnit.SECONDS: return 60;\n            case timeunit_1.TimeUnit.MINUTES: return 60;\n            case timeunit_1.TimeUnit.HOURS: return 24;\n            case timeunit_1.TimeUnit.DAY: return 7;\n            case timeunit_1.TimeUnit.DATE: return 31;\n            case timeunit_1.TimeUnit.MONTH: return 12;\n            case timeunit_1.TimeUnit.YEAR:\n                var yearstat = stats['year_' + fieldDef.field];\n                if (!yearstat) {\n                    return null;\n                }\n                return yearstat.distinct -\n                    (stat.missing > 0 && filterNull[type] ? 1 : 0);\n        }\n    }\n    if (fieldDef.aggregate) {\n        return 1;\n    }\n    return stat.distinct -\n        (stat.missing > 0 && filterNull[type] ? 1 : 0);\n}\nexports.cardinality = cardinality;\nfunction title(fieldDef) {\n    if (isCount(fieldDef)) {\n        return exports.COUNT_DISPLAYNAME;\n    }\n    var fn = fieldDef.aggregate || fieldDef.timeUnit || (fieldDef.bin && 'bin');\n    if (fn) {\n        return fn.toString().toUpperCase() + '(' + fieldDef.field + ')';\n    }\n    else {\n        return fieldDef.field;\n    }\n}\nexports.title = title;\n//# sourceMappingURL=fielddef.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-lite/src/fielddef.js\n ** module id = 172\n ** module chunks = 0\n **/","\"use strict\";\n(function (AggregateOp) {\n    AggregateOp[AggregateOp[\"VALUES\"] = 'values'] = \"VALUES\";\n    AggregateOp[AggregateOp[\"COUNT\"] = 'count'] = \"COUNT\";\n    AggregateOp[AggregateOp[\"VALID\"] = 'valid'] = \"VALID\";\n    AggregateOp[AggregateOp[\"MISSING\"] = 'missing'] = \"MISSING\";\n    AggregateOp[AggregateOp[\"DISTINCT\"] = 'distinct'] = \"DISTINCT\";\n    AggregateOp[AggregateOp[\"SUM\"] = 'sum'] = \"SUM\";\n    AggregateOp[AggregateOp[\"MEAN\"] = 'mean'] = \"MEAN\";\n    AggregateOp[AggregateOp[\"AVERAGE\"] = 'average'] = \"AVERAGE\";\n    AggregateOp[AggregateOp[\"VARIANCE\"] = 'variance'] = \"VARIANCE\";\n    AggregateOp[AggregateOp[\"VARIANCEP\"] = 'variancep'] = \"VARIANCEP\";\n    AggregateOp[AggregateOp[\"STDEV\"] = 'stdev'] = \"STDEV\";\n    AggregateOp[AggregateOp[\"STDEVP\"] = 'stdevp'] = \"STDEVP\";\n    AggregateOp[AggregateOp[\"MEDIAN\"] = 'median'] = \"MEDIAN\";\n    AggregateOp[AggregateOp[\"Q1\"] = 'q1'] = \"Q1\";\n    AggregateOp[AggregateOp[\"Q3\"] = 'q3'] = \"Q3\";\n    AggregateOp[AggregateOp[\"MODESKEW\"] = 'modeskew'] = \"MODESKEW\";\n    AggregateOp[AggregateOp[\"MIN\"] = 'min'] = \"MIN\";\n    AggregateOp[AggregateOp[\"MAX\"] = 'max'] = \"MAX\";\n    AggregateOp[AggregateOp[\"ARGMIN\"] = 'argmin'] = \"ARGMIN\";\n    AggregateOp[AggregateOp[\"ARGMAX\"] = 'argmax'] = \"ARGMAX\";\n})(exports.AggregateOp || (exports.AggregateOp = {}));\nvar AggregateOp = exports.AggregateOp;\nexports.AGGREGATE_OPS = [\n    AggregateOp.VALUES,\n    AggregateOp.COUNT,\n    AggregateOp.VALID,\n    AggregateOp.MISSING,\n    AggregateOp.DISTINCT,\n    AggregateOp.SUM,\n    AggregateOp.MEAN,\n    AggregateOp.AVERAGE,\n    AggregateOp.VARIANCE,\n    AggregateOp.VARIANCEP,\n    AggregateOp.STDEV,\n    AggregateOp.STDEVP,\n    AggregateOp.MEDIAN,\n    AggregateOp.Q1,\n    AggregateOp.Q3,\n    AggregateOp.MODESKEW,\n    AggregateOp.MIN,\n    AggregateOp.MAX,\n    AggregateOp.ARGMIN,\n    AggregateOp.ARGMAX,\n];\nexports.SHARED_DOMAIN_OPS = [\n    AggregateOp.MEAN,\n    AggregateOp.AVERAGE,\n    AggregateOp.STDEV,\n    AggregateOp.STDEVP,\n    AggregateOp.MEDIAN,\n    AggregateOp.Q1,\n    AggregateOp.Q3,\n    AggregateOp.MIN,\n    AggregateOp.MAX,\n];\n//# sourceMappingURL=aggregate.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-lite/src/aggregate.js\n ** module id = 173\n ** module chunks = 0\n **/","\"use strict\";\n(function (TimeUnit) {\n    TimeUnit[TimeUnit[\"YEAR\"] = 'year'] = \"YEAR\";\n    TimeUnit[TimeUnit[\"MONTH\"] = 'month'] = \"MONTH\";\n    TimeUnit[TimeUnit[\"DAY\"] = 'day'] = \"DAY\";\n    TimeUnit[TimeUnit[\"DATE\"] = 'date'] = \"DATE\";\n    TimeUnit[TimeUnit[\"HOURS\"] = 'hours'] = \"HOURS\";\n    TimeUnit[TimeUnit[\"MINUTES\"] = 'minutes'] = \"MINUTES\";\n    TimeUnit[TimeUnit[\"SECONDS\"] = 'seconds'] = \"SECONDS\";\n    TimeUnit[TimeUnit[\"MILLISECONDS\"] = 'milliseconds'] = \"MILLISECONDS\";\n    TimeUnit[TimeUnit[\"YEARMONTH\"] = 'yearmonth'] = \"YEARMONTH\";\n    TimeUnit[TimeUnit[\"YEARMONTHDAY\"] = 'yearmonthday'] = \"YEARMONTHDAY\";\n    TimeUnit[TimeUnit[\"YEARMONTHDATE\"] = 'yearmonthdate'] = \"YEARMONTHDATE\";\n    TimeUnit[TimeUnit[\"YEARDAY\"] = 'yearday'] = \"YEARDAY\";\n    TimeUnit[TimeUnit[\"YEARDATE\"] = 'yeardate'] = \"YEARDATE\";\n    TimeUnit[TimeUnit[\"YEARMONTHDAYHOURS\"] = 'yearmonthdayhours'] = \"YEARMONTHDAYHOURS\";\n    TimeUnit[TimeUnit[\"YEARMONTHDAYHOURSMINUTES\"] = 'yearmonthdayhoursminutes'] = \"YEARMONTHDAYHOURSMINUTES\";\n    TimeUnit[TimeUnit[\"YEARMONTHDAYHOURSMINUTESSECONDS\"] = 'yearmonthdayhoursminutesseconds'] = \"YEARMONTHDAYHOURSMINUTESSECONDS\";\n    TimeUnit[TimeUnit[\"HOURSMINUTES\"] = 'hoursminutes'] = \"HOURSMINUTES\";\n    TimeUnit[TimeUnit[\"HOURSMINUTESSECONDS\"] = 'hoursminutesseconds'] = \"HOURSMINUTESSECONDS\";\n    TimeUnit[TimeUnit[\"MINUTESSECONDS\"] = 'minutesseconds'] = \"MINUTESSECONDS\";\n    TimeUnit[TimeUnit[\"SECONDSMILLISECONDS\"] = 'secondsmilliseconds'] = \"SECONDSMILLISECONDS\";\n})(exports.TimeUnit || (exports.TimeUnit = {}));\nvar TimeUnit = exports.TimeUnit;\nexports.TIMEUNITS = [\n    TimeUnit.YEAR,\n    TimeUnit.MONTH,\n    TimeUnit.DAY,\n    TimeUnit.DATE,\n    TimeUnit.HOURS,\n    TimeUnit.MINUTES,\n    TimeUnit.SECONDS,\n    TimeUnit.MILLISECONDS,\n    TimeUnit.YEARMONTH,\n    TimeUnit.YEARMONTHDAY,\n    TimeUnit.YEARMONTHDATE,\n    TimeUnit.YEARDAY,\n    TimeUnit.YEARDATE,\n    TimeUnit.YEARMONTHDAYHOURS,\n    TimeUnit.YEARMONTHDAYHOURSMINUTES,\n    TimeUnit.YEARMONTHDAYHOURSMINUTESSECONDS,\n    TimeUnit.HOURSMINUTES,\n    TimeUnit.HOURSMINUTESSECONDS,\n    TimeUnit.MINUTESSECONDS,\n    TimeUnit.SECONDSMILLISECONDS,\n];\n//# sourceMappingURL=timeunit.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-lite/src/timeunit.js\n ** module id = 174\n ** module chunks = 0\n **/","\"use strict\";\nvar Model_1 = require('./Model');\nvar axis_1 = require('./axis');\nvar data_1 = require('./data');\nvar layout_1 = require('./layout');\nvar facet_1 = require('./facet');\nvar legend_1 = require('./legend');\nvar mark_1 = require('./mark/mark');\nvar scale_1 = require('./scale');\nvar common_1 = require('./common');\nvar util_1 = require('../util');\nvar data_2 = require('../data');\nvar channel_1 = require('../channel');\nvar Model_2 = require('./Model');\nexports.Model = Model_2.Model;\nfunction compile(spec) {\n    var model = new Model_1.Model(spec);\n    var config = model.config();\n    var output = util_1.extend(spec.name ? { name: spec.name } : {}, {\n        width: 1,\n        height: 1,\n        padding: 'auto'\n    }, config.viewport ? { viewport: config.viewport } : {}, config.background ? { background: config.background } : {}, {\n        data: data_1.compileData(model).concat([layout_1.compileLayoutData(model)]),\n        marks: [compileRootGroup(model)]\n    });\n    return {\n        spec: output\n    };\n}\nexports.compile = compile;\nfunction compileRootGroup(model) {\n    var spec = model.spec();\n    var rootGroup = util_1.extend({\n        name: spec.name ? spec.name + '-root' : 'root',\n        type: 'group',\n    }, spec.description ? { description: spec.description } : {}, {\n        from: { data: data_2.LAYOUT },\n        properties: {\n            update: {\n                width: { field: 'width' },\n                height: { field: 'height' }\n            }\n        }\n    });\n    var marks = mark_1.compileMark(model);\n    if (model.has(channel_1.ROW) || model.has(channel_1.COLUMN)) {\n        util_1.extend(rootGroup, facet_1.facetMixins(model, marks));\n    }\n    else {\n        common_1.applyConfig(rootGroup.properties.update, model.config().cell, common_1.FILL_STROKE_CONFIG.concat(['clip']));\n        rootGroup.marks = marks;\n        rootGroup.scales = scale_1.compileScales(model);\n        var axes = (model.has(channel_1.X) && model.axis(channel_1.X) ? [axis_1.compileAxis(channel_1.X, model)] : [])\n            .concat(model.has(channel_1.Y) && model.axis(channel_1.Y) ? [axis_1.compileAxis(channel_1.Y, model)] : []);\n        if (axes.length > 0) {\n            rootGroup.axes = axes;\n        }\n    }\n    var legends = legend_1.compileLegends(model);\n    if (legends.length > 0) {\n        rootGroup.legends = legends;\n    }\n    return rootGroup;\n}\nexports.compileRootGroup = compileRootGroup;\n//# sourceMappingURL=compile.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-lite/src/compile/compile.js\n ** module id = 175\n ** module chunks = 0\n **/","\"use strict\";\nvar config_1 = require('../config');\nvar channel_1 = require('../channel');\nvar data_1 = require('../data');\nvar fielddef_1 = require('../fielddef');\nvar vlEncoding = require('../encoding');\nvar mark_1 = require('../mark');\nvar type_1 = require('../type');\nvar util_1 = require('../util');\nvar config_2 = require('./config');\nvar stack_1 = require('./stack');\nvar scale_1 = require('./scale');\nvar scale_2 = require('../scale');\nvar aggregate_1 = require('../aggregate');\nvar channel_2 = require('../channel');\n;\nvar Model = (function () {\n    function Model(spec) {\n        var model = this;\n        this._spec = spec;\n        var mark = this._spec.mark;\n        var encoding = this._spec.encoding = this._spec.encoding || {};\n        var config = this._config = util_1.mergeDeep(util_1.duplicate(config_1.defaultConfig), spec.config);\n        vlEncoding.forEach(this._spec.encoding, function (fieldDef, channel) {\n            if (!channel_1.supportMark(channel, this._spec.mark)) {\n                console.warn(channel, 'dropped as it is incompatible with', this._spec.mark);\n                delete this._spec.encoding[channel].field;\n            }\n            if (fieldDef.type) {\n                fieldDef.type = type_1.getFullName(fieldDef.type);\n            }\n            if ((channel === channel_1.PATH || channel === channel_1.ORDER) && !fieldDef.aggregate && fieldDef.type === type_1.QUANTITATIVE) {\n                fieldDef.aggregate = aggregate_1.AggregateOp.MIN;\n            }\n        }, this);\n        var scale = this._scale = [channel_1.X, channel_1.Y, channel_1.COLOR, channel_1.SHAPE, channel_1.SIZE, channel_1.ROW, channel_1.COLUMN].reduce(function (_scale, channel) {\n            if (vlEncoding.has(encoding, channel)) {\n                var channelScale = encoding[channel].scale || {};\n                var channelDef = encoding[channel];\n                var _scaleType = scale_1.scaleType(channelScale, channelDef, channel, mark);\n                if (util_1.contains([channel_1.ROW, channel_1.COLUMN], channel)) {\n                    _scale[channel] = util_1.extend({\n                        type: _scaleType,\n                        round: config.facet.scale.round,\n                        padding: (channel === channel_1.ROW && model.has(channel_1.Y)) || (channel === channel_1.COLUMN && model.has(channel_1.X)) ?\n                            config.facet.scale.padding : 0\n                    }, channelScale);\n                }\n                else {\n                    _scale[channel] = util_1.extend({\n                        type: _scaleType,\n                        round: config.scale.round,\n                        padding: config.scale.padding,\n                        includeRawDomain: config.scale.includeRawDomain,\n                        bandSize: channel === channel_1.X && _scaleType === scale_2.ScaleType.ORDINAL && mark === mark_1.TEXT ?\n                            config.scale.textBandWidth : config.scale.bandSize\n                    }, channelScale);\n                }\n            }\n            return _scale;\n        }, {});\n        this._axis = [channel_1.X, channel_1.Y, channel_1.ROW, channel_1.COLUMN].reduce(function (_axis, channel) {\n            if (vlEncoding.has(encoding, channel)) {\n                var channelAxis = encoding[channel].axis;\n                if (channelAxis !== false) {\n                    _axis[channel] = util_1.extend({}, channel === channel_1.X || channel === channel_1.Y ? config.axis : config.facet.axis, channelAxis === true ? {} : channelAxis || {});\n                }\n            }\n            return _axis;\n        }, {});\n        this._legend = [channel_1.COLOR, channel_1.SHAPE, channel_1.SIZE].reduce(function (_legend, channel) {\n            if (vlEncoding.has(encoding, channel)) {\n                var channelLegend = encoding[channel].legend;\n                if (channelLegend !== false) {\n                    _legend[channel] = util_1.extend({}, config.legend, channelLegend === true ? {} : channelLegend || {});\n                }\n            }\n            return _legend;\n        }, {});\n        this._stack = stack_1.compileStackProperties(mark, encoding, scale, config);\n        this._config.mark = config_2.compileMarkConfig(mark, encoding, config, this._stack);\n    }\n    Model.prototype.stack = function () {\n        return this._stack;\n    };\n    Model.prototype.toSpec = function (excludeConfig, excludeData) {\n        var encoding = util_1.duplicate(this._spec.encoding);\n        var spec;\n        spec = {\n            mark: this._spec.mark,\n            encoding: encoding\n        };\n        if (!excludeConfig) {\n            spec.config = util_1.duplicate(this._spec.config);\n        }\n        if (!excludeData) {\n            spec.data = util_1.duplicate(this._spec.data);\n        }\n        return spec;\n    };\n    Model.prototype.cellWidth = function () {\n        return (this.isFacet() ? this.config().facet.cell.width : null) ||\n            this.config().cell.width;\n    };\n    Model.prototype.cellHeight = function () {\n        return (this.isFacet() ? this.config().facet.cell.height : null) ||\n            this.config().cell.height;\n    };\n    Model.prototype.mark = function () {\n        return this._spec.mark;\n    };\n    Model.prototype.spec = function () {\n        return this._spec;\n    };\n    Model.prototype.has = function (channel) {\n        return vlEncoding.has(this._spec.encoding, channel);\n    };\n    Model.prototype.encoding = function () {\n        return this._spec.encoding;\n    };\n    Model.prototype.fieldDef = function (channel) {\n        return this._spec.encoding[channel] || {};\n    };\n    Model.prototype.field = function (channel, opt) {\n        if (opt === void 0) { opt = {}; }\n        var fieldDef = this.fieldDef(channel);\n        var scale = this.scale(channel);\n        if (fieldDef.bin) {\n            opt = util_1.extend({\n                binSuffix: scale_1.scaleType(scale, fieldDef, channel, this.mark()) === scale_2.ScaleType.ORDINAL ? '_range' : '_start'\n            }, opt);\n        }\n        return fielddef_1.field(fieldDef, opt);\n    };\n    Model.prototype.channelWithScales = function () {\n        var model = this;\n        return channel_2.CHANNELS.filter(function (channel) {\n            return !!model.scale(channel);\n        });\n    };\n    Model.prototype.reduce = function (f, init, t) {\n        return vlEncoding.reduce(this._spec.encoding, f, init, t);\n    };\n    Model.prototype.forEach = function (f, t) {\n        vlEncoding.forEach(this._spec.encoding, f, t);\n    };\n    Model.prototype.isOrdinalScale = function (channel) {\n        var fieldDef = this.fieldDef(channel);\n        var scale = this.scale(channel);\n        return this.has(channel) && scale_1.scaleType(scale, fieldDef, channel, this.mark()) === scale_2.ScaleType.ORDINAL;\n    };\n    Model.prototype.isFacet = function () {\n        return this.has(channel_1.ROW) || this.has(channel_1.COLUMN);\n    };\n    Model.prototype.dataTable = function () {\n        return vlEncoding.isAggregate(this._spec.encoding) ? data_1.SUMMARY : data_1.SOURCE;\n    };\n    Model.prototype.data = function () {\n        return this._spec.data;\n    };\n    Model.prototype.transform = function () {\n        return this._spec.transform || {};\n    };\n    Model.prototype.config = function () {\n        return this._config;\n    };\n    Model.prototype.sort = function (channel) {\n        return this._spec.encoding[channel].sort;\n    };\n    Model.prototype.scale = function (channel) {\n        return this._scale[channel];\n    };\n    Model.prototype.axis = function (channel) {\n        return this._axis[channel];\n    };\n    Model.prototype.legend = function (channel) {\n        return this._legend[channel];\n    };\n    Model.prototype.scaleName = function (channel) {\n        var name = this.spec().name;\n        return (name ? name + '-' : '') + channel;\n    };\n    return Model;\n}());\nexports.Model = Model;\n//# sourceMappingURL=Model.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-lite/src/compile/Model.js\n ** module id = 176\n ** module chunks = 0\n **/","\"use strict\";\nvar scale_1 = require('./scale');\nvar axis_1 = require('./axis');\nvar legend_1 = require('./legend');\nexports.defaultCellConfig = {\n    width: 200,\n    height: 200\n};\nexports.defaultFacetCellConfig = {\n    stroke: '#ccc',\n    strokeWidth: 1\n};\nvar defaultFacetGridConfig = {\n    color: '#000000',\n    opacity: 0.4,\n    offset: 0\n};\nexports.defaultFacetConfig = {\n    scale: scale_1.defaultFacetScaleConfig,\n    axis: axis_1.defaultFacetAxisConfig,\n    grid: defaultFacetGridConfig,\n    cell: exports.defaultFacetCellConfig\n};\n(function (FontWeight) {\n    FontWeight[FontWeight[\"NORMAL\"] = 'normal'] = \"NORMAL\";\n    FontWeight[FontWeight[\"BOLD\"] = 'bold'] = \"BOLD\";\n})(exports.FontWeight || (exports.FontWeight = {}));\nvar FontWeight = exports.FontWeight;\n(function (Shape) {\n    Shape[Shape[\"CIRCLE\"] = 'circle'] = \"CIRCLE\";\n    Shape[Shape[\"SQUARE\"] = 'square'] = \"SQUARE\";\n    Shape[Shape[\"CROSS\"] = 'cross'] = \"CROSS\";\n    Shape[Shape[\"DIAMOND\"] = 'diamond'] = \"DIAMOND\";\n    Shape[Shape[\"TRIANGLEUP\"] = 'triangle-up'] = \"TRIANGLEUP\";\n    Shape[Shape[\"TRIANGLEDOWN\"] = 'triangle-down'] = \"TRIANGLEDOWN\";\n})(exports.Shape || (exports.Shape = {}));\nvar Shape = exports.Shape;\n(function (HorizontalAlign) {\n    HorizontalAlign[HorizontalAlign[\"LEFT\"] = 'left'] = \"LEFT\";\n    HorizontalAlign[HorizontalAlign[\"RIGHT\"] = 'right'] = \"RIGHT\";\n    HorizontalAlign[HorizontalAlign[\"CENTER\"] = 'center'] = \"CENTER\";\n})(exports.HorizontalAlign || (exports.HorizontalAlign = {}));\nvar HorizontalAlign = exports.HorizontalAlign;\n(function (VerticalAlign) {\n    VerticalAlign[VerticalAlign[\"TOP\"] = 'top'] = \"TOP\";\n    VerticalAlign[VerticalAlign[\"MIDDLE\"] = 'middle'] = \"MIDDLE\";\n    VerticalAlign[VerticalAlign[\"BOTTOM\"] = 'bottom'] = \"BOTTOM\";\n})(exports.VerticalAlign || (exports.VerticalAlign = {}));\nvar VerticalAlign = exports.VerticalAlign;\n(function (FontStyle) {\n    FontStyle[FontStyle[\"NORMAL\"] = 'normal'] = \"NORMAL\";\n    FontStyle[FontStyle[\"ITALIC\"] = 'italic'] = \"ITALIC\";\n})(exports.FontStyle || (exports.FontStyle = {}));\nvar FontStyle = exports.FontStyle;\n(function (StackOffset) {\n    StackOffset[StackOffset[\"ZERO\"] = 'zero'] = \"ZERO\";\n    StackOffset[StackOffset[\"CENTER\"] = 'center'] = \"CENTER\";\n    StackOffset[StackOffset[\"NORMALIZE\"] = 'normalize'] = \"NORMALIZE\";\n    StackOffset[StackOffset[\"NONE\"] = 'none'] = \"NONE\";\n})(exports.StackOffset || (exports.StackOffset = {}));\nvar StackOffset = exports.StackOffset;\nexports.defaultMarkConfig = {\n    color: '#4682b4',\n    strokeWidth: 2,\n    size: 30,\n    barThinSize: 2,\n    tickThickness: 1,\n    fontSize: 10,\n    baseline: VerticalAlign.MIDDLE,\n    text: 'Abc',\n    shortTimeLabels: false,\n    applyColorToBackground: false\n};\nexports.defaultConfig = {\n    numberFormat: 's',\n    timeFormat: '%Y-%m-%d',\n    cell: exports.defaultCellConfig,\n    mark: exports.defaultMarkConfig,\n    scale: scale_1.defaultScaleConfig,\n    axis: axis_1.defaultAxisConfig,\n    legend: legend_1.defaultLegendConfig,\n    facet: exports.defaultFacetConfig,\n};\n//# sourceMappingURL=config.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-lite/src/config.js\n ** module id = 177\n ** module chunks = 0\n **/","\"use strict\";\n(function (ScaleType) {\n    ScaleType[ScaleType[\"LINEAR\"] = 'linear'] = \"LINEAR\";\n    ScaleType[ScaleType[\"LOG\"] = 'log'] = \"LOG\";\n    ScaleType[ScaleType[\"POW\"] = 'pow'] = \"POW\";\n    ScaleType[ScaleType[\"SQRT\"] = 'sqrt'] = \"SQRT\";\n    ScaleType[ScaleType[\"QUANTILE\"] = 'quantile'] = \"QUANTILE\";\n    ScaleType[ScaleType[\"QUANTIZE\"] = 'quantize'] = \"QUANTIZE\";\n    ScaleType[ScaleType[\"ORDINAL\"] = 'ordinal'] = \"ORDINAL\";\n    ScaleType[ScaleType[\"TIME\"] = 'time'] = \"TIME\";\n    ScaleType[ScaleType[\"UTC\"] = 'utc'] = \"UTC\";\n})(exports.ScaleType || (exports.ScaleType = {}));\nvar ScaleType = exports.ScaleType;\n(function (NiceTime) {\n    NiceTime[NiceTime[\"SECOND\"] = 'second'] = \"SECOND\";\n    NiceTime[NiceTime[\"MINUTE\"] = 'minute'] = \"MINUTE\";\n    NiceTime[NiceTime[\"HOUR\"] = 'hour'] = \"HOUR\";\n    NiceTime[NiceTime[\"DAY\"] = 'day'] = \"DAY\";\n    NiceTime[NiceTime[\"WEEK\"] = 'week'] = \"WEEK\";\n    NiceTime[NiceTime[\"MONTH\"] = 'month'] = \"MONTH\";\n    NiceTime[NiceTime[\"YEAR\"] = 'year'] = \"YEAR\";\n})(exports.NiceTime || (exports.NiceTime = {}));\nvar NiceTime = exports.NiceTime;\nexports.defaultScaleConfig = {\n    round: true,\n    textBandWidth: 90,\n    bandSize: 21,\n    padding: 1,\n    includeRawDomain: false,\n    nominalColorRange: 'category10',\n    sequentialColorRange: ['#AFC6A3', '#09622A'],\n    shapeRange: 'shapes',\n    fontSizeRange: [8, 40]\n};\nexports.defaultFacetScaleConfig = {\n    round: true,\n    padding: 16\n};\n//# sourceMappingURL=scale.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-lite/src/scale.js\n ** module id = 178\n ** module chunks = 0\n **/","\"use strict\";\n(function (AxisOrient) {\n    AxisOrient[AxisOrient[\"TOP\"] = 'top'] = \"TOP\";\n    AxisOrient[AxisOrient[\"RIGHT\"] = 'right'] = \"RIGHT\";\n    AxisOrient[AxisOrient[\"LEFT\"] = 'left'] = \"LEFT\";\n    AxisOrient[AxisOrient[\"BOTTOM\"] = 'bottom'] = \"BOTTOM\";\n})(exports.AxisOrient || (exports.AxisOrient = {}));\nvar AxisOrient = exports.AxisOrient;\nexports.defaultAxisConfig = {\n    offset: undefined,\n    grid: undefined,\n    labels: true,\n    labelMaxLength: 25,\n    tickSize: undefined,\n    characterWidth: 6\n};\nexports.defaultFacetAxisConfig = {\n    axisWidth: 0,\n    labels: true,\n    grid: false,\n    tickSize: 0\n};\n//# sourceMappingURL=axis.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-lite/src/axis.js\n ** module id = 179\n ** module chunks = 0\n **/","\"use strict\";\nexports.defaultLegendConfig = {\n    orient: undefined,\n    shortTimeLabels: false\n};\n//# sourceMappingURL=legend.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-lite/src/legend.js\n ** module id = 180\n ** module chunks = 0\n **/","\"use strict\";\n(function (Mark) {\n    Mark[Mark[\"AREA\"] = 'area'] = \"AREA\";\n    Mark[Mark[\"BAR\"] = 'bar'] = \"BAR\";\n    Mark[Mark[\"LINE\"] = 'line'] = \"LINE\";\n    Mark[Mark[\"POINT\"] = 'point'] = \"POINT\";\n    Mark[Mark[\"TEXT\"] = 'text'] = \"TEXT\";\n    Mark[Mark[\"TICK\"] = 'tick'] = \"TICK\";\n    Mark[Mark[\"CIRCLE\"] = 'circle'] = \"CIRCLE\";\n    Mark[Mark[\"SQUARE\"] = 'square'] = \"SQUARE\";\n})(exports.Mark || (exports.Mark = {}));\nvar Mark = exports.Mark;\nexports.AREA = Mark.AREA;\nexports.BAR = Mark.BAR;\nexports.LINE = Mark.LINE;\nexports.POINT = Mark.POINT;\nexports.TEXT = Mark.TEXT;\nexports.TICK = Mark.TICK;\nexports.CIRCLE = Mark.CIRCLE;\nexports.SQUARE = Mark.SQUARE;\n//# sourceMappingURL=mark.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-lite/src/mark.js\n ** module id = 181\n ** module chunks = 0\n **/","\"use strict\";\nvar channel_1 = require('../channel');\nvar encoding_1 = require('../encoding');\nvar fielddef_1 = require('../fielddef');\nvar mark_1 = require('../mark');\nvar util_1 = require('../util');\nfunction compileMarkConfig(mark, encoding, config, stack) {\n    return util_1.extend(['filled', 'opacity', 'orient', 'align'].reduce(function (cfg, property) {\n        var value = config.mark[property];\n        switch (property) {\n            case 'filled':\n                if (value === undefined) {\n                    cfg[property] = mark !== mark_1.POINT && mark !== mark_1.LINE;\n                }\n                break;\n            case 'opacity':\n                if (value === undefined && util_1.contains([mark_1.POINT, mark_1.TICK, mark_1.CIRCLE, mark_1.SQUARE], mark)) {\n                    if (!encoding_1.isAggregate(encoding) || encoding_1.has(encoding, channel_1.DETAIL)) {\n                        cfg[property] = 0.7;\n                    }\n                }\n                break;\n            case 'orient':\n                if (stack) {\n                    cfg[property] = stack.groupbyChannel === channel_1.Y ? 'horizontal' : undefined;\n                }\n                if (value === undefined) {\n                    cfg[property] = fielddef_1.isMeasure(encoding[channel_1.X]) && !fielddef_1.isMeasure(encoding[channel_1.Y]) ?\n                        'horizontal' :\n                        undefined;\n                }\n                break;\n            case 'align':\n                if (value === undefined) {\n                    cfg[property] = encoding_1.has(encoding, channel_1.X) ? 'center' : 'right';\n                }\n        }\n        return cfg;\n    }, {}), config.mark);\n}\nexports.compileMarkConfig = compileMarkConfig;\n//# sourceMappingURL=config.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-lite/src/compile/config.js\n ** module id = 182\n ** module chunks = 0\n **/","\"use strict\";\nvar channel_1 = require('../channel');\nvar scale_1 = require('../scale');\nvar config_1 = require('../config');\nvar mark_1 = require('../mark');\nvar fielddef_1 = require('../fielddef');\nvar encoding_1 = require('../encoding');\nvar util_1 = require('../util');\nvar common_1 = require('./common');\nvar scale_2 = require('./scale');\nfunction compileStackProperties(mark, encoding, scale, config) {\n    var stackFields = getStackFields(mark, encoding, scale);\n    if (stackFields.length > 0 &&\n        util_1.contains([mark_1.BAR, mark_1.AREA], mark) &&\n        config.mark.stacked !== config_1.StackOffset.NONE &&\n        encoding_1.isAggregate(encoding)) {\n        var isXMeasure = encoding_1.has(encoding, channel_1.X) && fielddef_1.isMeasure(encoding.x), isYMeasure = encoding_1.has(encoding, channel_1.Y) && fielddef_1.isMeasure(encoding.y);\n        if (isXMeasure && !isYMeasure) {\n            return {\n                groupbyChannel: channel_1.Y,\n                fieldChannel: channel_1.X,\n                stackFields: stackFields,\n                offset: config.mark.stacked\n            };\n        }\n        else if (isYMeasure && !isXMeasure) {\n            return {\n                groupbyChannel: channel_1.X,\n                fieldChannel: channel_1.Y,\n                stackFields: stackFields,\n                offset: config.mark.stacked\n            };\n        }\n    }\n    return null;\n}\nexports.compileStackProperties = compileStackProperties;\nfunction getStackFields(mark, encoding, scale) {\n    return [channel_1.COLOR, channel_1.DETAIL].reduce(function (fields, channel) {\n        var channelEncoding = encoding[channel];\n        if (encoding_1.has(encoding, channel)) {\n            if (util_1.isArray(channelEncoding)) {\n                channelEncoding.forEach(function (fieldDef) {\n                    fields.push(fielddef_1.field(fieldDef));\n                });\n            }\n            else {\n                var fieldDef = channelEncoding;\n                fields.push(fielddef_1.field(fieldDef, {\n                    binSuffix: scale_2.scaleType(scale[channel], fieldDef, channel, mark) === scale_1.ScaleType.ORDINAL ? '_range' : '_start'\n                }));\n            }\n        }\n        return fields;\n    }, []);\n}\nfunction imputeTransform(model) {\n    var stack = model.stack();\n    return {\n        type: 'impute',\n        field: model.field(stack.fieldChannel),\n        groupby: stack.stackFields,\n        orderby: [model.field(stack.groupbyChannel)],\n        method: 'value',\n        value: 0\n    };\n}\nexports.imputeTransform = imputeTransform;\nfunction stackTransform(model) {\n    var stack = model.stack();\n    var encoding = model.encoding();\n    var sortby = model.has(channel_1.ORDER) ?\n        (util_1.isArray(encoding[channel_1.ORDER]) ? encoding[channel_1.ORDER] : [encoding[channel_1.ORDER]]).map(common_1.sortField) :\n        stack.stackFields.map(function (field) {\n            return '-' + field;\n        });\n    var valName = model.field(stack.fieldChannel);\n    var transform = {\n        type: 'stack',\n        groupby: [model.field(stack.groupbyChannel)],\n        field: model.field(stack.fieldChannel),\n        sortby: sortby,\n        output: {\n            start: valName + '_start',\n            end: valName + '_end'\n        }\n    };\n    if (stack.offset) {\n        transform.offset = stack.offset;\n    }\n    return transform;\n}\nexports.stackTransform = stackTransform;\n//# sourceMappingURL=stack.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-lite/src/compile/stack.js\n ** module id = 183\n ** module chunks = 0\n **/","\"use strict\";\nvar channel_1 = require('../channel');\nvar fielddef_1 = require('../fielddef');\nvar sort_1 = require('../sort');\nvar type_1 = require('../type');\nvar time_1 = require('./time');\nvar util_1 = require('../util');\nexports.FILL_STROKE_CONFIG = ['fill', 'fillOpacity',\n    'stroke', 'strokeWidth', 'strokeDash', 'strokeDashOffset', 'strokeOpacity',\n    'opacity'];\nfunction applyColorAndOpacity(p, model) {\n    var filled = model.config().mark.filled;\n    var fieldDef = model.fieldDef(channel_1.COLOR);\n    applyMarkConfig(p, model, exports.FILL_STROKE_CONFIG);\n    var value;\n    if (model.has(channel_1.COLOR)) {\n        value = {\n            scale: model.scaleName(channel_1.COLOR),\n            field: model.field(channel_1.COLOR, fieldDef.type === type_1.ORDINAL ? { prefn: 'rank_' } : {})\n        };\n    }\n    else if (fieldDef && fieldDef.value) {\n        value = { value: fieldDef.value };\n    }\n    if (value !== undefined) {\n        if (filled) {\n            p.fill = value;\n        }\n        else {\n            p.stroke = value;\n        }\n    }\n    else {\n        p[filled ? 'fill' : 'stroke'] = p[filled ? 'fill' : 'stroke'] ||\n            { value: model.config().mark.color };\n    }\n}\nexports.applyColorAndOpacity = applyColorAndOpacity;\nfunction applyConfig(properties, config, propsList) {\n    propsList.forEach(function (property) {\n        var value = config[property];\n        if (value !== undefined) {\n            properties[property] = { value: value };\n        }\n    });\n}\nexports.applyConfig = applyConfig;\nfunction applyMarkConfig(marksProperties, model, propsList) {\n    applyConfig(marksProperties, model.config().mark, propsList);\n}\nexports.applyMarkConfig = applyMarkConfig;\nfunction formatMixins(model, channel, format) {\n    var fieldDef = model.fieldDef(channel);\n    if (!util_1.contains([type_1.QUANTITATIVE, type_1.TEMPORAL], fieldDef.type)) {\n        return {};\n    }\n    var def = {};\n    if (fieldDef.type === type_1.TEMPORAL) {\n        def.formatType = 'time';\n    }\n    if (format !== undefined) {\n        def.format = format;\n    }\n    else {\n        switch (fieldDef.type) {\n            case type_1.QUANTITATIVE:\n                def.format = model.config().numberFormat;\n                break;\n            case type_1.TEMPORAL:\n                def.format = timeFormat(model, channel) || model.config().timeFormat;\n                break;\n        }\n    }\n    if (channel === channel_1.TEXT) {\n        var filter = (def.formatType || 'number') + (def.format ? ':\\'' + def.format + '\\'' : '');\n        return {\n            text: {\n                template: '{{' + model.field(channel, { datum: true }) + ' | ' + filter + '}}'\n            }\n        };\n    }\n    return def;\n}\nexports.formatMixins = formatMixins;\nfunction isAbbreviated(model, channel, fieldDef) {\n    switch (channel) {\n        case channel_1.ROW:\n        case channel_1.COLUMN:\n        case channel_1.X:\n        case channel_1.Y:\n            return model.axis(channel).shortTimeLabels;\n        case channel_1.COLOR:\n        case channel_1.SHAPE:\n        case channel_1.SIZE:\n            return model.legend(channel).shortTimeLabels;\n        case channel_1.TEXT:\n            return model.config().mark.shortTimeLabels;\n        case channel_1.LABEL:\n    }\n    return false;\n}\nfunction sortField(orderChannelDef) {\n    return (orderChannelDef.sort === sort_1.SortOrder.DESCENDING ? '-' : '') + fielddef_1.field(orderChannelDef);\n}\nexports.sortField = sortField;\nfunction timeFormat(model, channel) {\n    var fieldDef = model.fieldDef(channel);\n    return time_1.format(fieldDef.timeUnit, isAbbreviated(model, channel, fieldDef));\n}\nexports.timeFormat = timeFormat;\n//# sourceMappingURL=common.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-lite/src/compile/common.js\n ** module id = 184\n ** module chunks = 0\n **/","\"use strict\";\n(function (SortOrder) {\n    SortOrder[SortOrder[\"ASCENDING\"] = 'ascending'] = \"ASCENDING\";\n    SortOrder[SortOrder[\"DESCENDING\"] = 'descending'] = \"DESCENDING\";\n    SortOrder[SortOrder[\"NONE\"] = 'none'] = \"NONE\";\n})(exports.SortOrder || (exports.SortOrder = {}));\nvar SortOrder = exports.SortOrder;\n//# sourceMappingURL=sort.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-lite/src/sort.js\n ** module id = 185\n ** module chunks = 0\n **/","\"use strict\";\nvar util_1 = require('../util');\nvar channel_1 = require('../channel');\nvar timeunit_1 = require('../timeunit');\nfunction format(timeUnit, abbreviated) {\n    if (abbreviated === void 0) { abbreviated = false; }\n    if (!timeUnit) {\n        return undefined;\n    }\n    var timeString = timeUnit.toString();\n    var dateComponents = [];\n    if (timeString.indexOf('year') > -1) {\n        dateComponents.push(abbreviated ? '%y' : '%Y');\n    }\n    if (timeString.indexOf('month') > -1) {\n        dateComponents.push(abbreviated ? '%b' : '%B');\n    }\n    if (timeString.indexOf('day') > -1) {\n        dateComponents.push(abbreviated ? '%a' : '%A');\n    }\n    else if (timeString.indexOf('date') > -1) {\n        dateComponents.push('%d');\n    }\n    var timeComponents = [];\n    if (timeString.indexOf('hours') > -1) {\n        timeComponents.push('%H');\n    }\n    if (timeString.indexOf('minutes') > -1) {\n        timeComponents.push('%M');\n    }\n    if (timeString.indexOf('seconds') > -1) {\n        timeComponents.push('%S');\n    }\n    if (timeString.indexOf('milliseconds') > -1) {\n        timeComponents.push('%L');\n    }\n    var out = [];\n    if (dateComponents.length > 0) {\n        out.push(dateComponents.join('-'));\n    }\n    if (timeComponents.length > 0) {\n        out.push(timeComponents.join(':'));\n    }\n    return out.length > 0 ? out.join(' ') : undefined;\n}\nexports.format = format;\nfunction smallestUnit(timeUnit) {\n    if (!timeUnit) {\n        return undefined;\n    }\n    if (timeUnit.indexOf('second') > -1) {\n        return 'second';\n    }\n    if (timeUnit.indexOf('minute') > -1) {\n        return 'minute';\n    }\n    if (timeUnit.indexOf('hour') > -1) {\n        return 'hour';\n    }\n    if (timeUnit.indexOf('day') > -1 || timeUnit.indexOf('date') > -1) {\n        return 'day';\n    }\n    if (timeUnit.indexOf('month') > -1) {\n        return 'month';\n    }\n    if (timeUnit.indexOf('year') > -1) {\n        return 'year';\n    }\n    return undefined;\n}\nexports.smallestUnit = smallestUnit;\nfunction parseExpression(timeUnit, fieldRef, onlyRef) {\n    if (onlyRef === void 0) { onlyRef = false; }\n    var out = 'datetime(';\n    var timeString = timeUnit.toString();\n    function get(fun, addComma) {\n        if (addComma === void 0) { addComma = true; }\n        if (onlyRef) {\n            return fieldRef + (addComma ? ', ' : '');\n        }\n        else {\n            return fun + '(' + fieldRef + ')' + (addComma ? ', ' : '');\n        }\n    }\n    if (timeString.indexOf('year') > -1) {\n        out += get('year');\n    }\n    else {\n        out += '2006, ';\n    }\n    if (timeString.indexOf('month') > -1) {\n        out += get('month');\n    }\n    else {\n        out += '0, ';\n    }\n    if (timeString.indexOf('day') > -1) {\n        out += get('day', false) + '+1, ';\n    }\n    else if (timeString.indexOf('date') > -1) {\n        out += get('date');\n    }\n    else {\n        out += '1, ';\n    }\n    if (timeString.indexOf('hours') > -1) {\n        out += get('hours');\n    }\n    else {\n        out += '0, ';\n    }\n    if (timeString.indexOf('minutes') > -1) {\n        out += get('minutes');\n    }\n    else {\n        out += '0, ';\n    }\n    if (timeString.indexOf('seconds') > -1) {\n        out += get('seconds');\n    }\n    else {\n        out += '0, ';\n    }\n    if (timeString.indexOf('milliseconds') > -1) {\n        out += get('milliseconds', false);\n    }\n    else {\n        out += '0';\n    }\n    return out + ')';\n}\nexports.parseExpression = parseExpression;\nfunction rawDomain(timeUnit, channel) {\n    if (util_1.contains([channel_1.ROW, channel_1.COLUMN, channel_1.SHAPE, channel_1.COLOR], channel)) {\n        return null;\n    }\n    switch (timeUnit) {\n        case timeunit_1.TimeUnit.SECONDS:\n            return util_1.range(0, 60);\n        case timeunit_1.TimeUnit.MINUTES:\n            return util_1.range(0, 60);\n        case timeunit_1.TimeUnit.HOURS:\n            return util_1.range(0, 24);\n        case timeunit_1.TimeUnit.DAY:\n            return util_1.range(0, 7);\n        case timeunit_1.TimeUnit.DATE:\n            return util_1.range(1, 32);\n        case timeunit_1.TimeUnit.MONTH:\n            return util_1.range(0, 12);\n    }\n    return null;\n}\nexports.rawDomain = rawDomain;\n//# sourceMappingURL=time.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-lite/src/compile/time.js\n ** module id = 186\n ** module chunks = 0\n **/","\"use strict\";\nvar util_1 = require('../util');\nvar aggregate_1 = require('../aggregate');\nvar channel_1 = require('../channel');\nvar data_1 = require('../data');\nvar type_1 = require('../type');\nvar mark_1 = require('../mark');\nvar time_1 = require('./time');\nvar scale_1 = require('../scale');\nvar config_1 = require('../config');\nvar timeunit_1 = require('../timeunit');\nvar fielddef_1 = require('../fielddef');\nexports.COLOR_LEGEND = 'color_legend';\nexports.COLOR_LEGEND_LABEL = 'color_legend_label';\nfunction compileScales(model) {\n    return model.channelWithScales().reduce(function (scales, channel) {\n        var fieldDef = model.fieldDef(channel);\n        if (channel === channel_1.COLOR && model.legend(channel_1.COLOR) && (fieldDef.type === type_1.ORDINAL || fieldDef.bin || fieldDef.timeUnit)) {\n            scales.push(colorLegendScale(model, fieldDef));\n            if (fieldDef.bin) {\n                scales.push(binColorLegendLabel(model, fieldDef));\n            }\n        }\n        scales.push(mainScale(model, fieldDef, channel));\n        return scales;\n    }, []);\n}\nexports.compileScales = compileScales;\nfunction mainScale(model, fieldDef, channel) {\n    var scale = model.scale(channel);\n    var sort = model.sort(channel);\n    var scaleDef = {\n        name: model.scaleName(channel),\n        type: scaleType(scale, fieldDef, channel, model.mark()),\n    };\n    scaleDef.domain = domain(scale, model, channel, scaleDef.type);\n    util_1.extend(scaleDef, rangeMixins(scale, model, channel, scaleDef.type));\n    if (sort && (typeof sort === 'string' ? sort : sort.order) === 'descending') {\n        scaleDef.reverse = true;\n    }\n    [\n        'round',\n        'clamp', 'nice',\n        'exponent', 'zero',\n        'padding', 'points'\n    ].forEach(function (property) {\n        var value = exports[property](scale[property], scaleDef.type, channel, fieldDef);\n        if (value !== undefined) {\n            scaleDef[property] = value;\n        }\n    });\n    return scaleDef;\n}\nfunction colorLegendScale(model, fieldDef) {\n    return {\n        name: model.scaleName(exports.COLOR_LEGEND),\n        type: 'ordinal',\n        domain: {\n            data: model.dataTable(),\n            field: model.field(channel_1.COLOR, (fieldDef.bin || fieldDef.timeUnit) ? {} : { prefn: 'rank_' }), sort: true\n        },\n        range: { data: model.dataTable(), field: model.field(channel_1.COLOR), sort: true }\n    };\n}\nfunction binColorLegendLabel(model, fieldDef) {\n    return {\n        name: model.scaleName(exports.COLOR_LEGEND_LABEL),\n        type: 'ordinal',\n        domain: {\n            data: model.dataTable(),\n            field: model.field(channel_1.COLOR, { prefn: 'rank_' }),\n            sort: true\n        },\n        range: {\n            data: model.dataTable(),\n            field: fielddef_1.field(fieldDef, { binSuffix: '_range' }),\n            sort: {\n                field: model.field(channel_1.COLOR, { binSuffix: '_start' }),\n                op: 'min'\n            }\n        }\n    };\n}\nfunction scaleType(scale, fieldDef, channel, mark) {\n    if (!channel_1.hasScale(channel)) {\n        return null;\n    }\n    if (util_1.contains([channel_1.ROW, channel_1.COLUMN, channel_1.SHAPE], channel)) {\n        return scale_1.ScaleType.ORDINAL;\n    }\n    if (scale.type !== undefined) {\n        return scale.type;\n    }\n    switch (fieldDef.type) {\n        case type_1.NOMINAL:\n            return scale_1.ScaleType.ORDINAL;\n        case type_1.ORDINAL:\n            if (channel === channel_1.COLOR) {\n                return scale_1.ScaleType.LINEAR;\n            }\n            return scale_1.ScaleType.ORDINAL;\n        case type_1.TEMPORAL:\n            if (channel === channel_1.COLOR) {\n                return scale_1.ScaleType.TIME;\n            }\n            if (fieldDef.timeUnit) {\n                switch (fieldDef.timeUnit) {\n                    case timeunit_1.TimeUnit.HOURS:\n                    case timeunit_1.TimeUnit.DAY:\n                    case timeunit_1.TimeUnit.MONTH:\n                        return scale_1.ScaleType.ORDINAL;\n                    default:\n                        return scale_1.ScaleType.TIME;\n                }\n            }\n            return scale_1.ScaleType.TIME;\n        case type_1.QUANTITATIVE:\n            if (fieldDef.bin) {\n                return util_1.contains([channel_1.X, channel_1.Y, channel_1.COLOR], channel) ? scale_1.ScaleType.LINEAR : scale_1.ScaleType.ORDINAL;\n            }\n            return scale_1.ScaleType.LINEAR;\n    }\n    return null;\n}\nexports.scaleType = scaleType;\nfunction domain(scale, model, channel, scaleType) {\n    var fieldDef = model.fieldDef(channel);\n    if (scale.domain) {\n        return scale.domain;\n    }\n    if (fieldDef.type === type_1.TEMPORAL) {\n        if (time_1.rawDomain(fieldDef.timeUnit, channel)) {\n            return {\n                data: fieldDef.timeUnit,\n                field: 'date'\n            };\n        }\n        return {\n            data: model.dataTable(),\n            field: model.field(channel),\n            sort: {\n                field: model.field(channel),\n                op: 'min'\n            }\n        };\n    }\n    var stack = model.stack();\n    if (stack && channel === stack.fieldChannel) {\n        if (stack.offset === config_1.StackOffset.NORMALIZE) {\n            return [0, 1];\n        }\n        return {\n            data: data_1.STACKED_SCALE,\n            field: model.field(channel, { prefn: 'sum_' })\n        };\n    }\n    var includeRawDomain = _includeRawDomain(scale, model, channel, scaleType), sort = domainSort(model, channel, scaleType);\n    if (includeRawDomain) {\n        return {\n            data: data_1.SOURCE,\n            field: model.field(channel, { noAggregate: true })\n        };\n    }\n    else if (fieldDef.bin) {\n        return scaleType === scale_1.ScaleType.ORDINAL ? {\n            data: model.dataTable(),\n            field: model.field(channel, { binSuffix: '_range' }),\n            sort: {\n                field: model.field(channel, { binSuffix: '_start' }),\n                op: 'min'\n            }\n        } : channel === channel_1.COLOR ? {\n            data: model.dataTable(),\n            field: model.field(channel, { binSuffix: '_start' })\n        } : {\n            data: model.dataTable(),\n            field: [\n                model.field(channel, { binSuffix: '_start' }),\n                model.field(channel, { binSuffix: '_end' })\n            ]\n        };\n    }\n    else if (sort) {\n        return {\n            data: sort.op ? data_1.SOURCE : model.dataTable(),\n            field: (fieldDef.type === type_1.ORDINAL && channel === channel_1.COLOR) ? model.field(channel, { prefn: 'rank_' }) : model.field(channel),\n            sort: sort\n        };\n    }\n    else {\n        return {\n            data: model.dataTable(),\n            field: (fieldDef.type === type_1.ORDINAL && channel === channel_1.COLOR) ? model.field(channel, { prefn: 'rank_' }) : model.field(channel),\n        };\n    }\n}\nexports.domain = domain;\nfunction domainSort(model, channel, scaleType) {\n    if (scaleType !== scale_1.ScaleType.ORDINAL) {\n        return undefined;\n    }\n    var sort = model.sort(channel);\n    if (util_1.contains(['ascending', 'descending', undefined], sort)) {\n        return true;\n    }\n    if (typeof sort !== 'string') {\n        return {\n            op: sort.op,\n            field: sort.field\n        };\n    }\n    return undefined;\n}\nexports.domainSort = domainSort;\nfunction _includeRawDomain(scale, model, channel, scaleType) {\n    var fieldDef = model.fieldDef(channel);\n    return scale.includeRawDomain &&\n        fieldDef.aggregate &&\n        aggregate_1.SHARED_DOMAIN_OPS.indexOf(fieldDef.aggregate) >= 0 &&\n        ((fieldDef.type === type_1.QUANTITATIVE && !fieldDef.bin) ||\n            (fieldDef.type === type_1.TEMPORAL && util_1.contains([scale_1.ScaleType.TIME, scale_1.ScaleType.UTC], scaleType)));\n}\nfunction rangeMixins(scale, model, channel, scaleType) {\n    var fieldDef = model.fieldDef(channel), scaleConfig = model.config().scale;\n    if (scaleType === scale_1.ScaleType.ORDINAL && scale.bandSize && util_1.contains([channel_1.X, channel_1.Y], channel)) {\n        return { bandSize: scale.bandSize };\n    }\n    if (scale.range && !util_1.contains([channel_1.X, channel_1.Y, channel_1.ROW, channel_1.COLUMN], channel)) {\n        return { range: scale.range };\n    }\n    switch (channel) {\n        case channel_1.X:\n            return {\n                rangeMin: 0,\n                rangeMax: model.cellWidth()\n            };\n        case channel_1.Y:\n            return {\n                rangeMin: model.cellHeight(),\n                rangeMax: 0\n            };\n        case channel_1.SIZE:\n            if (model.mark() === mark_1.BAR) {\n                if (scaleConfig.barSizeRange !== undefined) {\n                    return { range: scaleConfig.barSizeRange };\n                }\n                var dimension = model.config().mark.orient === 'horizontal' ? channel_1.Y : channel_1.X;\n                return { range: [model.config().mark.barThinSize, model.scale(dimension).bandSize] };\n            }\n            else if (model.mark() === mark_1.TEXT) {\n                return { range: scaleConfig.fontSizeRange };\n            }\n            if (scaleConfig.pointSizeRange !== undefined) {\n                return { range: scaleConfig.pointSizeRange };\n            }\n            var xIsMeasure = fielddef_1.isMeasure(model.encoding().x);\n            var yIsMeasure = fielddef_1.isMeasure(model.encoding().y);\n            var bandSize = xIsMeasure !== yIsMeasure ?\n                model.scale(xIsMeasure ? channel_1.Y : channel_1.X).bandSize :\n                Math.min(model.scale(channel_1.X).bandSize || scaleConfig.bandSize, model.scale(channel_1.Y).bandSize || scaleConfig.bandSize);\n            return { range: [9, (bandSize - 2) * (bandSize - 2)] };\n        case channel_1.SHAPE:\n            return { range: scaleConfig.shapeRange };\n        case channel_1.COLOR:\n            if (fieldDef.type === type_1.NOMINAL) {\n                return { range: scaleConfig.nominalColorRange };\n            }\n            return { range: scaleConfig.sequentialColorRange };\n        case channel_1.ROW:\n            return { range: 'height' };\n        case channel_1.COLUMN:\n            return { range: 'width' };\n    }\n    return {};\n}\nexports.rangeMixins = rangeMixins;\nfunction clamp(prop, scaleType) {\n    if (util_1.contains([scale_1.ScaleType.LINEAR, scale_1.ScaleType.POW, scale_1.ScaleType.SQRT,\n        scale_1.ScaleType.LOG, scale_1.ScaleType.TIME, scale_1.ScaleType.UTC], scaleType)) {\n        return prop;\n    }\n    return undefined;\n}\nexports.clamp = clamp;\nfunction exponent(prop, scaleType) {\n    if (scaleType === scale_1.ScaleType.POW) {\n        return prop;\n    }\n    return undefined;\n}\nexports.exponent = exponent;\nfunction nice(prop, scaleType, channel, fieldDef) {\n    if (util_1.contains([scale_1.ScaleType.LINEAR, scale_1.ScaleType.POW, scale_1.ScaleType.SQRT, scale_1.ScaleType.LOG,\n        scale_1.ScaleType.TIME, scale_1.ScaleType.UTC, scale_1.ScaleType.QUANTIZE], scaleType)) {\n        if (prop !== undefined) {\n            return prop;\n        }\n        if (util_1.contains([scale_1.ScaleType.TIME, scale_1.ScaleType.UTC], scaleType)) {\n            return time_1.smallestUnit(fieldDef.timeUnit);\n        }\n        return util_1.contains([channel_1.X, channel_1.Y], channel);\n    }\n    return undefined;\n}\nexports.nice = nice;\nfunction padding(prop, scaleType, channel) {\n    if (scaleType === scale_1.ScaleType.ORDINAL && util_1.contains([channel_1.X, channel_1.Y], channel)) {\n        return prop;\n    }\n    return undefined;\n}\nexports.padding = padding;\nfunction points(__, scaleType, channel) {\n    if (scaleType === scale_1.ScaleType.ORDINAL && util_1.contains([channel_1.X, channel_1.Y], channel)) {\n        return true;\n    }\n    return undefined;\n}\nexports.points = points;\nfunction round(prop, scaleType, channel) {\n    if (util_1.contains([channel_1.X, channel_1.Y, channel_1.ROW, channel_1.COLUMN, channel_1.SIZE], channel) && prop !== undefined) {\n        return prop;\n    }\n    return undefined;\n}\nexports.round = round;\nfunction zero(prop, scaleType, channel, fieldDef) {\n    if (!util_1.contains([scale_1.ScaleType.TIME, scale_1.ScaleType.UTC, scale_1.ScaleType.ORDINAL], scaleType)) {\n        if (prop !== undefined) {\n            return prop;\n        }\n        return !fieldDef.bin && util_1.contains([channel_1.X, channel_1.Y], channel);\n    }\n    return undefined;\n}\nexports.zero = zero;\n//# sourceMappingURL=scale.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-lite/src/compile/scale.js\n ** module id = 187\n ** module chunks = 0\n **/","\"use strict\";\nvar axis_1 = require('../axis');\nvar channel_1 = require('../channel');\nvar fielddef_1 = require('../fielddef');\nvar type_1 = require('../type');\nvar util_1 = require('../util');\nvar common_1 = require('./common');\nfunction compileInnerAxis(channel, model) {\n    var isCol = channel === channel_1.COLUMN, isRow = channel === channel_1.ROW, type = isCol ? 'x' : isRow ? 'y' : channel;\n    var def = {\n        type: type,\n        scale: model.scaleName(channel),\n        grid: true,\n        tickSize: 0,\n        properties: {\n            labels: {\n                text: { value: '' }\n            },\n            axis: {\n                stroke: { value: 'transparent' }\n            }\n        }\n    };\n    var axis = model.axis(channel);\n    ['layer', 'ticks', 'values', 'subdivide'].forEach(function (property) {\n        var method;\n        var value = (method = exports[property]) ?\n            method(model, channel, def) :\n            axis[property];\n        if (value !== undefined) {\n            def[property] = value;\n        }\n    });\n    return def;\n}\nexports.compileInnerAxis = compileInnerAxis;\nfunction compileAxis(channel, model) {\n    var isCol = channel === channel_1.COLUMN, isRow = channel === channel_1.ROW, type = isCol ? 'x' : isRow ? 'y' : channel;\n    var axis = model.axis(channel);\n    var def = {\n        type: type,\n        scale: model.scaleName(channel)\n    };\n    util_1.extend(def, common_1.formatMixins(model, channel, model.axis(channel).format));\n    [\n        'grid', 'layer', 'offset', 'orient', 'tickSize', 'ticks', 'title',\n        'tickPadding', 'tickSize', 'tickSizeMajor', 'tickSizeMinor', 'tickSizeEnd',\n        'titleOffset', 'values', 'subdivide'\n    ].forEach(function (property) {\n        var method;\n        var value = (method = exports[property]) ?\n            method(model, channel, def) :\n            axis[property];\n        if (value !== undefined) {\n            def[property] = value;\n        }\n    });\n    var props = model.axis(channel).properties || {};\n    [\n        'axis', 'labels',\n        'grid', 'title', 'ticks', 'majorTicks', 'minorTicks'\n    ].forEach(function (group) {\n        var value = properties[group] ?\n            properties[group](model, channel, props[group] || {}, def) :\n            props[group];\n        if (value !== undefined) {\n            def.properties = def.properties || {};\n            def.properties[group] = value;\n        }\n    });\n    return def;\n}\nexports.compileAxis = compileAxis;\nfunction offset(model, channel) {\n    return model.axis(channel).offset;\n}\nexports.offset = offset;\nfunction gridShow(model, channel) {\n    var grid = model.axis(channel).grid;\n    if (grid !== undefined) {\n        return grid;\n    }\n    return !model.isOrdinalScale(channel) && !model.fieldDef(channel).bin;\n}\nexports.gridShow = gridShow;\nfunction grid(model, channel) {\n    if (channel === channel_1.ROW || channel === channel_1.COLUMN) {\n        return undefined;\n    }\n    return gridShow(model, channel) && ((channel === channel_1.Y || channel === channel_1.X) && !(model.has(channel_1.COLUMN) || model.has(channel_1.ROW)));\n}\nexports.grid = grid;\nfunction layer(model, channel, def) {\n    var layer = model.axis(channel).layer;\n    if (layer !== undefined) {\n        return layer;\n    }\n    if (def.grid) {\n        return 'back';\n    }\n    return undefined;\n}\nexports.layer = layer;\n;\nfunction orient(model, channel) {\n    var orient = model.axis(channel).orient;\n    if (orient) {\n        return orient;\n    }\n    else if (channel === channel_1.COLUMN) {\n        return axis_1.AxisOrient.TOP;\n    }\n    else if (channel === channel_1.ROW) {\n        if (model.has(channel_1.Y) && model.axis(channel_1.Y).orient !== axis_1.AxisOrient.RIGHT) {\n            return axis_1.AxisOrient.RIGHT;\n        }\n    }\n    return undefined;\n}\nexports.orient = orient;\nfunction ticks(model, channel) {\n    var ticks = model.axis(channel).ticks;\n    if (ticks !== undefined) {\n        return ticks;\n    }\n    if (channel === channel_1.X && !model.fieldDef(channel).bin) {\n        return 5;\n    }\n    return undefined;\n}\nexports.ticks = ticks;\nfunction tickSize(model, channel) {\n    var tickSize = model.axis(channel).tickSize;\n    if (tickSize !== undefined) {\n        return tickSize;\n    }\n    return undefined;\n}\nexports.tickSize = tickSize;\nfunction title(model, channel) {\n    var axis = model.axis(channel);\n    if (axis.title !== undefined) {\n        return axis.title;\n    }\n    var fieldTitle = fielddef_1.title(model.fieldDef(channel));\n    var maxLength;\n    if (axis.titleMaxLength) {\n        maxLength = axis.titleMaxLength;\n    }\n    else if (channel === channel_1.X && !model.isOrdinalScale(channel_1.X)) {\n        maxLength = model.cellWidth() / model.axis(channel_1.X).characterWidth;\n    }\n    else if (channel === channel_1.Y && !model.isOrdinalScale(channel_1.Y)) {\n        maxLength = model.cellHeight() / model.axis(channel_1.Y).characterWidth;\n    }\n    return maxLength ? util_1.truncate(fieldTitle, maxLength) : fieldTitle;\n}\nexports.title = title;\nvar properties;\n(function (properties) {\n    function axis(model, channel, axisPropsSpec, def) {\n        var axis = model.axis(channel);\n        return util_1.extend(axis.axisWidth !== undefined ?\n            { strokeWidth: { value: axis.axisWidth } } :\n            {}, axisPropsSpec || {});\n    }\n    properties.axis = axis;\n    function labels(model, channel, labelsSpec, def) {\n        var fieldDef = model.fieldDef(channel);\n        var axis = model.axis(channel);\n        if (!axis.labels) {\n            return util_1.extend({\n                text: ''\n            }, labelsSpec);\n        }\n        if (util_1.contains([type_1.NOMINAL, type_1.ORDINAL], fieldDef.type) && axis.labelMaxLength) {\n            labelsSpec = util_1.extend({\n                text: {\n                    template: '{{ datum.data | truncate:' + axis.labelMaxLength + '}}'\n                }\n            }, labelsSpec || {});\n        }\n        if (axis.labelAngle !== undefined) {\n            labelsSpec.angle = { value: axis.labelAngle };\n        }\n        else {\n            if (channel === channel_1.X && (fielddef_1.isDimension(fieldDef) || fieldDef.type === type_1.TEMPORAL)) {\n                labelsSpec.angle = { value: 270 };\n            }\n            else if (channel === channel_1.ROW && model.has(channel_1.X)) {\n                labelsSpec.angle = { value: def.orient === 'left' ? 270 : 90 };\n            }\n        }\n        if (axis.labelAlign !== undefined) {\n            labelsSpec.align = { value: axis.labelAlign };\n        }\n        else {\n            if (labelsSpec.angle) {\n                if (labelsSpec.angle.value === 270) {\n                    labelsSpec.align = {\n                        value: def.orient === 'top' ? 'left' :\n                            def.type === 'x' ? 'right' :\n                                'center'\n                    };\n                }\n                else if (labelsSpec.angle.value === 90) {\n                    labelsSpec.align = { value: 'center' };\n                }\n            }\n        }\n        if (axis.labelBaseline !== undefined) {\n            labelsSpec.baseline = { value: axis.labelBaseline };\n        }\n        else {\n            if (labelsSpec.angle) {\n                if (labelsSpec.angle.value === 270) {\n                    labelsSpec.baseline = { value: def.type === 'x' ? 'middle' : 'bottom' };\n                }\n                else if (labelsSpec.angle.value === 90) {\n                    labelsSpec.baseline = { value: 'bottom' };\n                }\n            }\n        }\n        return labelsSpec || undefined;\n    }\n    properties.labels = labels;\n})(properties = exports.properties || (exports.properties = {}));\n//# sourceMappingURL=axis.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-lite/src/compile/axis.js\n ** module id = 188\n ** module chunks = 0\n **/","\"use strict\";\nvar vlFieldDef = require('../fielddef');\nvar util_1 = require('../util');\nvar scale_1 = require('../scale');\nvar bin_1 = require('../bin');\nvar channel_1 = require('../channel');\nvar data_1 = require('../data');\nvar fielddef_1 = require('../fielddef');\nvar type_1 = require('../type');\nvar scale_2 = require('./scale');\nvar time_1 = require('./time');\nvar aggregate_1 = require('../aggregate');\nvar DEFAULT_NULL_FILTERS = {\n    nominal: false,\n    ordinal: false,\n    quantitative: true,\n    temporal: true\n};\nfunction compileData(model) {\n    var def = [source.def(model)];\n    var summaryDef = summary.def(model);\n    if (summaryDef) {\n        def.push(summaryDef);\n    }\n    rankTransform(def[def.length - 1], model);\n    filterNonPositiveForLog(def[def.length - 1], model);\n    var stackDef = model.stack();\n    if (stackDef) {\n        def.push(stack.def(model, stackDef));\n    }\n    return def.concat(dates.defs(model));\n}\nexports.compileData = compileData;\nvar source;\n(function (source_1) {\n    function def(model) {\n        var source = { name: data_1.SOURCE };\n        var data = model.data();\n        if (data) {\n            if (data.values && data.values.length > 0) {\n                source.values = model.data().values;\n                source.format = { type: 'json' };\n            }\n            else if (data.url) {\n                source.url = data.url;\n                var defaultExtension = /(?:\\.([^.]+))?$/.exec(source.url)[1];\n                if (!util_1.contains(['json', 'csv', 'tsv'], defaultExtension)) {\n                    defaultExtension = 'json';\n                }\n                source.format = { type: model.data().formatType || defaultExtension };\n            }\n        }\n        var parse = formatParse(model);\n        if (parse) {\n            source.format = source.format || {};\n            source.format.parse = parse;\n        }\n        source.transform = transform(model);\n        return source;\n    }\n    source_1.def = def;\n    function formatParse(model) {\n        var calcFieldMap = (model.transform().calculate || []).reduce(function (fieldMap, formula) {\n            fieldMap[formula.field] = true;\n            return fieldMap;\n        }, {});\n        var parse;\n        model.forEach(function (fieldDef) {\n            if (fieldDef.type === type_1.TEMPORAL) {\n                parse = parse || {};\n                parse[fieldDef.field] = 'date';\n            }\n            else if (fieldDef.type === type_1.QUANTITATIVE) {\n                if (vlFieldDef.isCount(fieldDef) || calcFieldMap[fieldDef.field]) {\n                    return;\n                }\n                parse = parse || {};\n                parse[fieldDef.field] = 'number';\n            }\n        });\n        return parse;\n    }\n    function transform(model) {\n        return nullFilterTransform(model).concat(formulaTransform(model), filterTransform(model), binTransform(model), timeTransform(model));\n    }\n    source_1.transform = transform;\n    function timeTransform(model) {\n        return model.reduce(function (transform, fieldDef, channel) {\n            var ref = fielddef_1.field(fieldDef, { nofn: true, datum: true });\n            if (fieldDef.type === type_1.TEMPORAL && fieldDef.timeUnit) {\n                transform.push({\n                    type: 'formula',\n                    field: fielddef_1.field(fieldDef),\n                    expr: time_1.parseExpression(fieldDef.timeUnit, ref)\n                });\n            }\n            return transform;\n        }, []);\n    }\n    source_1.timeTransform = timeTransform;\n    function binTransform(model) {\n        return model.reduce(function (transform, fieldDef, channel) {\n            var bin = model.fieldDef(channel).bin;\n            var scale = model.scale(channel);\n            if (bin) {\n                var binTrans = util_1.extend({\n                    type: 'bin',\n                    field: fieldDef.field,\n                    output: {\n                        start: fielddef_1.field(fieldDef, { binSuffix: '_start' }),\n                        mid: fielddef_1.field(fieldDef, { binSuffix: '_mid' }),\n                        end: fielddef_1.field(fieldDef, { binSuffix: '_end' })\n                    }\n                }, typeof bin === 'boolean' ? {} : bin);\n                if (!binTrans.maxbins && !binTrans.step) {\n                    binTrans.maxbins = bin_1.autoMaxBins(channel);\n                }\n                transform.push(binTrans);\n                if (scale_2.scaleType(scale, fieldDef, channel, model.mark()) === scale_1.ScaleType.ORDINAL || channel === channel_1.COLOR) {\n                    transform.push({\n                        type: 'formula',\n                        field: fielddef_1.field(fieldDef, { binSuffix: '_range' }),\n                        expr: fielddef_1.field(fieldDef, { datum: true, binSuffix: '_start' }) +\n                            ' + \\'-\\' + ' +\n                            fielddef_1.field(fieldDef, { datum: true, binSuffix: '_end' })\n                    });\n                }\n            }\n            return transform;\n        }, []);\n    }\n    source_1.binTransform = binTransform;\n    function nullFilterTransform(model) {\n        var filterNull = model.transform().filterNull;\n        var filteredFields = util_1.keys(model.reduce(function (aggregator, fieldDef) {\n            if (filterNull ||\n                (filterNull === undefined && fieldDef.field && fieldDef.field !== '*' && DEFAULT_NULL_FILTERS[fieldDef.type])) {\n                aggregator[fieldDef.field] = true;\n            }\n            return aggregator;\n        }, {}));\n        return filteredFields.length > 0 ?\n            [{\n                    type: 'filter',\n                    test: filteredFields.map(function (fieldName) {\n                        return 'datum.' + fieldName + '!==null';\n                    }).join(' && ')\n                }] : [];\n    }\n    source_1.nullFilterTransform = nullFilterTransform;\n    function filterTransform(model) {\n        var filter = model.transform().filter;\n        return filter ? [{\n                type: 'filter',\n                test: filter\n            }] : [];\n    }\n    source_1.filterTransform = filterTransform;\n    function formulaTransform(model) {\n        return (model.transform().calculate || []).reduce(function (transform, formula) {\n            transform.push(util_1.extend({ type: 'formula' }, formula));\n            return transform;\n        }, []);\n    }\n    source_1.formulaTransform = formulaTransform;\n})(source = exports.source || (exports.source = {}));\nvar summary;\n(function (summary) {\n    function def(model) {\n        var dims = {};\n        var meas = {};\n        var hasAggregate = false;\n        model.forEach(function (fieldDef, channel) {\n            if (fieldDef.aggregate) {\n                hasAggregate = true;\n                if (fieldDef.aggregate === aggregate_1.AggregateOp.COUNT) {\n                    meas['*'] = meas['*'] || {};\n                    meas['*'].count = true;\n                }\n                else {\n                    meas[fieldDef.field] = meas[fieldDef.field] || {};\n                    meas[fieldDef.field][fieldDef.aggregate] = true;\n                }\n            }\n            else {\n                if (fieldDef.bin) {\n                    dims[fielddef_1.field(fieldDef, { binSuffix: '_start' })] = fielddef_1.field(fieldDef, { binSuffix: '_start' });\n                    dims[fielddef_1.field(fieldDef, { binSuffix: '_mid' })] = fielddef_1.field(fieldDef, { binSuffix: '_mid' });\n                    dims[fielddef_1.field(fieldDef, { binSuffix: '_end' })] = fielddef_1.field(fieldDef, { binSuffix: '_end' });\n                    var scale = model.scale(channel);\n                    if (scale_2.scaleType(scale, fieldDef, channel, model.mark()) === scale_1.ScaleType.ORDINAL) {\n                        dims[fielddef_1.field(fieldDef, { binSuffix: '_range' })] = fielddef_1.field(fieldDef, { binSuffix: '_range' });\n                    }\n                }\n                else {\n                    dims[fielddef_1.field(fieldDef)] = fielddef_1.field(fieldDef);\n                }\n            }\n        });\n        var groupby = util_1.vals(dims);\n        var summarize = util_1.reduce(meas, function (aggregator, fnDictSet, field) {\n            aggregator[field] = util_1.keys(fnDictSet);\n            return aggregator;\n        }, {});\n        if (hasAggregate) {\n            return {\n                name: data_1.SUMMARY,\n                source: data_1.SOURCE,\n                transform: [{\n                        type: 'aggregate',\n                        groupby: groupby,\n                        summarize: summarize\n                    }]\n            };\n        }\n        return null;\n    }\n    summary.def = def;\n    ;\n})(summary = exports.summary || (exports.summary = {}));\nvar stack;\n(function (stack) {\n    function def(model, stackProps) {\n        var groupbyChannel = stackProps.groupbyChannel, fieldChannel = stackProps.fieldChannel, facetFields = (model.has(channel_1.COLUMN) ? [model.field(channel_1.COLUMN)] : [])\n            .concat((model.has(channel_1.ROW) ? [model.field(channel_1.ROW)] : []));\n        var stacked = {\n            name: data_1.STACKED_SCALE,\n            source: model.dataTable(),\n            transform: [{\n                    type: 'aggregate',\n                    groupby: [model.field(groupbyChannel)].concat(facetFields),\n                    summarize: [{ ops: ['sum'], field: model.field(fieldChannel) }]\n                }]\n        };\n        return stacked;\n    }\n    stack.def = def;\n    ;\n})(stack = exports.stack || (exports.stack = {}));\nvar dates;\n(function (dates) {\n    function defs(model) {\n        var alreadyAdded = {};\n        return model.reduce(function (aggregator, fieldDef, channel) {\n            if (fieldDef.timeUnit) {\n                var domain = time_1.rawDomain(fieldDef.timeUnit, channel);\n                if (domain && !alreadyAdded[fieldDef.timeUnit]) {\n                    alreadyAdded[fieldDef.timeUnit] = true;\n                    aggregator.push({\n                        name: fieldDef.timeUnit,\n                        values: domain,\n                        transform: [{\n                                type: 'formula',\n                                field: 'date',\n                                expr: time_1.parseExpression(fieldDef.timeUnit, 'datum.data', true)\n                            }]\n                    });\n                }\n            }\n            return aggregator;\n        }, []);\n    }\n    dates.defs = defs;\n})(dates = exports.dates || (exports.dates = {}));\nfunction rankTransform(dataTable, model) {\n    if (model.has(channel_1.COLOR) && model.fieldDef(channel_1.COLOR).type === type_1.ORDINAL) {\n        dataTable.transform = dataTable.transform.concat([{\n                type: 'sort',\n                by: model.field(channel_1.COLOR)\n            }, {\n                type: 'rank',\n                field: model.field(channel_1.COLOR),\n                output: {\n                    rank: model.field(channel_1.COLOR, { prefn: 'rank_' })\n                }\n            }]);\n    }\n}\nexports.rankTransform = rankTransform;\nfunction filterNonPositiveForLog(dataTable, model) {\n    model.forEach(function (_, channel) {\n        var scale = model.scale(channel);\n        if (scale && scale.type === scale_1.ScaleType.LOG) {\n            dataTable.transform.push({\n                type: 'filter',\n                test: model.field(channel, { datum: true }) + ' > 0'\n            });\n        }\n    });\n}\nexports.filterNonPositiveForLog = filterNonPositiveForLog;\n//# sourceMappingURL=data.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-lite/src/compile/data.js\n ** module id = 189\n ** module chunks = 0\n **/","\"use strict\";\nvar channel_1 = require('../channel');\nvar data_1 = require('../data');\nvar mark_1 = require('../mark');\nvar time_1 = require('./time');\nfunction compileLayoutData(model) {\n    var distinctSummary = [channel_1.X, channel_1.Y, channel_1.ROW, channel_1.COLUMN].reduce(function (summary, channel) {\n        if (model.has(channel) && model.isOrdinalScale(channel)) {\n            var scale = model.scale(channel);\n            if (!(scale.domain instanceof Array)) {\n                summary.push({\n                    field: model.field(channel),\n                    ops: ['distinct']\n                });\n            }\n        }\n        return summary;\n    }, []);\n    var cellWidthFormula = scaleWidthFormula(model, channel_1.X, model.cellWidth());\n    var cellHeightFormula = scaleWidthFormula(model, channel_1.Y, model.cellHeight());\n    var isFacet = model.has(channel_1.COLUMN) || model.has(channel_1.ROW);\n    var formulas = [{\n            type: 'formula',\n            field: 'cellWidth',\n            expr: cellWidthFormula\n        }, {\n            type: 'formula',\n            field: 'cellHeight',\n            expr: cellHeightFormula\n        }, {\n            type: 'formula',\n            field: 'width',\n            expr: isFacet ?\n                facetScaleWidthFormula(model, channel_1.COLUMN, 'datum.cellWidth') :\n                cellWidthFormula\n        }, {\n            type: 'formula',\n            field: 'height',\n            expr: isFacet ?\n                facetScaleWidthFormula(model, channel_1.ROW, 'datum.cellHeight') :\n                cellHeightFormula\n        }];\n    return distinctSummary.length > 0 ? {\n        name: data_1.LAYOUT,\n        source: model.dataTable(),\n        transform: [].concat([{\n                type: 'aggregate',\n                summarize: distinctSummary\n            }], formulas)\n    } : {\n        name: data_1.LAYOUT,\n        values: [{}],\n        transform: formulas\n    };\n}\nexports.compileLayoutData = compileLayoutData;\nfunction cardinalityFormula(model, channel) {\n    var scale = model.scale(channel);\n    if (scale.domain instanceof Array) {\n        return scale.domain.length;\n    }\n    var timeUnit = model.fieldDef(channel).timeUnit;\n    var timeUnitDomain = timeUnit ? time_1.rawDomain(timeUnit, channel) : null;\n    return timeUnitDomain !== null ? timeUnitDomain.length :\n        model.field(channel, { datum: true, prefn: 'distinct_' });\n}\nfunction scaleWidthFormula(model, channel, nonOrdinalSize) {\n    if (model.has(channel)) {\n        if (model.isOrdinalScale(channel)) {\n            var scale = model.scale(channel);\n            return '(' + cardinalityFormula(model, channel) +\n                ' + ' + scale.padding +\n                ') * ' + scale.bandSize;\n        }\n        else {\n            return nonOrdinalSize + '';\n        }\n    }\n    else {\n        if (model.mark() === mark_1.TEXT && channel === channel_1.X) {\n            return model.config().scale.textBandWidth + '';\n        }\n        return model.config().scale.bandSize + '';\n    }\n}\nfunction facetScaleWidthFormula(model, channel, innerWidth) {\n    var scale = model.scale(channel);\n    if (model.has(channel)) {\n        var cardinality = scale.domain instanceof Array ? scale.domain.length :\n            model.field(channel, { datum: true, prefn: 'distinct_' });\n        return '(' + innerWidth + ' + ' + scale.padding + ')' + ' * ' + cardinality;\n    }\n    else {\n        return innerWidth + ' + ' + model.config().facet.scale.padding;\n    }\n}\n//# sourceMappingURL=layout.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-lite/src/compile/layout.js\n ** module id = 190\n ** module chunks = 0\n **/","\"use strict\";\nvar util = require('../util');\nvar util_1 = require('../util');\nvar channel_1 = require('../channel');\nvar fielddef_1 = require('../fielddef');\nvar axis_1 = require('./axis');\nvar scale_1 = require('./scale');\nvar common_1 = require('./common');\nfunction facetMixins(model, marks) {\n    var hasRow = model.has(channel_1.ROW), hasCol = model.has(channel_1.COLUMN);\n    if (model.has(channel_1.ROW) && !fielddef_1.isDimension(model.encoding().row)) {\n        util.error('Row encoding should be ordinal.');\n    }\n    if (model.has(channel_1.COLUMN) && !fielddef_1.isDimension(model.encoding().column)) {\n        util.error('Col encoding should be ordinal.');\n    }\n    return {\n        marks: [].concat(getFacetGuideGroups(model), [getFacetGroup(model, marks)]),\n        scales: scale_1.compileScales(model),\n        axes: [].concat(hasRow && model.axis(channel_1.ROW) ? [axis_1.compileAxis(channel_1.ROW, model)] : [], hasCol && model.axis(channel_1.COLUMN) ? [axis_1.compileAxis(channel_1.COLUMN, model)] : [])\n    };\n}\nexports.facetMixins = facetMixins;\nfunction getCellAxes(model) {\n    var cellAxes = [];\n    if (model.has(channel_1.X) && model.axis(channel_1.X) && axis_1.gridShow(model, channel_1.X)) {\n        cellAxes.push(axis_1.compileInnerAxis(channel_1.X, model));\n    }\n    if (model.has(channel_1.Y) && model.axis(channel_1.Y) && axis_1.gridShow(model, channel_1.Y)) {\n        cellAxes.push(axis_1.compileInnerAxis(channel_1.Y, model));\n    }\n    return cellAxes;\n}\nfunction getFacetGroup(model, marks) {\n    var name = model.spec().name;\n    var facetGroup = {\n        name: (name ? name + '-' : '') + 'cell',\n        type: 'group',\n        from: {\n            data: model.dataTable(),\n            transform: [{\n                    type: 'facet',\n                    groupby: [].concat(model.has(channel_1.ROW) ? [model.field(channel_1.ROW)] : [], model.has(channel_1.COLUMN) ? [model.field(channel_1.COLUMN)] : [])\n                }]\n        },\n        properties: {\n            update: getFacetGroupProperties(model)\n        },\n        marks: marks\n    };\n    var cellAxes = getCellAxes(model);\n    if (cellAxes.length > 0) {\n        facetGroup.axes = cellAxes;\n    }\n    return facetGroup;\n}\nfunction getFacetGroupProperties(model) {\n    var facetGroupProperties = {\n        x: model.has(channel_1.COLUMN) ? {\n            scale: model.scaleName(channel_1.COLUMN),\n            field: model.field(channel_1.COLUMN),\n            offset: model.scale(channel_1.COLUMN).padding / 2\n        } : { value: model.config().facet.scale.padding / 2 },\n        y: model.has(channel_1.ROW) ? {\n            scale: model.scaleName(channel_1.ROW),\n            field: model.field(channel_1.ROW),\n            offset: model.scale(channel_1.ROW).padding / 2\n        } : { value: model.config().facet.scale.padding / 2 },\n        width: { field: { parent: 'cellWidth' } },\n        height: { field: { parent: 'cellHeight' } }\n    };\n    common_1.applyConfig(facetGroupProperties, model.config().cell, common_1.FILL_STROKE_CONFIG.concat(['clip']));\n    common_1.applyConfig(facetGroupProperties, model.config().facet.cell, common_1.FILL_STROKE_CONFIG.concat(['clip']));\n    return facetGroupProperties;\n}\nfunction getFacetGuideGroups(model) {\n    var rootAxesGroups = [];\n    if (model.has(channel_1.X)) {\n        if (model.axis(channel_1.X)) {\n            rootAxesGroups.push(getXAxesGroup(model));\n        }\n    }\n    else {\n        if (model.has(channel_1.ROW)) {\n            rootAxesGroups.push.apply(rootAxesGroups, getRowGridGroups(model));\n        }\n    }\n    if (model.has(channel_1.Y)) {\n        if (model.axis(channel_1.Y)) {\n            rootAxesGroups.push(getYAxesGroup(model));\n        }\n    }\n    else {\n        if (model.has(channel_1.COLUMN)) {\n            rootAxesGroups.push.apply(rootAxesGroups, getColumnGridGroups(model));\n        }\n    }\n    return rootAxesGroups;\n}\nfunction getXAxesGroup(model) {\n    var hasCol = model.has(channel_1.COLUMN);\n    var name = model.spec().name;\n    return util_1.extend({\n        name: (name ? name + '-' : '') + 'x-axes',\n        type: 'group'\n    }, hasCol ? {\n        from: {\n            data: model.dataTable(),\n            transform: [{\n                    type: 'aggregate',\n                    groupby: [model.field(channel_1.COLUMN)],\n                    summarize: { '*': ['count'] }\n                }]\n        }\n    } : {}, {\n        properties: {\n            update: {\n                width: { field: { parent: 'cellWidth' } },\n                height: {\n                    field: { group: 'height' }\n                },\n                x: hasCol ? {\n                    scale: model.scaleName(channel_1.COLUMN),\n                    field: model.field(channel_1.COLUMN),\n                    offset: model.scale(channel_1.COLUMN).padding / 2\n                } : {\n                    value: model.config().facet.scale.padding / 2\n                }\n            }\n        }\n    }, model.axis(channel_1.X) ? {\n        axes: [axis_1.compileAxis(channel_1.X, model)]\n    } : {});\n}\nfunction getYAxesGroup(model) {\n    var hasRow = model.has(channel_1.ROW);\n    var name = model.spec().name;\n    return util_1.extend({\n        name: (name ? name + '-' : '') + 'y-axes',\n        type: 'group'\n    }, hasRow ? {\n        from: {\n            data: model.dataTable(),\n            transform: [{\n                    type: 'aggregate',\n                    groupby: [model.field(channel_1.ROW)],\n                    summarize: { '*': ['count'] }\n                }]\n        }\n    } : {}, {\n        properties: {\n            update: {\n                width: {\n                    field: { group: 'width' }\n                },\n                height: { field: { parent: 'cellHeight' } },\n                y: hasRow ? {\n                    scale: model.scaleName(channel_1.ROW),\n                    field: model.field(channel_1.ROW),\n                    offset: model.scale(channel_1.ROW).padding / 2\n                } : {\n                    value: model.config().facet.scale.padding / 2\n                }\n            }\n        },\n    }, model.axis(channel_1.Y) ? {\n        axes: [axis_1.compileAxis(channel_1.Y, model)]\n    } : {});\n}\nfunction getRowGridGroups(model) {\n    var name = model.spec().name;\n    var facetGridConfig = model.config().facet.grid;\n    var rowGrid = {\n        name: (name ? name + '-' : '') + 'row-grid',\n        type: 'rule',\n        from: {\n            data: model.dataTable(),\n            transform: [{ type: 'facet', groupby: [model.field(channel_1.ROW)] }]\n        },\n        properties: {\n            update: {\n                y: {\n                    scale: model.scaleName(channel_1.ROW),\n                    field: model.field(channel_1.ROW)\n                },\n                x: { value: 0, offset: -facetGridConfig.offset },\n                x2: { field: { group: 'width' }, offset: facetGridConfig.offset },\n                stroke: { value: facetGridConfig.color },\n                strokeOpacity: { value: facetGridConfig.opacity },\n                strokeWidth: { value: 0.5 }\n            }\n        }\n    };\n    return [rowGrid, {\n            name: (name ? name + '-' : '') + 'row-grid-end',\n            type: 'rule',\n            properties: {\n                update: {\n                    y: { field: { group: 'height' } },\n                    x: { value: 0, offset: -facetGridConfig.offset },\n                    x2: { field: { group: 'width' }, offset: facetGridConfig.offset },\n                    stroke: { value: facetGridConfig.color },\n                    strokeOpacity: { value: facetGridConfig.opacity },\n                    strokeWidth: { value: 0.5 }\n                }\n            }\n        }];\n}\nfunction getColumnGridGroups(model) {\n    var name = model.spec().name;\n    var facetGridConfig = model.config().facet.grid;\n    var columnGrid = {\n        name: (name ? name + '-' : '') + 'column-grid',\n        type: 'rule',\n        from: {\n            data: model.dataTable(),\n            transform: [{ type: 'facet', groupby: [model.field(channel_1.COLUMN)] }]\n        },\n        properties: {\n            update: {\n                x: {\n                    scale: model.scaleName(channel_1.COLUMN),\n                    field: model.field(channel_1.COLUMN)\n                },\n                y: { value: 0, offset: -facetGridConfig.offset },\n                y2: { field: { group: 'height' }, offset: facetGridConfig.offset },\n                stroke: { value: facetGridConfig.color },\n                strokeOpacity: { value: facetGridConfig.opacity },\n                strokeWidth: { value: 0.5 }\n            }\n        }\n    };\n    return [columnGrid, {\n            name: (name ? name + '-' : '') + 'column-grid-end',\n            type: 'rule',\n            properties: {\n                update: {\n                    x: { field: { group: 'width' } },\n                    y: { value: 0, offset: -facetGridConfig.offset },\n                    y2: { field: { group: 'height' }, offset: facetGridConfig.offset },\n                    stroke: { value: facetGridConfig.color },\n                    strokeOpacity: { value: facetGridConfig.opacity },\n                    strokeWidth: { value: 0.5 }\n                }\n            }\n        }];\n}\n//# sourceMappingURL=facet.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-lite/src/compile/facet.js\n ** module id = 191\n ** module chunks = 0\n **/","\"use strict\";\nvar channel_1 = require('../channel');\nvar fielddef_1 = require('../fielddef');\nvar mark_1 = require('../mark');\nvar util_1 = require('../util');\nvar common_1 = require('./common');\nvar type_1 = require('../type');\nvar scale_1 = require('./scale');\nfunction compileLegends(model) {\n    var defs = [];\n    if (model.has(channel_1.COLOR) && model.legend(channel_1.COLOR)) {\n        var fieldDef = model.fieldDef(channel_1.COLOR);\n        var scale = model.scaleName(useColorLegendScale(fieldDef) ?\n            scale_1.COLOR_LEGEND :\n            channel_1.COLOR);\n        var def = model.config().mark.filled ? { fill: scale } : { stroke: scale };\n        defs.push(compileLegend(model, channel_1.COLOR, def));\n    }\n    if (model.has(channel_1.SIZE) && model.legend(channel_1.SIZE)) {\n        defs.push(compileLegend(model, channel_1.SIZE, {\n            size: model.scaleName(channel_1.SIZE)\n        }));\n    }\n    if (model.has(channel_1.SHAPE) && model.legend(channel_1.SHAPE)) {\n        defs.push(compileLegend(model, channel_1.SHAPE, {\n            shape: model.scaleName(channel_1.SHAPE)\n        }));\n    }\n    return defs;\n}\nexports.compileLegends = compileLegends;\nfunction compileLegend(model, channel, def) {\n    var fieldDef = model.fieldDef(channel);\n    var legend = model.legend(channel);\n    def.title = title(legend, fieldDef);\n    util_1.extend(def, formatMixins(legend, model, channel));\n    ['orient', 'values'].forEach(function (property) {\n        var value = legend[property];\n        if (value !== undefined) {\n            def[property] = value;\n        }\n    });\n    var props = (typeof legend !== 'boolean' && legend.properties) || {};\n    ['title', 'symbols', 'legend', 'labels'].forEach(function (group) {\n        var value = properties[group] ?\n            properties[group](fieldDef, props[group], model, channel) :\n            props[group];\n        if (value !== undefined) {\n            def.properties = def.properties || {};\n            def.properties[group] = value;\n        }\n    });\n    return def;\n}\nexports.compileLegend = compileLegend;\nfunction title(legend, fieldDef) {\n    if (typeof legend !== 'boolean' && legend.title) {\n        return legend.title;\n    }\n    return fielddef_1.title(fieldDef);\n}\nexports.title = title;\nfunction formatMixins(legend, model, channel) {\n    var fieldDef = model.fieldDef(channel);\n    if (fieldDef.bin) {\n        return {};\n    }\n    return common_1.formatMixins(model, channel, typeof legend !== 'boolean' ? legend.format : undefined);\n}\nexports.formatMixins = formatMixins;\nfunction useColorLegendScale(fieldDef) {\n    return fieldDef.type === type_1.ORDINAL || fieldDef.bin || fieldDef.timeUnit;\n}\nexports.useColorLegendScale = useColorLegendScale;\nvar properties;\n(function (properties) {\n    function symbols(fieldDef, symbolsSpec, model, channel) {\n        var symbols = {};\n        var mark = model.mark();\n        switch (mark) {\n            case mark_1.BAR:\n            case mark_1.TICK:\n            case mark_1.TEXT:\n                symbols.shape = { value: 'square' };\n                break;\n            case mark_1.CIRCLE:\n            case mark_1.SQUARE:\n                symbols.shape = { value: mark };\n                break;\n            case mark_1.POINT:\n            case mark_1.LINE:\n            case mark_1.AREA:\n                break;\n        }\n        var filled = model.config().mark.filled;\n        common_1.applyMarkConfig(symbols, model, util_1.without(common_1.FILL_STROKE_CONFIG, [filled ? 'fill' : 'stroke']));\n        if (filled) {\n            symbols.strokeWidth = { value: 0 };\n        }\n        var value;\n        if (model.has(channel_1.COLOR) && channel === channel_1.COLOR) {\n            if (useColorLegendScale(fieldDef)) {\n                value = { scale: model.scaleName(channel_1.COLOR), field: 'data' };\n            }\n        }\n        else if (model.fieldDef(channel_1.COLOR).value) {\n            value = { value: model.fieldDef(channel_1.COLOR).value };\n        }\n        if (value !== undefined) {\n            if (filled) {\n                symbols.fill = value;\n            }\n            else {\n                symbols.stroke = value;\n            }\n        }\n        else if (channel !== channel_1.COLOR) {\n            symbols[filled ? 'fill' : 'stroke'] = symbols[filled ? 'fill' : 'stroke'] ||\n                { value: model.config().mark.color };\n        }\n        symbols = util_1.extend(symbols, symbolsSpec || {});\n        return util_1.keys(symbols).length > 0 ? symbols : undefined;\n    }\n    properties.symbols = symbols;\n    function labels(fieldDef, symbolsSpec, model, channel) {\n        if (channel === channel_1.COLOR) {\n            if (fieldDef.type === type_1.ORDINAL) {\n                return {\n                    text: {\n                        scale: model.scaleName(scale_1.COLOR_LEGEND),\n                        field: 'data'\n                    }\n                };\n            }\n            else if (fieldDef.bin) {\n                return {\n                    text: {\n                        scale: model.scaleName(scale_1.COLOR_LEGEND_LABEL),\n                        field: 'data'\n                    }\n                };\n            }\n            else if (fieldDef.timeUnit) {\n                return {\n                    text: {\n                        template: '{{ datum.data | time:\\'' + common_1.timeFormat(model, channel) + '\\'}}'\n                    }\n                };\n            }\n        }\n        return undefined;\n    }\n    properties.labels = labels;\n})(properties || (properties = {}));\n//# sourceMappingURL=legend.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-lite/src/compile/legend.js\n ** module id = 192\n ** module chunks = 0\n **/","\"use strict\";\nvar channel_1 = require('../../channel');\nvar mark_1 = require('../../mark');\nvar stack_1 = require('../stack');\nvar util_1 = require('../../util');\nvar area_1 = require('./area');\nvar bar_1 = require('./bar');\nvar line_1 = require('./line');\nvar point_1 = require('./point');\nvar text_1 = require('./text');\nvar tick_1 = require('./tick');\nvar common_1 = require('../common');\nvar markCompiler = {\n    area: area_1.area,\n    bar: bar_1.bar,\n    line: line_1.line,\n    point: point_1.point,\n    text: text_1.text,\n    tick: tick_1.tick,\n    circle: point_1.circle,\n    square: point_1.square\n};\nfunction compileMark(model) {\n    if (util_1.contains([mark_1.LINE, mark_1.AREA], model.mark())) {\n        return compilePathMark(model);\n    }\n    else {\n        return compileNonPathMark(model);\n    }\n}\nexports.compileMark = compileMark;\nfunction compilePathMark(model) {\n    var mark = model.mark();\n    var name = model.spec().name;\n    var hasParentData = model.has(channel_1.ROW) || model.has(channel_1.COLUMN);\n    var dataFrom = { data: model.dataTable() };\n    var details = detailFields(model);\n    var pathMarks = [util_1.extend(name ? { name: name + '-marks' } : {}, {\n            type: markCompiler[mark].markType(),\n            from: util_1.extend(hasParentData || details.length > 0 ? {} : dataFrom, { transform: [{ type: 'sort', by: sortPathBy(model) }] }),\n            properties: { update: markCompiler[mark].properties(model) }\n        })];\n    if (details.length > 0) {\n        var facetTransform = { type: 'facet', groupby: details };\n        var transform = mark === mark_1.AREA && model.stack() ?\n            [stack_1.imputeTransform(model), stack_1.stackTransform(model), facetTransform] :\n            [].concat(facetTransform, model.has(channel_1.ORDER) ? [{ type: 'sort', by: sortBy(model) }] : []);\n        return [{\n                name: (name ? name + '-' : '') + mark + '-facet',\n                type: 'group',\n                from: util_1.extend(hasParentData ? {} : dataFrom, { transform: transform }),\n                properties: {\n                    update: {\n                        width: { field: { group: 'width' } },\n                        height: { field: { group: 'height' } }\n                    }\n                },\n                marks: pathMarks\n            }];\n    }\n    else {\n        return pathMarks;\n    }\n}\nfunction compileNonPathMark(model) {\n    var mark = model.mark();\n    var name = model.spec().name;\n    var hasParentData = model.has(channel_1.ROW) || model.has(channel_1.COLUMN);\n    var dataFrom = { data: model.dataTable() };\n    var marks = [];\n    if (mark === mark_1.TEXT &&\n        model.has(channel_1.COLOR) &&\n        model.config().mark.applyColorToBackground && !model.has(channel_1.X) && !model.has(channel_1.Y)) {\n        marks.push(util_1.extend(name ? { name: name + '-background' } : {}, { type: 'rect' }, hasParentData ? {} : { from: dataFrom }, { properties: { update: text_1.text.background(model) } }));\n    }\n    marks.push(util_1.extend(name ? { name: name + '-marks' } : {}, { type: markCompiler[mark].markType() }, (!hasParentData || model.stack() || model.has(channel_1.ORDER)) ? {\n        from: util_1.extend(hasParentData ? {} : dataFrom, model.stack() ?\n            { transform: [stack_1.stackTransform(model)] } :\n            model.has(channel_1.ORDER) ?\n                { transform: [{ type: 'sort', by: sortBy(model) }] } :\n                {})\n    } : {}, { properties: { update: markCompiler[mark].properties(model) } }));\n    if (model.has(channel_1.LABEL) && markCompiler[mark].labels) {\n        var labelProperties = markCompiler[mark].labels(model);\n        if (labelProperties !== undefined) {\n            marks.push(util_1.extend(name ? { name: name + '-label' } : {}, { type: 'text' }, hasParentData ? {} : { from: dataFrom }, { properties: { update: labelProperties } }));\n        }\n    }\n    return marks;\n}\nfunction sortBy(model) {\n    if (model.has(channel_1.ORDER)) {\n        var channelDef = model.encoding().order;\n        if (channelDef instanceof Array) {\n            return channelDef.map(common_1.sortField);\n        }\n        else {\n            return common_1.sortField(channelDef);\n        }\n    }\n    return null;\n}\nfunction sortPathBy(model) {\n    if (model.mark() === mark_1.LINE && model.has(channel_1.PATH)) {\n        var channelDef = model.encoding().path;\n        if (channelDef instanceof Array) {\n            return channelDef.map(common_1.sortField);\n        }\n        else {\n            return common_1.sortField(channelDef);\n        }\n    }\n    else {\n        return '-' + model.field(model.config().mark.orient === 'horizontal' ? channel_1.Y : channel_1.X);\n    }\n}\nfunction detailFields(model) {\n    return [channel_1.COLOR, channel_1.DETAIL, channel_1.SHAPE].reduce(function (details, channel) {\n        if (model.has(channel) && !model.fieldDef(channel).aggregate) {\n            details.push(model.field(channel));\n        }\n        return details;\n    }, []);\n}\n//# sourceMappingURL=mark.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-lite/src/compile/mark/mark.js\n ** module id = 193\n ** module chunks = 0\n **/","\"use strict\";\nvar channel_1 = require('../../channel');\nvar fielddef_1 = require('../../fielddef');\nvar common_1 = require('../common');\nvar area;\n(function (area) {\n    function markType() {\n        return 'area';\n    }\n    area.markType = markType;\n    function properties(model) {\n        var p = {};\n        var orient = model.config().mark.orient;\n        if (orient !== undefined) {\n            p.orient = { value: orient };\n        }\n        var stack = model.stack();\n        var xFieldDef = model.encoding().x;\n        if (stack && channel_1.X === stack.fieldChannel) {\n            p.x = {\n                scale: model.scaleName(channel_1.X),\n                field: model.field(channel_1.X, { suffix: '_start' })\n            };\n        }\n        else if (fielddef_1.isMeasure(xFieldDef)) {\n            p.x = { scale: model.scaleName(channel_1.X), field: model.field(channel_1.X) };\n        }\n        else if (fielddef_1.isDimension(xFieldDef)) {\n            p.x = {\n                scale: model.scaleName(channel_1.X),\n                field: model.field(channel_1.X, { binSuffix: '_mid' })\n            };\n        }\n        if (orient === 'horizontal') {\n            if (stack && channel_1.X === stack.fieldChannel) {\n                p.x2 = {\n                    scale: model.scaleName(channel_1.X),\n                    field: model.field(channel_1.X, { suffix: '_end' })\n                };\n            }\n            else {\n                p.x2 = {\n                    scale: model.scaleName(channel_1.X),\n                    value: 0\n                };\n            }\n        }\n        var yFieldDef = model.encoding().y;\n        if (stack && channel_1.Y === stack.fieldChannel) {\n            p.y = {\n                scale: model.scaleName(channel_1.Y),\n                field: model.field(channel_1.Y, { suffix: '_start' })\n            };\n        }\n        else if (fielddef_1.isMeasure(yFieldDef)) {\n            p.y = {\n                scale: model.scaleName(channel_1.Y),\n                field: model.field(channel_1.Y)\n            };\n        }\n        else if (fielddef_1.isDimension(yFieldDef)) {\n            p.y = {\n                scale: model.scaleName(channel_1.Y),\n                field: model.field(channel_1.Y, { binSuffix: '_mid' })\n            };\n        }\n        if (orient !== 'horizontal') {\n            if (stack && channel_1.Y === stack.fieldChannel) {\n                p.y2 = {\n                    scale: model.scaleName(channel_1.Y),\n                    field: model.field(channel_1.Y, { suffix: '_end' })\n                };\n            }\n            else {\n                p.y2 = {\n                    scale: model.scaleName(channel_1.Y),\n                    value: 0\n                };\n            }\n        }\n        common_1.applyColorAndOpacity(p, model);\n        common_1.applyMarkConfig(p, model, ['interpolate', 'tension']);\n        return p;\n    }\n    area.properties = properties;\n    function labels(model) {\n        return undefined;\n    }\n    area.labels = labels;\n})(area = exports.area || (exports.area = {}));\n//# sourceMappingURL=area.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-lite/src/compile/mark/area.js\n ** module id = 194\n ** module chunks = 0\n **/","\"use strict\";\nvar channel_1 = require('../../channel');\nvar fielddef_1 = require('../../fielddef');\nvar common_1 = require('../common');\nvar bar;\n(function (bar) {\n    function markType() {\n        return 'rect';\n    }\n    bar.markType = markType;\n    function properties(model) {\n        var p = {};\n        var orient = model.config().mark.orient;\n        var stack = model.stack();\n        var xFieldDef = model.encoding().x;\n        if (stack && channel_1.X === stack.fieldChannel) {\n            p.x = {\n                scale: model.scaleName(channel_1.X),\n                field: model.field(channel_1.X, { suffix: '_start' })\n            };\n            p.x2 = {\n                scale: model.scaleName(channel_1.X),\n                field: model.field(channel_1.X, { suffix: '_end' })\n            };\n        }\n        else if (fielddef_1.isMeasure(xFieldDef)) {\n            if (orient === 'horizontal') {\n                p.x = {\n                    scale: model.scaleName(channel_1.X),\n                    field: model.field(channel_1.X)\n                };\n                p.x2 = {\n                    scale: model.scaleName(channel_1.X),\n                    value: 0\n                };\n            }\n            else {\n                p.xc = {\n                    scale: model.scaleName(channel_1.X),\n                    field: model.field(channel_1.X)\n                };\n                p.width = { value: sizeValue(model, channel_1.X) };\n            }\n        }\n        else if (model.fieldDef(channel_1.X).bin) {\n            if (model.has(channel_1.SIZE) && orient !== 'horizontal') {\n                p.xc = {\n                    scale: model.scaleName(channel_1.X),\n                    field: model.field(channel_1.X, { binSuffix: '_mid' })\n                };\n                p.width = {\n                    scale: model.scaleName(channel_1.SIZE),\n                    field: model.field(channel_1.SIZE)\n                };\n            }\n            else {\n                p.x = {\n                    scale: model.scaleName(channel_1.X),\n                    field: model.field(channel_1.X, { binSuffix: '_start' }),\n                    offset: 1\n                };\n                p.x2 = {\n                    scale: model.scaleName(channel_1.X),\n                    field: model.field(channel_1.X, { binSuffix: '_end' })\n                };\n            }\n        }\n        else {\n            if (model.has(channel_1.X)) {\n                p.xc = {\n                    scale: model.scaleName(channel_1.X),\n                    field: model.field(channel_1.X)\n                };\n            }\n            else {\n                p.x = { value: 0, offset: 2 };\n            }\n            p.width = model.has(channel_1.SIZE) && orient !== 'horizontal' ? {\n                scale: model.scaleName(channel_1.SIZE),\n                field: model.field(channel_1.SIZE)\n            } : {\n                value: sizeValue(model, (channel_1.X))\n            };\n        }\n        var yFieldDef = model.encoding().y;\n        if (stack && channel_1.Y === stack.fieldChannel) {\n            p.y = {\n                scale: model.scaleName(channel_1.Y),\n                field: model.field(channel_1.Y, { suffix: '_start' })\n            };\n            p.y2 = {\n                scale: model.scaleName(channel_1.Y),\n                field: model.field(channel_1.Y, { suffix: '_end' })\n            };\n        }\n        else if (fielddef_1.isMeasure(yFieldDef)) {\n            if (orient !== 'horizontal') {\n                p.y = {\n                    scale: model.scaleName(channel_1.Y),\n                    field: model.field(channel_1.Y)\n                };\n                p.y2 = {\n                    scale: model.scaleName(channel_1.Y),\n                    value: 0\n                };\n            }\n            else {\n                p.yc = {\n                    scale: model.scaleName(channel_1.Y),\n                    field: model.field(channel_1.Y)\n                };\n                p.height = { value: sizeValue(model, channel_1.Y) };\n            }\n        }\n        else if (model.fieldDef(channel_1.Y).bin) {\n            if (model.has(channel_1.SIZE) && orient === 'horizontal') {\n                p.yc = {\n                    scale: model.scaleName(channel_1.Y),\n                    field: model.field(channel_1.Y, { binSuffix: '_mid' })\n                };\n                p.height = {\n                    scale: model.scaleName(channel_1.SIZE),\n                    field: model.field(channel_1.SIZE)\n                };\n            }\n            else {\n                p.y = {\n                    scale: model.scaleName(channel_1.Y),\n                    field: model.field(channel_1.Y, { binSuffix: '_start' })\n                };\n                p.y2 = {\n                    scale: model.scaleName(channel_1.Y),\n                    field: model.field(channel_1.Y, { binSuffix: '_end' }),\n                    offset: 1\n                };\n            }\n        }\n        else {\n            if (model.has(channel_1.Y)) {\n                p.yc = {\n                    scale: model.scaleName(channel_1.Y),\n                    field: model.field(channel_1.Y)\n                };\n            }\n            else {\n                p.y2 = {\n                    field: { group: 'height' },\n                    offset: -1\n                };\n            }\n            p.height = model.has(channel_1.SIZE) && orient === 'horizontal' ? {\n                scale: model.scaleName(channel_1.SIZE),\n                field: model.field(channel_1.SIZE)\n            } : {\n                value: sizeValue(model, channel_1.Y)\n            };\n        }\n        common_1.applyColorAndOpacity(p, model);\n        return p;\n    }\n    bar.properties = properties;\n    function sizeValue(model, channel) {\n        var fieldDef = model.fieldDef(channel_1.SIZE);\n        if (fieldDef && fieldDef.value !== undefined) {\n            return fieldDef.value;\n        }\n        var markConfig = model.config().mark;\n        if (markConfig.barSize) {\n            return markConfig.barSize;\n        }\n        return model.isOrdinalScale(channel) ?\n            model.scale(channel).bandSize - 1 :\n            !model.has(channel) ?\n                model.config().scale.bandSize - 1 :\n                markConfig.barThinSize;\n    }\n    function labels(model) {\n        return undefined;\n    }\n    bar.labels = labels;\n})(bar = exports.bar || (exports.bar = {}));\n//# sourceMappingURL=bar.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-lite/src/compile/mark/bar.js\n ** module id = 195\n ** module chunks = 0\n **/","\"use strict\";\nvar channel_1 = require('../../channel');\nvar common_1 = require('../common');\nvar line;\n(function (line) {\n    function markType() {\n        return 'line';\n    }\n    line.markType = markType;\n    function properties(model) {\n        var p = {};\n        if (model.has(channel_1.X)) {\n            p.x = {\n                scale: model.scaleName(channel_1.X),\n                field: model.field(channel_1.X, { binSuffix: '_mid' })\n            };\n        }\n        else {\n            p.x = { value: 0 };\n        }\n        if (model.has(channel_1.Y)) {\n            p.y = {\n                scale: model.scaleName(channel_1.Y),\n                field: model.field(channel_1.Y, { binSuffix: '_mid' })\n            };\n        }\n        else {\n            p.y = { field: { group: 'height' } };\n        }\n        common_1.applyColorAndOpacity(p, model);\n        common_1.applyMarkConfig(p, model, ['interpolate', 'tension']);\n        return p;\n    }\n    line.properties = properties;\n    function labels(model) {\n        return undefined;\n    }\n    line.labels = labels;\n})(line = exports.line || (exports.line = {}));\n//# sourceMappingURL=line.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-lite/src/compile/mark/line.js\n ** module id = 196\n ** module chunks = 0\n **/","\"use strict\";\nvar channel_1 = require('../../channel');\nvar common_1 = require('../common');\nvar point;\n(function (point) {\n    function markType() {\n        return 'symbol';\n    }\n    point.markType = markType;\n    function properties(model, fixedShape) {\n        var p = {};\n        if (model.has(channel_1.X)) {\n            p.x = {\n                scale: model.scaleName(channel_1.X),\n                field: model.field(channel_1.X, { binSuffix: '_mid' })\n            };\n        }\n        else {\n            p.x = { value: model.config().scale.bandSize / 2 };\n        }\n        if (model.has(channel_1.Y)) {\n            p.y = {\n                scale: model.scaleName(channel_1.Y),\n                field: model.field(channel_1.Y, { binSuffix: '_mid' })\n            };\n        }\n        else {\n            p.y = { value: model.config().scale.bandSize / 2 };\n        }\n        if (model.has(channel_1.SIZE)) {\n            p.size = {\n                scale: model.scaleName(channel_1.SIZE),\n                field: model.field(channel_1.SIZE)\n            };\n        }\n        else {\n            p.size = { value: sizeValue(model) };\n        }\n        if (fixedShape) {\n            p.shape = { value: fixedShape };\n        }\n        else if (model.has(channel_1.SHAPE)) {\n            p.shape = {\n                scale: model.scaleName(channel_1.SHAPE),\n                field: model.field(channel_1.SHAPE)\n            };\n        }\n        else if (model.fieldDef(channel_1.SHAPE).value) {\n            p.shape = { value: model.fieldDef(channel_1.SHAPE).value };\n        }\n        else if (model.config().mark.shape) {\n            p.shape = { value: model.config().mark.shape };\n        }\n        common_1.applyColorAndOpacity(p, model);\n        return p;\n    }\n    point.properties = properties;\n    function sizeValue(model) {\n        var fieldDef = model.fieldDef(channel_1.SIZE);\n        if (fieldDef && fieldDef.value !== undefined) {\n            return fieldDef.value;\n        }\n        return model.config().mark.size;\n    }\n    function labels(model) {\n    }\n    point.labels = labels;\n})(point = exports.point || (exports.point = {}));\nvar circle;\n(function (circle) {\n    function markType() {\n        return 'symbol';\n    }\n    circle.markType = markType;\n    function properties(model) {\n        return point.properties(model, 'circle');\n    }\n    circle.properties = properties;\n    function labels(model) {\n        return undefined;\n    }\n    circle.labels = labels;\n})(circle = exports.circle || (exports.circle = {}));\nvar square;\n(function (square) {\n    function markType() {\n        return 'symbol';\n    }\n    square.markType = markType;\n    function properties(model) {\n        return point.properties(model, 'square');\n    }\n    square.properties = properties;\n    function labels(model) {\n        return undefined;\n    }\n    square.labels = labels;\n})(square = exports.square || (exports.square = {}));\n//# sourceMappingURL=point.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-lite/src/compile/mark/point.js\n ** module id = 197\n ** module chunks = 0\n **/","\"use strict\";\nvar channel_1 = require('../../channel');\nvar common_1 = require('../common');\nvar util_1 = require('../../util');\nvar type_1 = require('../../type');\nvar text;\n(function (text) {\n    function markType() {\n        return 'text';\n    }\n    text.markType = markType;\n    function background(model) {\n        return {\n            x: { value: 0 },\n            y: { value: 0 },\n            width: { field: { group: 'width' } },\n            height: { field: { group: 'height' } },\n            fill: {\n                scale: model.scaleName(channel_1.COLOR),\n                field: model.field(channel_1.COLOR, model.fieldDef(channel_1.COLOR).type === type_1.ORDINAL ? { prefn: 'rank_' } : {})\n            }\n        };\n    }\n    text.background = background;\n    function properties(model) {\n        var p = {};\n        common_1.applyMarkConfig(p, model, ['angle', 'align', 'baseline', 'dx', 'dy', 'font', 'fontWeight',\n            'fontStyle', 'radius', 'theta', 'text']);\n        var fieldDef = model.fieldDef(channel_1.TEXT);\n        if (model.has(channel_1.X)) {\n            p.x = {\n                scale: model.scaleName(channel_1.X),\n                field: model.field(channel_1.X, { binSuffix: '_mid' })\n            };\n        }\n        else {\n            if (model.has(channel_1.TEXT) && model.fieldDef(channel_1.TEXT).type === type_1.QUANTITATIVE) {\n                p.x = { field: { group: 'width' }, offset: -5 };\n            }\n            else {\n                p.x = { value: model.config().scale.textBandWidth / 2 };\n            }\n        }\n        if (model.has(channel_1.Y)) {\n            p.y = {\n                scale: model.scaleName(channel_1.Y),\n                field: model.field(channel_1.Y, { binSuffix: '_mid' })\n            };\n        }\n        else {\n            p.y = { value: model.config().scale.bandSize / 2 };\n        }\n        if (model.has(channel_1.SIZE)) {\n            p.fontSize = {\n                scale: model.scaleName(channel_1.SIZE),\n                field: model.field(channel_1.SIZE)\n            };\n        }\n        else {\n            p.fontSize = { value: sizeValue(model) };\n        }\n        if (model.config().mark.applyColorToBackground && !model.has(channel_1.X) && !model.has(channel_1.Y)) {\n            p.fill = { value: 'black' };\n            var opacity = model.config().mark.opacity;\n            if (opacity) {\n                p.opacity = { value: opacity };\n            }\n            ;\n        }\n        else {\n            common_1.applyColorAndOpacity(p, model);\n        }\n        if (model.has(channel_1.TEXT)) {\n            if (util_1.contains([type_1.QUANTITATIVE, type_1.TEMPORAL], model.fieldDef(channel_1.TEXT).type)) {\n                var format = model.config().mark.format;\n                util_1.extend(p, common_1.formatMixins(model, channel_1.TEXT, format));\n            }\n            else {\n                p.text = { field: model.field(channel_1.TEXT) };\n            }\n        }\n        else if (fieldDef.value) {\n            p.text = { value: fieldDef.value };\n        }\n        return p;\n    }\n    text.properties = properties;\n    function sizeValue(model) {\n        var fieldDef = model.fieldDef(channel_1.SIZE);\n        if (fieldDef && fieldDef.value !== undefined) {\n            return fieldDef.value;\n        }\n        return model.config().mark.fontSize;\n    }\n})(text = exports.text || (exports.text = {}));\n//# sourceMappingURL=text.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-lite/src/compile/mark/text.js\n ** module id = 198\n ** module chunks = 0\n **/","\"use strict\";\nvar channel_1 = require('../../channel');\nvar common_1 = require('../common');\nvar tick;\n(function (tick) {\n    function markType() {\n        return 'rect';\n    }\n    tick.markType = markType;\n    function properties(model) {\n        var p = {};\n        if (model.has(channel_1.X)) {\n            p.xc = {\n                scale: model.scaleName(channel_1.X),\n                field: model.field(channel_1.X, { binSuffix: '_mid' })\n            };\n        }\n        else {\n            p.xc = { value: model.config().scale.bandSize / 2 };\n        }\n        if (model.has(channel_1.Y)) {\n            p.yc = {\n                scale: model.scaleName(channel_1.Y),\n                field: model.field(channel_1.Y, { binSuffix: '_mid' })\n            };\n        }\n        else {\n            p.yc = { value: model.config().scale.bandSize / 2 };\n        }\n        if (model.config().mark.orient === 'horizontal') {\n            p.width = { value: model.config().mark.tickThickness };\n            p.height = model.has(channel_1.SIZE) ? {\n                scale: model.scaleName(channel_1.SIZE),\n                field: model.field(channel_1.SIZE)\n            } : {\n                value: sizeValue(model, channel_1.Y)\n            };\n        }\n        else {\n            p.width = model.has(channel_1.SIZE) ? {\n                scale: model.scaleName(channel_1.SIZE),\n                field: model.field(channel_1.SIZE)\n            } : {\n                value: sizeValue(model, channel_1.X)\n            };\n            p.height = { value: model.config().mark.tickThickness };\n        }\n        common_1.applyColorAndOpacity(p, model);\n        return p;\n    }\n    tick.properties = properties;\n    function sizeValue(model, channel) {\n        var fieldDef = model.fieldDef(channel_1.SIZE);\n        if (fieldDef && fieldDef.value !== undefined) {\n            return fieldDef.value;\n        }\n        var scaleConfig = model.config().scale;\n        var markConfig = model.config().mark;\n        if (markConfig.tickSize) {\n            return markConfig.tickSize;\n        }\n        var bandSize = model.has(channel) ?\n            model.scale(channel).bandSize :\n            scaleConfig.bandSize;\n        return bandSize / 1.5;\n    }\n    function labels(model) {\n        return undefined;\n    }\n    tick.labels = labels;\n})(tick = exports.tick || (exports.tick = {}));\n//# sourceMappingURL=tick.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-lite/src/compile/mark/tick.js\n ** module id = 199\n ** module chunks = 0\n **/","\"use strict\";\nvar aggregate_1 = require('./aggregate');\nvar timeunit_1 = require('./timeunit');\nvar type_1 = require('./type');\nvar vlEncoding = require('./encoding');\nvar mark_1 = require('./mark');\nexports.DELIM = '|';\nexports.ASSIGN = '=';\nexports.TYPE = ',';\nexports.FUNC = '_';\nfunction shorten(spec) {\n    return 'mark' + exports.ASSIGN + spec.mark +\n        exports.DELIM + shortenEncoding(spec.encoding);\n}\nexports.shorten = shorten;\nfunction parse(shorthand, data, config) {\n    var split = shorthand.split(exports.DELIM), mark = split.shift().split(exports.ASSIGN)[1].trim(), encoding = parseEncoding(split.join(exports.DELIM));\n    var spec = {\n        mark: mark_1.Mark[mark],\n        encoding: encoding\n    };\n    if (data !== undefined) {\n        spec.data = data;\n    }\n    if (config !== undefined) {\n        spec.config = config;\n    }\n    return spec;\n}\nexports.parse = parse;\nfunction shortenEncoding(encoding) {\n    return vlEncoding.map(encoding, function (fieldDef, channel) {\n        return channel + exports.ASSIGN + shortenFieldDef(fieldDef);\n    }).join(exports.DELIM);\n}\nexports.shortenEncoding = shortenEncoding;\nfunction parseEncoding(encodingShorthand) {\n    return encodingShorthand.split(exports.DELIM).reduce(function (m, e) {\n        var split = e.split(exports.ASSIGN), enctype = split[0].trim(), fieldDefShorthand = split[1];\n        m[enctype] = parseFieldDef(fieldDefShorthand);\n        return m;\n    }, {});\n}\nexports.parseEncoding = parseEncoding;\nfunction shortenFieldDef(fieldDef) {\n    return (fieldDef.aggregate ? fieldDef.aggregate + exports.FUNC : '') +\n        (fieldDef.timeUnit ? fieldDef.timeUnit + exports.FUNC : '') +\n        (fieldDef.bin ? 'bin' + exports.FUNC : '') +\n        (fieldDef.field || '') + exports.TYPE + type_1.SHORT_TYPE[fieldDef.type];\n}\nexports.shortenFieldDef = shortenFieldDef;\nfunction shortenFieldDefs(fieldDefs, delim) {\n    if (delim === void 0) { delim = exports.DELIM; }\n    return fieldDefs.map(shortenFieldDef).join(delim);\n}\nexports.shortenFieldDefs = shortenFieldDefs;\nfunction parseFieldDef(fieldDefShorthand) {\n    var split = fieldDefShorthand.split(exports.TYPE);\n    var fieldDef = {\n        field: split[0].trim(),\n        type: type_1.TYPE_FROM_SHORT_TYPE[split[1].trim()]\n    };\n    for (var i = 0; i < aggregate_1.AGGREGATE_OPS.length; i++) {\n        var a = aggregate_1.AGGREGATE_OPS[i];\n        if (fieldDef.field.indexOf(a + '_') === 0) {\n            fieldDef.field = fieldDef.field.substr(a.toString().length + 1);\n            if (a === aggregate_1.AggregateOp.COUNT && fieldDef.field.length === 0) {\n                fieldDef.field = '*';\n            }\n            fieldDef.aggregate = a;\n            break;\n        }\n    }\n    for (var i = 0; i < timeunit_1.TIMEUNITS.length; i++) {\n        var tu = timeunit_1.TIMEUNITS[i];\n        if (fieldDef.field && fieldDef.field.indexOf(tu + '_') === 0) {\n            fieldDef.field = fieldDef.field.substr(fieldDef.field.length + 1);\n            fieldDef.timeUnit = tu;\n            break;\n        }\n    }\n    if (fieldDef.field && fieldDef.field.indexOf('bin_') === 0) {\n        fieldDef.field = fieldDef.field.substr(4);\n        fieldDef.bin = true;\n    }\n    return fieldDef;\n}\nexports.parseFieldDef = parseFieldDef;\n//# sourceMappingURL=shorthand.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-lite/src/shorthand.js\n ** module id = 200\n ** module chunks = 0\n **/","\"use strict\";\nvar channel_1 = require('./channel');\nvar vlEncoding = require('./encoding');\nvar mark_1 = require('./mark');\nvar util_1 = require('./util');\nfunction alwaysNoOcclusion(spec) {\n    return vlEncoding.isAggregate(spec.encoding);\n}\nexports.alwaysNoOcclusion = alwaysNoOcclusion;\nfunction fieldDefs(spec) {\n    return vlEncoding.fieldDefs(spec.encoding);\n}\nexports.fieldDefs = fieldDefs;\n;\nfunction getCleanSpec(spec) {\n    return spec;\n}\nexports.getCleanSpec = getCleanSpec;\nfunction isStack(spec) {\n    return (vlEncoding.has(spec.encoding, channel_1.COLOR) || vlEncoding.has(spec.encoding, channel_1.SHAPE)) &&\n        (spec.mark === mark_1.BAR || spec.mark === mark_1.AREA) &&\n        (!spec.config || !spec.config.mark.stacked !== false) &&\n        vlEncoding.isAggregate(spec.encoding);\n}\nexports.isStack = isStack;\nfunction transpose(spec) {\n    var oldenc = spec.encoding;\n    var encoding = util_1.duplicate(spec.encoding);\n    encoding.x = oldenc.y;\n    encoding.y = oldenc.x;\n    encoding.row = oldenc.column;\n    encoding.column = oldenc.row;\n    spec.encoding = encoding;\n    return spec;\n}\nexports.transpose = transpose;\n//# sourceMappingURL=spec.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-lite/src/spec.js\n ** module id = 201\n ** module chunks = 0\n **/","\"use strict\";\nvar util_1 = require('./util');\nvar mark_1 = require('./mark');\nexports.DEFAULT_REQUIRED_CHANNEL_MAP = {\n    text: ['text'],\n    line: ['x', 'y'],\n    area: ['x', 'y']\n};\nexports.DEFAULT_SUPPORTED_CHANNEL_TYPE = {\n    bar: util_1.toMap(['row', 'column', 'x', 'y', 'size', 'color', 'detail']),\n    line: util_1.toMap(['row', 'column', 'x', 'y', 'color', 'detail']),\n    area: util_1.toMap(['row', 'column', 'x', 'y', 'color', 'detail']),\n    tick: util_1.toMap(['row', 'column', 'x', 'y', 'color', 'detail']),\n    circle: util_1.toMap(['row', 'column', 'x', 'y', 'color', 'size', 'detail']),\n    square: util_1.toMap(['row', 'column', 'x', 'y', 'color', 'size', 'detail']),\n    point: util_1.toMap(['row', 'column', 'x', 'y', 'color', 'size', 'detail', 'shape']),\n    text: util_1.toMap(['row', 'column', 'size', 'color', 'text'])\n};\nfunction getEncodingMappingError(spec, requiredChannelMap, supportedChannelMap) {\n    if (requiredChannelMap === void 0) { requiredChannelMap = exports.DEFAULT_REQUIRED_CHANNEL_MAP; }\n    if (supportedChannelMap === void 0) { supportedChannelMap = exports.DEFAULT_SUPPORTED_CHANNEL_TYPE; }\n    var mark = spec.mark;\n    var encoding = spec.encoding;\n    var requiredChannels = requiredChannelMap[mark];\n    var supportedChannels = supportedChannelMap[mark];\n    for (var i in requiredChannels) {\n        if (!(requiredChannels[i] in encoding)) {\n            return 'Missing encoding channel \\\"' + requiredChannels[i] +\n                '\\\" for mark \\\"' + mark + '\\\"';\n        }\n    }\n    for (var channel in encoding) {\n        if (!supportedChannels[channel]) {\n            return 'Encoding channel \\\"' + channel +\n                '\\\" is not supported by mark type \\\"' + mark + '\\\"';\n        }\n    }\n    if (mark === mark_1.BAR && !encoding.x && !encoding.y) {\n        return 'Missing both x and y for bar';\n    }\n    return null;\n}\nexports.getEncodingMappingError = getEncodingMappingError;\n//# sourceMappingURL=validate.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-lite/src/validate.js\n ** module id = 202\n ** module chunks = 0\n **/","var d3 = require('d3'),\n    $ = require('vega').util.mutator;\n\nmodule.exports = {\n  init: function(el, param, spec) {\n    return (rewrite(param, spec), handle(el, param));\n  },\n  bind: function(param, view) {\n    param.dom.forEach(function(el) { el.__vega__ = view; });\n    view.onSignal(param.dom[0].name, function(k, v) { param.set(v); });\n  }\n};\n\n// spec re-write\n\nfunction rewrite(param, spec) {\n  // add signal to top-level if not defined\n  var sg = spec.signals || (spec.signals = []);\n  for (var i=0; i<sg.length; ++i) {\n    if (sg[i].name === param.signal) break;\n  }\n  if (i === sg.length) {\n    sg.push({\n      name: param.signal,\n      init: param.value\n    });\n  }\n\n  // replace values for re-write entries\n  (param.rewrite || []).forEach(function(path) {\n    $(path)(spec, {signal: param.signal});\n  });\n}\n\n// HTML output handlers\n\nfunction handle(el, param) {\n  var p = el.append('div')\n    .attr('class', 'vega-param');\n\n  p.append('span')\n    .attr('class', 'vega-param-name')\n    .text(param.name || param.signal);\n\n  var input = form;\n  switch (param.type) {\n    case 'checkbox': input = checkbox; break;\n    case 'select':   input = select; break;\n    case 'radio':    input = radio; break;\n    case 'range':    input = range; break;\n  }\n\n  return input(p, param);\n}\n\nfunction form(el, param) {\n  var fm = el.append('input')\n    .on('input', update);\n\n  for (var key in param) {\n    if (key === 'signal' || key === 'rewrite') continue;\n    fm.attr(key, param[key]);\n  }\n  fm.attr('name', param.signal);\n\n  var node = fm.node();\n  return {\n    dom: [node],\n    set: function(value) { node.value = value; }\n  };\n}\n\nfunction checkbox(el, param) {\n  var cb = el.append('input')\n    .on('change', function() { update.call(this, this.checked); })\n    .attr('type', 'checkbox')\n    .attr('name', param.signal)\n    .attr('checked', param.value || null)\n    .node();\n\n  return {\n    dom: [cb],\n    set: function(value) { cb.checked = !!value || null; }\n  };\n}\n\nfunction select(el, param) {\n  var sl = el.append('select')\n    .attr('name', param.signal)\n    .on('change', function() {\n      update.call(this, this.options[this.selectedIndex].__data__);\n    });\n\n  sl.selectAll('option')\n    .data(param.options)\n   .enter().append('option')\n    .attr('value', vg.util.identity)\n    .attr('selected', function(x) { return x === param.value || null; })\n    .text(vg.util.identity);\n  \n  var node = sl.node();\n  return {\n    dom: [node],\n    set: function(value) {\n      var idx = param.options.indexOf(value);\n      node.selectedIndex = idx;\n    }\n  };\n}\n\nfunction radio(el, param) {\n  var rg = el.append('span')\n    .attr('class', 'vega-param-radio');\n\n  var nodes = param.options.map(function(option) {\n    var id = 'vega-option-' + param.signal + '-' + option;\n\n    var rb = rg.append('input')\n      .datum(option)\n      .on('change', update)\n      .attr('id', id)\n      .attr('type', 'radio')\n      .attr('name', param.signal)\n      .attr('value', option)\n      .attr('checked', option === param.value || null);\n\n    rg.append('label')\n      .attr('for', id)\n      .text(option);\n\n    return rb.node();\n  });\n\n  return {\n    dom: nodes,\n    set: function(value) {\n      for (var i=0; i<nodes.length; ++i) {\n        if (nodes[i].value === value) {\n          nodes[i].checked = true;\n        }\n      }\n    }\n  };\n}\n\nfunction range(el, param) {\n  var val = param.value !== undefined ? param.value :\n    ((+param.max) + (+param.min)) / 2;\n\n  var rn = el.append('input')\n    .on('input', function() {\n      lbl.text(this.value);\n      update.call(this, +this.value);\n    })\n    .attr('type', 'range')\n    .attr('name', param.signal)\n    .attr('value', val)\n    .attr('min', param.min)\n    .attr('max', param.max)\n    .attr('step', param.step || vg.util.bins({\n      min: param.min,\n      max: param.max,\n      maxbins: 100\n    }).step);\n\n  var lbl = el.append('label')\n    .attr('class', 'vega-range')\n    .text(val);\n\n  var node = rn.node();\n  return {\n    dom: [node],\n    set: function(value) {\n      node.value = value;\n      lbl.text(value);\n    }\n  };\n}\n\nfunction update(value) {\n  if (value === undefined) value = this.__data__ || d3.event.target.value;\n  this.__vega__.signal(this.name, value).update();\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-embed/src/parameter.js\n ** module id = 203\n ** module chunks = 0\n **/","// open editor url in a new window, and pass a message\nmodule.exports = function(window, url, data) {\n  var editor = window.open(url),\n      wait = 10000,\n      step = 250,\n      count = ~~(wait/step);\n\n  function listen(evt) {\n    if (evt.source === editor) {\n      count = 0;\n      window.removeEventListener('message', listen, false);\n    }\n  }\n  window.addEventListener('message', listen, false);\n\n  // send message\n  // periodically resend until ack received or timeout\n  function send() {\n    if (count <= 0) return;\n    editor.postMessage(data, '*');\n    setTimeout(send, step);\n    count -= 1;\n  }\n  setTimeout(send, step);\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vega-embed/src/post.js\n ** module id = 204\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_205__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"jquery\"\n ** module id = 205\n ** module chunks = 0\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_206__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"base/js/events\"\n ** module id = 206\n ** module chunks = 0\n **/"],"sourceRoot":""}